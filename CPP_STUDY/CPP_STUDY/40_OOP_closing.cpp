#include <iostream>
using namespace std;

// 오늘의 주제 : 객체지향 마무리

/*
 1) struct vs class
 C++에서는 struct나 class나 종이 한 장 차이다.
 사실 배웠던 class문법들을 struct에 대부분 적용가능합니다.
 다른점 이라면 struct는 기본 접근지정자가 public이고, class는 기본 접근 지정자가 private입니다.
 왜 이렇게 했을까? : C++이라는 언어 자체가 C언어에서 파생되어 발전했기 때문에, 호환성을 지키기 위함.
 이 둘이 거의 비슷함에도 용도구분을 해서 사용하는걸 지향
 -> struct는 그냥 구조체 (데이터 묶음)을 표현하는 용도
 -> class는 객체 지향 프로그래밍의 특징을 나타내는 용도

 2) static 변수, static 함수 (static = 정적인, 고정된)
 예시를 들어서 스타크래프트의 마린을 클래스로 만든다고 했을때 마린은 체력, 공격력을 가지고 있다고 가정했습니다.
 그런데 마린이 공격력 업그레이드를 할 수 있었습니다! 그래서 체력 40, 공격력 6 인 마린들이 공격력 7 이되었습니다.
 이걸 코드로 표현하는 방법들중 첫째로 손으로 일일히 생성한 마린 하나하나를 찾아 마린._attack = 7;로 입력할 수도 있을 것입니다.

 체력의 경우는 처음 유닛이 생성될 때는 같은 수치로 생성되겠지만, 이후 전투나 회복을 각 객체마다 다르게 격을 것이기 때문에 
 _hp는 객체 고유의 값으로 가지고 있어야 할 것입니다. 반면, _attack은 값이 변동되는 경우는 위처럼 공격력 업그레이드 같은 
 이벤트가 있을 때 모든 객체가 일괄적으로 증감 할 것입니다.

 _attack같이 일괄적으로 변경되는 값들을 하드코딩으로 변경마다 손으로 일일히 변경해주는것은 비 효율적일 것입니다. 그럴때 
 이 공격력 값을 다른 코드로 빼서 관리 할 수도 있지만! 공격력이라는 값이 클래스 내부에 있어서 가독성이 늘고 한번에 관리하기 
 쉽도록 표현하는 방법이 필요합니다. 
 static [TYPE] [변수이름] 
 이 스태틱 변수가 클래스 내부에는 있지만 실제 활용방식같은 것은 클래스 외부의 변수, 전역변수처럼 활용 할수 있게 됩니다.
 정확히 말하면 '외부 선언' 이라고 합니다.

 스태틱을 변수뿐만이 아닌 함수에도 사용할 수 있습니다. 
 마린이 데미지를 입는걸 표현한 함수가 있다고 한다면 마린의 체력에 대한 함수일것입니다. 그리고 체력은 각각 마린객체의 고유한 
 속성이니 데미지 입는 함수도 각 객체마다 사용 해야 할 것입니다.
 그러면 함수에도 static을 붙이면 어떻게 될까요? 스태틱 변수와 비슷하게 전역 함수와 비슷하게 활용합니다.
 그리고 정적 함수 내에서 사용할수 있는 변수들은 같은 정적 변수뿐 입니다.

 코드상에서 멤버변수와 스태틱변수는 클래스 내에 모아놔서 살펴보기 편하지만, 메모리상으로 까보면 생성한 m1이라는 마린객체에는 
 체력값만 있습니다. 스태틱 변수는 메모리내에 혼자 동떨어져 관리 되고있었습니다.
 그럼 static 변수는 어떤 메모리?
 - 초기화하면 .data
 - 초기화 안 하면 .bss
 스태틱은 클래스 내에서만 사용할수 있는 문법은 아니고 함수내에서도 사용할 수 있습니다. 그러면 함수내에 정의된 변수긴 하니깐
 스택메모리에 올라가 있을까? 해서 메모리를 까보니 함수내에 정의한 스태틱 변수라도 스택외, .data영역에 자리하고 있었습니다.
 그리고 함수내에 정의된 지역변수의 경우 스택에 저장되어있다가 함수가 종료되면 같이 유효하지 않게되어 생명주기가 함수 시작/종료
 이지만 함수내에 정의된 정적 지역 변수(static 지역변수)는 생명주기가 프로그램 시작/종료입니다. 그럼에도 불구하고 이 정적 지역 변수
 의 가시범위 즉 변수를 사용 할 수있는 범위는 함수내에 한 하는것이 전역변수와의 다른점 이라고 할 수 있습니다.

*/

// 1) struct vs class
struct TestStruct
{
	void StructFunc() { cout << "Function in Struct!" << endl; }

	int _a;
	int _b;
};

class TestClass
{
	int _a;
	int _b;
};

// 2) static 변수, static 함수
class Marine
{
public:
	// 각 객체마다 적용하는 함수 
	void TakeDamage(int damage)
	{
		_hp -= damage;
	}

	static void SetAttack(int val)
	{
		s_attack = val;
	}
public:
	// 각각의 마린 객체에 종속적
	int _hp;

	// 특정 마린 객체와 무관
	// 마리이라는 '클래스' 자체와 연관
	static int s_attack;  // 설계도상으로만 존재
};

int Marine::s_attack = 0;

class Player
{
public:
	int _id;
};

int GenerateId()
{
	// 생명주기 : 프로그램 시작/종료 (메모리에 항상 올라가 있음)
	// 가시범위 : 본 함수 내에서 사용 가능

	// 정적 지역 객체 : 함수가 실행될때마다 1로 초기화 되는것이 아닌 계속 값이 유지됩니다.
	static int s_id = 1;

	return s_id++;
}

int main()
{
	// 1) struct vs class
	TestStruct ts;
	ts.StructFunc();

	TestClass tc;

	// 2) static 변수, static 함수
	Marine m1;
	m1._hp = 40;
	Marine::s_attack = 6;  // 스태틱 변수로 같은 클래스의 객체들의 값을 한번에 조작 할 수 있습니다.
	//m1.s_attack = 6;
	m1.TakeDamage(10);

	Marine m2;
	m2._hp = 40;
	//m2.s_attack = 6;

	// 마린 공격력 업그레이드 완료! 
	Marine::s_attack = 7;
	//m1.s_attack = 7;
	//m2.s_attack = 7;

	Marine::SetAttack(10);

	return 0;
}