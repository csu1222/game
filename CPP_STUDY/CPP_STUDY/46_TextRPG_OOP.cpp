#include <iostream> // CPP 공식 라이브러리는 < >, 커스텀 라이브러리는 " "
using namespace std;
#include "46_Game.h"

// 오늘의 주제 : Text RPG (객체지향)

/*
진행 순서 
1. 게임 전체적으로 관리할 Game이라는 클래스와 각 플레이어를 관리할 Player클래스를 만들어줍니다.(VS에서 클래스 생성을 하면 같은 이름의 헤더 파일과 cpp 파일을 만들어줍니다.)
2. 우선 플레이어 헤더 파일에서 플레이어의 직업들인 기사, 궁수, 법사를 플래이어 객체를 상속 시켜서 만들었습니다. 각 플레이어 타입을 구분하기위해 플레이어 클래스에 플레이어타입이라는 멤버 변수를 만들었고 enum으로 값을 할당 했습니다.
3. 플레이어 객체를 생성할 때 플레이어 타입을 초기화 해주기 위해 인자로 플레이어 타입을 받는 생성자를 만들었습니다. (Player(int playerType) : _playerType(playerType){}) 그리고 상속 관계가 있으니 소멸자도 가상 함수로 만들어 주었습니다.(객체 소멸할때 가상함수 소멸자가 있어야 깔끔히 메모리 해제해 줄 수 있습니다.(다형성))
4. 플레이어 객체가 가지고 있어야 할 멤버 변수가 체력,공격력,방어력이 있는데 이 변수들은 몬스터도 동일하게 가지고 있을 걸로 예상되서 플래이어 클래스의 상위 클래스로 크리쳐 클래스를 만들었습니다. 크리쳐 클래스의 멤버 변수로 크리처타입(플레이어타입과 유사하게 enum을 활용했습니다.) 크리쳐들이 공통으로 가지고 있을 체력, 공격력, 방어력을 초기화 해주었습니다. 크리쳐 클래스도 크리쳐 타입을 인자로 받는 생성자를 만들어주고 가상 소멸자 함수도 만들었습니다.
5. 플래이어 클래스에 크리쳐 클래스를 상속 시켜주고 더 하위 클래스인 기사, 궁수, 법사 클래스에게 각자의 스탯을 초기화 시켜주었습니다.
6. 게임 클래스가 이 텍스트 알피지의 모든부분을 아우르는 클래스이기 때문에 게임 클래스에 플레이어 클래스를 멤버 클래스로 받아줍니다.(is - a, has - a 방식으로 상속을 할건지 멤버 클래스로 받을 것인지 구분합니다.) 멤버 클래스는 일반 클래스로 받는 방법과 클래스타입 포인터로 받는 방법이 있었습니다. 일반적으로 클래스 포인터 타입으로 생성하는걸 추천하셨는데 그 이유는 일반 멤버 클래스로 만들 경우 Player라는 클래스에서 하위 클래스인 기사, 궁수, 법사 클래스로 타입 변환을 할 수 없습니다.(상위 클래스인 플레이어 클래스가 하위 클래스인 기사,궁수,법사 보다 범위가 작기 때문에 억지로 타입 변환을 했다가 엉뚱한 메모리를 건드릴 수 있기 때문) (또 한가지 클래스 자체를 멤버 클래스로 만들면 안되는 이유: 클래스 자체를 가지고 있으면 게임 객체의 생성/소멸이 플레이어 객체의 생성/소멸과 일치화 됩니다. 즉, 플레이어가 생성된 다음 게임 객체가 생성 될수 있습니다. 그런데 어떤이유에서 플레이어 클래스에서 다시 게임 클래스를 인클루드 했을 경우 두 클래스가 서로 상대방이 먼저 존재 해야 자신이 존재할수 잇는 순환 오류가 생길 수 있습니다.) 클래스 포인터 타입 멤버 변수는 헤더파일을 미리 인클루드 하지 않아도 괜찮습니다. 왜냐하면 포인터는 구현부 없이 그저 주소를 가리키는 바구니이기 때문입니다. 그래도 인클루드 없이 그냥 클래스포인터 타입을 만들면 빨간 밑줄이 쳐지는데 이것은 전방선언으로 나중에 알려준다는 약속을 해놓으면 통과가 됩니다.
7. 게임 클래스의 생성자와 소멸자를 만들어주었습니다. 게임 헤더에는 그냥 선언만 하고 게임.cpp 파일에서 구현을 해주었습니다. 게임 cpp 파일에서 게임 헤더파일을 인클루드하고 Game::Game(){} 같은 문법으로 구현부를 만들수 있었습니다. 생성자 함수이니 반환 타입이 없는것이고 일반 함수의 경우 void Game::Init(){ } 같이 반환타입도 같이 입력해줘야합니다. 
8. 다음으로 메인 함수에서 게임 객체를 생성해 봤습니다. 이후 해줘야하는것은 게임 객체를 초기화(game.Init)해주고 게임이 while(true)를 도는 시행마다 게임 객체를 업데이트(game.Update) 해줘야 겠습니다. 이 초기화 업데이트도 게임 클래스에 만들어주겠습니다.게임 클래스 생성자에서 플레이어 타입을 일단 nullptr로 만들었습니다.(아직 플레이어를 생성하지 않았기 때문) 그러면 게임에 들어가서는 플레이어의 타입을 정해야 하는데게임이 while문을 돌기 시작 할 때 조건문으로 플레이어가 nullptr인지 확인후 플레이어 생성 함수를 실행하도록 다시 게임 클래스에 만들어주겠습니다.
9. 메인함수.게임객체.업데이트함수.플래이어생성함수 순으로 타곡들어가서 플레이어 생성 기능을 구현하였습니다. 플레이어 헤더에 있던 enum PlayerType을 사용해 int형 input을 받아 어떤 직업을 선택할지 고르고 조건문으로 선택한 input 값과 Playertype이 일치하는 직업을 게임 클래스의 플레이어 클래스 포인터 변수 _player 에 new [직업]으로 Heap영역에 객체를 생성해 객체 주소를 할당했습니다. 여기서 몇가지 오류가 발생했는데 첫째, cpp파일단위로 컴파일을 하기 때문에 객체생성를 하기위해 플레이어 헤더파일을 인클루드 해주었습니다. 두번째 실수로 플레이어 헤더에 각 직업 클래스에서 public: 을 설정해주지 않아 엑세스 할수 없어서 전부 public: 처리 해주었습니다.
10. 이전에 구현했던 절차지향 텍스트 알피지에서 캐릭터를 생성하면 이후로 필드로 들어가 몬스터와 싸웠었습니다. 그래서 이후 field헤더,cpp 파일을 만들었고 생각해보니 몬스터는 field내에서만 존재할것 같습니다. 다시 몬스터 헤더,cpp 파일을 만들고 몬스터 생성을 구현해보았습니다. 구현 방법은 플레이어생성 때와 비슷하게 몬스터도 크리쳐를 상속 할것이니 크리쳐 헤더파일을 인클루드하고 CT_MONSTER를 인자로 받는 생성자, 몬스터 타입을 구별할 enum, 각 몬스터가 가지고 있을 monsterType, 그리고 Monster객체를 상속받을 각 하위 클래스들(체력,공격력,방어력을 초기화 해주었습니다.)
11. 다시 felid를 보면 이 필드 객체를 어디에서 생성할것인가? 이 게임의 전체 관리는 Game클래스에서 하니 게임 클래스에 필드클래스 포인터 변수를 만들었습니다.(그리고 게임cpp 파일에서 필드포인터 변수를 nullptr로 초기화) 필드 객체를 생성하는 것은 Game.Init에서 하기로 했습니다.(_field = new Field();)게임 cpp에 필드 헤더를 인클루드 해주고 이제 필드헤더에서 기능을 구현해야겠습니다. 게임 헤더때 처럼 선언만 하고 실질적 구현은 필드 cpp파일에서 하였습니다. 필드 생성자에서 나중에 _monster객체를 생성할 것이니 _monster = nullptr로 초기화 해주고 생성을했으면 소멸자에서 delete를 해주어야겠습니다.
12. 필드 클래스에서도 Update라는 멤버 변수로 반복문을 돌면서 몬스터생성과 전투를 해줄 것입니다. 전투를 하기위해서 몬스터 뿐만아니라 플레이어정보도 필요하니 인자로 받아주었습니다.
13. 우선 몬스터 생성. 몬스터는 별개 인풋이 없이 랜덤값으로 만들었습니다. (srand와 rand의 조합)
14. StartBattle함수는 전투 함수는 Update함수 안에서 실행되고 Update함수의 매개변수인 player정보를 다시 가지고 전투를 치를 것입니다.
15. 잠깐! 전투가 진행되는 중에 반복적으로 몬스터와 플레이어의 스탯을 프린트할 일이 있을것 같습니다. 몬스터와 플레이어 둘의 공통된 상위 클래스인 크리쳐 클래스에서 스탯 프린트 함수를 만들어주면 좋겠습니다.하지만 각 플레이어 직업군들, 몬스터들의 스탯을 프린트 할것이니 크리쳐 클래스에서는 가상함수로 선언만 해주었습니다.(추상 가상함수를 만들면 하위 상속 클래스에서 반드시 상세한 구현은 해줘야합니다.)몬스터와 플레이어각 클래스에서 상속받은 프린트 함수를 구현하였습니다.
16. 전투함수에서 먼저 플레이어와 몬스터의 정보를 프린트하고나서 진짜 데미지를 주고 받아야 합니다. StartBattle함수에서 데미지 교환을 바로 하는것보다는 데미지 교환 자체는 플레이어와 몬스터가 하는 기능이니 다시 크리쳐 클래스에 구현하는게 더 객체지향적이라고 합니다. 
17. 크리쳐 클래스에서 OnAttacked라는 공격받음 함수를 만들었습니다. 객체들이 들고있는 공격력과 체력과 방어력등을 적절히 사용했습니다.
18. 한번 공격을 받을 때마다 내가 죽었나?를 체크합니다.(IsDead함수) 체크 방법은 반환 타입을 bool로 하고 자신의 _hp <= 0 을 반환하면 true or false가 반환 될것입니다.
19. StartBattle함수로 돌아가 서로 한대씩 주고받고 IsDead를 체크합니다. 만약 몬스터가 죽었을 경우 몬스터 정보를 한번 프린트해주고, 바로 몬스터 객체를 delete해줍니다. delete다음 바로 다시 몬스터 객체 값을 nullptr로 밀어버려야 다시 몬스터를 만들기 위한 조건문이었던 nullptr이 통과됩니다. 마지막으로 break;로 StartBattle을 빠져나오면 Game.Update의 whlie문을 돌아 다시 몬스터생성부터 반복하게 될것입니다.
20. 반면 플레이어가 죽었을 경우 정보 프린트후 break;로 빠져나왔습니다. 왜 바로 플레이어 객체를 삭제하지 않았을까요? 몬스터의 경우 생성부터 field객체에서 관리하였고 플레이어는 Game객체에서 관리하였기 때문에 플레이어객체를 삭제한다면 Game객체에서 하는게 맞다고 합니다. 그래서 일단 StartBattle함수에서 break로 나오게 되면 field->Update에서도 빠져나오고 그러면 이제 Game.Update의 반복을 돌게되는데 이때 조건문으로 플레이어의 IsDead를 체크하고 delete, _player를 nullptr로 초기화합니다. 이후 바로 CreatePlayer를 실행해주면 다음 순서인 field를 들어가 다시 전투를 하게 되겠습니다.


#)
전방선언: 이전 절차지향프로그래밍 때도 함수를 메인함수 위에 전부 구현하다 이후에는 함수의 시그니처만 미리 선언하고 메인 밑으로 구현부를 옮겼습니다. 클래스도 마찬가지로 전방선언을 할 수 있습니다. * 보통 헤더 파일에서는 전방선언으로 일단 통과되게 해도 괜찮지만 cpp파일에 인클루드한 상태에서는 실질적으로 코드가 필요하니 헤더를 인클루드 해줘야 겠습니다.
include ""? <>? : 지금까지 정체는 모르지만 암시적으로 사용해 왔던 #include에 대해 항상쓰던 #include <iostream> 이 있고 이번에 코드를 각 클래스 단위로 나눠서 서로 소통하기 위해 쓰는 #include "Game.h" 같은 문법의 차이는 < > 의 경우 C++가 공식적으로 지원하는 라이브러리가 쓰는 기호이고 "" 는 사용자가 커스텀한 라이브러리를 불러오는 기호 입니다. 
using namespace : 모르지만 일부러 무시하고 그냥 쓰던 코드 2 using namespace std;의 대해, 앞으로는 남이 만든 여러 라이브러리를 가져다 쓰게 될 텐데 자신의 코드에서 사용한 클래스 이름과 우연히 남의 라이브러리 내의 클래스 이름이 곂칠 수 있습니다. 그러면 컴파일러는 이름이 똑같은 클래스가 여러번 호출되어있으니 제대로 작동하지 못할것입니다. 그래서 이 클래스가 어디에서 온것인지 앞에 이름표(namespace)를 붙이는 것입니다. 인클루드한 헤더파일의 클래스를 호출하듯 [라이브러리 이름] :: [클래스이름] 이렇게 호출하게 됩니다. 이글의 주제인 using namespace는 명시적으로 이름표를 붙히지 않아도 알아듣게끔 해주는 코드입니다. 즉, using namespace std;로 여태껏 cout 함수를 사용했던것이 사실은 std :: cout 으로 매번 사용 했어야 하는것입니다.
*/


int main()
{
	srand((unsigned int)time(nullptr));

	Game game;

	game.Init();

	while (true)
	{
		game.Update();
	}


	return 0;
}