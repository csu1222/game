#include <iostream>
using namespace std;

// 오늘의 주제 : 객체 지향의 시작

// - 새로운 프로그래밍 방법인 객체지향을 배우기 전에 일단 지금까지 실습이나 배워왔던 스타일은 무었인가?
// -- 절차(procedural)지향 프로그래밍
// -- 절차(procedural)는 어셈블리나 다른언어에서는 '함수' 라고도 불렸습니다.
// -- 그러면 지금까지 절차지향프로그래밍의 문제점에 대해 생각해보겠습니다.
// -- 프로그래밍 자체는 어떤 데이터가 있고 이 데이터를 잘 조작 해서 원하는 결과물을 만들어 내는 것입니다.
// -- 절차지향 프로그래밍에서는 데이터는 전역변수든, 지역변수든 으로 관리하고 있고 , 이 데이터를 어떤 로직으로 조작하느냐? 기능 하나씩을 함수로써 
// -- 부분 부분 관리하고 있습니다. 프로젝트가 커지고 사양이 변경되면 먼저 만들어 뒀던 함수들이 제대로 작동 하지 않을 수 있습니다. 
// -- 결론으로 확장성쪽으로 별로 좋지 못하다.

// 그래서 오늘의 주제인 객체지향 프로그래밍이라는 패러다임은 최근까지 많이 사용되고 있는 방법론으로 특히 게임 개발에서는 많이들 사용하고 있으니 
// 꼭 숙지 해야 하겠습니다.



// 데이터 + 가공(로직, 동작)

// 객체지향의 주인공은 객체
// - 객체란?  : 객체(object)란 게임속에 보이는 모든 오브젝트를 말하는것 (플레이어, 몬스터, GameRoom(방을 생성해서 하는 게임도 있죠) 등등)

// Knight를 설계해보자
// - 속성(데이터) : hp, attack, position(위치좌표  x, y)
// - 기능(동작) : Move, Attack, DIe

// class 문법은 당장 어떤 변수를 선언한 것은 아니고 설계도라고 생각하면됩니다.
// struct문법과 비슷하다고 생각
class Knight
{
public:					// 이부분에 기능(동작)을 같이 설계해놓았습니다. 선언만 할 수도 있고 정의도 한번에 할 수도 있습니다.
	// 멤버 함수 라고 합니다.
	void Move(int y, int x);
	void Attack();
	void Die()
	{
		hp = 0;			// 클래스 내부에서는 멤버 변수가 전역변수가 아니고, 매개변수로 주어지지도 않아도 사용 할 수 있습니다.
		cout << "Die" << endl;

	}

public:
	// 멤버 변수 라고 합니다.
	int hp;
	int attack;
	int posX;
	int posY;
};

// 멤버 함수 구현부는 기존처럼 외부에 만들 수 있지만 어디에 속해 있는지 표시해줘야합니다.
void Knight::Move(int y, int x)
{
	posY = y;
	posX = x;
	cout << "Move" << endl;
}

void Knight::Attack()
{
	cout << "Attack : " << attack << endl;
}

// 기존 함수
void Move(Knight* knight, int y, int x)
{
	knight->posY = y;
	knight->posX = x;
}

// class 라는 설계도에 따라 데이터를 생성 할때 이전 배웠던 것 처럼 두가지 방식이 있었습니다.
// 1) 전역변수 , 2) 지역변수
// Knight k1; 전역변수로도 가능하고


// Instantiate 객체를 만든다!

int main()
{
	// 객체를 생성하고 각자의 속성을 지정 해주면 각각 개별의 물체가 되는것
	Knight k1;
	k1.hp = 100;
	k1.attack = 10;
	k1.posY = 0;
	k1.posX = 0;

	Knight k2;
	k2.hp = 80;
	k2.attack = 5;
	k2.posY = 1;
	k2.posX = 1;

	// 객체의 기능은 객체.기능 으로 실행 가능 했습니다.
	k1.Move(2, 2);
	k1.Attack();
	k1.Die();

	// 그러면 원래 배웠던 함수나 구조체와 비슷해 보이는데 어떤 점이 다른가?
	// - 구조체가 가진 정보를 수정하는 함수는 매개변수로 포인터와 다른 인자를 줘야 했습니다.
	// - 객체의 경우 객체자체가 멤버 함수로써 가진 기능을 사용하여 자신의 정보를 직접 줄 수 있습니다.
	Move(&k1, 3, 4);

	// 함수와 멤버함수의 차이를 메모리 상으로 살펴보면 
	// 일단, 객체 자체의 크기는 구조체와 같이 멤버 변수들의 크기 합 만큼 이었습니다.
	// 멤버 변수가 같이 메모리 상에 잡혀 있지 않았습니다.
	// 그러면, Move() 함수와 k1.Move()는 어떤 차이가 있었느냐 하면
	// 둘 다 비슷하게 k1의 주소를 push해서 각각 함수에서 k1에 접근 하고 있었습니다.
	// 멤버 함수 k1.Move()를 좀 더 살펴보면 push 해준 k1의 주소를 'this'라는 곳에 mov해주고 y, x 좌표를 'this'기준으로 변경해주고 있습니다.


	return 0;
}