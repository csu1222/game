#include <iostream>
using namespace std;

// 오늘의 주제 : 템플릿 기초

/*
	왜 그냥 템플릿이 아니고 템플릿 기초라고 강조하느냐
	- C++에서 템플릿이 정말 어려운 부분이고 응용할것과 알아야 할 것이 정말 많습니다. (C++ 에서 템플릿 만으로 책한권이 나오는정도)
	- 이후 배울 STL에서 사용할 기초만 일단 알고 지나가는 의미입니다.

	그럼 템플릿은 무었인가?
	
	템플릿 : 함수나 클래스를 찍어내는 틀
	1) 함수 템플릿 *
	2) 클래스 템플릿

	
	간단히 Print라는 이름의 함수를 만들었다고 해보겠습니다. 시그니쳐는 이렇습니다.
	void Print(int a);	기능은 인자로 받은 a를 로그 출력하는 것 입니다.

	그런데 이 Print함수는 정수 인자만 받습니다. 다른 타입도 출력하고 싶어서 오버로딩을 하였습니다.
	void Print(float a);
	void Print(double a);
	void Print(const char* a); 
	등등 이러면 여러 타입의 인자들도 Print로 출력할 수 있게되었습니다. 
	하지만, 타입마다 함수를 손수 입력하면 반복되는 코드가 많아집니다. 코드를 줄이고 더 간편히 기능을 만들고 싶으면 
	함수가 받는 인자 자리만 용도에 맞게 바꿔주면 될 것입니다.

	그럴때 쓰는게 [템플릿] 이라고 합니다.

	템플릿을 사용할 기초 문법은 
	template<typename T>  // T 자리는 템플릿에 이름을 지어준것 T가 아니라 원하는 이름으로 해도 됩니다

	위의 Print함수로 예를들면
	Print(T a) { cout << a << endl; }
	이렇게 매개변수의 타입이 들어갈 곳에 템플릿을 넣어주면 아 한개의 함수로도 int, float, double, strig등 타입의 
	인자를 잘 출력해주었습니다.

	템플릿은 하나의 함수의 매개변수를 여러가지를 쓰게 하는것이 아니고,
	하나의 틀을만들어 함수가 어떤 타입의 인자를 사용할때 그 타입의 함수를 만들어 내고 있습니다.
	컴파일러가 컴파일 당시에 인자의 타입을 추론을 해서 해당하는 함수를 만들어 줍니다.

	컴파일러에게 다 맞기지 않고 사용자가 지정하고 싶을 때는 이렇게 합니다.
	Print<int>(50); 

	용도에 맞게 직접 타입을 지정하고 싶을 때, 컴파일러에게 맡기고 싶을 때 구분해서 사용하면 되겠습니다.

	그리고 템플릿의 기본 문법은 template<typename T> 이긴 한데
	c++에서 지원하는 문법으로 templaye<class T> 도 위 타입네임과 같은 의미라고 합니다.

	템플릿을 매개변수의 타입으로만 사용하는것은아닙니다.
	만약에, 인자 두개를 받아서 두 값을 합하고 합한 값을 반환하는 함수가 있을때 
	인자 두개의 타입뿐만아니라 반환되는 부분도 템플릿을 이용할 수 있습니다.

	또한가지 그러면 한 함수내에서 여러 타입의 매개변수를 사용할때는 템플릿을 사용하지 못하는건가?
	그럴땐 사용하는 타입 갯수만큼 typename을 만들어주면 되겠습니다
	template<typename T1, typename T2>
	[함수]

	그러면 혹시 여태껏 열심히 배운 커스텀 클래스도 템플릿으로 쉽게 다룰 수 있을까요?
	예시를 들때면 항상나오던 Knight클래스를 예로 들어보겠습니다.
	멤버변수로 _hp = 100; 을 들고있는 Knight를 Print(T a) { cout << a << endl;} 함수로 출력해보려고 합니다.
	일단 빨간줄로 에러라고 안뜨길레 빌드 까지 해보니 이번에는 에러가 떳습니다.
	그 이유는 템플릿으로 알아서 함수를 만들어 준다고 해도 빌드에서 에러가 없을때 가능한것입니다. 
	클래스는 << 라는 연산자가 호환되지 않기 때문에 에러가 났습니다.
	그래서 << 를 연산자 오버로딩 하면 되겠습니다.

	cout << 에서 왼쪽항에 있는 cout을 F12로 따라가면 ostream타입의 객체라는 것을 알수 있습니다.
	전역 연산자 함수 버전으로 반환 타입은 ostream& 으로 하고 매개변수로 (ostream& os, Knight& k) 를 받아줍니다.
	구현부에 os(여기에 cout이 올겁니다.) << k._hp(Knight클래스의 체력만 뽑아서 출력합니다.) return 으로 os를 그대로 반환해줍니다.
	
	Knight의 _hp만 덩그러니 출력하는게 심심해서 얘만 특수 처리를 해보겠습니다. 그럴때 사용하는것이 
	[템플릿 특수화]라는 문법입니다.
	템플릿이라는 마법의 문법으로 그때 그때 맞는 함수를 찍어내는 걸 배웠습니다. 그러면 특별한 경우의 예외처리를 해서 
	예를 들면 Knight를 사용하면 예외로 다른 형태의 함수를 만들어 내는것 입니다.
	템플릿 특수화의 방법은 일단 템플릿이긴 템플릿이니 
	template<>		// typename이 들어갈 공간을 비워둡니다.
	void Print(Knight a) { cout << "Knight!!" endl; } 
	이런식으로 Knigth가 인자로 올때의 예외적 함수 내용을 적어줍니다.
*/

// 템플릿 사용 기본 문법
template<typename T>
void Print(T a)	//인자의 타입대신 템플릿을 넣어줍니다.
{
	cout << a << endl;
}

template<typename T1, typename T2>
void Print(T1 a, T2 b)
{
	cout << a << " " << b << endl;
}

template<typename T>
T Add(T a, T b)
{
	return a + b;
}

// 커스텀 클래스
class Knight
{
public:
	// ...
public:
	int _hp = 100;
};

// << 연산자 오버로딩(전역함수 버전)
ostream& operator<< (ostream& os, const Knight& k)
{
	os << k._hp;
	return os;
}

// 템플릿 특수화
template<>
void Print(Knight a)
{
	cout << "Knight  !!!!!!!!!" << endl;
	cout << a._hp << endl;
}

int main()
{
	// 템플릿 : 인자 하나
	Print<int>(50);
	Print(50.0f);
	Print(50.0);
	Print("Hello World");


	// 템플릿 : 인자들과 반환타입 1가지
	int result = Add(3, 5);
	float result2 = Add<float>(2.22f, 3.5f);


	// 템플릿 : 타입이 다수 일때
	Print(50, "Hello World");


	// 커스텀 클래스를 연산자 오버로딩을 해서 템플릿으로 함수를 만들수 있게 
	Knight k;
	Print(k);


	return 0;
}