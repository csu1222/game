#include <iostream>
using namespace std;
#include "47_Player.h"

// 오늘의 주제 : 전방 선언

/*
지금까지 클래스를 어느 메모리에 생성하는지 많이 알아 봤었습니다.
1. 지역변수 : Stack 메모리에 저장 후 직접 접근
2. 동적할당 : Heap 메모리에 저장 후 포인터로 접근

두 방법모두 생각해보면 이 클래스가 얼마만큼의 크기인지 미리 알아야 적절한 메모리의 공간을 확보 할 수 있을 것입니다.
오늘의 핵심 질문 : Player는 몇바이트?
(hp, attack을 들고 있습니다.)
- int 2개 = 2 * 4 = 8바이트  금방 알 수 있엇습니다.

그러면 Player 클래스에 Monster객체가 멤버 클래스로 들고 있을때
Player는 몇바이트?
- 이경우 원래있던 멤버 변수 int형 두개와 Monster클래스의 크기를 알아야 하는데 Monster의 헤더 파일에 직접 들어가기전에는 크기를 알 수 없었습니다. 결국 Player라는 설계도와 Monster라는 설계도를 합쳐서 봐야(#include "Monster.h") 확실한 크기를 알 수 있을 것입니다. 
- Player int 2개 + Monster int 3개 = 20바이트

이번에는 Player클래스에서 Monster클래스 포인터 타입 멤버 변수(Monster*)를 들고 있을 때
Player는 몇바이트?
이러면 원래 있던 멤버 변수 2개와 클래스 포이터 타입의 멤버변수가 있습니다. 이 포인터 변수는 원본이 얼마나 크든 그냥 주소값일 뿐 운영체제에따라 4,8 바이트 중 하나입니다. 딱히 Monster.h를 인클루드 안해도 크기 자체는 알 수 있습니다. (문법상 Monster는 정의 되어 있지 않아 빌드 되지는 않습니다.) 헤더파일에 일단 내용을 나중에 알려줄게~ 라는 의미로 클래스 이름만 적어 놓는것을 
[ 전방선언 ] 이라고 했습니다.

	코드 위쪽에 class Monster; 형태로 선언하는것도 전방선언이고 
	멤버변수를 만들때 그냥 class Monster* _target; 으로 한번에 선언하는것도 전방선언이라고 합니다.

 - int 2개 + pointer(현재 프로젝트 운영체제는 32비트이니깐 4바이트) = 12바이트


 클래스 포인터 변수를 사용하고 전방선언하면 만사 OK 같지만 아직 해결할 일이 남아 있습니다.
 만약 Player클래스에서 멤버 함수로 KillMonster라는 몬스터의 체력을 바로 0으로 만드는 치트같은
 함수가 있다고 해보겠습니다. 분명 전방선언하였는데 클래스포인터 _target의 속성에 접근할수 
 없습니다. 몬스터의 체력을 0으로 만든다는것은 (*target)._hp = 0; 이런 코드를 말하는것입니다.
 (*targe) 까지는 가능합니다. 포인터의 주소를 따라가는것은 가능하니까요 하지만 뒤의 _hp는 
 Monster의 설계도가 있어야 Monster클래스의 몇번째 오프셋인지 알고 접근해서 값을 수정할 것
 입니다. 결국은 Monster.h를 인클루드 해줘야 한다는 것입니다. 
 그러면 결국 클래스 포인터를 전방선언하나 직접 인클루드 해오나 별 차이가 없지 않나 할 수 
 있지만 헤더파일에 클래스포인터와 전방선언을 하고 cpp파일에서 함수의 구현을하면서 
 cpp파일에서만 인클루드를 한다는 차이점이 있습니다.
 (cpp파일에서 구현하지 않고 헤더 파일에서 직접 기능 구현을 하려면 헤더에서 Mosnter.h를 인클루드 해야합니다.)

 
 추가로 이번에는 플레이어 끼리 PVP를 하기위해 Player클래스에 Player멤버 클래스가 필요하다고
 해보겠습니다. 그래서 그냥 일반 Player클래스 멤버 변수를 선언하게되면 이때 
 Player는 몇바이트 일까요?
 - Player의 크기는 8바이트 + Player의 크기( 8바이트 + Player의크기 (...))
 로 자신 안에서 다시 자신의 크기를 계산하는 재귀적인 오류에 빠지게 될것입니다.

 그래서 다음으로 Player클래스 포인터 타입 변수(Player*) 를 가지고 있다고 하면 
 바로 통과가 됩니다 . Player클래스의 크기도 명확합니다. 주소의 크기만 더하면 되니깐요
*/



int main()
{
	Player p1; // 지역변수 (Stack)

	Player* p2 = new Player(); // 동적할당 (Heap)

	// 자신과 같은 타입을 멤버 변수로 삼았습니다.
	p1._target2 = p2;

	return 0;
}