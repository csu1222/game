#include <iostream>
using namespace std;

// 오늘의 주제 : 불리언(bool)과  실수

// 불리언 (bool) = 참 / 거짓

bool isHighLevel = true;
bool isPlayer = true;
bool isMale = false;

// [NOTE]
// 사실 bool은 1바이트 짜리 정수 데이터에 불과합니다.
// 그러면 왜 정수 시간에 안 다뤘을까?
// -> 일리 있음.  어셈블리 문법에서 bool이라는 것은 없습니다. 그저 0이면 false 1이면 true 라는 분기문으로 구현합니다.
// 그러면 왜 bool이라는 타입을 사용할까? -> bool만 봐도 참/거짓 둘 중 하나라는 힌트를 줍니다.(가독성)
// 가독성 예시)

/*int isFemale = 1;
if (isFemale != 0)		이 조건문만 봤을 때 갑자기 여성의 수?를 묻는다고 읽힐 수 있습니다.
	{
	  TODO
	}*/

/*
위의 isMale 변수를 가져다 써보겠습니다.
if (isMale == false)		bool을 쓰면 바로 isMale이 bool 타입 참/거짓을 판별하기 위한 변수라는 것을 알수 있습니다.
	{
		TODO
	}
*/

// 왜 bool은 1바이트 씩이나 할당 했을까?
// 0과 1만 있으면 된다면 1bit만 쓰면 메모리 절약이 되지 않을까 생각할 수 있습니다.
// 어셈블리에서도 레지스터 최소단위는 1바이트 였습니다
// - al = 1byte
// 최소 단위가 1바이트기에 bool도 1바이트가 되겠습니다.

// 실수 (부동소수점)
// 3.141592 같은 소수점 자리가 있는 수
// 실수 타입에는 float, double 두가지 형식이 있습니다.

// 그러면 이 실수는 어떻게 표현될까요?
// 정수에서는 각 비트당 하나의 숫자씩 할당되어 표현이 되었습니다.
// 금방 생각하면 (2바이트) . (2바이트) 이렇게 점을 기준으로 2바이트씩 숫자를 할당하면 되지 않을까?
// but 이러면 (0~65536).(0~65535) 의 범위의 수 밖에 표현 못합니다.

// 부동소수점 # 부동(不動 움직이지 않는 X), (浮動 부유하듯 움직이는 O)
// . 을 유동적으로 움직여서 표현하는 방법

// 3.1415926535 를 예시로 들어보겠습니다.
// 3.1415926536 = 0.31415926535 * 10 = 314.15926535 * 10^-2
// 1) 정규화 = 0.31415926535 * 10
// 2) 31415926535 (유효숫자) 1 (지수)

// float = 부호 (1bit) + 지수 (8bit) + 유효숫자 (23bit) = 4바이트
// double = 부호 (1bit) + 지수 (11bit) + 유효숫자 (52bit) = 8바이트

float attackSpeed = -3.375f; // 초기값 뒤에 f를 붙여줘야 float타입이라고 인식이 됩니다. 없으면 float로 선언해도 double타입으로 인식됩니다.
double attackSpeed2 = 1.245;

// float 와 double의 차이점은 데이터 크기
// float = 4바이트
// double = 8바이트

// ex) -3.375라는 값을 저장
// 1) 2진수로 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
//	- 0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
// 2) 정규화 = 0b1.1011 * 2^1 (2진수에서는 맨앞의 1이 오게끔 하면 유효 숫자입니다.)
//	1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 unsigned byte라고 가정하고 숫자 + 127 을 해줍니다.
// 예상결과 = 0b 1 10000000 1011'0000'0000'0000'0000'000  (바이트 단위 리틀 엔디안으로 저장 되어있을 것이기 때문)

// 프로그래밍에서 부동소수점은 항상 '근사값' 이라는 것을 명심
// 예를 들어 1/3 = 0.33333333333333333333333333 처럼 무한히 긴 실수를 컴퓨터는 정확히 표현 할 수 없습니다.
// 특히 수가 커질 수록 오차 범위도 커집니다.
// 실수 사이에서  실수 == 실수 로 비교하는것은 지양

int main()
{
}