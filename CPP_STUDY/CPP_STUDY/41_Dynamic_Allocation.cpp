#include <iostream>
using namespace std;

// 오늘의 주제 : 동적 할당 (Dynamic Allocation) * 중요 *

/*
 메모리 구조 복습
 검색 엔진에 메모리 구조를 검색하면 이런 이미지가 나왔었습니다.
 - 1) 코드 영역 : 실행할 프로그램의 코드
 - 2) 데이터 영역 : 전역(globla)변수, 정적(static)변수
 - 3) 힙 영역 : 동적 할당(오늘의 주제)
 - 4) 스택 영역 : 지역변수(local), 매개변수(parameter), ret할 주소(ebp, esp) 

 이 중 코드영역은 지금 작성하고 있는 텍스트 그 자체이고, 
 데이터 영역/스택 영역에 대해 지금까지 배웠습니다.
 그러면 지금껏 배워오던 메모리들로 그럭저럭 프로그램을 잘 만들어 왔는데!
 굳이 새로운 영역(힙 영역)이 필요할까?

 실제 상황 예시)
 - MMORPG 동접 1명 ~ 5만명, 몬스터 1마리 ~ 500만마리 
 - 이런 방대한 데이터를 스택에 저장하면 스택오버플로우가 일어납니다. 애초에 스택은 이렇게 쓰라고 있는 영역이 아닌 함수마다 그때 그때 쓸 지역변수, 매개변수, ret주소 등을 잠시 저장해놓기 위해 있는 메모리입니다.
 - 그렇다면 전역변수로 데이터 영역에 저장하면 어떨까? -> 동접자가 1명 ~ 5만명으로 유동적인 상태지만 항상 500만마리의 몬스터를 준비하고 있어야 함으로 비효율적 일 것입니다. 
 -- 스택 영역 : 함수가 끝나면 같이 정리되는 불안정한 메모리, 잠시 함수에 매개변수를 넘긴다거나 하는 용도로는 OK
 -- 메모리 영역 : 프로그램이 실행되는 도중에는 '무조건'사용되는 영역
 - 희망사항)
 -- 필요할때만 사용하고 , 필요없으면 반납할 수 있는!
 -- 그러면서도 (스택과는 다르게) 우리가 생성/소멸 시점을 관리할 수 있는!
 -- 그런 아름다운 메모리 없나? -> 힙 (HEAP)

 동적 할당과 연관된 함수/연산자 : malloc, free, new, delete. new[ ], delete[ ]


 컴퓨터나 모바일의 기초지식(유저영역, 커널영역)

 유저 영역 [메모장], [LOL], [브라우저], [카톡] 등등
 --------------------------------------------------
 커널 영역 (Windows, Android 등의 핵심 코드)

 갑자기 왜 이런 이야기를 하는가? 
 -> 게임개발중이니 게임이 실행되는 유저영역에 우리 코드를 다 집어 넣으면 되지 않을까? 하는 생각이 들지만 게임내에서 몬스터를 생성한다던지 하는 동작을 막 하다보면 그 메모리 주변에 있는 프로그램들의 메모리 까지 침범 할수도 있을 것 같습니다.그래서 현대의 프로그램들은 각 프로그램끼리 간섭할 수 없게끔 만든다고 합니다. 그리고 우리 프로그램에서 추가로 동적 할당을 해 메모리가 더 필요해지면 유저 영역에서 메모리를 할당 받는것이 아닌 커널영역에서 메모리를 받아옵니다.
 동적 할당의 흐름 요약
 - 1) 유저 영역 - 운영체제에서 제공하는 API 호출
 - 2) 커널 영역 - 메모리 할당해서 건내줌
 - 3) 유저 영역 - ㄳㄳ 잘 쓸게요~
 하지만 매번 커널 영역에 메모리를 요청하기에는 커널 영역은 중요하고 다양한 프로그램들을 관리 하고 있습니다.
 해서 처음에 메모리를 요청 할때 넉넉하게 메모리를 요청해 놓고
 메모리가 필요할때 마다 적절한 영역을 가져다 씁니다.(malloc, new 등)
 C++ 에서는 기본적으로 CRT(C 런타임 라이브러리)의 [힙 관리자]를 통해 힘 영역 사용
 단, 정말 원한다면 우리가 직접 API를 통해 힙을 생성하고 관리할 수도 있음 (MMORPG 서버 메모리 풀링(고급과정))

 동적 할당 연관 연산자/함수 중 
 1) malloc() : malloc에 커서를 가져다 보면 시그니처를 살펴 볼수 있습니다. 
	일단 함수이고, 반환하는 타입은 void* 보이드형 포인터? 처음보지만 일단 넘어가서 인자로는 size_t 라는 걸 받아주고 있습니다. (번외 참조) 
	즉, malloc은 인자로 unsigned int를 받는다~.  
	malloc도 메모리를 할당 받으려는 함수인데 음수의 메모리를 할당받는다는게 말이 안되니 양수만 인자로 받는게 이해가 됩니다. 
	인자 만큼의 메모리를 확보해서 그 메모리 시작 주소를 void* (보이드형 포인터)로 반환해줍니다. (CRT의 [힙 관리자]를 사용)
	- 할당할 메모리 크기를 인자로 건내준다.
	- 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해 준다(메모리 부족시 NULL포인터 반환)


	 (번외) size_t? 생소합니다. 알아보려면 코드에 size_t를 입력하고 커서를 가져다 댄 다음 F12를 누르면 어떻게 만들었는지 쭉 타고 들어간다고 합니다.
		#ifdef _WIN64
			typedef unsigned __int64 size_t;
		#else
			typedef unsigned int     size_t;
		#endif
		이런 코드가 나오는데 typedef 가 무었인가 하면 type a b; 라고 하면 a라는 타입을 b라는 이름으로도 사용하게끔 하고 싶다는 의미입니다. 결국 의미는 64비트 환경에서는 unsigned __int64 타입을 size_t 라고 부를 꺼고, 만약 64비트환경이 아닌(즉, x86(32비트)) 환경에서는 unsigned int 를 size_t 라고도 부를것이라는 뜻입니다. 
		즉, 지금은 32비트 환경에서 작업 중이니 size_t = unsigned int 라는 뜻이네요

	 (번외 2) 그런데 잠깐! void* ?? 무엇일까?
		* 이 있으니 포인터는 포인터 일텐데 (주소를 담는 바구니) => OK
		타고가면 void 가 있다? 즉, 아무것도 없다? => NO
		타고가면 void 즉 뭐가 있는지 모르니 너가 적당히 변환해서 사용해라 => OK

 2) free : malloc과 한 쌍으로 사용합니다. malloc (혹은 기타 calloc, realloc등의 사촌)을 통해 할당된 영역을 해제
	[힙 관리자]가 할당/미할당 여부를 구분해서 관리
	free의 인자로는 malloc으로 할당되었던 포인터가 오는데, malloc처럼 할당할 크기를 받아서 그 크기만큼의 영역을 해지하는게 아닌데 어떻게 
	영역을 적당히 잡고 해지 해줄까?
	-> 인자로 준 메모리 주소를 메모리 상으로 가보면 할당되는 영역의 위쪽에(상위 메모리)에 이미 할당된 크기가 저장되어 있습니다. 즉,
	  malloc으로 메모리를 할당하면 힙 관리자가 할당한 크기만 딱 잡히는게 아닌 할당 메모리 상위에 헤더 정보를 같이 할당하는 것입니다.
 
 주의) malloc, free를 건드기 시작하는 시점에서 점점 메모리 관련 버그가 발생할 확률이 높아집니다.
	*Heap Overflow
	- 유효한 힙 범위를 초과해서 사용하는 문제 
	(예시 : 객체 크기 만큼의 메모리를 malloc으로 할당해서 사용해야하는데 malloc의 인자를 실수로 더 작은 크기로 할당하는 경우)
	*free를 까먹었을경우
	- 메모리는 계속 할당해서 쓰는데 free를 까먹어서 해제를 안해주게 되면 점점 메모리 누수가 일어나 더이상 데이터를 저장할 메모리가 
	남지 않게 됩니다.
	*Double Free
	- 말그대로 free를 두번(여러번) 했을 경우 대부분 크래시가 나고 끝납니다.
	- 할당된 메모리에는 쓸 메모리와 이 메모리크기가 얼마인지가 포함된다고 했는데 첫 free에서 메모리가 싹 밀리고 나면 
	다음 free가 실행될때 메모리 크기에 대한 데이터가 터무니 없는 값으로 되어있어 크래시가 됩니다.
	*Use-After-Free (가장 끔찍하다고 하네요) : 메모리를 free 한 후에 다시 그 주소를 사용하는 경우
	- malloc으로 할당한 메모리가 있고 그 주소를 가리키는 포인터가 있을 것입니다. free로 메모리를 해제한후에도 포인터 자체는 할당 되었었던
	주소를 들고 있기때문에 메모리 해제 이후 그 주소에 접근하여 사용하면 이후 엉뚱한 데이터가 조작되는 버그가 일어날 수 있습니다.
	프로그래머 입장 : OMG 망했다!!!
	해커 입장 : 심봤다!!

	이런 주의점이 있다고 해서 동적 할당 자체가 문제가 있는것은 아니고 동적 할당을 활용할 때 그만큼 조심해야한다는 이야기
 
 malloc / free는 C언어 시절부터 사용하던 명령어들 이었습니다. C++ 에서는 new / delete, new[] / delete[]가 등장 하였습니다.
 3) new / delete : C++ 에서 추가된 연산자(malloc/free는 함수였습니다.) 
	new 사용법은 [TYPE]* [변수이름] = new [TYPE] 
	malloc에서는 sizeof로 할당할 메모리의 크기를 인자로 줘야 했었고 new 문법같은 경우 할당할 타입만큼의 크기를 알아서 할당해줍니다.
	delete 사용법은 delete [변수이름];
	주의할 점은 malloc/free, new/delete 짝을 맞춰줘야지 두 가지를 혼동해서 섞어 쓰면 어떤결과가 될지 장담 못한다고 합니다.

4) new[] / delete[] : 메모리할당을 한 데이터씩이 아닌 연달아 여러개의 데이터의 크기만큼 할당 할때 
	new[] 사용법은 [TYPE]* [변수이름] = new [TYPE][배열크기];
    delete[] 사용법은 delete[] [변수이름];

 malloc/free  vs  new/delete
 - 사용 편의성 -> new/delete 승!
 - 타입에 상관없이 특정한 크기의 메모리 영역을 할당 받고 싶다? -> malloc/free 승!
 * 그런데 둘의 가장 가장 근본적인 중요한 차이는 따로 있음!
	new/delete는 (생성타입이 클래스일 경우) 생성자/소멸자를 호출해준다!!
	malloc/free로 객체를 만큼 메모리를 할당 받을경우 인자로 준 sizeof(클래스)는 그저 이 크기 만큼 메모리를 할당해준다는 의미이고
	new/delete의 new/delete [클래스] 는 클래스 크기만큼의 메모리를 할당해줌과 동시에 생성자/소멸자를 호출해주어 초기화등을 해줍니다.
	아마도 malloc/free는 C언어 시절 객체지향프로그래밍이 고려대상이 아니었기 때문이 아닐까 하고 생각합니다.
*/


// 실제 상황 예시)
class Monster
{
public:
	Monster() { cout << "Monster()" << endl; }
	~Monster() { cout << "~Monster()" << endl; }
public:
	int _hp;
	int _x;
	int _y;
};


// 그렇다면 전역 변수는 어떨까?
// 동접자가 1명일때든 5만명 일때든 이 프로그램은 항상 500만 마리의 몬스터를 준비해야 할 것입니다.
// Monster monster[500 * 10000];



int main()
{
	//// 몬스터 500만 마리를 배열로 만들어 보겠습니다.
	//Monster monster[500 * 10000];
	//// 실행결과 스택 오버플로우가 나기도 하고, 만약 실행되면 이 몬스터 객체 배열만 600메가바이트를 차지합니다. 경고로 힙 영역을 사용하라고 뜨네요

	// malloc / free
	//size_t
	void* pointer = malloc(sizeof(Monster));
	// void* 를 변환해서 몬스터로 사용하기
	Monster* m1 = (Monster*)pointer;
	m1->_hp = 100;
	m1->_x = 0;
	m1->_y = 0; 

	free(pointer);

	// new / delete
	Monster* m2 = new Monster;
	m2->_hp = 200;
	m2->_x = 2;
	m2->_y = 4;
	delete m2;

	Monster* m3 = new Monster[5];
	m3->_hp = 200;
	m3->_x = 2;
	m3->_y = 4;

	Monster* m4 = (m3 + 1);
	m4->_hp = 150;
	m4->_x = 5;
	m4->_y = 3;

	delete[] m3;

	return 0;
}