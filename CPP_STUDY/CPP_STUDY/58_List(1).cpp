#include <iostream>
using namespace std;
#include <list>
#include <vector>

// 오늘의 주제 : list  - 1 - 동작원리
// 
// - vector와 비슷한 선형적인 컨테이너, vector와 다르게 node구조

/*
	list (연결 리스트)

	- list의 동작원리  #
	- 중간 삽입/삭제
	- 처음/끝 삽입/삭제
	- 임의 접근

	동작 원리


	list : 연결 리스트
	list 중에서도 단일 / 이중 / 원형 이 있습니다.
	그 중 제일 쉽게 단일 list를 기준으로

	vector처럼 선형으로 데이터가 저장되는 것은 동일
	하지만 메모리상으로 연속되게 있을 필요가 없어집니다. 
	- [1] -> [2] -> [3]	-> [4] -> [5](이미지로 나타낸다면)
	서로 어디에 존재하는지만 알고 있는상태로 드문 드문 존재 하고 있어요

	그러면 각 원소가 다음 원소가 어디있는지 어떻게 알 수 있을까요?
	위의 각 숫자들을 노드라고 하겠습니다. 
	어디에 무었이 있는지 알려주는 타입? 포인터 였습니다. 각 노드들이 포인터로 연결되어 있는것 같습니다.

	밑에 Node클래스를 간이로 만들었습니다. 
	각 노드는 분명 값을 가지고 있습니다. 그래야 이 list란 컨테이너가 의미가 있을 테니깐요
	그리고 각 노드는 다음 노드의 주소를 가지고 있어야 합니다. 타고가면 다음 노드가 있을것입니다. 즉, Node타입 포인터 입니다.
	그리고 이 노드 구조가 앞으로 자료구조에서 자주 등장할거라고 합니다.
	
	위 예시처럼 한방향, 선형으로 가리키고 있다면 단일 list

	- [1] <-> [2] <-> [3] <-> [4] <-> [5]
	이렇게 노드끼리 서로를 가리키고 있다면  이중 list
	_next와 _prev, _data를 가지고 있어 앞뒤의 주소를 압니다.

	- [1] <-> [2] <-> [3] <-> [4] <-> [5] <-> [1] ... 
	list의 마지막 부분이 다시 list의 첫부분을 가리키고 있어서 연결이 되면 원형 리스트 입니다.


	그러면 이런식의 동작원리를 가진 list가 
	- 중간 삽입/삭제	(GOOD)
	- 처음/끝 삽입/삭제 (GOOD)
	- 임의 접근
	에 대해 어떤 효율을 가지고 있는지 알아 보겠습니다.

	중간 삽입/삭제 
	- vector의 경우에는 메모리상 연속되어야 하기때문에 중간에 삽입/삭제 하기 위해서는 수정위치 뒤로는 전부 다시 복사 붙여넣기를 했어야 합니다.
	list는 연속되어 있을 필요가 없기 때문에 중간 삽입/삭제하는 수정위치의 앞 뒤의 노드들의 포인터들만 조정해주면 되겠습니다.

	처음/끝 삽입/삭제
	- 중간 삽입/삭제와 같은 이유로 용이 합니다.

	임의 접근 (Random Access  i번째 데이터는 어디 있습니까?)
	- list는 각 노드들이 메모리상에 흩어져 있고 서로 포인터로 가리키는 형태이다 보니 i번째 데이터를 찾기 위해서는 맨처음 노드부터 
	하나씩 세어가면서 노드들을 따라가 찾을 수 밖에 없습니다. 
	vector처럼 [ ] 로 값을 찾기위해서는 이 데이터뭉치가 메모리상 연속해 있을것이라는 확신이 있어야 하는데 list는 그럴수 없습니다.

	list의 iterator를 메모리상으로 살펴보니 주소 3개를 가지고 있었습니다. 
	그 중 위의 두개는 컨테이너 정보에 대한 주소이고 3번째 주소가 list의 첫번째 노드의 주소 였습니다. 
	이 첫번째 노드도 두개의 주소와 자신의값을 가지고 있습니다. 두개의 주소는 각각 다음 노드의 주소, 이전 노드의 주소였습니다.
	하지만 첫번째 노드가 이전 노드의 주소도 들고 있는게 이상합니다. 타고 들어가 보면, list.end() 가 가리키고 있는 주소입니다.
	이 end iterator도 주소세개를 가지고 있고 세번째 주소인 end노드도 두개의 주소와 하나의 쓰레기 값을 가지고 있습니다. 
	즉, end노드는 이 list가 끝났다는 의미로만사용하고 값을 가져다 쓰지는 말라는 의미입니다. end 노드에서 다시 이전 주소로 가게 되면
	list의 마지막 노드의 주소가 나옵니다. 
	[1] [2] [3] [4] ..... [마지막] [end] [1] [2] ... 
	형태로 이어져 있는것입니다.

	하지만 
	list<int>::iterator itBegin = li.begin();
	list<int>::iterator itEnd = li.end();
	일때 
	--itBegin;
	이면 itEnd를 가리켜야할텐데 크래쉬가 납니다. 주소상으로는 이어져 있지만 시작 지점에서 뒤로갈수 없게 막아두었습니다. 이렇게 쓰지 말라는 것이겠지요
	--itEnd;
	는 잘 작동됩니다. 이말도 end 지점과 마지막노드는 주소상으로도 이어져 있고 실제 사용도 가능합니다.
	++itEnd;
	이 코드는 --itBegin 처럼 크래쉬가 납니다. 

	즉 end지점과 begin지점의 연결점은 어떤 다른용도로 이어놓았지 실제 사용을 하라고 만든것이 아니었습니다.
	

	그리고 list의 iterator의 연산중 막혀있는것이 몇가지 있는데
	list<int>::iterator it2 = li.begin();
	일때  it2++, ++it2, --it2, it2-- 는 가능하지만
	it2 + 10; 같은건 불가능 했습니다. 이유는 임이 접근때 말했듯이 list는 한번에 10번 뒤의 노드에 접근하고 싶어도 결국 노드 하나씩 하나씩 
	거쳐서 이동해야 하기 때문입니다.


	추가로 알아야 할것

	* 임의 접근이 안 된다
	* 중간 삽입/삭제 빠르다(?)
	두 명제가 말이 앞뒤가 안맞는것 같습니다.

	50번 인덱스에 있는 데이터를 삭제 하려면?

	list<int>::iterator it = li.begin();
	for(int i = 0; i < 50; i++)
		it++;
	이렇게 이터레이터를 반복문을 사용해 목표 인덱스까지 옮겨야합니다.
	이후 

	li.erase(it); 
	로 목표 인덱스의 노드를 지우는것은 간편합니다.

	지금 실험한 위의 for문을 돌아서 접근한 것과

	erase로 노드를 삭제한것을 분리해서 생각해야 위의 모순이 이해가 될것입니다.

	list<int> li;   에서 li가 100번째 값까지 하나씩 더한 정수를 가지게 될것인데 그중 50번째 iterator를 따로 저장했다고 한다면
	list<int>::iterator itRemember;

	for (int i = 0; i < 100; i ++)
	{
		if (i == 50)
		{
			itRemember = li.insert(li.end(), i);
		{
		else
		{
			li.push_back(i);
		}
	}

	로 굳이 50번째 인덱스의 iterator를 따로 가지고 있다고 할때 

	li.erase(itRemember); 
	이럴때 중간 삭제가 용이하다는 의미입니다.


*/


class Node
{
public:
	Node*	_next;
	Node*	_prev;
	int		_data;
};


int main()
{
	list<int> li;

	for (int i = 0; i < 100; i++)
		li.push_back(i);

	// li.push_front(10);    // 벡터와 다르게 푸쉬 프론트를 지원합니다.
	int size = li.size();	// list도 size 기능이 있네요
	// li.capacity(); - X  // capacity 기능은 없습니다.

	int first = li.front();
	int last = li.back();

	// li[3] = 10;     // [ ] 연산자로 인덱스 접근을 할수 없습니다.


	// iterator는 제공합니다. 하지만 작동방식은 vector와 매우 다를 것입니다.
	list<int>::iterator itBegin = li.begin();
	list<int>::iterator itEnd = li.end();

	int* ptrBegin = &(li.front());
	int* ptrEnd = &(li.back());

	for (list<int>::iterator it = li.begin(); it != li.end(); ++it)
	{
		cout << *it << endl;
	}

	li.insert(itBegin, 100);
	li.erase(li.begin());
	li.pop_front();			// erase로 맨앞 값을 지우려면 pop_front가 더욱 어울립니다.
	li.remove(10);			// 인자와 같은 모든 요소를 삭제해줍니다.



	return 0;
}