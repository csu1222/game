


    멤버 변수와 멤버 함수


블루프린트 클래스에 더 나아가서 멤버 변수 멤버 함수를 배워볼겁니다. 

프로젝트에 들어가서 가장 먼저 생각해야하는게 설계도에서 내가 무엇이 필요한지 곰곰히 생각하는 시간을 가져야합니다. 

스타크래프트 마린을 예시로 들어보겠습니다. 

마린이란 유닛의 설계도를 그려야 하는데 들고 있을 데이터와 로직이 있을겁니다.
먼저 들고 있어야할 데이터는 무엇이 있을까요? 이름이 필요할것이고 또 체력,최대체력이 있을것이고 공격력도 있을것이고 또 방어력도 있을겁니다. 
거기에 스팀팩이라는 기능이 있는데 스팀팩을 사용할수 있는지 여부를 불리언으로도 들고 있을겁니다. 
또 유닛이 위치해있는 좌표도 있고 어떤 업그레이드를 했는지, 또 몇명을 잡았는지도 들고 있을겁니다. 
단순해 보이는 마린하나에서도 이렇게 다양한 데이터를 들고 있습니다. 

이런 다양한 변수들을 설계도에 적어놨다고 해서 당장 메모리를 차지하는게 아닙니다. 그냥 설계도에 불과할 뿐이고 실제로 객체를 찍어내야 그때 메모리를 차지하게 됩니다.

여기서 끝이 아니고 로직에 해당하는 마린이 할수 있는 행동을 생각해봐야합니다. 
기본적으로 이동하는 기능, 이동중에 멈추는 기능, 적군을 만났을때 적을 공격하는 기능, 그리고 패트롤이라고 일정 좌표를 왕복하면서 경계하는 기능
등등 여러 기능 로직들을 가지고 있을겁니다. 함수로 만들어 줄건데 입력값 구현부 출력값으로 만들어 준다는 것입니다. 

여기까지 이론을 알아봤는데 실제 블루프린트에서는 어떻게 추가해야할지 보겠습니다. 

생각보다 단순한데 그냥 블루프린트 클래스 화면에서 왼쪽아래에 변수란에는 변수 추가를 함수란에는 함수 추가를 해주면 됩니다. 
위의 마린의 예시처럼 간단하게 이름 string, 현재 체력 integer, 최대 체력 integer, 스팀팩 사용 가능 여부 boolean 으로 만들어 줬습니다. 
그리고 지금까지 보이지만 무시하고 있던 변수옆 눈감은 표시들을 모두 클릭해 눈을 뜬상태로 만들어 줍니다. 이것은 클래스 외부에서도 이 변수들을 확인할 수 있게끔 해주는 것입니다. 
이걸 켜주면 Map 에서 클래스로 만든 오브젝트의 Details에서 Default란아래에 수정할수 있는걸 볼 수 있습니다. 굳이 이렇게 툴상에서 수정할 일이 있을지는 모르겠지만 말입니다. 

또 클래스파일을 드래그 드롭하면 만든 오브젝트를 배치할 수도 있습니다. 싱글플레이 게임이라면 이미 몬스터위치같은게 다 지정되어있다면 툴상에서 직접 미리 배치해 두는 경우도 있고
그게아니라 MMORPG 처럼 클라측은 처음에 어떤 물체들이 있는지는 모르고 서버에 요청해 서버가 연산한 위치에 물체가 배치되는 상황이라면 툴이 아니라 코드상에서 배치해주게 됩니다. 
SpawnActor같은 기능을 보면 만들 클래스를 선택해주고 만들어줄 좌표도 Make TransForm으로 좌표를 만들어 연결해주면 프로그램 실행시 물체가 배치 되는걸 볼 수 있습니다.

이렇게 해서 클래스에 변수를 만들면 그게 실제로 객체를 만들때 포함이 됩니다. 
그런만큼 잘 생각해서 설계를 해야 하는겁니다. 왜냐면 만약 몬스터를 설계했는데 괜히 중복된 데이터 4바이트 짜리라도 들고 있게 했다가 몬스터가 50000마리를 찍어내게되면 20만 바이트의 손해가 
생깁니다. 

이전에 함수에 대한 내용에서 로컬변수는 크게 메모리를 신경안써도 되지만 클래스의 멤버변수는 좀 신경을 써야 한다고 말한적이 있는데 지금 내용이 그것입니다.
함수의 수명에 따라 휘발되는 스택메모리에 저장되는 지역변수와 객체가 존재하는동안 살아서 힙 영역에 저장되는 멤버 변수간의 차이입니다. 

여기서 끝이 아니고 데이터에 해당하는 멤버 변수뿐만아니라 로직에 해당하는 멤버 함수를 보겠습니다. 
역시 마찬가지로 멤버 변수를 추가하던 부분 위쪽에 함수도 추가할 수 있습니다. 
함수를 추가해 보면 이전에 함수 파일을 만들어 사용하던때와 별 다를게 없습니다. 입력값도 추가할 수 있고 출력값도 추가할수 있습니다. 

멤버 함수와 일반함수들과의 차이점을 알아보자면 멤버 변수는 같은 클래스내의 멤버 변수들에 접근해 사용할수 있습니다. 멤버 변수중에 현재 체력을 그냥 출력해보는 함수를 만들어 봅니다.
바로 멤버변수 Hp를 Get 해와서 PrintText에 연결해 줄 수 있습니다. 

그런데 이게 놀라운점인데 일반적으로 함수는 어떤 객체와 연관성이 있는 함수가 아니었습니다. 그냥 독립적인 함수였기 때문에 아무데서나 호출할수 있었습니다. 
멤버함수의 경우에는 객체에 종속되어있는 함수이고 객체의 설계도상에 적혀있는 함수입니다. 그래서 멤버 함수를 호출하기 위해서는 아무데서나 호출할수 있는게 아닌 
객체를 일단 만들고 그 객체에서 멤버 함수를 호출해야 사용할 수 있습니다.

아까 레벨 블루프린트에서 SpawnActor 을 했던곳에서 반환핀을 땡겨보면 변수로 승격이 됩니다. 객체를 변수로 저장하는겁니다. 이 객체의 핀을 다시 땡겨보면 위에서 만든 우리의 멤버변수를 호출 할 수 있습니다. 

그냥 생으로 멤버 변수 Test를 호출할수 있는게 아니라 객체에서부터 호출해야 가능합니다. 

멤버변수의 연결핀에서 객체와의 선을 끊어버리면 self 라는 기본값을 가지고 컴파일이 실패하는걸 볼 수 있습니다. 객체를 잘 연결해줘야 통과되는걸 볼수 있고 

말이 나온 Self라는 것은 어떤 개념이냐 하면 아까 만든 Test 멤버 함수 말고 Test2 라는 멤버 함수 하나을 더 만들어 서 Test에서 Test2를 호출해보면 입력 핀에 self가 들어오는데 
한번 어떤 객체에서 Test가 호출되면 그 안에서호출된 Test2는 따로 다시 객체를 연결받지않아도 이어받아 호출이 됩니다. 
즉, self는 현재 함수가 실행되는 내 자신 이라는 의미로 해석하면됩니다. 

추가로 멤버 변수는 낭비가 없이 설계를 해야한다고 했는데 멤버 함수는 그에 비해서는 더욱 널널합니다. 멤버 함수는 객체하나당 각각 메모리를 차지하는게 아니고 
함수들이 저장되는 메모리가 따로 위치하고 같은 설계도로 만들어낸 객체들은 이 함수쪽으로 연결되어 로직을 실행하게됩니다. 