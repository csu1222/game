


    캐스팅


이전 시간에 객체지향의 상속성에 대해 알아봤습니다. 

블루프린트 클래스를 만들때 상속성을 고려해 만들수 있게 되었고 상속관계의 클래스는 부모님의 유산을 물려받을 수 있어서
코드 재사용성을 늘릴 수 있었고 변수로 관리할 때도 상위 계층인 부모 클래스로 관리할 수도 있었습니다. 

이게 다가 아니고 또 다른 특징이 있습니다. 경우에따라서는 자신 클래스 타입으로 관리하는게 더 편할 수 있고 다른 경우는 부모 클래스로 관리하는게 편하기도 합니다. 
두 타입을 왔다갔다 하는걸 '캐스팅', '형변환'이라고 하고 이것이 이번시간의 주제입니다. 

참조 타입 끼리의 형변환을 알아볼것입니다. 

이전시간에 했던것처럼 Actor를 상속받는 BP_Player를 만들고 Hp, MaxHp를 int 타입으로 멤버변수로 들고 있을것이고 
BP_Player를 상속받는 BP_Knihgt도 만들고 이번에는 BP_Knight만 가지고 있는 변수를 만들어 보겠습니다. 예를 들어 기사는 스태미나 라는 int 타입 스테이터스를 가지고 있다고 해보겠습니다.

BP_Player와 그걸 상속받은 BP_Knight가 있는 상태에서 레벨 블루프린트로 가보겠습니다. 

기사 객체를 만드는 Spawn Actor BP Knight로 객체를 만들겠습니다. 반환 값을 변수로 승격하고 확인하면 BP_Knight 타입 변수가 생성됩니다. Knight라는 이름으로 수정합니다.
여기서 추가적으로 살펴보고 싶은건 이 Knight로 뭘 할수 있는가 입니다. 부모 클래스에 물려받은 Hp, MaxHp를 꺼내 사용할 수 있을것이고 
또 BP_Knight에서 추가한 Stamina 도 꺼내 사용할 수 있습니다. 

이제 부터 조금씩 어려워지는데 Knihgt 변수는 타입 자체가 BP_Knight이기 때문에 BP_Arhcer 객체나 BP_Mage 객체를 저장할 수 없습니다. 
공용으로 사용하려면 BP_Player 객체를 만들어 저장하는게 대안이라고 했습니다. Player라는 이름의 변수를 추가해 BP_Player 타입으로 지정했습니다. 

이렇게 만든 Player 변수를 Spawn Actor BP Knight 의 반환 핀에 연결해보면 가능하긴합니다. 여기서 간접적인 형변환이 일어났다고 할 수 있습니다. 
지금 처럼 Player 변수를 사용하면 아쳐나 메이지도 저장할수 있기 때문에 편하기는 하지만 

BP_Knight 에서만 가지고 있는 Stamina에는 접근 할 수 없습니다. 
분명 객체 원본은 Knight가 맞기는 하지만 Player로 관리해주겠다고 한 시점에서 Stamina에는 접근할 수 없게 되는겁니다. 
그러면 에당초 BP_Player로 형변환하지말고 BP_Knight로 사용해야하지 않을까 생각이 듭니다.

항상 뭐가 무조건 옳다라는것은 없습니다. 이전시간에도 말했듯이 상속될 함수에서 일정 자식타입만 받아주면 그 함수버전을 여러 버전을 만들어야 합니다. 

이전 시간부터 같은이야기만 계속 맴도는것 같은데 결국은 Knight 변수를 BP_Plyaer로 관리하고 있어도 원본은 BP_Knight 라는건 변함이 없습니다. 그러면 다시 돌아갈수 있습니다. 
BP_Player로 형변환 했던 Player 변수에서 핀을 땡겨 Cast To BP_Knight 라는 함수를 찾아보거나 아니면 그냥 BP_Knight 만 쳐도 검색이 될겁니다. 이 것으로 다시 BP_Knight로 캐스팅을 할수 있습니다. 

여기까지만 보면 왜 바로 BP_Knight 타입으로 받아주면 되지 왜 BP_Player로 형변환 했다가 다시 BP_Knight로 형변환을 하는지 이해가 안갈수 있습니다. 

하지만 객체 변수들을 BP_Player로 캐스팅해 관리하면 한번에 같이 관리할 수 있고 Cast To BP_Knight 를 정상적으로 통과 했다면 원본이 BP_Knight이고 아니라면 Cast Failed 인 경우로 빠져나가게됩니다. 
즉, 변수의 원본이 BP_Knight 인지를 질문하는겁니다. 


이 부분이 정말 중요한 부분입니다. BP_Knight 객체를 생성하고 BP_Player 라는 어떻게 보면 좀 더 범위가 작은 클래스로 캐스팅하면 데이터가 소실되는것이 아닌지 생각합니다. 
하지만 그렇지 않습니다. 

BP_Knight 객체가 스폰으로 생성이되어서 힙 영역에 일정 메모리를 할당받아 주소도 생겼을 것이고 그안에 Hp, MaxHp, Stamina 등의 데이터를가지고 있을겁니다. 
그리고 Knight 변수는 BP_Knight 객체의 주소를 들고 있으면서 그 곳의 데이터를 BP_Knight 라고 해석하는겁니다. 
또 Player 변수는 BP_Knight 객체의 주소를 들고 BP_Player라고 해석합니다. 그러니까 사실 데이터 손실은 나지 않았고 단지 그 데이터를 보는 관점에 따랄 BP_Player에 대한 정보만 접근할 수 있는지 
아니면 BP_Knight 까지 데이터를 접근할 수 있는건지 다른겁니다. 

그리고 형변환이 일어날 수 있다고 했지만 성공해야 이후가 가능한거지 항상 형변환이 성공한다는 말은 아닙니다. 
예를들어 Spawn Actor로 BP_Player 객채를 만들었다가 BP_Knight 타입변수에 넣어줄수 있는지를 해보면 안되는걸 볼 수 있습니다. 왜 그럴까요?
말로 풀어 보면 알 수 있는데 기사는 플레이어입니다. 라고하면 맞는 말인데 플레이어는 기사입니다 라고하면 말이 이상해집니다. 플레이어는 기사일수도 마법사일수도 궁수일 수도 있는데 
그냥 기사라고 단정지을수 없는것입니다. 

부모 클래스에서 자식클래스로는 캐스팅이 되지 않는겁니다. 
이전에 BP_Knight 객체를 BP_Player 변수로 캐스팅햇다가 다시 BP_Knight 로 돌아온것은 원본이 BP_Knight이기 때문에 가능했습니다.


그래서 BP_Player의 멤버 함수 OnDamaged가 받는 인자타입을 BP_Player로 받아주는게 좋을것이고 받은 인자를 가지고 동작할때 공통적인 부분을 다룰때는 그냥 진행하지만 
기사에만 적용되는 로직이 있다고 하면 어떻게 해야할까요 내부에서 다시 BP_Knight 로 캐스팅가능한지 체크해서 처리해주면 될것입니다. 아까 Cast To 함수를 사용하면 해당 클래스로 
캐스팅이 되거나 안될때의 코드흐름이 나뉘어서 유사 브랜치 역할을 해줄 수 있었습니다. 