

        Rotator


로테이터 라고 해서 회전과 관련된 내용입니다. 이전시간 환경을 가져다 사용할겁니다. 

구체 액터를 몬스터라고 했고 실린더와 큐브를 조합해 총을 든 플레이어를 표현했었습니다. 플레이어의 총구가 다른 임의의 방향을 가리키고 있을때 
플로어 중앙에 있는 몬스터를 향해 방향을 돌리는 작업을 해볼겁니다. 

레벨 블루프린트에는 몬스터와 플레이어의 참조를 가져온 상태입니다. 

맵에서 플레이어의 디테일을 보면서 회전 시켜보면 로테이션이라는 수치가 변한다는걸 알 수 있습니다.

다시 레벨 블루프린트로 와서 이번에는 아직 다뤄보지 않은 변수 타입인 로테이션 타입과 트래스폼 타입 변수를 만들어 봤습니다. 이때 트랜스 폼 타입 변수의 내용을 보면 
또 세가지 타입을 한번에 들고 있는데 Location, Rotation, Scale 세가지 를 들고 있습니다. 즉, 트래스폼 이라는 타입은 위치, 회전, 크기에 대한 정보들을 한번에 관리합니다. 
그렇기 때문에 또 트랜스 폼을 구조체 핀 분할로 노드 상에서 분리해 볼 수 있고 또 그중 Location은 Vector타입이기때문에 한번더 분해 할 수 있습니다. 
Rotator도 분해가 가능하고 Sclae 도 분해가 가능합니다. 세가지 모두 float 3개로 이뤄져 있기 때문에 결국 float 9개로 이루어진 구조체가 트랜스폼입니다. 

그러면 이번 주제인 Rotator는 어떤게 특별할까요 어짜피 분해해서 float 세개를 관리할꺼면 그냥 Vector로 관리하지 굳이 Rotator 라는 타입을 따로 만들었는지 궁금합니다.
사실은 Rotator 가 float 세개로 이뤄져 있는것 같이 보이지만 컴퓨터가 보기에는 float 네개로 되어있습니다. x,y,z,w 라는 값이 있습니다. 네번째 w 값은 왜 사용하냐면
그냥 세개의 값으로 로테이션을 관리하게 되면 치명적인 문제가 발생하는데 '짐벌 락' 현상이라고 합니다. 

짐벌 락 현상은 영상으로 봐야 확실히 이해가 가는데 x축 회전 y축 회전 z축 회전을 하다보면 이중 두개의 축이 곂치게 되면 제대로된 회전이 불가능해지는 현상입니다. 
그래서 이걸 방지하기위해 4번째 w 값을 같이 관리하면서 짐벌 락 회전을 우회 합니다. 

이 짐벌 락 현상은 꼭 게임에서만 등장하는 문제가 아닌 물리적으로도 유명한 문제이고 항공기 관련 내용에서도 다루고 있습니다. 

로테이션 변수의 핀을 끌어다 To Quaternion 이라는 노드를 배치하고 구조체 핀 분할로 확인하면 X,Y,Z,W로 관리하고 있다는걸 알 수 있습니다.
결론은 로테이터 라는 변수 타입은 겉으로 보기에는 벡터와 마찬가지로 float 세개로 관리하는것 같지만 짐벌 락 현상을 방지하기 위해 내부적으로는 float 네개로 관리된다고 알 수 있습니다. 

여기서 쿼터니언이 무엇인지를 좀 더 알기 위해서는 복소수에 대해 알아야 하는데 꼭 완벽하게 알고 있어야 하지는 않고 굳이 관련된 엔진 프로그래머가 아닌 이상 그냥 이런게 있다 정도로만 
넘어가면 되겠습니다. 

그래서 이번시간에 하고 싶은것은 로테이터를 활용해 플레이어의 방향을 몬스터 쪽으로 회전 시키고 싶은겁니다. 
Set Actor Rotation 이라는 기능을 사용해 회전을 시킬수 있습니다. 회전 시킬 액터를 연결시키고 회전시키고 싶은 값을 로테이터로 넣어주면 되는데 
x, y, z 값이라고도 하고 커서를 가져다 대면 Roll, Pitch, Yaw 또는 롤, 피치, 여 라고 표현하기도 합니다. 
각각이 뭘 말하는지 맵으로 가서 살펴보면  x축을 기준으로 회전하면 롤 이라는 것이고 y축 대상으로 회전하면 피치, z축 기준 회전을 여라고 합니다. 

그러면 결국 플레이어가 몬스터 쪽을 보도록 회전을 하도록 해야 하는데 그러면 삼각함수등을 이용해 값을 구해야 하는게 아닐까 생각이 듭니다. 
그런데 이미 엔진에 관련된 기능들이 함수화 되어서 제공되고 이것을 가져다 사용하는걸 권장합니다.

먼저 몬스터와 플레이어 두 물체의 위치를 꺼내올것인데 함수중에 Find Look at Rotation 이라는 함수가 있습니다. 입력으로 시작위치와 끝나는 위치를 주게되면 그 회전값이  반환 되는 함수입니다. 
커서를 가져다 대면 설명도 "시작 위치에서 타겟 위치를 바라보도록 오브젝트의 회전값을 구해줍니다." 라고 되어있습니다. 
사용하기 위해서 플레이어의 Location과 몬스터의 Location을 각각 인자로 넘겨주면 될것 같습니다. 

이렇게 해서 테스트를 해보면 플레이어가 휙 고개를 돌려 몬스터를 바라보는걸 확인할 수 있습니다. 

이런식으로 이미 제공되어있는 함수들을 활용해 회전을 구현하는게 맘편할것입니다. 굳이 세부적인 이론을 공부해 직접 구현하는것은 특수한 이유가 아니고서는 효용이 떨어집니다. 

추가로 좀 더 원하는것은 만약 몬스터가 좀 위쪽에 있었다면 실행하는순간 플레이어도 비스듬히 위쪽을 바라 보게 될겁니다. 이게 문제되지 않는 상황도 있을건데 그게 아니라 
바라보는 몬스터가 보스몬스터라서 키가 크다고 플레이어가 위를 쳐다보는것은 잘 없는 일입니다. 그냥 z축 대상으로만 회전하도록 해주고 싶다고 하면 어떻게 할까요?

Find Look at Rotation 함수의 결과물에서 z축 결과물 만 빼고 다 날려주면 되겠습니다. 반환핀을 구조체 핀 분할을 해서 이중 z값만 가져다가 로테이터를 만들어 줘 Set Actor Rotation에 연결해주면 되겠습니다. 
핵심은 회전을 할때 원하는 조건에 따라 로테이터의 값들을 취사 선택해 사용할 수 있다는것입니다. 

또 한가지 추가로 지금 상황을 프로그램을 시작하자마자 휙 몬스터를 보는게 맘에 안들고 천천히 보도록 하면 좋을것 같습니다. 
이럴때 활용할 수 있는 기능이 Rinterp to 라고 인터프리션 보간을 해주는 기능입니다. 
Rinterp To 노드를보면 현재 로테이터 값과 타겟 로테이션 갑을 주고 Delta time Interp Speed를 인자로 받고 있습니다. 

이것을 Set Actor Rotation에 연결해주고 또 틱 이벤트에서 실행해줘서 스르륵 회전하도록 해줍니다. 


정리해보자면 로테이터는 벡터와 달리 float 네개로 이루어진 쿼터니언 이었고 쿼터니언을 사용하는이유는 짐벌 락 현상을 피하기 위해서였다 
내부적으로는 그렇고 사용하는것은 그냥 x,y,z 값들을 가지고 다루면 되었습니다. Set Actor Rotation 으로 타겟 오브젝트의 회전을 수정해주고 
플레이어가 몬스터를 바라보는 회전각도를 구할때는 직접 삼각함수를 사용해도 되겠지만 간단하게 지원되는 Find Look at Rotation 함수를 사용할 수도 있습니다. 
바라보는 각도를 어떤 축으로만 하고 싶다면 회전값에서 따로 추출해 사용할 수도 있었습니다. 
그리고 한번에 휙 돌려보는게 아닌 스르륵 회전하도록 하는 기능은 Rinterp To 라는 기능이었습니다. 