


    상속성 


지난시간 연습문제를 하면서 클래스로 객체를 사용할때 불편한 점에 대해 알아봤습니다. 

이전 시간에 연습문제 풀었던 코드들은 다 날리고 새로 만들어 볼건데 RPG를 예로 들어 Knight, Archer, Mage 라는 세가지 클래스를 만들었습니다. 

레벨 블루 프린트에서 변수를 만들때 딱 타입을 정해주면서 만들어야 했습니다. 
여기서 아쉬운점은 아쳐 변수를 기사 변수와  동시에 관리할 수 없습니다. 그냥 변수를 각각 관리하면 되지 않나 싶기도 한데
여러 변수를 뭉쳐서 한번에 관리하는것에 이점도 있습니다. 

변수를 한번에 관리하는 이점으로는 나이트 아쳐 메이지 세가지 직업의 플레이어들을 그냥 플레이어아이디로 묶어서 Map으로 관리할 수도 있는데 
각각 관리하면 Map도 각각 만들어 관리해야합니다. 이런 각각 관리하는게 가지수가 늘면 늘수록 불편해 질겁니다. 

이외에도 이전 연습문제에서 살펴봤듯이 공통된 기능을 각 클래스마다 관리해야하면 매우 번거로운 일이 될겁니다. 

그래서 객체지향에서는 설계에 대해 많은 이론이 있는데 그 중에서도 객체지향을 지탱하는 3대 요소가 있습니다. 
'상속성', '은닉성', '다형성'입니다. 그 중에 오늘 알아볼것이 상속성입니다. 

상속을 이해하면 위에서 말한 문제들을 다 해결할 수 있습니다. 

일상적인 상황에서 상속이라는 단어는 부모로부터 재산이나 빚을 이어 받는걸 상속이라고 합니다. 
마찬가지로 프로그래밍에서의 상속도 그렇습니다. 무엇인가 더 상위 구조에서 기능을 물려받는것입니다. 상속 관계를 어떻게 설정할지를 고려할때는 "is a" 를 생각하면됩니다.
영어권 프로그래밍에서 유명한 말인데 예를들어 "고양이는 동물 입니까?" 라는 질문을 하면 고양이는 동물이 맞기 때문에 고양이라는 클래스를 만들때는 더 상위인 동물 클래스로부터 상속
받으면 되겠다 라고 생각하면 됩니다. 
위에서 만들었던 Knight, Archer, Mage 라는 클래스들을 생각했을때 이 것들은 더 상위인 플레이어 클래스로 묶을 수 있을것 같습니다. 

상속 받는법을 알아보겠습니다. 새로 블루프린트 클래스 BP_Player 를 만들어 줍니다. 이 클래스를 상속하도록하는 방법이 몇가지 있는데 먼저 지금처럼 먼저 따로 Knight 클래스를 만들었을 경우도
수정할 수 있습니다. BP_Knight 파일을 열고 위의 클래스 세팅을 클릭합니다. 그러면 최상단에 부모클래스가 액터로 되어있습니다. 이건 처음 클래스를 만들때 이렇게 선택해줘서 이고 
BP_Player를 검색해 부모 클래스로 설정하면 됩니다. 

이 방법말고 아예 클래스를 만들때 상속받는 방법을 알아보겠습니다. BP_Archer를 삭제하고 다시 만들면서 알아 보겠습니다. 
새 블루프린트 클래스를 만들면 항상 뭔지모르고 액터를 고르던 창이 뜹니다. 여기서 하단에 모든 클래스쪽 화살표를 열고 그곳에 BP_Player를 검색해 선택합니다. 
사실 이 부분에서 어떤 클래스를 상속할지 알려주고 있었습니다. 

그래서 처음 생성할때 설정하거나 이미 만들었더라도 중간에 상속받을 수 있다는겁니다. 
BP_Mage도 BP_Player를 상속받도록 해줍니다. 

이제 공통으로 사용될 데이터나 로직들을 BP_Player에서 관리해주면 산하 클래스들에 일괄 적용됩니다. 
Hp, MaxHp같은 공용으로 사용할 만한 변수를 Player클래스에 추가하고 Knight, Archer, Mage를 보면 일단 딱히 뭐가 추가된거 같지는 않지만 클래스 블루프린트에서 Get Hp를 해보면 
잘 작동한다는걸 알 수 있습니다. 

클래스 멤버 변수중에는 보이지 않지만 블루프린트 창에서 톱니바퀴를 클릭해 상속받은 변수 표시를 켜주면 아주 많은 변수들이 숨겨져 있던걸 알 수 있습니다. 
BP_Player만 상속 받았는데 왜 HP, MaxHp 만 있는게 아니라 그 외에도 상속받은 변수가 많냐면 BP_Player 자체도 Actor라는 클래스를 상속 받아 만들었었기 때문입니다. 
즉 Knight, Archer, Mage는 Player를 상속받기도 했지만 그 윗줄 클래스들도 상속 받은것이기도 하다는겁니다.

이 상황에서 BP_Player에 이전 시간에 만들었던 OnDamaged 를 만든다면 BP_Player 를 상속받은 하위 클래스들은 모두 OnDamaged를 사용할 수 있게 되는겁니다. 
이전 시간에 발견했던 문제점중 비슷한 코드를 여러군데에 하나하나 만들어야 한다는게 문제중 하나였습니다. 그걸 이렇게 우회할 수 있게 되었습니다.

Player vs Monster 에서 사용했었으니까 OnDamaged를 하나더 상위 클래스 Creature 같은 이름으로 지어 여기에서 OnDamaged 함수를 관리하면 될것같습니다. 

또 하나 유용한 기능은 자식 클래스들을 더 상위 클래스로 캐스팅하면 같은 타입으로 관리 할 수 있게 됩니다. 
이전 시간에 알아봤던 문제점중에 OnDamaged의 인자로 BP_Knight, BP_Archer 같은 타입으로 받게 되면 각 타입마다 하나씩 함수를 만들어 줬어야 하는데 이걸을 뭉뚱그려서 BP_Player타입으로 같이 사용할수 
있게 된겁니다. 그리고 같은 부모 클래스를 가지고있다면 캐스팅 안해도 인자로 줄 수도 있습니다. 

정리하자면 
상속을 받으면서 반복될수 있는 코드를 상위 클래스에서 관리하면서 정리가 된다는 것과 공통된 부모 클래스를 가진 클래스 끼리는 부모 클래스의 멤버 함수에 인자로 다 줄수 있게 됩니다.
이 속성을 상속성 이라고 합니다. 