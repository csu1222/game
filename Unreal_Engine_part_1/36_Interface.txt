


        인터페이스


인터페이스에 대해 설명하기 위해서는 그 필요성부터 시작해야합니다. 

우선 '다중 상속'부터 시작해 보겠습니다. 

다중상속이란. 이전에 배운 상속을 기억할겁니다. 상속의 이점은 반복되는 코드를 정리할 수 있고 또 자식 객체를 부모객체로 캐스팅하면 한번에 관리할수도 있었습니다. 
여기까지는 상속성에 대한 내용이었고 여기에 다형성을 적용할 수 있었습니다. 상속 받은 멤버 함수에서 자식 클래스에서 원하는 사양으로 함수를 재 정의 할수 있었고 
오버라이드라고 했습니다. 

예를 들어 몬스터라는 클래스를 만들고 그 자식 클래스로 오크, 스켈레톤이 있다고 해보겠습니다. 
여기서 새로운 사양으로 오크 스켈레톤이란 것을 만들게 되었습니다. 오크와 스켈레톤의 두 성질을 다 가지고 있어야 할텐데 
양쪽의 상태를 동시에 받는걸 다중 상속이라고 합니다. 

그런데 다중상속은 대부분의 프로그래밍 언어에서 굉장히 끔찍하게 생각합니다. 
위의 예시에서 오크와 스켈레톤의 포효가 각각 다른 소리를 내고 있었고 이 포효는 몬스터로부터 내려온 몬스터들은 다 가지고 있는 기능이라고 하면 
오크 스켈레톤은 두 포효중 뭘 상속받아야 하는지부터 햇갈립니다. 

일부 언어에서는 다중 상속을 허락하되 가급적이면 사용하지 말라고 하던가 아니면 최근의 언어에서는 아예 다중상속을 할수 없게 하였습니다. 
블루프린트만 하더라도 다중 상속이라는 기능이 없습니다. 

조금 아쉬울 수 있습니다. 위의 예시에서 오크 스켈레톤이라는 걸 만들기에는 다중상속이 딱 맞을것 같은데 말입니다. 


또 다른 예를들어보겠습니다. 어떤 게임을 만들건데 이번에는 유닛들마다 날라다니는 기능을 부여하려고 합니다. 
그래서 날수 있는 몬스터들을 FlyableMonster 라는 클래스를 만들고 이것도 일단 몬스터이다보니 Monster 클래스를 상속 받을겁니다. 

FlyableMonster에는 넣고 싶은 기능이 일단 날아야 하니까 Fly 라는 기능과 착지하는 Land 라는 기능을 넣어주겠습니다. 
그런데 만약에 오크가 일반적인 오크가 아니라 날개달린 오크가 등장하게 되면 또 다중 상속을 해줘야 한다는 문제가 생깁니다. 그렇다고 안쓰기는 아쉬운게 
클래스마다 Fly, Land 같은 기능을 넣어주기보다는 상위 클래스를 만들어 묶어 관리하는게 편하였습니다. 

그리고 이럴때 이용할 수 있는게 인터페이스 라는 개념입니다. 
인터페이스는 상위 클래스로부터 기능을 상속받는다라는 개념은 아니고 어떤 클래스가 어떠어떠한 기능을 할것이라고 약속하는것에 가깝습니다. 
이렇게 말하면 이해하기 어려우니 실습을 통해 더 자세히 알아보겠습니다. 

액터를 상속받은 몬스터 클래스와 그 몬스터 클래스를 상속 받은 오크 클래스를 만들었습니다. 여기서 오크에 날라다닐 수 있다는 약속을 해줘야합니다. 
인터페이스를 만드는 방법은 컨텐츠 브라우저를 우클릭하고 블루프린트->블루프린트 인터페이스를 선택해주면 됩니다. 
이렇게 만든 인터페이스를 더블클릭으로 열어보면 새 함수 New Function 하나가 만들어져 있습니다. 
우리가 오크에 추가해주고 싶은 기능이 하늘을 날고 착지하는 Fly와 Land였으니까 각 함수를 만들어 보겠습니다. 

그런데 인터페이스에 추가된 함수를 보면 따로 노드를 추가하거나 하는 코드 수정이 안됩니다. 즉, 인터페이스는 함수의 시그니쳐를 물려받는 느낌이지 구현부를 물려받지는 않습니다. 
여기에 함수의 형태를 정해주는것이다 보니 입력은 어떻게 받는지 출력은 어떤걸 출력하는지를 정해 줄 수 있습니다. 

일단 지금은 왠지 모르지만 Land의 출력값으로 int타입 Result를 반환 한다고만 설정하고 컴파일 저장해주겠습니다. 
딱히 의미는 없지만 인터페이스의 경우는 출력값이 있는지 없는지에 따라 살짝다르게 동작하기 때문에 그걸 테스트 해보기 위해 의미없는 출력값을 하나 만든겁니다. 

이제 성공적으로 IFlyable 이라는 인터페이스를 만든 상태이고 인터페이스는 다른 클래스에서 상속받는 개념이 아니라 인터페이스를 구현하겠다고 약속을 해야합니다. 

다시 오크 클래스로 돌아가 상단에 클래스 세팅을 클릭하면 오른 창에 인터페이스 란이 있습니다. 그곳에 상속된 인터페이스와 구현된 인터페이스 란으로 나뉘는데 그 중 
구현된 인터페이스 쪽에 추가 버튼이 있고 아까 만든 IFlyable을 선택하면 Fly, Land 의 시그니쳐가 생깁니다. 

이 인터페이스와 상속이 다른점은 인터페이스는 여러개의 인터페이스를 추가할 수 있고 추가된 함수의 시그니처까지는 있지만 그 구현부는 직접 만들어야 합니다. 

추가한 인터페이스를 보면 아까 Fly는 반환 타입이 없게 만들었고 Land는 반환 타입이 있도록 만들었습니다. 
반환 값이 있으면 함수로 만들어지고 반환 값이 없으면 이벤트로 구현이 됩니다. 

우선은 Land를 살펴보면 Land를 더블 클릭해 선택하면 지역변수 란이 생기고 Land에서 사용하는 지역변수를 관리합니다. 
일단은 별 동작은 안하고 Land를 출력하고 끝내겠습니다. 
Fly에서도 그냥 Fly를 출력하고 끝내겠습니다. 

두 가지 함수형 인터페이스와 이벤트형 인터페이스의 차이를 보자면 먼저 함수형 인터페이스는 자신의 로컬 변수를 가질 수 있고 함수형은 한번 호출되면 구현부를 쭉 실행해야합니다. 
이벤트의 경우에는 딱 호출되었을때 이벤트에서 시작하기는 하겠지만 언제 끝날지는 정해져 있지 않습니다. 
특히나 어떨때 차이가 있냐면 기능중에 Delay라는 기능이 있는데 말 그대로 코드 흐름을 인자로 받은 시간동안 기다렸다가 실행하는 것인데 
이게 실제로 그런지 확인하기 위해 Delay 앞뒤로 PrintText를 해보겠습니다. 

이벤트에서는 딜레이를 줄 수 있는 이유가 이벤트부터 코드를 진행하기는 하는데 언제 까지 끝내라는 뭐가 없기 때문에 차례대로 하나씩 처리 할 수 있기 때문이고 
함수에서는 딜레이하게되면 나머지 코드가 실행되지 않기 때문에 엔진이 크래시가 납니다. 


결국 블루프린트에서 함수와 이벤트가 미세한 차이를 가지고 있는데 이벤트는 실행이 되는 계기다 라고 보면 되고 
함수는 하나의 기능이라서 시작했으면 끝까지 실행이 되어야 한다는 차이가 있습니다. 

블루프린트에서만 이렇게 이벤트와 함수형태로 나뉘어 만들어지고 다른 프로그래밍언어에서는 그냥 함수 형태로 만들어 집니다. 

이제 테스트를 할건데 이전처럼 Spawn Actor 로 BP_Orc 객체를 만들고 부모 클래스 변수인 BP_Monster로 받으면 한번에 관리할 수 있어습니다. 
이와 같이 변수로 IFlyable 타입의 변수를 만들 수 있습니다. 또 이것으로 BP_Orc를 받아줄 수도 있습니다. BP_Orc는 IFlyable을 구현할것이라고 약속했기때문에 가능합니다. 
IFlyable 변수의 이름은 FlyableObject라고 하겠습니다. 

FlyableObject 에서 역시 Fly를 호출할수 있고 Land도 호출할 수 있습니다. Fly, Land 순으로 호출하고 실행해보면 
로그가 Land가 먼저 뜨고 그 다음 Fly Start가 뜹니다 3초후에 Fly End가 뜨는걸 확인할 수 있습니다. 


그리고 상속에서도 비슷한 기능이 있었지만 우리가 결국 BP_Orc를 만들어 그 실체를 Flyable로 관리를 하고 있었습니다. 
그렇다는것은 오크 뿐만아니라 다른 추가적인 클래스도 Flyable로 관리할 수 있다는겁니다. 

경우에 따라 다시 원본 객체로 돌아가고 싶을 수도 있습니다. 인터페이스 변수의 핀을 땡겨서 살펴보면 Cast To BP_Orc로 다시 돌아가는 기능도 구비되어있습니다. 

결과적으로 상속을 잘 이해했다고 하면 인터페이스와 매우 비슷하게 사용할 수 있는데 다른점은 인터페이스는 여러개를 적용할수 있다는 점이었습니다. 
그리고 상속받으면 부모클래스에서 선언된 구현부를 그대로 사용할 수 있었는데 인터페이스는 함수의 시그니처만 주는것 뿐이지 구현부는 직접 만들어 사용해야 합니다.

이것을 어떻게 응용할 수 있을것인지는 어느날 방탈출 게임을 만든다고 해보겠습니다. 
방탈출게임에서 갇혀있는 상태에서 움직이다가 어떤 상호작용이 가능한 물체에 다가가면 영문 E 표시가 뜨고 E를 누르면 해당하는 상호작용이 일어나는 사양이라고 해보겠습니다. 
그러면 물체들을 만들때 상호작용이 가능한 물체라면 상호작용 인터페이스를 붙여서 관리해주면 편할겁니다. 
어떤 플레이어가 물체에 가까이 갔을때 그 물체가 상호작용이 가능한 타입인지를 체크하는데 Cast To Interactable 을 해봐서 통과가 된다면 상호작용이 된다거나 하는 식으로 구현할 수 있을겁니다. 
