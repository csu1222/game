


        함수 기초


본격적으로 함수 기초에 대해 알아볼건데 지금까지 알게 모르게 함수를 사용하고 있었습니다. 
PrintText 부터 Set, Get 도 다 함수라고 할 수 있었습니다.

함수를 사용하는방법으로 블루 프린트에서 변수를 추가하듯이 왼쪽 창에서 Funtion 추가를 하는 방법도 있긴한데 이건 C++에서 말하는 멤버 함수에 해당하는 것입니다.

오늘 배울 함수는 멤버 함수가 아니고 멤버함수는 나중에 객체 지향에 대해 배울때 다시 알아보겠습니다. 

레벨창으로 가서 콘텐츠 브라우저에 BluePrints 폴더에서 추가를 할건데 역시 우클릭 블루 프린트 -> 블루 프린트 함수 라이브러리 Funtion Library 를 추가합니다. 
그리고 그 파일을 더블 클릭해 열어주면 MuFuncLib 블루 프린트에 새 함수 New Function이라고 배치가 됩니다. 이것이 C++에서의 static function 입니다. 

이제는 DevMap 레벨 블루 프린트에서 새로 만든 함수를 호출할수 있습니다. 


함수 자체의 이론을 다시 한번 집어보자면 먼저 수학을 배우면서 함수를 처음 들었을겁니다. 수학에서는 기계같이 생각하라고 하는데 밀을 넣고 작동시키면 밀가루가 나오듯이 
x라는 수를 넣고 y라는 수를 꺼내는 것입니다. 

프로그래밍에서도 수학의 함수개념과 완전히 같지는 않지만 얼추 비슷합니다. 마치 믹서기처럼 과일들을 믹서기에 넣고 구동시키면 주스가 나옵니다. 

다시 언리얼로 돌아가 살펴보겠습니다. 함수를 호출하는것은 DevMap 레벨 블루 프린트에서 해주고 있는데 이 함수의 내용은 MyFuncLib 에서 코드를 입력해줘야합니다. 

함수를 구동할때 매개변수들을 받을 수 있고 또 반환 타입을 지정할수 있습니다. MyFuncLib에서 함수를 선택해보면 오른쪽 창에 입력과 출력을 추가해줄수 있습니다. 
예를들어 새 함수가 입력을 int 타입으로 두개 받아준다고 해보겠습니다. 

그러면 레벨 블루 프린트로 돌아가 새함수로 돌아가보면 왼쪽 입력 값으로 int 두개를 받아주는걸 볼 수 있습니다. 

지금까지 자연스럽게 사용했던 PrintText같은 노드의 핀들이 다 입력값이라는걸 알 수 있습니다. 

우리가 만든 새 함수에서는 왼지 모르겠지만 int 두개를 받아서 서로 더해준다고 해보겠습니다.
MyFuncLib에서 입력 받은 두 값을 +노드로 더해준 다음 끝이 아니라 반환을 해줘야하는데 새 함수에서 출력을추가하면 출력노드가 나옵니다. 값을 연결해주고 

다시 레벨 블루 프린트로 가보면 오른쪽 핀으로 출력 값이 나오고 있습니다. 

함수를 만들때 입력 출력값의 이름을 좀 더 의미있게 지어주면 사용할때 더 알아보기 쉬울것입니다. 함수이름 자체도 실제 동작보다 알아보기 쉽도록 지어 줄 수 있습니다. 


함수를 굳이 사용해야 하는 이유가 있다면 코드를 묶어서 관리하는 것에 의미가 있다고 할 수 있습니다. 
그냥 레벨 블루 프린트에서 모든 코드를 다 때려 박아서도 구현 할 수 있기는하지만 나중에 규모가 한참 커진다면 한 곳에 코드를 때려박았을 경우 스크롤만 엄청 길어지고 
살펴봐야할 코드가 어디인지 찾는데도 한참이걸릴것입니다. 

그래서 함수같은 기능 단위로 묶어서 관리하게되면 코드가 더욱 깔끔해 질겁니다. 

PrintText 같은 함수를 사용할때 어떤 입력값이 있고 반환값은 왜 없는지 내부적인 로직은 어떻게 되는지를 하나하나 알아보면서 사용한게 아니라 함수의 이름과 입력 인자의 이름을 
가지고 어떻게 사용해야 겠다 어떤 기능이겠구나 유추를 해서 잘 사용하고 있었습니다. 그렇듯 앞으로 배울 모든 함수를 속속들히 다 알아야 할 필요는없고 
어떤 기능인지만 알아도 사용은 할수 있겠습니다. 

이런 추상화를 거쳐야 여러명이 함께 하는 프로젝트가 잘 진행 될 수 있습니다. 

이런 코드 정리를 통한 추상화는 함수만 적용되는게 아닌 앞으로 배울 객체 지향 같은 것에도 적용됩니다. 

또 함수는 작업하는동안 자꾸 반복되는 작업을 함수로 만드는게 좋습니다. 만약 어떤 작업이 딱 한번만 동작한다면 그냥 함수 없이 코드를 적는게 성능상으로 나을 수 있습니다. 
함수라는것이 마치 순간이동처럼 호출된순간 함수의 본 코드가 있는곳으로 이동해 작업을 한 다음 다시 돌아오는 것 이기 때문에 굳이 한번만 실행될 작업을 왔다 갔다 하지 않아도 될것입니다. 


이제 함수 예제를 하나 보겠습니다. 

이전시간에 Hp라는 값을 변수로 만들어 힐링을 하는 연습문제를 만들어 본적이 있습니다. Get Hp를 하고 그걸 20 더한 다음 다시 Set Hp하는 코드였습니다. 이 코드를 복사해서 
여러곳에서 그냥 사용한다고 하면 문제가 생기는게 언젠가 사양이 추가된다고 해보겠습니다. 
예를들어 리그 오브 레전드에서는 자신에게 힐을 준사람이 있으면 이후 킬을 할때 어시스트를 주게 되는데 그러면 이 힐링을 하는 코드중 어딘가에 어시스트 기여도를 상승시킨다던지 하는 
코드가 추가 될텐데 문제는 이 추가되는 코드를 이곳 저곳에서 사용되는 힐링 코드에 각각 추가 해줘야 합니다. 이걸 수작업으로 하나씩 추가하려면 귀찮기도 하거니와 빼먹거나 잘못입력하는 
실수가 생길수 있습니다. 

그런데 이 힐하는 기능을 함수로 만들어 관리하면 이곳 저곳에서 사용한다고 해도 사양을 바꿀때 함수 원본 코드만 수정하면 흩어진 모든 힐링 함수들에 적용이 됩니다. 