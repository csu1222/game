


    슬라임 경주 


쭉 블루프린트를 한바퀴를 돌아봤습니다. 내용들을 생각해보면 다른 프로그래밍언어들과 마찬가지로 여러 기능들이 다 있고 그것을 비주얼 적으로 다룰 수 있는 툴이었습니다. 

이걸 배우고 끝이 아니라 활용해서 이런저런 게임을 만드는 실습을 해야 합니다. 
그런 의미에서 미니게임을 만들어보겠습니다. 

룰은 맵에 슬라임들을 쭉 배치한 다음 앞으로 각자의 속도로 이동하다가 목적지에 먼저 도달한 슬라임이 이기는 게임을 만들어 보겠습니다. 

슬라임 모델은 그냥 구체 셰이프를 사용하면 될것 같습니다 그런데 직접 맵에 하나씩 배치하는것 보다는 블루프린트 클래스로 관리해 주는게 좋겠습니다. 

BP_Slime 이라는 블루프린트 클래스를 만들고 컴포넌트 추가로 Sphere 를 추가했습니다. 
맵에 이 슬라임을 배치 해보면 사이즈가 좀 작아 보입니다. 한 5배정도 크기로 키워주면 좋겠는데 BP_Slime 클래스에서 Scale을 x,y,z 각각 5로 설정해주었습니다. 

다음으로 할 일은 생각해보면 일단 슬라임이 움직이는것은 전에 해봤듯이 Delta Time과 Speed 를 곱해 속도를 정하고 Set Actor Location을 틱 이벤트에서 실행해주면 될것입니다. 
그리고 목적지에 도달 했다는것을 어떻게 알 수 있을까요? 예를 들면 슬라임들이 x축을 따라 움직이도록 한 다음 각 슬라임들의 x 좌표가 일정 값이 되면 도달했다고 판별하는 방법이 있을것이고 
또 하나의 방법은 '충돌'을 이용하는겁니다. 

충돌은 본격적으로 언리얼엔진을 다룰때 등장하는 기능인데 맵에서 액터 배치 종류중 볼륨이라는 란이 있습니다. 그중 블로킹 볼륨이 있는데 일단 배치 해보겠습니다. 
큐브형태로 되어있는데 옆으로 늘리고 잘 해서 결승선이라는 영역을 만들어 봤습니다. 

이 블로킹 볼륨은 여러곳에서 사용되는데 알피지 게임에서 다음 맵으로 넘어갈때 맵의 끝쪽에 닿으면 맵이 이동된다거나 하는 식도 이 충돌 박스를 만들어 사용하는겁니다. 
그런데 이것을 그냥 배치한다고 끝이 아니라 따로 설정해줘야합니다. 

Slime 클래스에서 설정해줘야 하는데 이 객체가 충돌하는 오브젝트라는 것을 알려줘야 하는데 컴포넌트 추가에서 Colision 충돌이라는 부분이 있습니다. 기본적으로 큐브, 구, 캡슐 
형태가 있는데 지금 슬라임과 같은 구 형태 충돌을 배치하고 이름을 알아보기 쉽게 Colision이라고 지어주겠습니다. 
그리고 Colision의 속성을 보면 스피어 반경이라는것이 있습니다. 이것을 조절하면 노란 선이 움직이는데 이 선을 따라 충돌 판정을 하게 됩니다. 이 스피어 반경과 Scale 속성이 충돌반경에 영향을 주는것 
같습니다. 적절히 조절해서 슬라임 셰이프를 덮도록 조절합니다. 

그리고 나서 클래스 이벤트 그래프쪽으로 가보겠습니다. 
ActorBeginOverlap 이벤트라는 이벤트가 생겼을겁니다. 충돌되었을때 실행될 코드를 작성하면되는데 잠시 실험삼아 충돌이벤트에 그냥 텍스트 출력 함수를 연결해보겠습니다. 

한가지 더 설정해줘야하는게 있는데 맵으로 와서 슬라임의 속성중 Colision 란이 있고 이중 Generate Overlap Event 한글로는 레벨 스트리밍 도중 오버랩 이벤트 생성 이라는 옵션을 켜줘야 하는데 
오브젝트에다가 설정해주면 이 오브젝트에만 적용되고 다음 생성한 오브젝트에는 적용이 안될겁니다. 그래서 다시 BP_Slime 클래스에서 설정해주겠습니다. 클래스에서도 컴포넌트중 BP_Slime 컴포넌트 속성을 보면 
같은 오버랩 이벤트 생성 옵션이 있습니다. 

이제 충돌 실험 준비가 다 되었고 블로킹 볼륨에 닿도록 슬라임 오브젝트를 배치하고 실행하면 로그가 출력되고 안닿게 한다음 다시 하면 아무일도 일어나지 않습니다. 


충돌 실험은 끝났으니 다른 사양에따라 만들어 주겠습니다. 
먼저 슬라임을 4마리정도 배치할건데 레벨 블루프린트에서 Spawn Actor로 배치해도 되지만 그러면 배치할 좌표를 직접 계산해야하고 
아니면 맵에서 수동으로 슬라임을 배치해도 됩니다. 

쉽게 맵에서 그래그 드롭으로 배치했는데 여기서 조금 막막해지는것이 지금까지 문법에 대해 알아봤는데 실제로 적용하게되면 여러가지의 객체끼리 유기적으로 통신해서 움직이도록하는게 많이 어렵습니다. 

레벨 블루프린트에서 각각 슬라임의 참조를 가져와 사용해도 되지만 아니면 Get All Actor Of Class 로 BP_Slime클래스의 액터를 다 가져와 사용해도 됩니다. 
반환으로 BP_Slime의 배열이 반환됩니다. 이 배열을 변수로 승격해 Slimes라는 이름을 붙혀줬습니다.

이제 어디서 이 슬라임들이 이동하는 코드를 넣어줘야 할지 생각해보자면 배열을 순회하면서 이동하는 코드를 실행 해 줄 수도 있지만 이동은 슬라임 마다 내부적으로 동작하는 기능이기 때문에 
객체 지향을 적용해 움직이는것을 슬라임 내부에서 하도록 하겠습니다. 

클래스 내부에서도 BeginPlay 이벤트와 Tick 이벤트가 동시에 실행이 됩니다. 클래스의 Tick 이벤트에 이어서 이동하는 기능을 만들어 볼겁니다. 저번에 했던 것 처럼 Set Actor Location으로 구현 할 수 있습니다. 
그중에 x좌표만 어떤 속도로 이동하는것이 목표입니다. 그 방법은 Get Actor Location으로 현재 오브젝트의 위치를 가져와 x 좌표값을 + 연산을 해주면 됩니다. 이때 일단은 1이라는 값을 하드코딩으로 더해줄건데 
나중에는 Delta Time과 Speed 를 곱해 줘야합니다. 

이대로 한번 실행해보면 배치했던 슬라임들이 천천히 움직이는걸 볼 수 있습니다. 

그 다음으로 하고 싶은것은 속도를 조절하고 싶습니다. 레이싱인데 모두 동일한 속도라면 그냥 첫 위치가 곳 순위일것이기 때문에 재미가 없습니다. 

Random Float in Range 라고 특정 범위 내에서 랜덤한 float 값을 반환 하는 함수가 있습니다. 이걸로 50에서 100 사이의 랜덤한 값을 가져오고 또 이번에는 Delta Time과 곱해서 
속도를 보정했습니다. 이값을 슬라임 로케이션의 x 좌표값과 더해주겠습니다. 랜덤 범위는 차이를 크게 둬서 속도차를 더 많이 낼 수 있습니다. 

여기까지 해서 실행하면 이제 결승점에 도착한 순서대로 로그를 출력해주게 됩니다. 
기본 로그인 Hello 를 출력하도록 해놨기 때문에 누가 먼저 도착했는지를 잘 모르겠습니다. 슬라임들을 구별할수 있는 수단을 만들어보겠습니다. 
변수를 추가해서 String 타입으로 만들고 Name이라고 이름 지었습니다. 눈을 띄우고 다시 맵으로 가보겠습니다. 그러면 툴에서 슬라임이름을 직접 설정할 수 있습니다. 
구별할 수 있게 이름을 지어주고 결승선에 도착하면 출력할 프린트에 자신의 이름을 넣도록합니다. 

여기까지해서 일단 구분할 수는 있게 되었습니다. 

다음부터 어려워지는데 지금 BP_Slime 클래스에서 실행되는 코드와 레벨 블루프린트에서의 Actor는 각기 다른 Actor 라고 볼 수 있습니다. 
슬라임들중에서 자신이 이겼다라고 하는건 어떻게 알아야 할까요 다른 객체들을 포함해서 승리자가 있었는지를 판별해서 자신이 들어왔을때 승자가 있었으면 자신은 승리자가 아니고 
없었다면 자신이 승리자라는 걸 구현할 방법이 필요합니다. 

그 방법은 진짜 여러가지가 있을 수 있습니다. 그리고 이것으 디자인 패턴이라고 해서 이 구조를 어떻게 설계해 성능과 가독성과 이후 컨텐츠와의 연계를 생각하는것을 계속 생각하게될겁니다.

일단은 지금은 너무 깊은 고민보다는 직관적인 방법으로 구현해보겠습니다. 
먼저 블루프린트 클래스에서는 외부의 다른 슬라임들의 상태를 알기 힘들어 보입니다. 관리자 역의 레벨 블루프린트 측에서 체크하면 되겠습니다.

가장 직관적이고 무식한 방법으로 승자를 판별할것입니다. Tick이벤트가 매 프레임마다 호출되는 이벤트이기 때문에 여기서 승자가 있었는지를 체크하겠습니다. BP_Slime 클래스에서 충돌이벤트에서 관리해주겠습니다.
변수를 추가해줄건데 boolean 타입으로 이름은 bArrived 라고 만들어 줬습니다. 기본 값은 false로 두고 만약 도착했다면 True로 수정해주도록 하겠습니다.

이렇게 되면 밖에서는 슬라임이 끝까지 도착했는지를 추적하기 위해서는 이 bArrived를 체크하면 되겠습니다. Tick이벤트가 실행될때마다 맵이 가지고 있는 모든 슬라임들을 순회 하고 
각 원소들의 bArrived 를 체크합니다. 그런데 여기서 또 가장 먼저 도착한 슬라임이 있는지는 따로 체크해야 하기 때문에 레벨 블루프린트에 변수를 하나 더 만들어서 브랜치로 체크합니다. 

그리고 가장 먼저 도착한 슬라임이 누군지를 출력하고 싶다면 그 이름을 받을 string 변수를 하나 만들어서 저장합니다. 

만들다보면 승자의 이름도 첨에는 비어있다가 승자가 정해지면 값이 저장되니까 따로 불리언으로 승자가 있는지를 관리해야 하나 이름이 있는지 없는지로 체크하면 안되나 싶습니다.
이런건 여러가지 방법이 있을 수 있는데 레이싱을 하는 모든 오브젝트가 확실히 자신의 이름이 있다고 하면 이름으로 승리자를 관리하는것도 방법이 될겁니다. 

또 한가지 예외 체크를 해볼 것은 우연하게 동시에 도착한 슬라임이 있다면 레벨 블루프린트의 Slimes 배열에서 뒷 인덱스의 슬라임으로 덮어 씌워집니다.
이걸 방지하기 위해서는 for each 루프 대신 어떤 조건이 되면 루프에서 빠져나오는 for each with break 를 사용하겠습니다. 
for each with break는 for each 문과 비슷하지만 탈출조건을 주고 그 조건에 맞으면 루프를 빠져나왔었습니다. 처음으로 승자를 정한다음에 탈출 조건을 주면 되겠는데 처음으로 bWinner를 True로 바꾸고
WinnerName을 설정한 다음 확인차 승자 이름을 출력한 다음 For Each with Break 의 탈출조건에 연결 시킵니다. 이러면 맨 처음 한 슬라임이 도착했을때 루프가 끝납니다.

이렇게 해서 한번 실행해보면 가장 먼저 도착한 슬라임의 이름을 출력해주는 미니 게임이 완성되었습니다.

문법을 배우는것도 좋지만 그걸 적용해 프로그램을 만드는 연습을 하는게 핵심입니다. 
지금 방법은 아주 무식한 방법입니다. 


++ 슬라임 랭킹

슬라임 레이싱을 이어서 이젠 도착한 순서대로 랭킹을 매길 수 있도록 수정해보겠습니다. 

방법은 항상 수많은 방법이 있습니다. 
그 중에 무슨 방법이 더 효율적이고 아니고는 있겠지만 일단은 돌아가기만하면 오케이 입니다.

일단 지금은 bWinner 와 WinnerName 이라는 변수를 사용하고 있었는데 이 둘은 승자 하나만 기억하기 위해 만들었던 변수들이니 지금 사양에서는 필요없습니다. 

이제는 도착한 애들을 따로 관리할 필요가 있는데 도착한 각 슬라임 객체마다 내부적으로 도착한 순서를 관리해도 괜찮고 그게 아니라고 하면 그냥 레벨 블루프린트에서 도착한 순서대로 
슬라임 타입 배열에 들어가도록 해줄 수도 있습니다. 

레벨 블루프린트에서 배열로 관리하는 방식으로 해보겠습니다. BP_Slime 배열 타입 변수 Rankers 를 만들었습니다. 물론 배열이 아니라 Map으로 관리해서 이름을 Key, 순위를 Value로 관리하거나 반대도 가능할겁니다.

이제 루프가 끝날 조건이 어떻게 바뀔까요 Rankers의 내용물이 Slimes의 모든 원소들이 들어가면 끝나야 할겁니다. 각 배열의 Length를 비교해서 같아지면 종료하는 조건으로 사용합니다. 
그리고 이전 사양에서는 루프를 돌면서 승자 하나가 나오면 바로 빠져나와야 하니 For Each with Break를 했지만 지금은 계속 루프를 하면서 모든 슬라임의 랭킹을 기록해야 하니 다시 For Each 루프로 바꿉니다.
이어서 슬라임이 도착했는지 여부를 bArrived로 체크하고 있었는데 이때 이미 도착했다면 지금 막 도착했거나 아니면 이전에 도착했던 상태가 유지되고 있을 수 있습니다. 
그래서 두가지를 더 체크할겁니다. 

슬라임의 bArrived가 True 이고 Rankers 라는 배열에 아직 없는 객체여야지만 Rankers에 추가할 상태입니다. 배열안에 어떤 값이 있는지를 확인하는 기능이 Find, Contains 가 있었습니다. 
이중 Contains가 불리언을 뱉어줬었습니다. 이제 bArrived 와 Contains가 Not 인 상태가 And라면 이 슬라임을 Rankers 에 Add 해주면 됩니다. Add 다음은 로그를 찍어 주면 되겠습니다. 
포맷 텍스트로 몇번 랭크가 누구인지를 출력하면되는데 몇번 랭크인지는 Rankers에 추가된 순서대로일겁니다. 

이렇게 수정할 수 있지만 언제든 코드의 실수를 할수 있습니다. 항상 한번에 코드가 통과되어야 하는것은 절대 아니고 처음에는 문제가 생기는게 아주 빈번합니다. 
다만 그 문제가 어디서 생겼는지 빨리 확인하고 고칠수 있어야합니다. 