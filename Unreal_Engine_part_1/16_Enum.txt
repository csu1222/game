

        Enum 열거형


열거형은 자주 사용되는 개념입니다. 

어떤 곳에 사용될것이냐면 RPG 게임에서 캐릭터가 가만히 서있는 상황일수도 있고 걸어가는 중일수도 있고 전투중일 수도 있습니다. 
캐릭터의 상태를 관리해야할 필요가 생깁니다. 각 상태에 따라 알맞는 애니메이션을 틀어줘야합니다. 

이 상태를 지금까지 배운 내용으로 구현해보겠습니다.
각 상태를 변수이름으로 구별하고 각 각 값을 int 0부터 하나씩 할당했다고 하겠습니다. 
또 다른 예로는 인벤토리에 여러 가지 아이템들이 있을 수 있을 텐데 각 아이템의 종류로 어떤건 무기, 투구, 갑옷, 신발 등등 각각의 아이템 타입이 다를것입니다. 
이런것도 각각 아이템 슬롯에 어디에 들어갈지 정수로 관리할수 있을겁니다. 

그런데 문제가 있습니다. 캐릭터의 상태에서 0이 Idle 1이 Moving, 2 는 Attack이라고 해두고 
아이템에서는 0을 Helmet, 1은 Armor, 2는 Weapon 이라고 햇다고 해보겠습니다.
물론 각각 상황에 따라 캐릭터 상태에서는 이것 아이템을 가리킬때는 이것이라고 주의해 사용할 수도 있지만 게임을 여러 사람들과 공동 작업을 하고 또 어떤 날은 집중력이 떨어질 수도 있을텐데
이럴때는 각 번호를 혼동해 버릴 수 있습니다. 

그래서 정수를 직접 외워서 사용하는것을 소위 하드코딩이라고 하는 안좋은 습관입니다. 
좀 더 깔끔하게 관리하는 방법이 열거형 Enum이라고 합니다. 

언리얼엔진에서 블루 프린트가아닌 레벨창에 콘텐츠 브라우저 에서 콘텐츠 경로 아래에 BluePrints 라는 폴더를 새로 만들어줍니다. 그 안에서 우클릭해 블루프린트 -> 열거형 이라는 파일을 추가합니다. 
언리얼 네임 컨벤션에서 Enum 파일은 앞에 E를 붙여주는게 암묵적 룰이고 또 캐릭터 상태를 관리할것이기 때문에 EState 라고 이름지어주겠습니다. 

EState를 열면 Add Enumerator 혹은 이너머레이터 추가 라는 버튼이 있습니다. 이걸로 Enum들을 추가해주는겁니다. 일단 3개만 추가해서 Idle, Moving, Attack이라고 만들어보겠습니다. 
이렇게 하면 이 각 상태들은 내부적으로는 0,1,2 라는 값이지만 개발하는 입장에서는 마치 하나의 타입처럼 사용할수 있게됩니다. 

어떤 의미인지 다시 블루프린트로 가보겠습니다. 
변수를 추가할때 변수의 타입을 지정해 줄수 있는데 여기에서 EState를 검색 해보면 enum EState라고 나옵니다. 그리고 그 변수의 값을 아까 만든 구조대로 골라줄 수 있습니다. 

아이템슬롯도 마찬가지로 만들어주면 되는겁니다. 

State라는 이름의 변수를 EState 타입으로 만들었는데 이 변수도 마찬가지로 Get과 Set이 가능합니다. Set을 할때는 0,1,2를 직접 세팅하는게 아니라 Idle, Moving, Attack 을 골라주는걸 볼수 있습니다. 

enum 변수와 int 변수가 다른점은 int 변수끼리 크기가 같은지를 비교할때는 == 연산자를 사용했지만 enum은 ==enum 이라는 별도의 연산자 노드를 사용해야합니다. 

또 enum과 byte 타입의 색이 비슷한데 내부적으로는 정수와 별 다를게 없기 때문입니다. 
이걸 확인해보기위해 한가지 테스트를 해보면 BeginPlay 이벤트를 만들고 Byte to Enum EState 라는 게 있습니다. 어떤 정수를 EState라는 열거형으로 바꿔 주는 노드입니다. 
열거형 내부적으로 0,1,2 이기 때문에 변환이 될거라고 예상할 수 있습니다.  그 변환 된 값을 확인하기위해 또 enum to string 노드로 문자열로 변환후 PrintText로 출력해보겠습니다. 


또 열거형을 이용할때 유용한 기능중 하나는 열거형에 따라 분기를 시키고 싶다고 할때 물론 브랜치를 이용할수 있지만 좀더 직관적인 방법이 있습니다. 
Switch라는 기능입니다. Get State에서 핀을 끌어와 Switch 를 검색해보면 Switch on EState 라는 노드가 있습니다. 이 노드에서는 정말 직관적으로 state의 값에 따라 분기를 시켜줍니다. 
C++에서의 switch case 문에 해당하는 기능입니다. 

Enum 연습문제를 하나 풀어볼겁니다. 가위바위보 문제입니다. 
새로 Enum 파일을 추가해 각각 가위바위보 열거형을 만들어줍니다. 
블루프린트에 Player, Enermy 라는 ERockPaperScissors 타입 변수를 만들어 플레이어와 상대가 가위바위보 어떤걸 낼지를 표현해주겠습니다.

그리고 키보드 1,2,3 이벤트를 추가해 플레이어가 뭘 낼지를 골라줄겁니다. 여기까지 하면 플레이어가 뭘 낼지는 구현되었고 남은 것은 상대방이 낼 것입니다. 
상대방은 랜덤한 결과를 출력하고 싶은데 이때 사용할수 있는게 Random Integer 입니다.  3개를 랜덤으로 하나 꺼내오고 이 integer를 Byte로 변환 하고 Byte를 또 ERockPaperScissors 으로 변환해 
Set Enermy 해줍니다. 1,2,3 뭐든 누르면 Player는 자신이 낼 것을 정하고 Enermy는 랜덤한 값을 세팅하도록 해줍니다.

그 후 여기서 새로운 기능이 나오는데 CustomEvent 라는 이벤트를 만들어줍니다. 이름을 PrintCustom 이라고 지어주면 이제 Set Enermy를 한후 PrintCustom을 검색하면 PrintCustom이벤트에서 이어 실행되는 노드가 생깁니다. 
PrintCustom 에서는 Player, Enermy 각각 Get 해온뒤 Enum to String으로 문자열로 만든 다음 출력해 각각 뭘 냈는지를 출력해줍니다. 

이어서 이제는 가위바위보 결과를 출력해주는 부분을 만들어 보겠습니다.

새로 커스텀 이벤트를 만들고 PrintCustom으로 부터 이어지도록 했습니다. 새 커스텀 이벤트에서 2중의 스위치문을 사용해 플레이어가 뭘 냈는지 상대가 뭘 냈는지를 체크해서 총 9개의 경우의수를 체크하는것입니다.
가장 직관적인 방법이라고 할 수 있습니다. 

물론 이것 말고도 다른 방법이 있을수 있습니다. 
먼저 플레이어가 낸 값과 상대가 낸 값이 같은지 == 연산자로 판별하는것입니다. 이러면 바위 대 바위, 가위 대 가위, 보 대 보 세가지 케이스를 동시에 판별합니다. 
비겼는지를 브랜치로 분기를 해줍니다. 아니라면 내가 이긴 조건들을 모아서 출력하고 또 지는 케이스를 모아서 출력하는 방법이 있겠습니다. 

여기서 좀더 나아가면 결국 가위바위보라는 값은 0,1,2라는 정수이기때문에 수학적인 규칙을 찾아서 판별하는방법도 있습니다. 