데이터 기초 

>bit : 컴퓨터는 전기적인 신호만 감지 할 수 있는데 전기가 통하고 안통하고 0 과 1 이 최소한의 단위 입니다

>byte : bit가 8개 모이면 byte

>;(주석) : 어셈블리 언어에서 주석을 나타내는 기호

>2진수 표기법 : 2진수 앞에 0b를 붙이면된다 ex) 0b11, 0b10 ...

>16진수 표기법 : 앞에 0x 를 붙인다

>CPU의 구조 : ALU(arithmetic and logical unit 산술 논리 장치), 컨트롤 유닛, 레지스터, 버스 인터페이스

>메모리의 종류? : CPU안에 있는 레지스터, RAM, 하드디스크(HDD,SSD) 순으로 속도가 빠릅니다. CPU와의 거리가 
가까울 수록 빠르다고 생각할 수도 있습니다.

>레지스터 : CPU에서 연산중에 잠시 저장해야할 데이터를 저장해놓는 메모리 

>rax : 레지스터의 크기 중 64비트의 크기를 사용하는것을 rax 라고 합니다.(32비트=eax, 16비트=ax, ax를 둘로 쪼개면 각각ah,al)
가운데의 a를 a,b,c,d 로 바꾸면 다른 각각 주소가 할당합니다.

>엔디안 : 엔디안은 메모리에서 데이터를 저장할 때 어떤 순서로 저장하는지 입니다. 빅 엔디안과 리틀 엔디안 미들 엔디안이 있다고 합니다.

>빅 엔디안 : 데이터를 저장할때 최상위 바이트부터 차례로 저장하는 방식 
(예시)(0x12,0x34,0x56,0x78)
# 최상위란 메모리 주소의 숫자가 낮을 수록 최상위 

>리틀 엔디안 : 데이터를 저장할 때 최하위 바이트부터 차례로 저장하는 방식 대부분의 윈도우컴퓨터는 리틀 엔디안입니다.
(예시)(0x78,0x56,034,0x12)

>빅 엔디안과 리틀 엔디안 : 직관적으로는 빅 엔디안이 더욱 직관적이지민 왜 대부분이 사용하는 윈도우즈 환경에서는 리틀 엔디안인가하면
리틀 엔디안의 경우 포인터 값 참조가 쉽다는 점이 장점입니다. 제일 마지막 값이 처음으로 오기 때문에 첫 1byte를 가져오면 된다고 합니다.
빅 엔디안은 주로 네트워크에 사용되며 TCP/IP에서 사용합니다. 장점은 왼쪽부터 차례대로 저장되므로 읽기 편하다는 점이있습니다.

> 시프트 연산 : shift 는 옮기다 라는 의미 그대로 값을 원하는 쪽으로 옮기는 연산입니다. 예를 들어 
0011 0010 이라는 1 byte를 왼쪽으로 한칸 시프트 하면 0110 0100 이라는 값이 됩니다. 산술시프트일때는 할당된 데이터 에서 맨 앞 비트는 
0일때 양수 1일때 음수를 나타내는데 이 맨앞 양수 음수를 정하는 비트는 시프트에 포함되지 않습니다. 예를 들면
1011 0010 이라는 음수값이 있으면 오른 쪽으로 한칸 시프트 해보겠습니다. 1001 1001 이라는 값이 되는것 처럼 맨 앞의 비트는 움직이지 않습니다.

> 시프트 연산의 의미 : 단순히 비트들을 좌 우로 옮기는것에 무슨 의미가 있는지 잘 모를 수도 있지만 이 시프트 연산은 컴퓨터의 언어인 2진수에서는
왼쪽으로 한칸 옮기기 즉 한 단위를 올리는 것으로 값이 두배로 증가합니다. 반대로 오른쪽으로 옮기면 반으로 줄겠죠 

>  논리연산: 
not and or xor
조건A : 잘생겼다
조건B : 키가 크다
not A : 잘생겼다의 반대 -> (0이면 1, 1이면 0) 값의 반전
A and B : 잘생겼고 and 키도 크고 -> 둘다 1 이면 1, 아니면 0   두 조건 모두 충족하면 TRUE
A or B : 잘생겼거나 or 키가 크거나 -> 두 조건중 하나라도 충족하면 TRUE
A xor B : 잘생기고 작거나 or 못생기고 크거나   -> 둘다 1이거나 둘다 0이면 0, 아니면 1
응용사례 : bitflag(게임에서 각 비트마다 어떤 속성이라고 정하고 플레이어가 그 속성을 가지고 있는지 체크하는 것),
            xor는 같은 값을 두번 연산하면 자기자신으로 돌아오는 특징이 있습니다. 그래서 암호학에서 유용하게 쓰입니다.
            그리고 xor a, a 같이 자기자신을 xor하면 무조건 0이 됩니다.