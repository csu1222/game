


    캐릭터 생성 

이번 시간에는 단순한 비행기가 아니라 본격적인 캐릭터를 등장시켜볼겁니다. 
그 전에 이전 시간에 실습했던 BP_Plane, M_Blue, BP_GameMode는 다 지워주겠습니다. 임시로 실습용으로 만들어 뒀던 클래스들이기 때문입니다. 

캐릭터 에셋을 다운 받아야하는데 에픽게임즈에서 무료로 배포하는 에셋들이 있습니다. 
에픽게임즈 런처를 열어보면 마켓 플레이스라는 탭이 있습니다 여기서는 유료 에셋들도 있고 무료로 푸는 에셋들도 있습니다. 
아예 무료 탭이 있는데 여기서 에픽게임즈 콘텐츠를 들어가보겠습니다. 
우리가 실습해 볼 에셋은 이 중에 Paragon시리즈의 에셋을 가지고 해볼겁니다. 아마 파라곤이라는 게임을 출시했다가 망했다던지 해서 그냥 그 에셋 전체를 무료로 풀은것 같습니다. 
학습하기에 좋고 나중에 혼자 게임을 만들어볼때도 사용할 수 있는 고급 에셋들입니다. 

그래서 이 에셋들 중에서 어떤 걸 사용할거냐면 우리가 만들어볼 게임이 슈터게임이다 보니 총잡이에 해당하는 캐릭터를 만들어 보고 싶습니다. 
벨리카 라는 캐릭터가 그에 해닿해서 이 캐릭터를 다운받아주겠습니다. 그 후 추가할 프로젝트를 선택해주면 되겠습니다. 

프로젝트에 에셋을 추가한 후 다시 프로젝트를 열어보면 컨텐츠 파일안에 ParagonLtBelica 라는 폴더가 생기고 Audio, Character, FX 등이 들어있습니다. 
FX는 이펙트 같은거라고 보면됩니다. 
그런데 이 파일들 모두 가지고 있으면 git에 올리거나 할때 용량이 너무 많습니다. 그래서 그때 그떄 필요한 에셋만 남기고 지우겠습니다. 
이전에 스타터 컨텐츠를 지울때를 떠올려보면 서로 참조하고 있는것때문에 에러도 많이 나고 깔끔하게 지워지지도 않았는데 그래서 언리얼 엔진상에서 지우기 보다
파일 탐색기에서 직접 지워주면 됩니다. 

어떤 폴더를 지워줄것이냐면 일단 Audio와 FX 는 통째로 지워주고 Character폴더로 들어가서 Maps 폴더도 사용하지 않을것이니 지워줍니다. 
그리고 다시 Heroes/Belica 폴더로 들어가서 Skins라는 폴더가 있습니다. 이것은 롤같은데서 기본 영웅 모델과 스킨이 따로 있는데 그것과 비슷합니다 이번시간에서는 스킨은 사용하지 않을것이니 지워주겠습니다. 
여기까지 이번 시간에 필요한것만 남기고 삭제 했습니다.

언리얼 엔진으로 돌아가서 강의를 이어 진행하겠습니다. 
배치할 캐릭터는 ParagonLtBelica/Characters/Heroes/Belica 안에 있습니다. 
이 안에 Animation 폴더는 나중에 애니메이션시간에 사용해볼 모션들이 있고 Material 폴더에는 이전에 알아봤던 머티리얼들이 있습니다 메쉬에 옷을 입히는 느낌이었습니다. 
텍스쳐도 준비 되어 있는데 가장 중요한것은 역시 메쉬 일겁니다. 

Meshes폴더를 보면 비슷한 모양의 에셋들이 있습니다. 이중에서 관심을 가져야할 것은 스켈레탈 메쉬 라고 되어있는 벨리카 파일입니다. 
이 스켈레탈 메쉬 이외에 피직스 에셋, 스켈레톤, 릭, 스태틱 메쉬 등이 있습니다. 
이중에 피직스 메쉬는 메쉬를 몇몇 부분으로 나뉘어서 물리엔진을 적용시켜 동작할때 필요한 것입니다. 예를 들어 디아블로 시리즈중에 몬스터를 처치하면 몸이 파편이되어 사방으로 날아가는
연출같은것을 말합니다. 일단은 이정도로 넘어가고 스켈레탈 메쉬에 대해 더 알아보겠습니다. 

이전시간에 실습했던 책상이나 의자 같은것은 스태틱 메쉬입니다. 스태틱이라는것은 정적이다 라는 뜻이었습니다. 
스켈레탈 메쉬 같은 경우는 메쉬이긴한데 어떤 스켈레톤을 기반으로 되어있는 메쉬라는것입니다. 이게 무슨뜻인지 알아보기위해 일단 스켈레탈 메쉬 벨리카를 월드에 드래그 드랍해 배치해주겠습니다. 
와이어 프레임으로 보면 이 메쉬도 역시 삼각형들로 이뤄진 물체라는걸 알 수 있지만 이전 시간의 비행기와 다른것은 애니메이션이라는걸 적용해서 여러 모션을 취하게 할 수 있습니다. 

그러면 이 애니메이션을 어떻게 적용해야할까요 애니메이션은 아주 오래되고 중요한 문제입니다. 

애니메이션은 처음에 이어지는 여러 그림들을 빠르게 바꿔 출력하면 눈의 착시로 그림이 움직이는것 처럼 보이는것이 애니메이션인데 
3D 캐릭터도 애니메이션을 구현하려면 가장 쉬운 방법으로는 종이로 한 프레임씩 그리는것처럼 각 장면들을 휘리릭 보여주면 우리가 보는 화면에서는 애니메이션이 적용되는것 처럼 보일겁니다. 
그런데 그러기 위해서는 이 메쉬가 가지고 있는 수많은 삼각형들을 한 프레임마다 새로 만들어 주기는 효율이 좋지 않을겁니다. 
그래서 3D 모델링에서 애니메이션을 적용할때는 여러 메쉬를 바뀌치기 하는게 아니라 뼈대를 장착해 그 뼈를 움직이는걸로 애니메이션을 구현합니다. 

에셋중엘 Belica_Skeleton 이라는 파일을 열어보면 인체 모양과 비슷하게 각각 관절이라고 할 수 있는 곳에 뼈 Bone 들이 배치되어있습니다. 
만약 어깨 부분의 뼈들이 움직이게 되면 당연히 그 하위 계층에 있는 팔뚝, 손, 손가락 부분도 같이 움직일겁니다. 

메쉬를 단순히 겉모양에 삼각형들로 만드는게 아니라 루트 본 으로 부터 계층적인 구조로 뼈대를 만들고 그 뼈와의 상대 거리를 가진 공간에 정점들을 위치 시켜서 메쉬를 만들게 되면 
3D 애니메이션을 구현할때 어떤 뼈가 어떻게 움직인다라는 정보로 다루게 되면 자연스럽게 움직임을 취할 수 있게 됩니다. 

일일히 모든 정점들의 좌표를 계산하지 않고 그 상위 계층의 뼈를 조작하는것입니다. 

지금 알아본 내용은 아주아주 겉핥기에 해당하는 내용이고 전문적인 모델링, 애니메이팅 분야에서는 더 자세히 알아야 할겁니다. 

처음 3D게임을 만들어보는 입장에서는 스켈레탈 메쉬라는 용어가 왜 그런 이름인지를 아는 정도는 필요합니다. 
우리는 모델러분들이 만들어 준 이 스켈레텔 메쉬와 애니메이션을 가지고 게임을 만들면 됩니다. 

그런데 지금 그냥 스켈레탈 메시를 월드에 배치하는것만으로는 이걸 컨트롤 하기가 힘듭니다. 그래서 이전시간에 하던것처럼 블루프린트 클래스로 만들어 관리해주게 될겁니다.

컨텐츠 폴더아래에 다시 Blueprints 폴더를 만들고 새 블루프린트 클래스를 만들어 줄건데 이전시간에는 Pawn 클래스를 상속받았었습니다. 
Pawn클래스는 월드에 배치할 수 있고 빙의하여 컨트롤러에 영향을 받아 움직일수 있는 액터였고 그 아래로 Character 클래스는 Pawn에 더해서 걸어다니는 기능까지 추가된 클래스입니다. 
이번에는 Character를 상속받아 주겠습니다. 이름은 단순하게 BP_Player 라고 하겠습니다. 

BP_Player를 열어보면 이전 Pawn 클래스를 상속받은 BP_Plane보다 좀 더 많은 컴포넌트들을 가지고 있습니다. 캡슐 컴포넌트와 캐릭터 무브먼트 컴포넌트가 있고 캡슐 컴포넌트 아래로 화살표 컴포넌트와 메시라는 
컴포넌트가 있습니다. 이 컴포넌트들의 오른쪽으로 C++에서 편집이라고 되어있는데 이게 붙은 컴포넌트들은 이 클래스 파일내에서 임의로 삭제할수 없습니다. 
만약 이런 기본 컴포넌트들이 없었으면 좋겠다고 하면 한단계 위의 클래스인 Pawn클래스를 부모로 삼아 필요한 컴포넌트만 추가해 주면 됩니다. 

컴포넌트들을 간단히 설명해보자면 캡슐 컴포넌트는 이후 충돌과 밀접한 연관이 있고, 화살표 컴포넌트는 뷰포트에서 어떤 화살표로 방향을 가리키고 있는데 그곳이 이 객체의 앞방향이라는 뜻입니다. 
메쉬라는 부품은 이번시간에 많이 봤던 용어인데 커서를 가져다 대서 설명을 보면 스켈레탈 메쉬 컴포넌트라고 괄호로 설명합니다. 아까 살펴본 벨리카 라는 스켈레탈 메쉬를 이곳에 씌워주면 될것 같습니다. 

그래서 메쉬 컴포넌트의 디테일즈를 둘러보니 메쉬란에서 스켈레탈메쉬를 설정할수 있는 옵션이 있습니다. 여기서 Belica 를 골라주겠습니다. 

골라준 다음 보면 메쉬가 묘하게 중심이 아니라 조금 상단에 위치하고 있습니다. 이것은 모델링을 할때 로컬좌표를 메쉬의 어디 기준으로 두었는지에 따라 달라집니다. 
이 에셋같은 경우는 두 발 중간을 원점으로 두고 작업한것입니다. 우리는 이 것을 메쉬의 정중앙을 원점으로 하고 싶다면 뷰 포트에서 메쉬를 끌어 내려 캡슐의 중앙으로 오도록 세팅해주면됩니다. 
마우스로 대략 내리다보면 z 좌표가 -88이 되면 중앙으로 위치한다는것을 알 수 있습니다. 
그리고 캐릭터가 보는 방향이 화살표 컴포넌트와 일치하도록 로테이션도 조정해줍니다. 또 한가지 발밑에 총기도 같이 포함되어있는데 총도 이 스켈레톤 메쉬에 포함된 것이라는걸 알 수 있습니다. 
그런데 총이 캐릭터 메쉬에 포함되어있는건 일반적인상황은아닙니다. 보통 FPS에서는 무기 교체하는 기능이 있는데 그러려면 무기는 따로 관리해야 맞습니다. 파라곤이라는 게임에서는 한가지 무기만 사용하는 사양이었던것 
같습니다.

이제 다시 DevMap 으로 가서 방금 만든 블루프린트 클래스를 드래그 드롭해 배치해보겠습니다. 
이제 이 객체에 빙의해서 조작하면 되는데 가장 쉬운 방법은 배치한 객체의 플레이어 자동 빙의 값을 Player0으로 세팅해주면됩니다. 이것은 현재 배치된 객체에만적용되니깐 이 객체를 지우고 다시 배치하면 
또 다시 설정해줘야하는 단점이 있습니다. 이 방법이 아니라면 새로 BP_GameMode를 만들어 월트세팅에서 게임모드를 설정하고 디폴트 폰 클래스를 BP_Player로 설정하면됩니다. 

일단 객체의 플레이어 자동 빙의 를 설정하고 게임을 시작하면 카메라 시점이 BP_Player의 정중앙에 위치하게 됩니다. 이 시점 말고 3인칭 시점을 하고 싶으면 이전 시간 비행기를 만들었을 때와 같이 
스프링암과 카메라 컴포넌트를 추가하면 되겠습니다. 스피링 암의 로테이션을 y 축 -30도 정도 주고 타겟 암 길이를 700 정도 주었습니다. 

그리고 나서 방금 알아본 게임모드를 사용하는 방법으로도 다시 실습해보았습니다. 
게임모드 베이스를 상속받은 클래스를 만드는데 이름은 BP_GameMode라고 하고 DevMap의 월드 세팅에서 게임모드를 BP_GameMode로 설정합니다. 바로 월드세팅에서 디폴트 폰 클래스를 BP_Player로 바꿔도 되고 
BP_GameMode 안에서 설정해줘도 됩니다. 그러면 월드에 PlayerStart 가 위치한곳에서 BP_Player 가 배치되고 거기에 빙의됩니다. 

이제 입력을 받아줄 차례입니다. 이전에 알아봤듯이 프로젝트 세팅 > 입력 > 축 매핑, 액션 매핑 에서 설정해주겠습니다. 축 맵핑으로 MoveForward와 MoveRight를 추가하고 
MoveForward에서는 W를 1.0 S를 -1.0으로 세팅, MoveRight는 D를 1.0, A를 -1.0으로 세팅했습니다. 

BP_Player 클래스로 돌아와서 이벤트 그래프 탭을 엽니다. 이미 있던 이벤트 노드들은 지워주고 MoveForward 축맵핑 이벤트와 MoveRight 축맵핑 이벤트를 꺼내줍니다. 
이것으로 캐릭터 이동을 구현해줄건데 이전시간에 비행기를 움직일때는 Set Actor Location으로 구현했었는데 이번에는 다른 방법으로 구현할겁니다.
파트2에서 했던 방법인데 Add Movement Input 함수입니다. 이 함수가 다른점은 이 객체가 어느 방향으로 가고 싶은지 방향을 정해주면 Scale Value에 따라 속도가 조절됩니다. 

Add Movement Input 와 Set Actor Location 을 비교해보겠습니다. Set Actor Location은 입력핀중 벡터를 입력하는곳에서 이동하려고하는 좌표를 막바로 넣어주어야 했었습니다. 
그래서 델타 세컨트와 움직일 속도를 곱해서 이동할 방향 벡터와 더해주고 해서 우리가 직접 계산해 입력했어야합니다. 
반면 Add Movement Input 의 벡터 입력핀은 어느 방향으로 이동하고 싶은지만 넣어주는것이고 나중에 Add Movement Input 함수 내부에서 이런저런 연산을 다한 후 값들을 소모한다고 표현합니다. 
Comsume 이라고 합니다. 예를들어서 Get Movement Input으로 노드를 검색해보면 Last 버전이 있고 Pending 버전이 있는데 Last 버전을 보면 Add Movement Input에 넣어줬던 인풋의 합산을
처리해주고 바로 마지막으로 받앗던 이동 벡터를 Last 에서 다시 반환해줍니다. 
그런데 Add Movement Input 함수에서 처리해주는건 알겠는데 이 함수는 어디에 속한 것이냐면 Character Movement Component에 속해있습니다. 그래서 인풋 받은 인자들을 소모시키는 주체는 
Character Movement 컴포넌트입니다.  

만약 이전 시간에 만들었던 비행기는 Pawn을 상속받은 객체였는데 거기서 Add Movement Input을 호출해 사용했다면 아무런 동작도 안할겁니다. Add Movement Input에서 인자들을 받아줘도 
소모시키는 주체인 Character Movement 컴포넌트가 없기 때문입니다. 

그래서 MoveForward 이벤트에서는 Add Movement Input 에 이동하고 싶은 방향을 Get Actor Forward Vector 함수를 연결해주면 되고 스케일은 이 방향으로 한 프레임당 어느정도로 이동할지를 넣어줍니다. 
범위는 -1.0 에서 1.0까지인데 음수를 받으면 이동하는방향의 반대로 가겠죠 이 스케일과 축맵핑의 반환값을 연결하면 자동으로 앞뒤 이동이 구현됩니다. 
마찬가지로 MoveRight도 대칭적으로 만들어주는데 Get Actor Right Vector 라고 캐릭터의 오른쪽 벡터를 가져오는 함수도 있으니 이걸 사용합니다. 

잘 동작하는지 게임을 실행해보면 의도대로 잘 움직이는걸 볼 수 있습니다. 
구현하면서 캐릭터의 이동속도는 정해준적이 없는데 어디서 관리하고 있냐면 결국 Add Movement Input 을 Consume 하는 부분 처리하는 부분인 캐릭터 무브먼트 컴포넌트에서 관리하고 있지 않을까 의심을 할 수 있고 
실제로도 그렇습니다.

캐릭터 무브먼트 컴포넌트의 디테일즈를 보면 디폴트 이동 타입도 있고 가속도와 최대속도도 이동 타입마다 지정해줄 수 있습니다. 즉, 합리적으로 조절할 수 있도록 이미 다 준비되어있습니다. 

오늘 실습하고 싶은 내용은 여기까지입니다. 
이전 시간에 해봤던 비행기 실습과 비슷한 작업을 3D 에셋을 가져와 실험해본것입니다. 


또 한가지 생각해볼것은 Add Movement Input 같은 기능을 그냥 보고 넘어가지 말고 왜 Set Actor Location이라는 기능이 있는데 굳이 분리해 새로 만들었을까를 궁금해 해야합니다. 
이 기능의 장점이라고 생각할 수 있는것은 Add Movement Input의 값을 소비하는 캐릭터 무브먼트 컴포넌트 대신에 다른 무브먼트 컴포넌트로 대체 된다면 그 컴포넌트에 맞는 이동 계산을 할 수 있을것이라고 
할 수 있습니다. 
즉 플레이어의 이동방향이라는 정보와 그 정보를 계산하는 부분은 분리해서 코드를 반복적으로 만들지 않고 컴포넌트를 바꾸는것으로 대체할수 잇다는 것입니다. 

언리얼 엔진의 좋은점은 이미 만들어진 기능들은 굳이 이렇게 만들어야 했을 이유들이 다 있기 때문에 어떤 기능을 사용하고 그 이유를 고민해보면 그 노하우를 얻을 수 있습니다. 
단점은 이런 기능이 너무 많아서 처음 배우는게 힘들다는 것입니다. 