


        레이 캐스팅


지난시간까지 충돌과 관련된 기본적인 실습을 해봤습니다. 
BP_Player와 BP_Box 의 충돌 이벤트 Ignore, Overlap, Block 등을 로그를 찍어가면서 테스트 해봤고 
카메라도 Block을 해서 벽에 부딛힌 카메라 시점을 실습해봤습니다. 또 충돌 프리셋을 프로젝트 세팅에서 직접 추가도 하고 규칙도 수정해봤습니다. 

이전시간에 만들었던 BP_Box 의 콜리전 타입은 WorldDynamics 였고 BP_Player 는 기본 Pawn 이었던것을 Custom Pawn 으로 실습하고 있었습니다. 
두 콜리전 프리셋에서 양쪽에대한 충돌 레벨을 정해주고 있었습니다. 일종의 보안레벨 같은 느낌이었는데 Ignore 부터 Overlap, Block 순으로 보안레벨이 올라가는 느낌이었고 
서로 충돌레벨이 다르다면 더 낮은 레벨을 기준으로 동작하고 있었습니다. 만약 Block 을 하고 싶다면 서로 Block 이어야만 되었습니다.


그 다음 오늘 실습할것은 충돌이 직접 오브젝트끼리 부대끼면서 발생하는 충돌도 있겠지만 원격으로 충돌을 테스트 하는 경우도 많습니다. 
어떤 경우가 있냐면 마우스 커서 방향으로 레이저를 쏴서 레이저와 물체가 충돌하는지를 테스트 할 수 있습니다. 이 레이저는 다양한 곳에 사용할 수 있는데 
지금 만드는 슈팅 게임같은경우는 레이저가 곧 사격방향이 될것이고 아니명 캐릭터 바로 발 아래로 레이저를 쏴서 피격이 가능한 물체가 있으면 그 위로 올라설 수 있게 한다던지
하는식으로 사용 할 수 있습니다.

이번시간 내내 콜리전을 사용할것이다 보니 프로젝트 세팅의 콜리전 창을 열어두고 작업을 시작하겠습니다.
그런데 이전시간에 빼먹은 내용중에 Object Channels 나 Trace Channels 에서 새 채널을 만들면서 디폴트 리스폰스 를 골라 줄 수 있습니다. 
이 디폴트 리스폰스에 대한 내용인데 만약 Ignore 가 디폴트 리스폰스인 채널을 Test 라고 만들었다고 해보겠습니다. 그러면 Preset 채널들을 정책을 보면 설정했던대로 Test 채널이 다 Ignore로 되어있는데
만약 Test 채널의 디폴트 리스폰스를 수정해 Overlap 으로 바꾸면 프리셋의 채널들도 같이 다 Overlap 으로 바뀌어있습니다. 
즉, 위쪽 Object Channels, Trace Channels 의 채널은 디폴트 리스폰스를 한번에 바꿔줄 수 있습니다.
마찬가지로 새 트레이스 채널을 추가하고 TestTrace 를 만들어 보면 여기도 한번에 규칙을 수정할 수 있습니다.

그런데 이때 만약에 Preset 쪽에서 수동으로 Test, TestTrace 의 규칙을 수정했다고 하겠습니다. 
그 후 Test, TestTrace 의 디폴트 리스폰스를 수정해도 한번 손을 댄 프리셋 채널들의 규칙은 바뀌지 않습니다. 이런 부분을 조심해야합니다.
그래서 어지간해서는 처음 새 채널을 만들때 최대한 넓은 범위가 유효하도록 만들어 주고 이후 세부적으로 바꾸는것은 최소한으로만 바꾸는 식으로 만들어 줘야합니다. 
애당초 잘못 만들었다면 아예 지우고 다시 만드는것을 추천합니다.

여기까지 지난 시간 충돌 기초시간에서 누락된 부분이었습니다. 


오늘의 주제인 레이캐스팅을 시작해보겠습니다. 
먼저 레이캐스팅을 우리는 총을 쏘는 곳에 사용할것이었습니다. 총을 쏘는 기능을 BP_PlayerController 에서 InputAction Fire 이벤트부터 시작해 BP_Player 의 Fire Weapon 함수를 호출해주는게
우리의 총 쏘는 로직이었습니다. Fire Weapon 에서는 아직 애니메이션 몽타주를 실행해주는 함수밖에 없었는데 이제 필요한 코드를 넣어주어야 합니다.

Fire Weapon 에서 충돌과 관련된 코드를 사용할겁니다. 오늘 테스트할 함수는 line Trace by 계열 함수입니다. 
Line Trace by Channel, Line Trace by Profile, Line Trace For Object 세가지 를 꺼내서 실습해보겠습니다.
가장 많이 사용하는게 레이저 포인터를 쏴서 판별하는것이라서 테스트 할것이지만 이번에 테스트하는 내용이 다른 모양에도 적용이 가능합니다. 
가령 Box Trace by Channel, Box Trace by Profile, Box Trace For Object 같은 식으로 같은 기전으로 다른 모양의 충돌 판별을 할 수 있습니다. 

이번시간에는 일단 레이저포인트 형태인 Line Trace 를 테스트 해보겠습니다.
가장 사용빈도가 높은 함수는 Line Trace by Channel 입니다. 이 함수의 이름에 있는 Channel 은 프로젝트 세팅에서 만들었던 MyAttackRange 같은것들을 말합니다. MyAttackRange 의 기본 리스폰스를 Overlap으로 
해놨었는데 그대로 사용하겠습니다.
그리고 입력값으로 Start 벡터와 End 벡터를 받고 있습니다. 우리 게임에서는 캐릭터를 기준으로 겨냥한 방향 끝까지를 주겠습니다. 
캐릭터 위치는 Get Actor Location 으로 가져올 수 있었습니다. 그리고 그 위치로부터 캐릭터의 앞방향을 가리키는 Get Actor Forward 가져올겁니다. 이 Forward 에 1000정도 를 곱해주면 
단위 벡터였던 Forward가 1000만큼 길다래 집니다. 이 벡터를 현재 플레이어위치인 Get Actor Location 을 더해주면 플레이어기준 앞으로 1000 이라는 거리를 가진 점이 됩니다. 
Get Actor Location 을 Line Trace by Channel 의 Start 로 넣어주고 Get Actor Forward * 1000 과 Get Actor Location 을 더해준 값을 End로 넣어줄겁니다.

시작점과 끝점이 세팅이 되었는데 다음은 Line Trace by Channel 의 입력값중 하나인 Draw Debug Type 을 For Duration 으로 설정해보겠습니다. 이 기능은 말 그대로 디버그를 하는 기능입니다. 
어떤 의미인지 게임을 실행해보겠습니다. 게임에서 왼클릭을하면 이제 캐릭터 전방으로 허공에 빨간 줄이 표시됩니다. 이 선을 공격판정을 하는것입니다. 
지금은 캐릭터 중심에서부터 뻗어 나가지만 나중에는 총구에서 부터 나가도록 해줄겁니다.

그런데 큐브같은 경우 이 공격범위에서 피격되지않고 그냥 뚫려서 지나가는걸 볼 수 있습니다. 따로 큐브메쉬나 플레이어를 따로 하나 배치해서 다시 총을 쏴보면 그 메쉬에서 막히고 
그 뒤로는 초록색으로 궤적이 남습니다. 즉 빨간색 궤적은 피격전 이고 초록색 궤적은 피격후 라는 걸 알 수 잇습니다. 이런 룰들이 뭣때문에 적용되는지가 궁금한데 그것에 대해 이번시간에 테스트를 하고 있는겁니다.

또 지금처럼 비주얼 적으로 디버깅을 할 수 있지만 로그로 찍어서 살펴보는 방법도 있습니다.
Line Trace by Channel 의 반환 값들을 보면 Our Hit 이라는게 있습니다. 커서를 가져다 대면 타입이 Result Hit Struct 라는 것입니다. 이 핀을 끌어서 Break Hit Result 라는 함수를 호출하면 
이 구조체를 스플릿해서 보여줍니다. 이 구조체가 가지고 있는 정보가 정말 다양하다는걸 알 수 있는데 여기서 Hit Actor 라는 정보를 로그 찍어보겠습니다. PrintString 에 연결해줘야합니다.
이제 피격된 액터가 있으면 그 액터의 이름을 출력해주게 됩니다. 

게임을 실행해보겠습니다. BP_Box를 쏘면 그냥 무시되고 큐브 오브젝트에 쏘면 Cube 라고 출력이 되는걸 볼 수 있습니다. 

당연한 이야기지만 충돌 규칙을 바꿔 주면 다른 오브젝트들도 피격이 되도록 할 수 있을겁니다.
여기서 살짝 차이가 나타나는데 지난번에 알아봤던 오브젝트 채널끼리의 충돌 테스트를 할때는 BP_Box 와 BP_Player 와의 충돌을 테스트 했었습니다. 양쪽의 오브젝트 타입에 대한 충돌규칙을 맞춰 
테스트를 했었습니다. 

그런데 재미있게도 Trace Channel 같은경우에는 양쪽의 충돌규칙을 맞추는게 아니라 한쪽의 충돌 규칙만 선택해주도록 되어있습니다.
이전시간에 콜리전 옵션에서 프리셋을 추가해 줄 수 있었는데 그때 오브젝트 타입은 골라줄 수 있지만 트레이스 타입은 고를 수 없었습니다. 

트레이스는 각 물체의 클래스에서 콜리전 프리셋의 트레이스 리스폰스로 정해주는 것이었습니다.
물론 Trace Channels 에서 디폴트 리스폰스를 정해 줫었지만 다음에 수정했을때 한번에 바꿀 수 있도록 하는 기능이지 디폴트 리스폰스를 무조건 따른다는 이야기는 아닙니다.

이어서 해줄 것은 BP_Box 나 BP_Player 가 피격판정을 받도록 해주고 싶은데 방법은 그냥 BP_Box, BP_Player 각각의 콜리전 프리셋에서 MyAttackRange 에 대해 Block 을 하도록 
설정해주면 될것입니다. 

그 다음 게임을 실행해 Cube 메쉬 뿐만아니라 BP_Box 와 BP_Player 를 쏴보면 이제 피격판정이 잘 일어납니다. 
이런식으로 사용하는 것이고 

지금 우리가 사용하는 레이저 광선을 쏘는 방식에서는 무조건 처음 만나는 오브젝트를 대상으로 피격판정을 계산합니다. 
무슨 말이냐면 다시 BP_Box, BP_Player 의 MyAttackRange 에 대한 충돌 규칙을 Overlap 으로 바꿔보았습니다. 다시 게임을 실행해보면 역시 다시 피격판정이 되지 않습니다. 
그래서 처음으로 Block 이 되는 오브젝트를 대상으로 판정한다가 line Trace 입니다. 

그런데 지금 BP_Box, BP_Player 둘다 MyAttackRange 에 대해 Overlap 인 상태에서 프로젝트 세팅의 Trace Channel 에서 MyAttackRange 의 Default Response 를 Block 으로 설정해보았습니다
이 상태에 게임을 실행해 보니깐 Cube 메쉬와 BP_Player 대상으로는 피격판정이 발생하고 있습니다. 그러니까 뭔가 좀 이상한겁니다. 
BP_Box 가 피격이 안되는건 Overlap 으로 설정했으니 이해가 되는데 BP_Player는 왜 또 피격이 되는지 궁금합니다. 

정답은 BP_Player의 캡슐 컴포넌트뿐만아니라 Mesh 쪽에도 똑같이 콜리전 프리셋이 되어있습니다. Mesh의 콜리전 프리셋은 CharacterMesh로 되어있고 MyAttackRange 에 대해서는 Block 으로 되어있습니다.
왜 그러냐면 MyAttackRange 의 Default Response 를 Block 으로 했으니 따로 손을 안댄 CharacterMesh 는 Default Response를 따라가게 되는겁니다. 
이것을 의도대로 BP_Player에도 피격판정을 안나게 하려면 따로 프로젝트 세팅 콜리전의 프리셋에서 CharacterMesh 의 충돌 규칙을 MyAttackRange 에 대해 Overlap 하도록 수정해줘야합니다. 
그래서 이런 일괄적으로 수정하는것은 좀 위험한 일이고 또 Default Response 를 Block 으로 두는것도 위험한 일입니다. 왠만하면 Ignore 나 Overlap 으로 두는걸 권장합니다. 

이렇게 해서 Line Trace by Channel 을 알아봤습니다. 시작 점과 끝 점 사이를 충돌 체크를 해주는데 충돌 규칙은 Channel 을 기준으로 하는 함수였습니다.
by Channel 말고 by Profile, For Object 버전도 있었으니 테스트를 해보겠습니다. by Channel은 실습이 끝났으니 지워줍니다. 

먼저 by Profile 버전을 보겠습니다. 
이 함수는 입력중 Start, End 를 by Channel 과 똑같이 받아주고 있고 디버그용으로 Draw Debug Type을 또 For Duration 으로 설정 할 수 있는게 같습니다
다른점은 Channel 을 골라주는대신 Profile Name 을 입력할 수 있는데 이 Profile Name 이 라는것이 무엇이냐면 프로젝트 세팅 콜리전의 Preset 들을 말합니다. 
프로젝트 세팅 콜리전의 Preset 의 설명을 읽어보면 프로젝트 프로파일이라고 되어있는데 이것과 프로파일 네임은 같은 말입니다. 
그래서 MyCharacter 프리셋을 사용하고 싶으면 그 이름을 by Profile 의 Profile Name 에 입력해주면됩니다. 

프로파일을 이렇게 설정해주면 이제는 Trace Channel 이 아닌 Object Type 이 MyCharacter 인 채널을 사용하는겁니다. 즉, 이제는 오브젝트 채널끼리의 충돌 규칙을 봐야하는데 
오브젝트 끼리의 충돌은 서로의 규칙이 영향을 끼칩니다. 그런것을 유의해서 실습을 해보겠습니다. 

MyCharacter 의 충돌규칙을 테스트할 WorldDynamics, Pawn 에 대해 Block 으로 해주고 BP_Player와 BP_Box 의 MyCharacter 에 대한 충돌 규칙도 Block 으로 해주고 
테스트를 해보면 모두 피격판정이 되는걸 볼 수 있습니다.

그런데 만약 언제든지 MyCharacter 의 충돌 규칙을 WorldDynamics, Pawn 에 대해 Overlap으로 바꿔 주면 이제는 둘 모두에 대해 피격판정이 발생하지 않습니다. 
이것 빼고는 by Channel 과 크게 다른게 없습니다. 

다음으로 For Object 버전을 확인해보겠습니다. 
역시 입력을 Start 와 End 를 받는게 같습니다. 다른점은 충돌규칙을 오브젝트 타입의 배열로 받고 있습니다. 이 함수는 정말 맞추고 싶은 오브젝트 타입을 넣어주면 됩니다. 
오브젝트 타입 배열을 간편히 만드는 Make Array 함수로 WorldDynamics와 Pawn 을 넣어 배열을 만들고 Line Trace For Object 에 넘겨줍니다. 

게임을 실행해 테스트해보면 설정해준 WorldDynamics와 Panw 에 대해 피격판정이 발생합니다. 

세가지 버전이 별 다르게 어렵진 않았습니다. 
다만 Trace By 시리즈 함수가 굉장히 여러가지 있었습니다. 캡슐모양 박스모양 구모양등의 충돌 트레이스 함수들이 있었는데 그 중 가장 많이 사용되는 Line 모양의 충돌 실습을 해보았습니다.

이제는 충돌 라인을 총구 앞에서부터 시작하도록 해주면 정말로 사격 테스트가 될것입니다. 
이렇게 해서 Lay Casting 혹은 Lay Tracing 이라고 하는 기법에 대해 테스트를 해봤습니다. 

이전시간과 지금시간까지 실습해봤던 내용중 Line Trace 함수들과 프로젝트 세팅 콜리전의 MyAttackRange, MyCharacter 라는 채널들도 다 삭제해주겠습니다. 실습을 위해 만들었던거지 
이후 우리 게임에 적용할 것들은 아니었습니다. 또한 DevMap에 실습을 위해 배치했던 Cube, BP_Player, BP_Box 들도 제거합니다. BP_Box 클래스도 마찬가집니다.


여기까지 언리얼에서의 충돌관련 실습을 해보았습니다. 


그런데 한가지 알아볼것이 있습니다. 언리얼 말고 유니티 엔진에서 예를 들어보면 좋을것 같습니다. 
유니티에서 큐브하나를 배치하였고 카메라도 하나 배치하였습니다. 월드를 살펴볼 화면과 카메라에서 보는 창이 두개로 나뉩니다. 

이 상태에서 레이 트래이싱을 적용하고 싶으면 충돌의 개념이 정말 중요하다고 했는데 
만약 만드는 게임이 스타 크래프트라는것이라고 하겠습니다. 스타크래프트에서는 화면에 수많은 건물, 유닛들이 있고 무언가를 선택하고 싶으면 클릭해서 선택했었습니다. 
이것은 언리얼의 뷰포트에서 물체를 선택하는것도 마찬가지입니다. 이 선택하는 행위 자체가 너무 당연하게 느껴질 수 있지만 절대 당연한것이 아닙니다. 
우리가 보고있는 뷰포트는 3D 처럼 보이지만 사실은 2D 화면입니다. 생각해보면 당연하게도 모니터 자체가 2D 밖에 표현할 수 없습니다. 
그럼 2D 화면을 눌렀더니 3D 게임 월드의 오브젝트를 선택한다는것은 사실 놀라운 일입니다. 

물체를 선택하는 원리는 카메라가 찍고있는 화면에서 그 중앙쯤에 있는 큐브를 눌렀다 하면 게임 월드에서는 카메라에서 중앙에 해당하는 방향으로 레이저를 쏘게 됩니다.
게임월드에서 카메라가 쏜 레이저가 물체에 충돌했다고 하면 해당 물체를 선택햇다고 판정하는것입니다. 
아까 실습했던 그 레이 트레이싱이 꼭 슈팅게임에서만 사용되는것이 아니라 왠만한 게임들 모두 사용하는 기술인겁니다. 
애초에 게임 엔진자체에서도 레이트레이싱으로 작업을 하고 있던것입니다. 
설명을 유니티에서 한것이지 언리얼이건 유니티건 모두 적용되는 이야기였습니다.

