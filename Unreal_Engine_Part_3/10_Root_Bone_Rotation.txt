


        루트 본 회전

이번에 알아볼 내용은 루트 본 회전입니다.
지금 우리 게임을 시작하고 카메라를 두리번 두리번 해보면 캐릭터가 카메라의 방향에 따라 똑같이 움직이고 있습니다. 
그런데 일반적인 슈팅 게임을 생각해보면 내가 카메라를 움직인다고 해서 온 몸이 따라 움직이는게 아니라 어느정도 각도 안에서는 
상체만 따라 두리번 거리는걸 본적이 있을 겁니다. 만약 카메라가 90도를 넘어서 움직이게 되면 그때 서야 발까지 같이 회전을 하는게 일반적일겁니다.
그래야 내가 앞을 바라보면서 조금 옆을 조준하는게 말이 되기 때문입니다. 

이것을 구현하기 위해서 몇가지 방안이 생각 날 수 있습니다. 가장 먼저는 지금까지 카메라의 방향과 캐릭터의 방향을 일치시켜주고 있던 옵션이 
BP_Player 의 디테일즈 중에서 Use Controller Rotation Yaw 라는 옵션을 켜주고 있었기 때문인데 그래서 이 옵션을 끄고 나면 확실히 이제는 
캐릭터가 카메라를 따라 움직이지는 않고 이후 처리를 통해 캐릭터의 앞 방향과 카메라의 앞 방향의 각도가 90도 이상 틀어지게되면 그때 
캐릭터를 회전시킨다던지 하면 되지않을까 생각할 수 있습니다. 그런데 이런 방법을 이미 조금 다름 방법으로 구현한 분이 있어서 
그것을 알아보는 시간을 가져볼 것입니다. 

그 방법이라는 것은 루트 본이라는 것을 회전시키는 방법입니다. 
루트 본이라는것이 무엇이냐면 우리가 사용하고 있는 캐릭터인 Belica 라는 스켈레탈 메쉬가 있었는데 같은 폴더에 스켈레탈 메시 말고 
스켈레톤이라는 파일 자체가 있습니다. 열어보면 벨리카를 이루고 있는 본들을 계층적으로 관리하고 있습니다.
파일 이름은 Belica_Skeleton 이라는 이름입니다. 
열어보면 왼쪽에 Bone 들 이 쫙 나옵니다. 그 중에서도 가장 위에 있는게 최상위 계층의 root 입니다. 
이 루트를 선택해서 회전시켜보면 나머지 모든 Bone들이 전부 딸려서 같이 회전하는걸 볼 수 있습니다.
이것을 이용해서 이미 회전한것을 반대로 돌려서 보정하는 개념입니다. 이렇게 말해서는 알아 들을 수가 없는데 
설명을 해보겠습니다. 

이전시간처럼 캐릭터를 중심에 두고 캐릭터가 바라보는 방향이 있을인데 이 방향이 0도라고 하고 주위로 360도 회전을 할 수 있다고 하겠습니다. 
이 상태에서 지금까지 마우스를 움직여 카메라를 회전시키고 또 지금까지 Use Controller Rotation Yaw 옵션으로 인해 캐릭터도 같이 회전하게 되었는데 
이런 상황에서 원래 바라보고 있던 방향을 기준으로 a 라는 각도를 회전했다고 하겠습니다. 
이때 우리가 하고 싶은 것은 카메라가 움직이는것과 별개로 캐릭터는 원래 바라보던곳을 보게 하고 싶은것인데 
Use Controller Rotation Yaw 를 끄고나서 나중에 카메라와 캐릭터의 방향이 같아지게끔 필요해질때 이것을 조절하는것도 가능하겠지만 
오늘 살펴볼 방법에서는 카메라와 캐릭터의 방향은 사실상 같은 방향으로 이동하는 상태에서 아까 알아본 root 본이라는 것을 원래 방향과 카메라가 움직인
각도인 a만틈 반대로 회전 시켜줄것입니다. 그러면 사실은 카메라, 컨트롤러의 방향을 받아서 액터가 회전하게 되지만 형태를 이루는 메쉬는 회전하기 전의 방향을 
보고 있게될겁니다. 
이것을 실습해보겠습니다.

설명은 여기까지이고 시작을 해보겠습니다.

본격적으로 ABP_Player 에서 작업을 하겠습니다. 애니메이션 블루프린트는 이벤트 그래프를 열면 내부에서 사용할 변수들을 가져오는 코드가 뜨고 
Anim 그래프를 누르면 Output Pose 에 최종 애니메이션을 넣어주는 그래프가 뜹니다. 
이벤트 그래프에서 사용할 변수들을 추가로 만들겠습니다. 

먼저 속도 Speed 라는것을 따로 관리하겠습니다. Float 타입변수로 만들어 주겠습니다. 
마찬가지로 Float 변수 세개를 더 만들어주는데 CharacterYaw, PrevCharacterYaw, RootYawOffset 이라고 이름 짓겠습니다. 
CharacterYaw, PrevCharacterYaw, RootYawOffset 이 세가지가 오늘 내용에서 중요한 역할을 할것입니다. 

각기 어떤 변수인지 설명하자면 CharacterYaw 는 카메라가 움직이는대로 같이 움직이는 캐릭터의 Yaw 값을 말합니다. 
PrevCharacterYaw 는 CharacterYaw 가 움직이는데 그 이전 프레임에 위치했던 CharacterYaw 값을 말합니다. 이것과 CharacterYaw 를 비교해서 현재 프레임에서 
캐릭터의 회전이 더 갔는지 덜 갔는지를 알 수 있습니다. 
RootYawOffset 는 PrevCharacterYaw 를 더해주는 느낌으로 최종적으로 이동했을때 얼마만큼을 돌아가야지만 원래 방향을 쳐다 볼지를 저장합니다.

이 변수들을 채워줘야하는데 지금 ABP_Player 의 이벤트 그래프는 이미 bMoving 이나 MovementOffsetYaw 같은걸 계산해주고 있는 상태라서 
더 코드를 추가하는것은 가독성이 좋지 않을겁니다. 한번 정리를 하고 시작하겠습니다. 
지난시간에 작업했던 코드들을 함수로 묶어서 관리해주겠습니다. 

UpdateMovement 라는 이름의 함수를 만들고 bMoving, MovementOffsetYaw 를 구해주던 코드들을 싹 긁어와서 이 함수에서 진행하도록 연결해줍니다. 
이 코드중에서 bMoving을 구하기 위해 현재 스피드가 0보다 큰지 비교해주는 부분이 있는데 비교하기전에 아까 만든 Speed 변수에 세팅해주는 코드를 끼워서 현재 스피드를 변수화
해주겠습니다. 이 다음은 이벤트 그래프에서 UpdateMovement를 한번 호출해주면 되겠습니다. 

다음으로 지금 이 ABP_Player 가 적용된 캐릭터를 지금까지 Try Get Pawn Owner 로 매번 가져오고 있었는데 이 후로도 계속 사용할거라면 변수화해서 사용하는게 나을겁니다.
BP_Player 타입 변수를 추가하고 Player 라는 이름으로 변수를 만들어서 편하게 찾도록 해줍니다. 
이 Player 같은경우는 매 프레임마다 가져올 필요는 없고 시작할때 한번만 저장해주면 되니까 다른 이벤트에서 세팅해줘야합니다. 
ABP_Player의 이벤트 그래프에서 Event Blueprint Initialize Animation 이라는 이벤트가 Begin Event 같은 역할을 합니다.여기서 Try Get Pawn Owner 로 가져온 
폰 객체를 다시 Cast To BP_Player 로 캐스팅한후 Player 변수에 세팅해줍니다.

이어서 오늘 내용을 작업해보겠습니다. 새 함수를 추가해줄건데 UpdateTurn 이라고 이름 짓겠습니다. 
먼저 Speed를 가져와 0보다 큰지 체크해 브랜치를 해주겠습니다. 지금 캐릭터가 멈춰있는지를 체크하는건데 이번시간에는 브랜치가 true인 상황 즉, 캐릭터가 움직이고 있을때는 
작업하지 않고 캐릭터가 멈춰있을때의 상황만 작업할겁니다. 그래서 브랜치가 true이면 RootYawOffset 을 그냥 0으로 세팅해주고 다음에 이부분을 작업해보겠습니다.

이제 브랜치가 flase 일때 입니다. 이때 각도를 체크해줘야 할겁니다. 그전에 현재 CharacterYaw를 업데이트하기전에 PrevCharacterYaw 에 세팅해주면 PrevCharacterYaw는 
이전 프레임의 CharacterYaw를 가지고 있게 되는겁니다. 이렇게 해주고 그 다음은 현재 프레임의 CharacterYaw 를 구해 세팅해주면 되겠습니다. 
그럼 CharacterYaw는 Player 의 Get Actor Rotation 을 가져오고 스플릿을해 Yaw 값을 가져오면 될겁니다.

이제 현재 회전값과 이전프레임 회전값을 구했으면 메쉬를 어느만큼 회전해야할지를 구해줘야 합니다. 현재 프레임 회전값에서 이전 프레임 회전값을 빼면 
이번 프레임에서 메쉬를 어느정도 회전해야하는지가 나올겁니다. 이 CharacterYaw - PrevCharacterYaw 를 한 값을 RootYawOffset 에서 다시 빼주겠습니다. 
왜 더해주지 않고 빼주냐면 어짜피 이 각도의 반대로 이동해야하기 때문에 나중에 부호를 바꿔주느니 처음부터 빼주는걸로 하는것입니다.
이 상태에서 혹시 몰라서 Normalize Axis 라는 함수도 한번 연결해줍니다. 
Normalize Axis 는 각도를 -180도에서 180도 사이로 유지하게 해주는 함수입니다. 혹시라도 RootYawOffset의 값이 180, -180 을 넘어서  너무 많이 회전하지 않도록 
보정을 해줍니다. 여기까지 계산이 완료되면 RootYawOffset 에 세팅해주겠습니다. 

이때쯤 한번 테스트를 해보겠습니다. 이렇게 구한 변수들이 제대로 적용되는지를 포맷 텍스트로 PrintText해주겠습니다.
RootYawOffset와 CharacterYaw 를 같이 출력해볼건데 게임을 시작하고 카메라를 돌려보면 카메라를 돌려서 캐릭터가 회전한 만큼 CharacterYaw가 증가하고 
반대로 RootYawOffset 는 감소하는것을 볼 수 있습니다.

그러면 이렇게 가져온 변수들을 가져와서 어떻게 할것인지 그것을 알아보겠습니다. 
어디서 이 작업을 해야하냐면 ABP_Player AnimGraph 에서 Output Pose 에 Layered blend per bone 한 애니메이션을 연결해주고 있던 이 사이에서 
한가지 더 처리를 해주게 됩니다. 

바로 Rotate Root Bone 이라는 함수인데 함수 이름만 봐도 어떤 기능을 하는지 티가 납니다. Pitch, Yaw, 그리고 Mesh to Component 라는 값을 입력 받고 
이 값에 따라 루트 본을 회전시킬것입니다. 

우리는 Yaw 만 활용할것이기 때문에 Rotate Root Bone 의 디테일즈에서 Pitch 쪽 에서 Expose As Pin 핀으로 노출을 선택해제하면 함수의 입력핀이 사라집니다.
Mesh to Component 도 사용하지 않을것이기 때문에 핀으로 노출을 꺼주면 이제 Yaw 값 만 남습니다. 이 Yaw에는 RootYawOffset 만큼을 회전시켜줘야 하니 연결해주겠습니다.

이제 게임을 실행해보면 가만히 서있을 때는 카메라를 움직여도 마치 Use Controller Rotation Yaw 가 꺼진것 처럼 캐릭터는 같은 방향을 보고 있습니다. 

다음으로 할것은 카메라를 따라서 상체만 움직이도록 만드는건데 이것은 다다음 시간에 알아볼 Aim Offset 과 관련된 내용입니다. 
그래서 이건 다음에 할건데 

그 전에 만약 화면에 크로스 헤어가 있는데 캐릭터의 90도가 넘어가도록 에임을 움직여도 캐릭터가 가만히 있는건 이상합니다. 총을 뒤로쏘는 격이기 때문인데 
일반적으로 90도를 넘어가면 캐릭터가 그 방향으로 회전해주게끔 해주는게 일반적일겁니다. 

실질적으로 에임이 90도를 넘었을때 그쪽을 바라보도록 하는 기능은 다음시간에 작업할 것이지만 최소한 90이상 넘어갔을때 그것을 인지하고 그쪽으로 회전하는 애니메이션은 
틀어주는건 이번시간에 해볼 작업입니다.

실제로 벨리카 리소스에서 애니메이션 폴더를 보면 Idle_Turn_180_Left, Idle_Turn_180_Right 라고 180 도 회전하는 애니메이션도 있고 
Idle_Turn_90_Left, Idle_Turn_90_Right 라고 90도 회전하는 애니메이션도 있습니다. 일단 90도 회전하는 버전의 애니메이션 두가지를 
우리가 애니메이션을 수정해 사용하는 폴더로 복사해줍니다. 복사해온 파일은 뒤에 _Edited 를 붙히는게 우리 규칙이었습니다. 

파일을 하나 열어보면 캐릭터가 돌아서는 모션이 나오고 그 뒤로 멍하니 있는 씬이 꽤 오래 유지됩니다. 쓸모없는 장면들은 모두 날려주겠습니다.
가져온 두 파일 모두 작업해줍니다. 

다음으로 ABP_Player 로 돌아갑니다. Locomotion 쪽에서 Idle 과 관련된 모션이 수정될것이기 때문에 Idle 상태로 들어가보겠습니다.

기존에 Idle_Relaxed 라고 하는 이 부분이 수정될겁니다. 여기서 상체와 하체를 나눠서 관리해보려고 합니다.
Idle 상태안에서 새로운 State Machine 을 두개 만들어 줍니다. 하나는 Idle Lower Body 라고 해서 하체를 관리하고 또 하나는 Idle Upper Body 라고 상체를 관리해주겠습니다.
여기서 두 애니메이션을 어떤 뼈 기준으로 나누는 Layered blend per bone 을 호출해줍니다. 여기서 어떤 뼈를 기준으로 나눌 건지  정해 줬었습니다.

이전에 상체하체를 나눌때 spine_01 이라는 뼈를 기준으로 나눴었습니다.

이렇게 해준 다음은 이제 새로 만든 상태 기계들을 채워줘야합니다.
IdleUpperBody 의 경우에는 그냥 아무것도 안하는 Idle 애니메이션을 틀어줄겁니다. IdleLowerBody가 핵심인데 여기서 회전하면서 왼쪽으로 가거나 오른쪽으로 가는 기능을 
넣어주겠습니다. 

일단 Idle_Zero_Pose 라는 애니메이션과 우리가 수정했던 Idle_Turn_90_Left_Edited, Idle_Turn_90_Right_Edited 를 꺼내 배치해줍니다.
기본적으로는 Idle_Zero_Pose로 가는게 기본이지만 상황에 따라 왼쪽으로 돌거나 오른쪽으로 도는 애니메이션을 틀어줘야 하니까 각각 오고가는 트랜지션 룰을 이어줍니다.

Idle_Zero_Pose to Idle_Turn_90_Left_Edited 부터 보겠습니다. RootYawOffset 이 90 보다 크다라는 비교를 일단 하겠습니다. 그리고 혹시 모르니 Speed가 0과 같다는 
조건을 And 불리언을해서 트랜지션 룰의 조건으로 삼습니다. Idle_Turn_90_Left_Edited 를 하는 조건이 RootYawOffset 이 90도 이상인 경우인 이유는 
실질적으로 캐릭터를 왼쪽으로 회전을 계속하면 RootYawOffset 가 양수가 되면서 90도가 넘어가면 회전을 해줘야 하기 때문에 이런 조건이 됩니다. 
이것과 대칭적인 Idle_Zero_Pose to Idle_Turn_90_Right_Edited 도 비슷하게 처리해줍니다.

이제 Turn Pose 에서 Zero Pose로 돌아가는 조건을 만들어 주겠습니다.
Time Remaining 이라고 함수를 검색해보면 Ratio 버전이 있습니다. 기존 실행하던 애니메이션에서 비율이 얼마나 남았는지를 체크 해주는데 
이게 만약 0.1 이하라고 하면 다음으로 넘어가줄 수 있습니다. 또 여러가지 조건이 있을 수 있습니다. 만약 Speed 가 0보다 크다면 이동을 시작했으니 다음 애니메이션으로 넘어가야 할
것이고 또 만약 Turn_Left 쪽 돌아가는 트랜지션룰에서 RootYawOffset 의 값이 음수다 라고 하면 한프레임에서 너무 많이 각도가 꺽인거니 다시 Zero Pose로 돌아갑니다. 
이 세가지 조건들을 or boolean 연산해주고 트랜지션룰에 넘겨주겟씁니다.
Turn Right 에서 Zero Pose로 돌아오는 트랜지션 룰에도 대칭적으로 넣어줍니다. 

이렇게 해서 컴파일 저장하면 프리뷰에서 이상하게 상체가 안보입니다. IdleUpperBody 에서 Idle 이아니라 Idle_Zero_Pose 를 사용하도록 해주겠습니다.

지금까지 한것을 정리해보자면 Rotate Root Bone 이라는 것을 하기 위해서 현재 캐릭터의 전면방향, 이전 프레임의 캐릭터 전면방향, 그리고 캐릭터의 기존 전면을 유지하기 위해 
회전해야하는 회전값들을 구해주고 세번째 변수만큼 Rotate Root Bone을 해줍니다.이러면 카메라를 돌려서 실제 캐릭터 방향은 바뀌어도 
본과 메쉬는 그냥 제 앞을 바라보고 있게끔 만들 수 있습니다.

여기에 추가로 카메라가 캐릭터의 90도를 넘어가게 됨면 해당 방향으로 회전하게끔 해주고 싶습니다. Idle 스테이트안에서 두가지 상태머신을 또 추가하고 
캐릭터의 상체와 하체를 따로 관리해 Layered blend per bone 으로 나눠 작업합니다. 
이중에 상체 상태기계는 일단 이번시간에는 그냥 Idle_Zero_Pose 만 유지하도록 하고 하체 상태기계에서는 Idle_Zero_Pose, Idle_Turn_90_Left_Edited, Idle_Turn_90_Right_Edited
세가지 상태를 오가게 되는데 기본이 Idle_Zero_Pose 이고 Idle_Turn_90_Left_Edited 나 Idle_Turn_90_Right_Edited 로 갈때는 RootYawOffset가 90 혹은 -90 범위를 넘었을경우
넘어가고 돌아올때는 반대로 0 이상 혹은 이하가 되거나 캐릭터가 움직이기 시작하거나 Turn 애니메이션이 90이상 진행되었을때 Idle_Zero_Pose로 돌아가도록 했습니다. 

게임을 실행해 테스트를 해보면 카메라를 좌우 90이상 돌리면 회전하는 애니메이션이 틀어집니다.하지만 실제로 회전하지는 않기 때문에 제자리 애니메이션이 틀어진다는것이 
어색합니다. 실제로 회전하는 것은 다음시간에 작업할 내용입니다.

