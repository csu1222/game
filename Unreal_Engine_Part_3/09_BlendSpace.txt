



        블렌드 스페이스 


블렌드 스페이스 라는것은 애니메이션은 특정 수치에따라 적절히 섞어주는것을 말합니다. 

지난시간 배웠던 애니메이션 몽타주에서도 비슷한 함수로 Layered blend per bone 이라고 해서 본을 기준으로 어떻게 블렌드할지를 정해주는 함수도 사용해봤었습니다. 
그래도 애니메이션 몽타주 내용 보다는 쉬운 내용이 될겁니다. 

시작하기에 앞서 파일 정리를 해보자면 ABP_Player나 AM_Fire 같은 파일들은 Animations 폴더에 넣어서 관련된 것끼리 모아 두겠습니다.

오늘 추가적으로 작업할것은 무엇이냐면 
지금까지 플레이어 캐릭터가 전후좌우로 움직이면사 각 방향을 보며 이동하고 또 왼클릭을하면 그 방향으로 총을쏘는 모션을 합니다. 
만들고자 하는 게임이 RPG라면 이런 식으로 움직이는게 문제가 없지만 보통 슈팅게임의 경우는 전후좌우로 움직이더라도 조준은 카메라 방향을 보면서 게걸음이라던가 뒷걸음을 합니다. 
이것을 만들어 볼겁니다.

지금의 이동 애니메이션은 다른 종류의 게임을 만들때 참고하면 되겠습니다. 예전 방식으로 복원을 합니다.
BP_Player의 디테일중 폰 항목에 가서 Use Controller Rotation Yaw 옵션을 켜주고 또 캐릭터 무브먼트 컴포넌트의 옵션중에 Orient Rotation to Movement 옵션을 꺼줍니다. 
Use Controller Rotation Yaw는 우리가 입력에 따라 회전하고 있는 컨트롤러의 로테이터중 Yaw 값을 이 캐릭터의 Yaw로 삼겠다는것이고 
Orient Rotation to Movement 는 캐릭터가 움직이는 방향쪽으로 캐릭터의 회전 값도 같이 회전시키는 것입니다. 

설정을 되돌리고 나서의 상태를 보면 이제 캐릭터는 컨트롤러, 카메라의 방향을 따라 Yaw가 회전하고 이동도 카메라 방향 전후좌우로 움직입니다. 
그렇지만 애니메이션은 항상 앞으로 이동하는 모션만 재생되는데 이것을 수정할겁니다. 

이 작업이 생각보다 간단하진 않고 선수 지식이 필요합니다. 
플레이어가 바라보는 방향을 0도로해서 시계방향으로 360도 표현할 수 있을겁니다. 캐릭터의 오른쪽을보면 90도가 될것이고 뒤를 보면 180도가 되는겁니다. 
거꾸로 왼쪽을 보게되면 -90도이고 왼쪽을 통해 뒤를보게되면 -180도가 됩니다. 
즉, 오른쪽으로 가다가 180도를 넘어서게되면 -180도로 넘어가고 -90도를 거쳐 다시 앞을 보면 0도가 되는 상태라고 하겠습니다. 
여기서 지금 바라보고 있는방향, 조준하고 있는 방향을 Aim Rotation이라고 하겠습니다. 이 Aim Rotation 과 무관하게 실제로 이동하고 있는 방향도 있을겁니다. 
그러니까 앞을 바라보고 있는 상태에서 뒤로 이동하게 되면 두 각도가 차이가 180도가 나게됩니다. 왼쪽과 오른쪽으로 이동하면 각각 방향으로 옆걸음을 치면 되는데 
만약 왼쪽 뒤 사이방향으로 이동하고 있다면 뒷걸음과 왼쪽 옆걸음 중간정도 애니메이션이 틀어져야 합니다. 
핵심이 무엇이냐면 Aim Rotation 이라고 하는 내가 바라보고 있는방향과 실제 이동하고 있는 각도 사이의 차이를 구해서 그것에 따른 처리를 해줘야 한다는것이 핵심입니다.

애니메이션을 조절하기 위해서 이 각도를 구해줘야 하는것이기 때문에 굳이 BP_Player 쪽에서 해주지 않고 ABP_Player에서 구해주겠습니다.
이전에 캐릭터가 움직이고있는지 여부를 bMoving 으로 구해서 사용하고 있는것 처럼 여기서 필요한 정보를 사용하면 되겠습니다. 

먼저 디버깅을 하면서 원하는 정보를 하나씩 구해볼겁니다. 우선 내가 바라보고 있는 방향을 Aim Rotation 이라고 했었는데 이것을 굳이 직접 구할 필요도 없고 
언리얼에서 이미 구현되어 있습니다. 다만 ABP 쪽 코드가 아니라 Pawn 산하에 있는 기능이니깐 Try Get Pawn Owner 라고해서 ABP_Player 를 사용하고 있는 Owner Pawn 을 가져오고 있습니다. 
bMoving도 이걸로 가져오고 있는데 다시 이것을 사용하겠습니다.

Try Get Pawn Owner 에서 핀을 땡겨서 Get Base Aim Rotation 이라는 함수로 Aim Rotation 을 가져올 수 있습니다. 이게 만약 우리가 컨트롤러를 사용하면 사실상 컨트롤러의 각도일것이고
그게 아니면 Pawn의 회전과 관련있는 것입니다. 실습을 통해 이게 무슨 의미인지를 살펴보겠습니다. PrintText를 연결해 어떤 수치가 나오는지 실시간으로 로그를 찍어보겠습니다.

게임을 시작하면 Pitch, Yaw, Roll 값을 출력해주는데 여기서 Yaw 값만 집중할겁니다. 아까 알아봤던 대로 카메라를 오른쪽으로 돌리면 점점 Yaw 값이 올라 가다가 정 뒤쪽을 넘어서면 -180 부터 서서히 값이 증가합니다. 

다음으로 추가적으로 구해야하는것은 이동하는 방향에 대한 회전값을 추출해야하는데 이건 어떻게 추출할 수 있냐면 마찬가지로 Try Get Pawn Owner 에서 부터 시작합니다. 
생각해보면 지금 이동하는 방향은 키보드 입력에 따라 Add Movement Input에 넣어서 플레이어의 캐릭터 무브먼트 컴포넌트로 전달해주고 있습니다. 
전달받은 방향과 무브먼트에 설정된 속도로 계산된 값을 가져올 때는 Get Velocity 로 가져올 수 있었습니다. 지금까지는 이 Get Velocity 를 바로 Vector Length 값으로 현재 속도만을 사용했었는데 
다시 Get Velocity의 반환값을 보면 벡터 타입으로 되어있습니다. 이 벡터를 가지고 방향 로테이터를 알고 싶은겁니다. 
사실 이것은 복잡한 수학이 필요한데 다행히 언리얼에서 해당 기능을 이미 만들어 놔서 직접 계산을 하지 않아도 됩니다. Make Rot From X 라는 함수입니다. 
X축만 주어진다면 그에 해당하는 로테이션을 가져오는 함수입니다.

Make Rot From X 의 자세한 원리를 알기 위해서는 게임수학 특히 행렬과 관련된 부분을 알아야 합니다.
아주 자세히는 말고 간단하게 설명해보겠습니다.

월드 좌표계 기준으로 X축이 Aim Rotation 0도 라고 하고 지금 캐릭터가 움직이고 있는 방향을 기준으로 그곳을 새로운 X축으로 만든다고 가정하겠습니다. 
월드 좌표계 X축에서 새로 만든 X축까지 얼마나 회전했는지를 구하는게 Mak Rot From X 라고 알면 되겠습니다.

그러면 이 Make Rot From X 를 PrintText로 출력해보면 어떻게 될지 알아보겠습니다. 
카메라를 움직이지 않고 앞으로 이동하면 0도라고 출력이 되고 뒤로가면 180도, 오른쪽을 90도 ,왼쪽은 -90도가 나옵니다. 
약간 카메라를 틀고나서 다시 같은 테스트를 하면 카메라 기준이 아닌 월드 스페이스 기준 X축으로 각도를 계산하는걸 알 수 있습니다. 

그래서 우리에게 필요한 두가지 값을 다 구한겁니다. 
Aim Rotation 과 캐릭터가 이동하는 Rotation 의 차이를 구해야 합니다. 두 로테이터의 차이를 구하는 함수가 이미 언리얼엔진에 포함되어 있습니다. 
Delta Rotator 라고 합니다. 입력울 받은 두 로테이터의 차이를 구하고 그 값의 Normalize를 해준 값이 반환됩니다. 이 반환값을 다시 로그로 찍어보겠습니다. 
이제는 이동할때 내가 바라보고 있는방향과 움직이는 방향에 따라 Yaw가 앞으로 가면 0도 오른쪽은 90도 등등으로 출력이 됩니다. 카메라를 다른곳으로 돌리고 다시 해봐도 마찬가지입니다. 

이 다음에 해야할 것은 오늘 배울 블렌드 스페이스를 가지고 적절히 애니메이션을 섞어 주면 되겠습니다. 
블렌드 스페이스를 사용하지 않고 굳이 직접 하는 방법을 궁리해보자면 우리가 애니메이션을 골라주고 있던 부분으로 가보겠습니다. ABP_Player 의 Locomotion 에서 애니메이션을 골라주고 있었는데 
만약 이동하고 있어서 Move 상태로 갔다면 Jog_Fwd 를 골라주고 있었는데 앞으로 이동하는것 외에도 아까 구한 델타 로테이션에 따라 전후좌우 애니메이션을 골라주는 상태를 각각 만드는 방법이 있는데
이 방법은 그다지 좋은 방법은 아닐겁니다. Move 자체가 움직이고 있다는 상태인데 여기에 전후좌우 각각을 상태로 분할해 관리하기에는 너무 세분화 된겁니다. 
세세한 부분까지 다 상태로 관리하면 상태 머신 내의 구조가 복잡해져서 굳이 따로 관리하는 이유가 퇴색됩니다. 

그래서 방향에 따른 여러 상태를 만들어 관리하는 방법말고 Move 상태 안에서 Jog_Fwd 에 해당하는 애니메이션을 그때그때 델타 로테이션에 따라 적절한 애니메이션으로 바꿔 줄겁니다. 

여기서 적절한 애니메이션으로 섞어주는것이 오늘의 주제인 블렌드 스페이스 입니다. 
블렌드 스페이스라는 파일을 만들려고 보면 Blend Space 와 Blend Space 1D 라고 두가지가 있습니다. 무슨 차이인가하면 애니메이션을 섞어줄때 섞어주는 요소가 딱 1개면 1D 버전을 사용하면되고
그 외에는 그냥 Blend Space를 사용하면 됩니다. 

이게 무슨 말이냐면 일단 Blend Space 1D 버전을 하나 만들어보겠습니다. 사용할 스켈레톤을 고르라고 뜨는데 Belica_Skeleton 을 선택해 만들겠습니다. 
파일이름은 블렌드 스페이스고 움직이는 애니메이션을 작업할것이니 BS_Move 라고 하겠습니다. 이제 애니메이션을 틀어줄때 관건이 되는 정보는 에임 로테이션과 움직이는 방향 로테이션 사이각도가 
얼마인지에 따라 애니메이션을 어떤 애니메이션을 사용하고 또 섞어줄 지를 정합니다.

그래서 BS_Move 를 열어보면 이 파일은 왼쪽에도 에셋 디테일이라는 것이 있습니다. 이 중 Axis Setting 아래로 Horizontal Axis 가로 축 이라는 옵션들이 있습니다. 
여기서 애니메이션에 영향을 주는 변수를 설정할 수 있습니다. 지금으 1D 버전으로 만들엇으니 이 가로축 변수가 하나밖에 없는데 만약 그냥 Blend Space 를 만들었다면 Horizontal Vertical 이라고 해서 
두개를 넣어 줄 수 있습니다. 지금은 1D를 사용하니까 하나밖에 없습니다. 

이 Horizontal Axis 의 이름은 MovementOffsetYaw 라고 하겠습니다. 내가 바라보고 있는 방향과 이동하는 차이에 대한 정보다 라는 의미입니다. 
밑으로 최소값과 최대값을 정해줘야합니다. 최소값은 -180 도에서 최대값은 180도 까지로 둔다고 했었습니다. 
그리고 이제 이 변수에 따라 달라질 애니메이션을 창 중앙하단 창에 올려줍니다. 먼저 에셋 브라우저에서 Jog_Fwd를 검색해서 이게 가장 기본상태 즉 0도일때 틀어주도록 하겠습니다. 
마우스로 드롭해서는 정확히 0도에 위치할 수 없으니 일단 배치한 다음 왼쪽 에셋 디테일에서 Jog_Fwd에 대한 옵션들이 있는데 여기서 MovementOffsetYaw 가 0일 때 위치하도록 할 수 있습니다. 
참고로 나중에 이동 애니메이션은 좀 더 빠르게 재생하고 싶다면 Rate Scale 이라는 옵션을 조정해주면됩니다.
이제 -180도 이거나 180도 일때는 뒤로가는 애니메이션 Jog_Bwd 를 배치해주면 됩니다. 
좌우도 Jog_Left, Jog_Right 도 90도 -90도에 위치해주겠습니다.

이렇게 각 애니메이션을 배치한 후 프리뷰를 틀고 애니메이션을 배치한 창을 클릭해 선택하고 ctrl 을 누르고 커서를 움직여보면 각 MovementOffsetYaw에 해당할때 프리뷰를 볼 수 있습니다. 

여기까지 만들었으면 이 것을 하나의 애니메이션 에셋 처럼 사용할 수 있다고 합니다.
ABP_Player 의 Locomotion 이 안의 Move 상태에서 사용하고 있던 Jog_Fwd 대신에 에셋 브라우저에 있는 BS_Move로 대체해주면 되겠습니다. 

BS_Move 는 입력 핀으로 MovementOffsetYaw 를 받고 있는데 이건 아까 ABP_Player 이벤트 그래프에서 이미 해당 값을 구했었습니다. 아직 저장은 안했었는데 아까 구한 델타 로테이션중 
Yaw 값을 Flaot 변수 MovementOffsetYaw 에 저장해주겠습니다.  이 저장한 값을 Move 상태에 배치한 BS_Move 노드에 연결해줍니다. 

그런데 지금 다시 게임을 실행해 좌우로 움직여보면 Jog_Fwd 가 먼저 재생되고 한참후에 옆으로 이동하는 애니메이션이 나오는걸 볼 수 있습니다.
뒤늦게 적용되는이유는 Locomotion을 살펴보면 Idle 에서 바로 Move로 넘어가는게 아니라 MoveStart 로 가서 Jog_Fwd_Edited 가 끝나고 나서 Move로 넘어갔습니다.
이런 Jog_Fwd_Edited 애니메이션의 뒷부분을 잘라줘야하는 것도 있고 또 MoveStart 도 앞으로 가는버전만 만들었는데 이 Start와 Stop도 블렌드 스페이스로 만들어서 블렌드해줘야 깔끔합니다.


정리해보면 블렌드 스페이스는 애니메이션 간에 보간을 해주는 기법이었습니다. 이 블렌딩 스페이스를 사용할때 필요한것은 Aim Rotation 이라고해서 캐릭터가 바라보고 있는 방향을 월드스페이스 기준 얼마나
회전했는지와 캐릭터가 실제로는 어느쪽으로 가고 있는지를 월드스페이스 기준의 로테이터가 필요했습니다. 이 두 값의 차이 로테이터가 곧 캐릭터보고 있는 방향에 비해 어느 각도로 가고 있는지를 뜻합니다. 
-180도에서 180도 사이의 값으로 나옵니다. 로테이터 값중 Yaw 만 가져와 사용했는데 대부분의 게임에서는 Yaw가 가장 많이 사용할겁니다. 
이 값을 델타 로테이터라고 명하고 이 값에 따라 블렌드 스페이스에서 어떤 애니메이션들을 섞을지를 배치해줍니다. 전진은 0도 후진은 180 혹은 -180도 좌측은 -90도 우측은 90도 이렇게 배치합니다. 
이렇게 만든 블렌드 스페이스는 애니메이션 에셋처럼 사용할 수 있는데 애니메이션 블루프린트에서 이 이동하는 블렌드 스페이스를 쓸 상태에 연결해주고 델타 로테이터도 변수화해서 넘겨줍니다. 

우리 프로젝트는 슈팅게임이기 때문에 컨트롤러가 바라보는 방향과 캐릭터의 방향이 일치하엿는데 RPG 게임의 경우에는 이 둘이 일치 하지 않을 수 있습니다. 


그런데 한가지더 살펴보면 벨리카 리소스 자체에서도 애니메이션 폴더를 보면 블렌드 스페이스를 자체 제공을 하고 있습니다. 살펴보면 JofFwdSlopeLean 이라는 파일을 열어보면 
경사진 곳을 올라갈때 그 경사에 따른 모션이 제공됩니다. 이건 Yaw 뿐만 아니라 Pitch 까지 사용하는 블렌드 스페이스 였습니다.