

    애니메이션 블루프린트

이번 시간에는 애니메이션에 대한 내용을 시작해보겠습니다. 
그전에 축 벨류를 프린트하던 코드는 이제 필요 없으니 삭제해줍니다. 

먼저 애니메이션 리소스들이 어딨냐면 DevMap으로 돌아가 콘텐츠 브라우저를 보겠습니다. 
ParagonLtBelica/Characters/Heores/Belica/Animations 위치에 있습니다. 
지난 파트 2에서 페이퍼 플립북 애니메이션을 만들때는 고전적인 방법인 여러 이미지를 빠르게 연달아 보여주면서 애니메이션을 연출했었습니다. 그렇게 
할 수 있는 이유는 상대적으로 2D 리소스의 용량이 크지 않아서 가능한 방법이었습니다. 3D부터는 그렇게 구현하기에는 너무 많은 용량을 차지하기때문에 
Bone 방식을 사용한다고 했었습니다. 

Animation 폴더에 있는 많은 리소스중에 오늘 사용해볼 것은 Jog_Fwd 입니다. 앞으로 뛰어가는 애니메이션입니다. 
스켈레탈 메쉬라고 해서 캐릭터를 이루는 모든 정점과 삼각형을 전부 저장해 한 프레임마다 새로 그려 구현하는 애니메이션이 아닌 
Bone 이라는 기준점들을 세워서 이 Bone의 상대거리에 맞춰 정점들이 위치하도록 하는 기법이었습니다. 

애니메이터들이 만든 이 애니메이션 파일을 우리는 가져다가 사용하는겁니다. 
뼈대를 움직여서 애니메이션을 만드는것이다 보니 비슷한 골격을 가지고 있는 객체는 공유해 섞어 쓸 수 있기는한데 아예 골격이 다른 슬라임 같은 캐릭터는 새로 만들어야 합니다. 

참고로 나중에 애니메이션 리타겟팅이라고 해서 다른 캐릭터를 기준으로 만든 애니메이션을 적용해보는 실습을 해볼겁니다. 

지금은 벨리카 에셋만 가지고 실습할것이기 때문에 아직은 신경쓰지 않겠습니다. 그리고 언리얼에서 정말 많은 툴을 제공하기 때문에 언리얼 자체에서 애니메이션을 수정할수도 있긴 합니다. 
그래서 애니메이션 창을 이리저리 살펴보는것을 추천합니다. 

Jog_Fwd를 실습해보겠습니다. 
먼저 애니메이션을 적용하는 가장 쉬운 방법을 알아보겠습니다. BP_Player 클래스로 돌아갑니다. 이 클래스가 가지고 있는 컴포넌트중에 Mesh가 있었습니다. 
애니메이션이라는것이 결국 이 Mesh 라고 하는 삼각형 덩어리를 움직이는것을 뜻하였으니까 이 Mesh 컴포넌트에 애니메이션을 담당하는 기능이 있을 확률이 높아 보입니다. 

역시 Mesh의 디테일즈에 애니메이션 란이 있습니다. 이 옵션에서 보이는 애니메이션 모드를 Use Animation Asset 로 하는게 애니메이션을 가장 쉽게 사용하는 방법입니다. 
아까 살펴본 애니메이션 파일들을 애니메이션 에셋이라고합니다. 그래서 우리가 실습하기로한 Jog_Fwd로 골라주고 저장 해줘보겠습니다. 
이때 뷰포트를보면 어떤 애니메이션인지 프리뷰를 나타냅니다. 다시 게임을 실행해보면 이전보다는 자연스럽게 캐릭터가 앞으로 이동하고 있습니다. 

이제는 캐릭터의 상태에따라 가만히 있는 애니메이션, 좌우를 보는 애니메이션, 점프를 하는 애니메이션등을 바꿔 줘야할겁니다. 
파트 2에서 페이퍼 2D 게임을 만들면서 이런 작업을 했었습니다. 
상태를 기반으로 캐릭터의 상황을 나눠 플립북을 틀어줬었습니다. 

그런데 3D에서도 이런 방식이 되는가 하면 간단한 게임의 경우에는 가능할 수 있습니다. 그런데 그렇게 하기에는 우리가 애니메이션 에셋이 너무나도 많습니다. 
거기다가 나중에는 총기를 겨누고 있는 방향을 Aim 오프셋으로 총구방향을 조절하는것을 나중에 만들 수 있게 됩니다. 
이런 너무나도 많은 경우의 수를 모두 상태로 관리하기에는 너무 벅찹니다. 

언리얼엔진에서는 그래서 이런 애니메이션을 관리하기위한 편리한 방법을 제공합니다. 
어떤 애니메이션 관리전용 클래스가 준비되어있는데 지금까지 코드를 보면 언리얼에서는 이동관련은 무브먼트 컴포넌트에서 관리하고, 입력과 관련된 부분은 플레이어 컨트롤러 에서 관리하고 이번에도 
애니메이션에 관련된 부분은 따로 클래스가 준비 되어있듯이 각 기능별로 잘 정리되어있습니다. 

애니메이션을 관리하는 클래스를 만들어 보겠습니다. Blueprints 폴더 안에서 우클릭을 하고 애니메이션 란에 가보면 애니메이션 블루프린트라는것이 있습니다. 
이것을 추가하려고 하면 다른 블루프린트와 다르게 프로젝트에 있는 스켈레톤을 선택해주는 창이 뜹니다. 이중에 우리는 Belica_Skeleton을 선택해주겠습니다. 
Drone 이라는 이름이 아마 이전 사양에서 벨리카가 따로 사용하는 드론용 스켈레톤 같습니다.
추가한 애니메이션 블루프린트 이름은 ABP_Player라고 해주겠습니다. 그리고 한번 파일을 열어줍니다. 

ABP_Player 를 열어보면 우리가 익히 다루던 블루프린트 클래스의 화면과 어느정도 비슷하기도하고 생소하기도 한 창이 뜹니다. 프리뷰 창도 있고 디테일즈 창도 있습니다. 
가운데 그래프 탭을 보면 이벤트 그래프가 있어서 여기에 코드를 작성하면 되겠다 싶습니다. 또 AnimGraph라고 해서 Output Pose라는 노드가 배치되어있는 그래프도 있습니다. 

그래서 애니메이션 클래스를 사용해볼겁니다. Output Pose 노드의 설명을 읽어 보면 최종 애니메이션 포즈를 이 노드에 연결해달라고 합니다. 
한번 시험삼아 위에서 한번 사용해봤던 Jog_Fwd 를 Output Pose에 꽂아줘 보겠습니다. Jog_Fwd 를 가져오는것은 오른쪽 디테일즈 밑에 에셋 브라우저에서 검색해 드래그 드랍하면됩니다.

이러면 최종적으로는 Jog_Fwd 애니메이션을 사용하겠다고 규칙을 정해준 겁니다. 
애니메이션 블루프린트를 적용해야하는데 이것은 또 어디서 할까요? 이런 것은 하나하나 외우지 않더라도 구조를 알고 있으면 예상할 수 있습니다. 
애니메이션을 적용할 무언가는 역시 메쉬일것이기 때문에 BP_Player 의 메쉬에서 설정해 줄것입니다. 

BP_Player 로 돌아온 다음 아까는 애니메이션 모드를 애니메이션 에셋으로 선택해줬던걸 애니메이션 클래스로 바꿔서 ABP_Player를 넣어주겠습니다. 
게임을 실행해보면 아까 와 마찬가지로 앞으로 뛰어가는 애니메이션이 적용되어 있습니다. 
앞으로는 이 애니메이션 클래스에 복잡한 규칙을 추가해나가면 되겠습니다. 

이제 우리가 실습해보고 싶은것은 가만히 서있을때는 Idle 애니메이션을 틀어주고 이동하기 시작하면 이동 애니메이션을 틀어주고 또 다시 속도가 0이되면 Idle 을 틀어주는것을 만들어보겠습니다. 

먼저 ABP_Player의 AnimGraph를 열어서 로직을 만들어야 하는데 State Machine 이라는 노드를 검색해보면 New State Machine 이라는것이 배치됩니다. 
이 상태 기계 안에서 현재 상태에 알맞는 애니메이션을 골라주게 됩니다. 이 State Machine은 이름을 수정해줄 수 있습니다. ChoseAnim 이라고 하겠습니다. 

상태기계라는 용어는 이전 파트들에서 언급된적이 있습니다. 그때는 상태 패턴이라고 했었는데 내가 어떤 상태에 있을때 그에 맞는 애니메이션을 골라줬었습니다. 
이런 상태 패턴에 대한 아이디어 없이 그냥 C++과 DirectX로 게임을 만들게 되면 무작정 불리언을 늘리면서 구현하려고 하는게 보통이라고 합니다. 
이런 방식으로 구현하게 되면 예외처리를 실수해서 죽어있는 상태에서 점프를 하게 된다던지 하는 버그가 생길 수 있습니다. 
그래서 이런 버그를 예방하기 위해 상태라는것을 쓰는겁니다. 예를 들어서 내가 지금 죽어있는 상태라고 하면 죽은 애니메이션을 틀어주고 다른 이동이나 점프 입력은 다 무시해주는 식으로 
만들어 줘야합니다. 

그래서 상태 기계라는것이 FSM (Finite-State Machine) 이라고 하는데 언리얼은 재미있게도 이 FSM을 코드로만 구현하는게 아닌 그래프로 관리할 수 있도록 만들어 줬습니다. 

우리가 만든 ChoseAnim 상태 머신을 더블 클릭해 안으로 들어가 보겠습니다. 

Entry 라는 노드만 덜렁 있는데 여기서 어떤 상태인지를 관리해주면 되는데 빈공간을 우클릭해보면 Add Stete가 있습니다.
하나 만들어서 Idle 상태를 만들어보겠습니다. Entry에서 드래그해 Idle 상태의 테두리 쯤에 놓으면 시작하면 일단 Idle 상태가 된다는 뜻이 된겁니다. 

Idle 상태에서 무엇을 할것인가는 다시 Idle 상태를 더블클릭해서 작성해줍니다. 
Idle 상태 안에 들어가면 익숙해 보이는 창이 뜹니다. AnimGraph처럼 어떤 애니메이션을 사용할지를 꽂아주는 창입니다. 

이제 게임을 실행하면 ABP_Player 를 참조해 애니메이션을 틀어줄 건데 ChoseAnim 상태 기계에서 틀어주는 애니메이션을 틀어주게됩니다. 
ChoseAnim 에서는 현재로서는 Idle 이라는 상태만 가리키고 있고 Idle에서는 Idle_Relaxed 애니메이션을 틀어줍니다. 
즉, 게임에서 Idle_Relaxed 가 틀어지는 상태입니다. 여기서 이제 플레이어가 움직이게되면 이동하는 애니메이션으로 바꿔주는 코드를 작성하면되겠습니다. 

ABP_Player의 ChoseAnim 상태기계로 돌아갑니다. Idle 외에 다른 상태를 추가해볼건데 아까 처럼 Add State로 스테이트를 만들고 그 안에서 사용할 애니메이션을 골라주는 방법도 있지만 
이번에는 그냥 에셋 브라우저에서 Jog_Fwd 에셋을 끌어다 놓으면 Jog_Fwd 이름으로 상태가 만들어지고 그 안에 자동적으로 애니메이션이 연결되어있습니다 이러면 좀 더 편하게 만들 수 있을겁니다.
이름도 F2를 눌러서 수정할 수 있습니다. Move 라고 하겠습니다. 

Move 상태를 만들었으면 이제 Move 상태로 이어줘야합니다. 조금 생각해보면 Idle 상태에서도 Move로 갈수 있어야 하고 Move 에서도 다시 Idle 로 갈 수 있어야합니다. 
그래서 서로를 가리키도록 연결해줍니다. 
Idle 에서 어떤 조건이 만족되면 Move로 넘어가게 되고 또 다시 Move 일때도 특정 조건이 만족되면 Idle로 넘어갈수 있습니다. 
만약 여기에 죽는 상태가 추가된다면 이 죽는 상태에서 부활하게 된다고 해도 곧바로 Move로 가지는 않을겁니다. 결국 우리가 설계한 로직대로 정리를 해놓으면 이 상태 기계에서 훨씬 깔끔하게 확인 할 수 있습니다. 

이제 어떤 상황에서 넘어갈수 있는지를 설정해주겠습니다. 
Idle 상태와 Move 상태를 연결한 화살표들에는 옆에 동그란 아이콘이 뜨는데 이것을 더블 클릭하면 어떤 조건일때 상태를 이동할지를 작성할 그래프가 뜹니다. 입력으로 불리언을 받아주고 있는데 
이 불리언 결과물에따라 넘어가던지 아닌지를 정해주게 될겁니다. 우리의 조건을 만들어 그 불리언을 넘겨주겠습니다.

조건을 어떻게 만들어 줄건지 이전 파트처럼 해보려고 Get Player pawn 같은걸로 플레이어를 가져와 억지로 조건을 만들어 주려고 해도 캐릭터 블루프린트 함수처럼 시작 노드가 없어서 다른 함수를 호출해줄 수 가 없습니다.

이렇게 하는게 아니고 좀 다른 방법을 사용해야합니다. 
애니메이션 블루프린트도 이벤트 그래프가 있었습니다. 그곳으로 가보겠습니다. 여기서 Event Blueprint Update Animation 이라는 이벤트가 있습니다. 
이 이벤트가 실질적으로 필요한 정보를 여기서 다 추출해 준 다음 그 정보를 이용해서 우리가 만들었던 상태간 전환 규칙에서 사용하면 됩니다. 

이렇게 하면 장점이 뭐냐면 지금까지 작업했던 BP_Player나 BP_PlayerController 등등에서 작업한 코드들을 이어서 ABP_Player 에서 코드를 진행하는게 아니라 
정말 필요한 데이터만 꺼내 가지고 있다가 매 프레임마다 애니메이션을 갱신하는데 사용한다는겁니다. 

나중에 가면 인공지능도 공부하게 될건데 여기서도 비슷한 느낌입니다. 

결과적으로 Idle to Move 라고 해서 Idle 상태에서 Move 상태로 가는 조건은 플레이어의속도가 0이 아니게 되었을 순간에 바꿔 줘야합니다. 이런 조건들을 Event Blueprint Update Animation 에서 가져오겠습니다.

그러면 플레이어의 속도를 어떻게 가져올까요? 힌트는 ABP_Player 이벤트 그래프에 Try Get Pawn Owner 함수가 있는게 힌트입니다. 이 애니메이션 블루프린트를 사용하고 있는 폰이 누구인지를 가져오고 있습니다. 
가져온게 폰이니까 Get Velocity 함수가 있을겁니다. 이 반환 값에 Length Vector를 하면 현재 속도를 가져올 수 있습니다. 그리고 그 값이 0보다 큰지를 불리언 변수로 들고 있으면 나중에 사용할 수 있습니다. 
bMoving 이라는 이름으로 저장하겠습니다. 

이러면 사실 ABP_Player에서 사용하는것은 bMoving 이라는 것만 다루고 있는것입니다. 나머지 게임 로직이 어떻게 동작하고 있는지는 아무런 상관이없습니다.

다시 ChoseAnim 를 보겠습니다. 이 상태 기계를 만들면서 시작할때 Idle 상태로 들어가고 Idle 은 Move 상태와 서로 조건에 따라 변경될 수 있어야 하는데 
그 조건에 대해 알아보고 있었습니다.

그러면 Idle to Move 로 가면 bMoving 을 조건으로 넘겨주면 되겠습니다. 반대로 Move to Idle 은 bMoving의 반대로 주면 되니까 Not Boolean을 해주겠습니다.

다시 게임을 실행해보겠습니다. 그러면 멈춰있을때는 Idle 애니메이션이 되고 움직이기 시작하면 Jog_Fwd 가 됩니다.
지금은 애니메이션이 두개 밖에 없으니 간단하게 만들었습니다. 

그런데 잘 보면 캐릭터가 멈출때 애니메이션이 끊기지 않고 부드럽게 다음 애니메이션으로 넘어가는걸 볼 수 있습니다. 이것을 블랜딩이라고 합니다.
Idle to Move 같은걸 트랜지션 룰 이라고 하는데 ChoseAnim 안에서 이 트랜지션 룰을 선택한 다음 디테일즈를 보면 블랜드 세팅이라는것이 있습니다. 이 세팅에서 경과 시간 Duration 이라는 옵션이 있습니다.
이 옵션은 몇초 동안 애니메이션을 섞을지를 뜻합니다. 만약 이 Duration을 0.0 으로 설정한다면 애니메이션을 섞는게 아닐라 바로 애니메이션이 넘어간다는 것입니다. 
실제로 게임을 실행해 테스트해보면 아까보다는 Idle 과 Move 사이의 동작이 뚝뚝 끊어집니다.
그래서 애니메이션 블루프린트를 사용할때는 블랜드같은 기능을 간편히 사용할 수 있고 거기다 블랜드의 종류도 다양합니다.

정리하겠습니다. 애니메이션을 캐릭터에 적용하기 위해서는 그냥 애니메이션 에셋을 할당하는방법도 있지만 그렇게 해서는 다양한 애니메이션들을 상황에 따라 바꾸기 어렵습니다. 
그래서 애니메이션 블루프린트라는 툴을 이용합니다. 여기서는 최종 출력 애니메이션을 받아주고 있습니다. 여기에 애니메이션을 직접 넘겨주기 전에 상태 기계라고 하는 이전 파트의 UpdateAnimation 함수에 해당하는
것을 사용해 상황에 맞는 애니메이션을 골라 줄 수 있습니다. 또 상황에 따라 상태를 변경하기위해서는 그 변경 조건이 필요한데 이것은 
애니메이션 블루프린트 이벤트 그래프에 있는 Event Blueprint Update Animation 이벤트로 부터 매 프레임 필요한 조건 값을 다른 로직들로 부터 가져와야합니다.
추가로 전환되는 애니메이션 사이의 부드러운 전환을 변환 조건 트랜지션 룰의 옵션인 블랜드 세팅에서 조작할 수 있었습니다.

이어서 한가지만 더 추가해보겠습니다.
애니메이션 목록을 보면 Idle 과 Jog 라고 해서 중간 과정들이 있는걸 볼 수 있습니다. 예를 들어 Jog_Fwd_Start 라는 애니메이션 에셋을 열어보면 멈춰있는 상태에서 이동하기 시작하는 애니메이션입니다.
이런 세세한 애니메이션을 추가하면서 퀄리티를 높여보겠습니다.

Jog_Fwd_Start를 ChoseAnim 에 추가해봅니다. 이것을 MoveStart 라고 하겠습니다. Idle 에서 이동하기 시작할때 바로 Move로 넘어가는게 아니고 MoveStart로 가야할겁니다.그리고 Move에서 
Idle로 돌아올때도 MoveStop 이라는 상태를 추가해서 Jog_Fwd_Stop 이라는 애니메이션을 실행해주겠습니다. 

그러면 이 4개의 상태를 오가는 트랜지션룰을 또 수정해보겠습니다. 
Idle to MoveStart 에서는 bMoving이 Ture 일때 넘어가게 될겁니다. 거꾸로 Move to MoveStop 일때는 bMoving이 false 일때 가 될겁니다. 
나머지 MoveStart to Move 와 MoveStop to Idle 은 어떻게 될까요 이 조건은 각 애니메이션이 끝났을때 가 될겁니다. 
이 애니메이션이 끝나고 난뒤 넘어가는 것은 이 트랜지션 룰 디테일즈를 보면 Automatic Rule Based on Sequence Player in State 스테이트의 시퀀스 플레이어에 따른 자동 규칙 
이라는 옵션을 켜주면 애니메이션이 끝나면 자동으로 다음 상태로 넘어가게 됩니다. 

이렇게 해서 게임을 실행해보겠습니다. 그러면 Idle과 Move 사이에 좀 더 자연스러운 동작으로 출발하고 정지도 하게됩니다. 그래도 어색한점이 남습니다. 
코드상에서 멈춤에서 이동까지 속도와 이동중에서 멈춤까지의 속도는 훨씬 빠르게 이뤄지는데 애니메이션이 이것을 못따라옵니다. 

추가로 트랜지션 룰을 추가해줄건데 MoveStart to MoveStop 과 MoveStop to MoveStart 입니다. 두 애니메이션 사이에서는 각 모션이 끝나야 다음으로 넘어가게 되어있어서 반응이 좀 느린것 같습니다. 
이 두 트랜지션룰의 조건으로는 bMoving 값을 주면 될겁입니다. MoveStart to MoveStop 은 bMoving이 false가 될때 전환, MoveStop to MoveStart 는 bMoving이 True일때 전환하도록 해주면 됩니다. 

이렇게 만들어보면 똑같은 조건이 중복되어서 나타납니다. Idle to MoveStat 와 MoveStop to MoveStart 일때는 bMoving이 True 라는 조건과 Move to MoveStop 일때와 MoveStart to MoveStop 일때는 
bMoving이 False 일때 라는조건이 겹칩니다.
이런경우에 이런 조건자체를 공유할 수 있습니다. Move to MoveStop 트랜지션룰의 디테일즈를 보면 트랜지션 룰 공유 라는 옵션이 있는데 오른쪽에 공유로 승격이라는 버튼을 클릭 해보면
마치 변수처럼 공유 조건을 저장할 수 있습니다. 클릭해 Not Moving 이라고 이름짓겠습니다. 그러면 이 트랜지션 룰 아이콘이 주황색이 되고 같은 조건을 사용하는 
MoveStart to MoveStop 에서도 트랜지션 룰 공유에서 Not Moving을 골라주면 같은 조건을 사용할 수 있습니다. Idle to MoveStart 와 MoveStop to MoveStart 도 Moving으로 공유로 승격해 바꿔주겠습니다.

이제 다시 게임을 시작해보면 움직임을 시작하자 마자 멈추는 애니메이션이 좀 더 부드러워졌습니다. 
그래도 아직 캐릭터 움직임이랑 애니메이션 이 잘 매칭이 되지 않는데 이 애니메이션은 조금 편집해 보겠습니다. 

우선 DevMap 으로 가서 컨텐츠 브라우저창을 보겠습니다. 컨텐츠 폴더아래로 새 폴더를 만등러 줄건데 Animations 라고 하겠습니다. 이 폴더로 아까 사용하던 Jog_Fwd_Start, Jog_Fwd_Stop 두개를 복사해주겠습니다. 
복사한 애니메이션 에셋의 이름을 바꿔주겠습니다. 원본을 수정하였다는것을 명시해주면 나중에 혼동이 줄어들겁니다. 각 파일명 뒤에 _Edited 를 붙여 줬습니다. 

이제 Jog_Fwd_Start_Edited 를 열어서 애니메이션을 수정해보겠습니다. 이 애니메이션에서는 첨에 움직이기 시작할때 너무 늦게 시작하는것 같습니다. 간단하게 0에서 15프레임 까지 동작을 제거해볼겁니다. 
사실 이런 애니메이션을 편집하는것은 프로그래머의 업무는 아닙니다. 다만 언리얼에 이런 기능이 있다는것만 한번 실습해보겠습니다. 
애니메이션 에셋 창의 하단에는 프레임을 고를수 있는 부분이 있는데 여기서 15프레임에 실행선을 가져다 놓고 우클릭을 해보면 딱 0부터 15프레임까지 제거 라는 기능이 있습니다. 
이러면 앞에 멈칫하던 모션이 사라진걸 볼 수 있습니다. 마찬가지로 뒷부분에 앞으로 달리는 모션이긴한데 너무 긴 부분을 적당히 날려주겠습니다. 46프레임에서 그 뒤로 잘라줄겁니다. 
만약 편집이 맘에 안들다 하면 ctrl + z 로 작업을 되돌릴 수 있습니다.

이렇게 수정한 애니메이션을 ABP_Player에 적용해보겠습니다. MoveStart 상태에서 우리가 수정한 Jog_Fwd_Start_Edited 로 바꿔주면 될것입니다. 

마찬가지로 Jog_Fed_Stop_Edited 도 마찬가지로 수정하고 또 MoveStop 상태도 애니메이션을 교체해주겠습니다.

게임을 실행해보면 좀 더 부드러운 동작이 되었습니다. 


정리하자면 이전 시간에 3D 게임의 이동과 회전 컨트롤러 설정을 하였고 거기에 애니메이션을 붙히는 작업을 해보았는데 애니메이션 블루프린트라는 파일을 만들어 작업했습니다. 
이 애니메이션 블루프린트 이하 ABP 를 캐릭터 클래스에 적용시키려면 Mesh 컴포넌트의 디테일즈 중 애니메이션 관련 옵션에서 사용할 ABP를 골라주면 되었습니다. 
ABP는 AnimGraph에서 사용할 최동 애니메이션을 연결해주면 되었는데 그냥 애니메이션을 연결하면 한가지만 사용하는 것이기 때문에 
상황에 따른 애니메이션 전환을 위해 State Machine 을 사용합니다. 이 상태머신에서는 상태 State들을 추가해 서로 어떤 조건일때 다음 상태로 전환할건지를 정해 줄 수 있고 
각 상태에서 사용할 애니메이션을 정해줍니다. 상태가 전환되는 조건을 트랜지션 룰 이라고 하는데 여기서 사용할 불리언은 ABP의 이벤트 그래프에서 변수라 저장해 사용합니다. 
Event Blueprint Update Animation 이 매프레임마다 필요한 불리언을 가져오게 됩니다. 이렇게 그 불리언만 가져오면 