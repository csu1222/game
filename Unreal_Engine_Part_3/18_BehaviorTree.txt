

    Behavior Tree


이번시간에 인공지능에 대해 알아볼겁니다. 물론 이전 시간에 간단한 몬스터 인공지능을 만들어 봤습니다. 
언리얼에서는 간편하게 사용할수 있는 Behavior Tree 가 준비되어 있기 때문에 한번 알아보겠습니다. 

이 Behavior Tree 는 처음 사용할때는 조금 복잡합니다. 또 그때문에 더 복잡한 인공지능을 구현할 수 있을겁니다. 

실습할 몬스터를 Pawn 을 상속받은 블루프린트 클래스 BP_Monster 를 만들어주고 현태는 그냥 실린더 메쉬를 가지고 이게 몬스터라고 치고 실습해보겠습니다.
몬스터는 이후에 인공지능을 붙혀서 월드에서 움직이게끔 할것이기 때문에 무브먼트 컴포넌트를 추가해주겠습니다. 
컴포넌트중에 잘 찾아보면 Floating Controller 라는것이 있습니다. 이것을 추가합니다.

또 몬스터를 조종할 컨트롤러를 새로 만듭니다. 이전에도 알아봤던 AIController 를 상속한 블루프린트 클레스를 BP_MonsterController 이름으로 만듭니다. 
일단 BP_MonsterController 를 만들었으면 잊기전에 BP_Monster 의 디테일에서 BP_MonsterController 를 사용하도록 물려줍니다. 

또 이번에 사용할 Behavior Tree 도 에셋으로 만들줄 수 있습니다. BT_Monster 라는 이름으로 만들어주고 또 같은 란에 짝궁이라고 할 수 있는 
BlackBoard 를 추가하고 BB_Monster 라고 하겠습니다. 

이제 BP_MonsterController 를 열어보겠습니다. 이벤트 그래프를 가서 시작할 이벤트를 배치해보겠습니다. 
컨트롤러에 몬스터 객체에 빙의되는순간의 이벤트인 Event On Possess 를 배치하겠습니다. 이어서 호출할 함수는 Behavior Tree 로 검색해보면 
Run Behavior Tree 라는 함수가 있습니다. 이함수에는 BT Asset 를 골라줄 수 있는데 지금은 BT_Monster 한가지 밖에 없으니 이걸 골라주면 
어떻게 동작하냐면 몬스터가 등장하는 순간에 BP_MonsterController 가 빙의 되고 빙의된 후에는 Run Behavior Tree 가 실행되 BT_Monster 가 실행됩니다. 

겸사겸사 BP_MonsterController 의 내 블루프린트 창의 톱니바퀴를 열어보면 Show Inherited Variables 를 켜주면 내가 상속받은 변수 목록을 볼 수 있습니다. 
변수 창을 열어보면 이미 AI 쪽에 BlackBoard 와 관련된 변수들이 존재하는걸 볼 수 있습니다. 알게모르게 이미 많은 기능이 숨어 있었습니다. 

지금 준비한 코드에서는 이제 Behavior Tree 에서 어떻게 동작할건지를 만들어주면되겠습니다. 

BT_Monster 를 열어보겠습니다. 본격적으로 Behavior Tree 에 대해 알아볼건데 
디테일즈를 보면 이미 블랙보드 에셋을 우리가 만든 BB_Monster 로 사용하게 되어 있습니다. 
비슷하게 애니메이션도 BP_Player 에서 애니메이션을 관리하지 않고 애니메이션 컨트롤러역할의 애니메니션 블루프린트 ABP_Player를 따로 만들어 관리했었습니다. 
애니메이션을 그리기 위한 변수를 ABP_Player 에서 관리하면서 사용했었습니다. 
비슷한 느낌으로 인공지능도 인공지능을 사용할 때 필요한 블랙보드에 적어 놓는다고 생각하면 됩니다. 블랙보드는 말 그대로 칠판이라는 단어인 까닭입니다. 

Behavior Tree 라는 용어를 직역하면 행동 나무 입니다. 이 말대로 Root 노드로부터 나무 형태로 가지를 뻗어가면서 행동원리를 만들어 줄겁니다. 
빈 곳을 우클릭하면 이벤트 그래프의 함수를 검색하는것처럼 노드를 배치할 수 있는데 기본적으로 사용하는 기능중에는 Move To, Play Sound, Wait 같이 명확히 의미를 알 수 있는 기능들이 있습니다.
물론 이 외에도 직접 기능을 만들어 배치할 수도 있습니다. 

이제 어떤 순서로 어떤 기능을 실행할지를 골라주는 기능이 또 있습니다. 가장 많이 사용하는 흐름제어 기능은 Selector, Sequence 대표적입니다. 

설명을 읽어보면 Selector 노드는 연결된 자식들을 왼쪽부터 오른쪽으로 실행하는데 자식 노드가 실패하면 다음 오른쪽 노드를 실행합니다. 자손 노드가 실행 성공했으면 다음 실행을 하지않고 이 셀렉터는 
성공한 것으로 치고 만약 모든 자손 노드가 실패했으면 셀렉터도 실패한것으로 합니다. 
비교를 하자면 if else 같은 느낌입니다. 연결된 자손노드중 하나만 실행 성공하면 빠져나오는 식입니다. 

Sequence는 for 문 같은 느낌의 노드로 연결된 자손들을 왼쪽에서 오른쪽으로 차례대로 실행하는데 현재 자손노드가 성공하면 다음 자손 노드를 실행하고 중간에 하나라도 실행에 실패하면 
작동을 멈추고 Sequence 는 실패한것으로 합니다. 

결국 이 부품들을 잘 조립해서 이리저리 인공지능을 만들어 줄 겁니다. 
기본 규칙으로 Root 에는 두개 이상의 노드를 연결해 줄 수 없고 하나의 노드만 연결할 수 있습니다. 

예를 들어서 Root 에서 Selector 를 연결하고 이어서 다시 Sequence 나 Selector 를 또 이어질 수 있습니다. 적당히 Wait 노드를 연결하고 Wait 를 선택해보면 
대기시간을 설정할 수 있습니다. 의미없이 1초를 기다리도록하면 이 인공지능은 별 의미없이 1초씩 기다리는 인공지능이 됩니다. 

그래서 일반적으로 인공지능을 만들때 몬스터들이 이리저리 로밍을 하다가 일정거리안에 들어온 플레이어를 쫒아가고 더 가까이 공격범위 안으로 들어오면 공격을 하는 인공지능이 
일반적이니 이것을 만들어 보면서 Behavior Tree 에 대해 더 알아보겠습니다.

사용했던 Wait, Move to, Play Sound 같은 노드를 Task 태스크 라고 부릅니다. 
우리가 하고싶은게 몬스터가 일정 영역을 배회하는 패트롤 태스크인데 이런 특이한 태스크는 당연히 언리얼에서 기본 제공하지 않고 우리가 직접 만들어야 합니다. 
BT_Monster 의 상단에 보면 새 태스크 라는 버튼이 있습니다. 클릭합니다. 그러면 윈도우 파일 탐색기에서 파일을 저장하는것 같은 창이 뜨고 태스크의 이름을 정해 저장해 줄 수 있는데 
우리 용도에 맞게 BTTask_FindPatrolLocation 이름으로 저장해주겠습니다. 

BTTask_FindPatrolLocation 가 자동으로 열릴텐데 블루프린트 클래스와 거의 비슷하게 만들어 줄 수 있습니다. 
일반적인 이벤트가 아니라 Event Receive Execute AI 라는 이벤트를 사용하겠습니다. 그리고 반드시 Finish Execute 라는 함수로 끝맺음을 해줘야합니다. 
Finish Execute 할때 이 태스크의 성공여부를 정해주는데 아까 Behavior Tree 는 각 태스크의 성공여부가 중요했으니 잊지말고 정해줘야합니다.

Event Receive Execute AI 에서는 Owner Controller 와 Controlled Pawn 을 가져올 수 있습니다. 우리가 이 태스크에서 하고싶은것은 BP_Monster 가 일정범위 내에서 랜덤으로 이동하게 하는겁니다. 
실제 게임에서는 배회를 하기전에 자신이 어디로 갈 수 있는지를 아는것도 필요합니다. 주변 지형을 스캔해 이동가능한 위치를 골라줘야하기 때문입니다. 
이럴때 사용하는것은 A-Star 같은 길찾기 알고리즘을 사용하면 됩니다. 

우리가 길찾기 알고리즘을 사용하려면 일단 '길' 이라는 영역을 만들어 줘야합니다. DevMap의 Place Actor 창에서 볼륨 쪽을 찾아보면 Nav Mesh Bounds Volume 이란게 있습니다.  
네비게이션 메쉬 라는것인데 이것을 월드에 배치해줍니다. 조그만 사각형 영역이 배치되는데 우리 월드 전체를 길찾기 영역으로 지정하려면 이 네브메쉬바운스 볼륨의 크기를 아주 크게 늘려주면 될겁니다. 
참고로 월드에 초록색 영역이 갈 수 있는 영역이라는 의미이고 P를 누르면 이 영역이 안보이게 되고 다시누르면 또 보이게 할 수 있습니다. 

다시 인공지능에 집중해보겠습니다. 
BTTask_FindPatrolLocation 로 돌아가보겠습니다. 이제는 네브메쉬바운드 볼륨이 배치 되었으니 Get Random Point Navigable Radius 라는 함수를 사용 할 수 있습니다. 
(현재 언리얼 엔진 5 버전 5.3에서는 Get Random Reachable Point Radius) 이 함수는 갈 수 있는 영역에서 랜덤 영역을 추출한다는 의미입니다. 
이 함수에 몬스터의 현재 로케이션을 연결해주고 이동할 범위도 입력해줍니다. 현재 로케이션은 Event Receive Execute AI 에서 Controlled Pawn 핀을 끌어 Get Actor Location 을 호출해 넘겨주면되고 
이동할 범위는 1000.0 이라고 입력해주겠습니다. 

그러면 랜덤 로케이션이 나올텐데 이 정보를 어떻게든 Behavior Tree 로 넘겨주면 됩니다. 그전에 먼저 한번 로그로 찍어보겠습니다. 
PrintString으로 출력해주고 이어서 Finish Execute 를 호출해주겠습니다. 일단 성공여부는 무조건 True 가 되도록 해줍니다. 

BT_Monster Root 로 부터 Selector -> Sequence 를 연결한 상태인데 Wait 를 3초 다음 태스크로 BTTask_FindPatrolLocation 를 연결해주었습니다.

게임을 실행해보면 3초에 한번씩 랜덤한 좌표가 찍히는걸 확인 할 수 있습니다. 

아직은 좌표만 구햇고 이동은 하지 않았습니다. 
여기서 조심해야하는데 BTTask_FindPatrolLocation 에서 구한 이 좌표를 어떻게 BT_Monster 로 전달해 줄 수 있을까요 
아까 처음에 말했던 것처럼 블랙보드라는 곳에서 BT 에서 사용할 정보들을 기입해서 사용한다고 했습니다. 그렇기 때문에 
BB_Monster 를 열어서 새 키를 추가할 수 있습니다. 새 키 추가를 클릭해보면 변수를 만드는것처럼 타입을 골라줄 수 있습니다. 지금 사용할 키는 Vector 로 받아줍니다. 이름도 
PatrolLocation 이라고 하겠습니다. 

BT_Monster 를 보면 방금 추가한 PatrolLocation 키가 블랙 보드 창에 추가되어있을겁니다. 이걸 이제 태스크 쪽에서 가져다 저장해야하는데 
특이한 타입의 변수를 사용해야합니다. 

BTTask_FindPatrolLocation 에서 변수를 추가해주는데 타입이 BlackBoard Key Selector 라는 타입입니다. 이름을 Location 이라고 하겠습니다.
생소한타입인데 어떤 느낌이냐면 마치 우리가 함수를 실행할때 입력을 받는것처럼 이 Key Selector 에 받아올 수 있습니다. 
현재 그냥 BlackBoard Key Selector 를 만들자 마자 BT_Monster 로 가보면 BTTask_FindPatrolLocation 를 눌러봐도 아직 달라진게 없습니다. 
하지만 다시 BTTask_FindPatrolLocation 로가서 외부에서더 이 변수를 볼 수 있게끔 옆에 눈 아이콘을 클릭하면 BT_Monster 에서 보이게 됩니다. 
여기에 이제 연결해주고 싶은 변수를 세팅해주면 됩니다. 

다시 설명해보자면 블랙 보드에 Key 를 추가해 Vector 타입 PatrolLocation 이라고 이름 지었습니다. 또 BTTask_FindPatrolLocation 에 변수를 하나 만들어 주는데 
BlackBoard Key Selector 라는 타입으로 Location 이라는 이름입니다. 이 변수를 외부에서도 확인 할 수 있도록 눈 아이콘을 열어줍니다. 
BT_Monster 에서 BTTask_FindPatrolLocation 태스크를 클릭해 Location 이 어떤 BlackBoard Key와 연결 될건지 골라주는데 PatrolLocation 로 선택합니다. 
이제 Location 은 블랙보드의 PatrolLocation 에 연결된 것입니다. 

여기서 끝이아닙니다. BTTask_FindPatrolLocation 에서 Location 을 get 하고 또 핀을 끌어다가 Set BlackBoard Value 시리즈 함수를 검색합니다. 
우리가 담아주고 싶던 정보는 벡터 타입이었으니 Set BlackBoard Value as Vector 함수를 꺼내줍니다. 
PrintString 에 연결하고 있던 벡터를 여기로 이어주고 Finish 로 이어줍니다. 

이동가능한 랜덤 좌표 하나를 받아오는것에 아주 긴 과정을 거쳐서 만들었습니다. 

BT_Monster 를 보면 이제서야 이제 그 좌표로 이동하는 Move To 태스크를 사용할 차례입니다. 여기서도 BlackBoard Key 를 고를 수 있는데 PatrolLocation 을 골라줍니다. 

생각보다 햇갈리게 되어있는데 BlackBoard 와 Behavior Tree 는 한 쌍이지만 따로 관리되고 있기 때문에 조금 복잡한 방법을 통하고 있습니다.

여기까지 만들고 한번 게임을 실행해보겠습니다. 몬스터가 배회를 하고 있는걸 볼 수 있습니다. 

아직 끝이 아니고 시작에 불과합니다. 태스크만 사용할 게 아니기 때문인데 그래도 지금 배운 Behavior Tree, BlackBoard, BlackBoard Key, Task 를 사용하는 방법을 
숙달해서 따로 찾아보지 않고 자연스럽게 가능하도록 하는게 좋습니다. 


이어서 살펴볼 기능은 Service 라는 기능입니다. 이것도 Behavior Tree 의 상단에 New Service 라는 버튼으로 만들 수 있습니다.
서비스는 무엇이냐 하면 우리가 1초 마다 영역을 스캔해서 몬스터 주변에 플레이어가 있는지를 찾고 싶다거나 하는 주기적으로 해야할 일들을 서비스로 만들어 추가할 수 있습니다.

서비스를 어떻게 추가하냐면 Selector, Sequence 같은 노드나 Move To 같은 태스크를 우클릭하면 Add Service 라는 게 있습니다. 커서를 가져다 대면 기본 제공 서비스 종류가 적다는걸 
알 수 있는데 왜냐면 서비스는 너무 케바케로 다르기 때문입니다. 

우리가 사용할 서비스를 만들어 보겠습니다. New Service를 누르고 BTService_FindTarget 이라고 이름짓겠습니다. 몬스터입장의 타겟을 찾는것이니 플레이어를 찾는것입니다. 

BTService_FindTarget 에서 사용할 이벤트는 Event Receive Tick AI 입니다. Event Tick 처럼 주기적으로 호출이 되는데 다른 점은 매 틱마다 호출하는게 아니라 
호출할 주기를 설정할 수 있습니다. 

다만 호출주기를 Event Receive Tick AI 의 디테일즈에서 설정하는게 아니라 상단에 클래스 디폴트를 클릭해 나오는 디테일즈 서비스 간격에서 설정해 줄 수 있습니다. 기본적으로 0.5 라고 
되어있는데 1.0으로 하면 1초에 한번 서비스를 호출한다는 의미이고 그 아래 랜덤 편차라는것이 있는데 호출되는 간격이 설정된 시간기준 전후로 랜덤하게 편차를 줄 수 있는 옵션입니다.
지금은 그냥 동일한 간격 1초마다 실행해주도록 1.0, 0 이라는 값을 주겠습니다. 
이 이벤트가 잘 동작하는지 로그를 찍어 보겠습니다. PrintText 로 Hello 라고 로그를 찍습니다. 

만든 서비스를 적용해줄 노드를 등록해야하는데 Root 아래있는 Selector 에 BTService_FindTarget 를 등록해주었습니다.

게임을 실행해보니 의도한 대로 1초마다 Hello 라고 출력됩니다. 

이제는 BTService_FindTarget 에서 타겟 즉 플레이어를 찾는 코드를 작성해야합니다. 
여기서 뭐가 필요할지 생각해보면 이 서비스 역시 BlackBoard Key 로 변수에 구한 타겟을 받아줘야할 것입니다. 
그래서 먼저 BB_Monster 로가서 Key를 추가해주겠습니다. Key 의 타입은 Object 타입으로 하고 이름은 TargetEnermy 정도로 해줍니다. 
이제 BTService_FindTarget 쪽에서 Key를 받아줄 준비를 하겠습니다. 변수를 BlackBoard Key Selector 타입으로 하고 이름은 Target 정도로 하면 될것 같습니다. 
이 변수의 눈모양 아이콘도 켜주고 이벤트 그래프에서 데이터를 저장할 준비를 먼저 하자면 Get Target 을 하고 핀에서 Set BlackBoard Value as Object 함수를 배치하겠습니다. 

이제 주변 오브젝트를 가져오는 함수로는 성능이 떨어지긴 하지만 Get Actor Of Class 함수가 있었습니다. 그래도 1초에 한번만 실행되는 이벤트니까 사용해보겠습니다.
찾을 클래스는 BP_Player 를 찾으면 될것입니다. 이어서 Valid 체크를해주겠습니다. Is Valid 를 해주고 또 이어서 브랜치를 하나더 해줄건데 뭘 체크할거냐면 몬스터와 플레이어의 거리를 
재서 충분히 가까우면 추격을 하도록 해주려고 합니다. 

몬스터와 플레이어간의 거리를 구하려면 Get Actor Of Class 에서 리턴된 플레이어 오브젝트를 Get Actor Location 하고 Event Receive Tick AI 의 리턴 Controlled Pawn 에서 Get Actor Location 
하면 각각의 로케이션을 가져옵니다. 둘 사이의 거리는 둘을 빼주고 Vector Length 를 해 그 길이를 구합니다. 구한 길이가 1000.0 보다 작은지를 체크해보겠습니다. 
해서 범위 내에 있다면 Set BlackBoard Value as Object 에 BP_Player 를 넘겨주고 아니라면 빈 오브젝트를 넘겨주도록 하겠습니다.

다시 BT_Monster 로 가보면 1초마다 몬스터는 1000.0 이라는 범위내에 플레이어가 있는지를 탐색할것입니다. 탐색이 성공한다면 TargetEnermy 에 플레이어가 저장될것입니다. 

이어서 알아볼 개념은 Decorator 입니다. BT_Monster 에서 Selector 밑으로 연결된 Sequence 에 추가할 겁니다. 데코레이터는 추가적인 조건을 붙히는 개념입니다. 
기본 제공되는 데코레이션을 보면 종류가 아주 많은데 대표적으로 사용할 수 있는게 BlackBoard Key 를 가지고 조건을 거는 BlackBoard Based Condition 이 유용합니다. 
얘를 들어서 지금 BTService_FindTarget 에서 몬스터 주면을 탐색해 TargetEnermy 에 값을 설정했거나 안한 상태일 건데 이 후로 BlackBoard Based Condition 의 디테일즈에서 
TargetEnermy 가 세팅이 되어있는지 아닌지를 보고 만약 아직 못찾았으면 좀 전에 만든 Patrol 코드를 실행하고 만약 찾았다면 플레이어를 따라가게끔 만들 수 있을겁니다. 

Root 아래에 있는 Selector 노드에서 두개의 Sequence 를 연결합니다. 왼쪽 Sequence 는 BlackBoard Based Condition 데코레이션에서 TargetEnermy 가 Is Not Set 일때 실행해주도록 하고 \
내용은 순찰을 계속 하도록 합니다. 
오른쪽 Sequence 에서는 반대로 TargetEnermy 가 Is Set 되었을때 실행해줄겁니다. 내용은 찾은 플레이어를 향해 다가가는 코드입니다. 

이제 찾은 플레이어를 향해 이동하는 코드를 만들어주겠습니다. 먼저 Behavior Tree 에서 이동하는 태스크는 Move To 였는데 이동할 대상을 BTService_FindTarget 에서 저장한 TargetEnermy 로 
설정하려고 하는데 골라줄 수 없습니다.

왜 그런지 BB_Monster 를 보면 Self Actor 는 키 타입이 Object 이긴한데 옆의 화살표를 열어보면 베이스 클래스가 Actor 입니다. 반면 TargetEnermy는 세부 베이스 클래스를 따로 골라주기 않았습니다. 
이것도 Actor 로 골라주겠습니다. 

TargetEnermy 의 베이스 클래스가 Object 라는것은 어떤 클래스로든 객체를 만들면 오브젝트가 되는것이고 Actor 라는것은 이것도 오브젝트이긴한데 월드에 배치할 수 있는 오브젝트로 Location 정보를 가지고 있다고 
확신 할 수 있는 오브젝트입니다. 그 이유로 베이스 클래스가 Actor 여야 Move To 태스크의 목표가 될 수 있습니다.  

이제 코드를 만들었으니 조금 정리를 해보자면 두 Sequence 를 어떻게 배치하느냐에 따라 코드의 실행 우선순위가 결정됩니다. Behavior Tree 에서는 왼쪽에서 오른쪽 순서로 실행되기 때문인데 
보통의 상황에서는 순찰하는 기능보다는 플레이어를 쫒아가는게 더 중요한 기능이니깐 플레이어를 쫒는 Sequence 를 왼쪽에 두겠습니다.

게임을 실행해 테스트를 해보았습니다. 의도는 몬스터가 순찰을 하고 일정 거리 안에 플레이어가 있다면 쫒아와야 하는데 플레이어를 익식하지 못합니다.

이유는 BT_Monster 에서 BTService_FindTarget 의 Target을 TargetEnermy 에 저장해주는걸 잊어서 그랬습니다.
이제는 의도한대로 플레이어를 잘 쫒아옵니다. 


이어서 뭘 더 추가할지 생각해보겠습니다. 플레이어를 찾으면 쫒아오는것은 맞는데 보통은 일정거리안으로 들어오면 공격을 한다거나 자폭을 한다거나하는 기능이 있을겁니다. 
이걸 한번 만들어 보겠습니다.

지금까지 Task 와 Service 는 커스텀으로 만들어 봤는데 아직 Decorator 는 커스텀으로 사용하지 않았으니깐 굳이 한번 커스텀 Decorator 를 만들어보겠습니다. 
만들 데코레이터는 나의 타겟 에너미가 일정 거리 안으로 들어왔는지 를 체크하는 데코레이터로 만들어보겠습니다. 

BTDecorator_IsTargetInRange 라는 이름으로 만들어 줍니다. 다음으로 사용법은 똑같습니다. 데이터를 넘겨줄 변수를 만드는데 BlackBoard Key Selector 타입으로 만들고 Target 이름으로 눈을 띄워줍니다. 
그리고 Range를 판별해주기 위해서 Float 변수 Range도 추가합니다. Range 도 밖에서 수정할 수 있도록 눈의 띄워줍니다.

다음으로 데코레이터는 오버라이드를 기억하면 됩니다. 데코레이터를 체크하는 기능중에 Perform Condition Check AI 라는 기능을 사용할겁니다. 
물론 오버라이드 할 수 있는 함수들은 다 기능에 따라 골라 사용할 수 있는데 기본적으로는 지금 고른것을 많이 사용한다고 합니다. 

Perform Condition Check AI 함수에서는 Owner Controller 와 Controlled Pawn 이 제공되고 리턴노드에서는 불리언을 받으면서 조건체크를 합니다. 
먼저 Controlled Pawn 으로 Get Actor Location 으로 몬스터의 위치를 가져오고 
지금까지는 Set 만 했던 BlackBoard Key 를 지금은 Get Target 이후 Get BlackBoard Value as Actor 로 타겟인 플레이어를 Actor로 가져와 봤습니다. 이어서 또 Get Actor Location 으로 
플레이어의 위치를 가져올 수 있습니다. 

몬스터의 위치와 플레이어의 위치를 빼주면 그 사이 만큼의 벡터가 생기고 그 길이인 Vector Length 를 해주면 두 오브젝트 사이의 거리가 나옵니다. 이 거리와 아까 추가한 변수 Range 와 비교해 
그 비교값을 리턴 노드에 연결해주면 됩니다. Range 값을 아직 안정했는데 100.0 정도로 주겠습니다. 

지금과 비슷한 작업을 BTService_FindTarget 에서도 했었습니다. 주변 플레이어를 탐색할때 그 범위를 1000.0 이라고 하드코딩했었는데 여기도 겸사 겸사 Range 변수를 추가해 관리해주겠습니다.

BT_Monster 에서도 서비스나 데코레이션의 Range 같은 것도 밖에서 수정할 수 있고 그게 더 편합니다.

BT_Monster 의 노드도 정리하겠습니다. BTService_FindTarget 에 의해 Target 이 세팅 되어있다면 이어서 다시 방금만든 BTDecorator_IsTargetInRange 으로 나뉠겁니다. 
이 나뉘는 것은 Selector 가 더 어울릴 것 같습니다.  
그러니까 현재 Root 노드 -> BTService_FindTarget 가 추가된 Selector -> BlackBoard Based Condition 으로 Target이 세팅된 Selector  이렇게 연결되어 있는겁니다. 
그 밑으로 sequence 두개를 연결해줍니다. 왼쪽 Sequence 에는 BTDecorator_IsTargetInRange 를 연결해 100.0 이라는 Range 안에 플레이어가 있는지를 판별해 성공한다면 
Wait 를 해주도록 하겠습니다 아직 공격하는 태스크는 만들지 않아서 Wait 만 해주는겁니다. 이 왼쪽 Sequence 가  실패했다면 다음으로 다시 플레이어에게 다가가는 Sequence 를 실행해주겠습니다.


이번시간에 알아본 Behavior Tree 는 아주 간단한 인공지능이라면 오히려 더 복잡할 수 있지만 조금이라도 어려운 인공지능을 만들게 되면 훨씬 가독성도 좋고 쉽다고 느낄 기능입니다.
