

    플레이어 컨트롤러

이전 두 시간에 걸쳐 캐릭터 에셋을 받아오고, 블루프린트 클래스화 해서 PlayerStart로 배치되게끔 디폴트 폰 클래스로 설정하고, 이동 함수로 Add Movement Input을 사용하고,
또 캐릭터 회전을 Add Controller Yaw Input 을 사용해 적용했습니다. 

그 결과로 캐릭터를 wsad로 이동하고 q, e 로 좌우 회전이 되도록 했습니다. 
그런데 이런 조작은 이 게임이 콘솔 게임이라 게임패드로 화면 회전을 조작해야한다면 모르겠지만 TPS 게임을 만들어 볼것이기 때문에 그러기 위해서는 마우스의 입력을 받아 회전하게끔 
해줘야할겁니다. 이것을 수정할 것이고 겸사겸사 플레이어 컨트롤러에 대한 이야기를 해볼겁니다. 

일단 먼저 BP_Player의 이벤트 그래프로 돌아와서 이전시간에 작업했던 Turn 축맵핑 이벤트로 부터 연결된 코드가 바뀌어야 합니다. 
이 입력과 관련된 부분은 프로젝트 세팅의 입력 부분에서 설정해주고 있었습니다. 

거기서 Turn 입력을 키보드 Q와 E를 받아주고 있었는데 이것 대신에 마우스 입력을 받아 줘야합니다. 검색으로 Mouse X 라고 찾으면 되는데 이게 마우스의 좌우좌표이고 
새로 입력을 LookUp이라고 만들고 마우스 Y로 입력을 받아줍니다. 
스케일은 일단 LookUp의 마우스 Y를 -1.0으로 주겠습니다. 나중에 이게 마음에 안들면 다시 와서 바꿔 주면 됩니다. 

다시 BP_Player의 이벤트 그래프로 돌아와서 이미 Turn 이벤트는 있으니 LookUp 이벤트를 배치해줍니다. 
Turn 에 이전시간 작업한 코드를 보니 Q,E로 좌우 회전을 했을때는 각 키를 누르는지 아닌지에 따라 정해진 속도로 회전했었는데 
마우스 입력을 받을때는 이런식이 아니라 내가 마우스를 움직이는 속도에 따라 회전도 같이 따라가야합니다. 
그래서 이전 작업과 느낌이 달라지는게 Axis Value의 범위가 -1.0 ~ 1.0 가 아닐 수 있다는 점이 있습니다. 

일단 이전시간에 TurnSpeed와 델타 세컨드를 곱하고 했던 것들을 다 지워주고 Add Controller Yaw Input에 Axis Value를 직접 꽂아 보겠습니다. 
그리고 LookUp 에는 Add Controller Pitch Input을 연결해주고 테스트 해보겠습니다. 

게임을 실행해서 마우스를 움직여 보면 좌우로는 회전하는데 위 아래로는 막혀있습니다. 
이 문제를 수정하기 전에 프린트 텍스트 쪽을 조금 정리해볼건데 이전시간에 플레이어의 Yaw와 플레이어 컨트롤러의 Yaw를 비교해 출력하던걸 삭제하고 
대신에 Turn 축맵핑 값이 얼마인지를 가져오고 LookUp도 가져와 출력해보겠습니다. 

이대로 다시한번 게임을 실행해보면 이 Axis Value가 -1 ~ 1 을 넘어서는 값을 출력한다는걸 확인할 수 있습니다. 키보드입력과 마우스 입력에는 차이가 있었습니다. 

다음으로 위아래로는 회전하지 않는 것을 수정해줘야합니다. 물론 이전시간에 알아봤던 BP_Player의 Use Controller Rotation Pitch를 켜주면 되지 않을까 싶습니다. 
그런데 이것은 이상한 점이 있습니다. 위아래로 화면은 움직이기는 하지만 플레이어 캐릭터도 같이 위아래로 같이 움직입니다. 
이것은 일반적인 게임에서 원하는것은 아닐겁니다. 일반적으로는 위아래로 화면을 움직일때 카메라만 움직이고 크로스헤어만 따라 가는식을 많이 사용할것입니다. 

그래서 이 Use Controller Rotation Pitch 를 꺼주고 또 스프링 암 컴포넌트의 디테일즈를 살펴보면 재미있게도 여기서도 Use Pawn Controller Rotation 이라는 옵션이 있습니다. 
이게 방금과 똑같은 이야기입니다. 폰을 컨트롤 하고 있는 컨트롤러의 로테이션을 이 스프링암에도 적용하겠다는 것입니다. 즉, 플레이어 컨트롤러의 로테이션과 스프링암의 로테이션을 동일화 하겠다는것입니다. 

이 스프링암의 Use Pawn Controller Rotation 옵션을 켜서 테스트 해보려면 이전에 스프링암이 캐릭터 기준으로 y축 -30도 정도 위치에 있도록 한것을 다시 원점으로 돌린 다음 테스트 
해보겠습니다. 
그러면 이제 우리가 하고 싶었던 데로 Turn, LookUp 으로 플레이어 컨트롤러를 회전 시키면 그에 따라 스프링암과 그에 딸린 카메라가 같이 회전하면서 캐릭터는 좌우로만 따라오고 위아래는 카메라만 움직이게 됩니다. 

다만 지금은 위아래로 그냥 수직으로도 움직일 수 있는것을 필요하면 범위 제한을 둘 수 있습니다. 


한가지 더 실습해보자면 우리가 지금까지 코드들을 BP_Player 에 넣어 놨습니다. 지금 돌이켜보면 결과적으로 로그찍는 코드를 제외하면 
각 입력 이벤트에서 한 두개의 함수만 꺼내 사용하는 작업 밖에 없습니다. 이미 다 아는 상태에서 복원하려면 금방 할 수 있다는 것입니다. 

그런데 이제 플레이어에 입력값을 관리하는것이 꼭 틀린 방법은 아니기도 합니다. 다만 나중에 코드량이 너무 많아 진다거나 아니면 특정상황에 따라 이 행동들이 바뀌기를 원한다면 
플레이어에서 관리 하기보다는 플레이어 컨트롤러에서 관리하는것도 좋은 방법입니다. 

새로 블루프린트 클래스를 만들고 플레이어 컨트롤러를 상속받아주면 됩니다. 클래스 이름은 BP_PlayerController 로 해주겠습니다. 그리고 월드세팅에서 Player Controller Class를 
지금만든 BP_PlayerController로 설정해줍니다. 

그리고 BP_PlayerController의 이벤트 그래프에 BP_Player 에서 인풋 받던 코드들을 모두 이전해줍니다. 
여기서 끝은 아니고 이제는 코드들이 BP_Player 입장에서 사용하던 함수들인데 이걸 플레이어 컨트롤러 입장의 함수를 사용하면 됩니다. 
예를 들면 Add Controller Yaw Input 의 경우도 플레이어 컨트롤러에서 호출하려고 하면 Add Yaw Input 함수를 사용하면 됩니다. 회전은 이렇게 수정하면 되고 

이동 코드의 경우에는 이동하려는 방향을 플레이어안에서 Get Actor Forward Vector 로 꺼내와 사용했었는데 이 것을 플레이어 컨트롤러에서 호출하면 플레이어가 아닌 컨트롤러의 Forward Vector 를 가져오게됩니다. 
또 Add Movement Input도 Self를 대상으로 하는게 아닌 플레이어를 대상으로 호출해주야합니다. 
그래서 플레이어 컨트롤러에서 자신이 컨트롤 하고 있는 플레이어를 가져오도록 Get Player Pawn 함수를 사용하면됩니다. 이렇게 가져온 플레이어를 변수로 들고 있어도 되고 그냥 그때 그때 가져와 사용해도 됩니다. 

게임을 실행해보면 이전과 같이 동작을 합니다. 다만 로그를 찍는 코드가 제대로 동작하지 않는데 
왜 이럴까 생각해보면 Turn Axix Event , LookUp Axis Event를 BP_PlayerController에서 호출하고 있기 때문에 BP_Player 에서는 Axis Value를 가져오지 못하는 구나 라는것을 유추 할 수 있습니다. 
이걸 수정하려면 그냥 로그를 찍는 코드도 BP_PlayerController로 이전하면 그만입니다. 


이번 실습에서 가장 중요했던 것은 결국 마우스를 입력 받아서 컨트롤 하는것과 BP_Player 에서 Use Controller Rotation Pitch를 사용하지 않는 이유 그 대신 스프링암에서 Use Controller Rotation으로 한 이유
입니다. 나중에 C++에서는 Use Controller Rotation Pitch 같은 부분을 true false 를 막 여기저기서 호출을하는데 왜 하는지를 모르면 어지럽고 복잡합니다. 
그래서 블루프린트에서 좀 더 이해하기 쉬운 환경에서 미리 배우고 넘어가면 좋겠습니다. 

나중에는 마우스 커서를 화면 중앙에 고정시키고 그 위치에 크로스헤어를 추가한 다음 에임을 클릭하면 그 위치의 몬스터에 피격판정을 계산하는 작업등을 할겁니다. 

마지막으로 또 한가지만 더 알아보자면 FPS에서 앉는 모션이나 점프하는 기능들이 있을텐데 이런 기능들이 언리얼에서는 무브먼트 컴포넌트에 모두 들어가 있습니다. 
실습을 위해 입력을 하나 추가해주겠습니다. 이번에는 그냥 한번 키를 누르면 끝나는 기능이기때문에 액션 맵핑으로 Jump라는 입력을만들어주겠습니다. 스페이스바에 할당해줍니다. 
그리고 나서 BP_PlayerController 에 Jump 이벤트를 배치하고 점프에 관한 기능을 만들어 주면 되겠습니다. 그런데 함수를 검색해보면 점프와 관련된 기능들이 이미 만들어져 있다는걸 알 수 있습니다. 
언리얼엔진에는 어지간해서는 숙이거나 기어가거나 점프하는 기능이 이미 만들어져있습니다. 이것이 슈팅 게임에 최적화 되어있는 엔진의 장점입니다. 

그런데 BP_PlayerController에서 Jump로 검색해도 관련 함수가 나오지 않는데 왜 그런거냐면 함수 검색은 기본적으로 Context Sensitive 라고 문맥상 말이 되는 애들만 검색해주기 때문에 안보이는것이고 
이것을 체크 해제하면 진짜로 모든 함수를 다 보여줍니다. 
여기서는 체크 해제후 Jump 함수를 가져오겠습니다. 
이후 아직 언리얼에 익숙하지 않는 입장에서는 왠만하면 Context Sensitive 을 켜주는게 좋기 때문에 다시 켜주겠습니다. 

Jump 함수를 보면 인풋으로 캐릭터클래스 레퍼런스를 받고 있습니다. 위에서 Add Input 시리즈함수는 Get Player Pawn 으로 넣어주면 되었었는데 Jump는 캐릭터를 넣어줘야하는데 
아마 캐릭터를 가져오는 함수가 있지 않을까 해서 찾아보면 역시 있습니다. Get Player Character 라는 함수를 호출해 연결해주겠습니다. 

이거만 하면 끝인가? 싶을수 있는데 한번 테스트를 해보겠습니다. 이동하면서 스페이스바를 누르면 정말 간단하게 점프를 합니다. 

물론 아직 애니메이션이 적용되지않았기 때문에 기본 포즈 그대로 움직이지만 아예 처음부터 만들면 이런 이동하고 회전하고 점프하는부분을 만드는데 꽤 많은 시간을 잡아먹게 되는데 
이것을 언리얼 엔진의 기본 기능을 통해 스킵하였습니다. 

다음시간부터 본격적으로 애니메이션을 넣어주겠습니다. 
그런데 이 슈팅게임에서 애니메이션은 할 이야기가 많습니다. RPG 게임은 그냥 Idle, Move, Skill 같은 애니메이션을 사용하면 되는데 슈팅 게임같은경우는 화면이 바라보는 방향을 따라서 
총기를 그쪽으로 겨냥하고 있습니다. 상체만 그렇게 움직이고 하는 부분적인 애니메이션이 들어갑니다. 