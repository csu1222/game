

        캐릭터 회전


이번시간에는 캐릭터 회전과 플레이어 컨트롤러에 대한 내용을 다뤄 볼겁니다. 

시작하기전에 캐릭터 이동에 사용했던 Add Movement Input 함수에 대해 몇가지 주의사항이 있습니다. 
이 주의사항은 이번 주제인 회전과도 연관되는 내용입니다.

이전시간에 Add Movement Input 을 설명하면서 Input Direction 은 이동하고자 하는 방향이라고했었습니다. 속도는 따로 캐릭터 무브먼트에서 관리를하고 방향만 입력해준다고 했었습니다. 
또 스케일은 진행할 방향에 곱해주는 값으로 음수를 주면 이동방향과 반대로 가는 성질이기 때문에 축 매핑의 반환값을 연결해주면 자동으로 양방향 이동을 제어할 수 있다고 했습니다.
왜 반복적으로 말을 하냐면 생각보다 햇갈릴수 있는 내용이기때문입니다. 

우리 코드에서는 MoveForward 의 방향 벡터로 넣은 것이 Get Forward Vector 라고 해서 길이, 크기가 1인 단위 벡터를 넘겨주고 있는데 만약 이걸 방향으로 사용하지 않고 
크기가 100인 벡터를 방향벡터로 삼는다면 어떻게 될지가 궁금합니다. 한번 실행해보면 여전히 같은 속도로 이동한다는걸 알 수 있습니다. 
착시가 아닌지 테스트 해보고 싶다면 Tick 이벤트에서 Get Velocity 라고 하는 함수를 출력해보면 됩니다. Get Velocity 는 무브먼트 컴포넌트가 있다면 그 속도를 반환한다고 되어있고 
반환값이 벡터이기 때문에 이 벡터의 길이 Vector Length를 PrintText 해보면 이제 프레임당 캐릭터의 속도를 출력해볼 수 있습니다. 

그러면 이제 Add Movement Input 에 입력하는 방향 벡터가 1이상으로 커져도 아무런 영향을 주지 않는다는걸 알 수 있습니다. 
이제 반대로 1보다 적은 값을 넣어볼텐데 (0.1, 0, 0) 이라는 벡터를 넣어보면 재미있게도 이동속도가 1/10 이 되는걸 알 수 있습니다. 

결국은 우리가 어느 방향으로 가고싶다고 표현을 하기는 하는데 그 방향 벡터가 0에서 1사이의 값이라면 무브먼트 컴포넌트에서 합산되는 결과물값에 영향을 준다는것입니다. 

이 부분이 따로 문서화가 안되 있어서 실험을 통해서 알아야 하는 부분입니다. 

그래서 이동이 단일 방향일때는 그렇다는걸 알 수 있었는데 Add Movement Input 이 딱 한번만 사용할 수 있는게 아니라 지금 우리 코드에서만 해도 앞뒤와 좌우로 두번에 걸쳐 사용하고 있었습니다. 

대각선으로 가도 속도가 같다는것도 알 수 있습니다. 가끔 대각선으로 가면 속도가 빨라진다고 아는 사람도 있는데 그렇지 않습니다. 
앞으로 가는 벡터와 오른쪽으로 가는벡터가 동시에 입력되면 두 벡터의 합이 이동하고자 하는 방향이 되는데 이 경우 합벡터의 크기가 1이상인경우는 무브먼트 컴포넌트가 정해놓은 속도록 이동하게 되고 
만약 0 에서 1사이의 값이라면 그에 비해 속도가 줄어들게 됩니다. 

다음으로 이번엔 앞으로 가는 코드에서 Scale값에 2를 곱한다음 위, 오른쪽으로 이동하게 되면 어떻게 될까요 앞으로가는벡터의 크기가 2이고 오른쪽으로 가는벡터의 크기가 1이 되는데 두 벡터의 합을 보면 
이전과 달리 대각선 45도가 아닌 좀더 앞방향에 더 기울어지게 이동하게 됩니다. 

여기까지 원래는 지난시간에 다뤘어야하는 내용인데 너무 길어져 이번 시간에 알아보게 된 내용입니다. 


이어서 회전에 대한 내용도 알아보겠습니다. 

일단 회전 실습을 하기 위해 회전에 사용할 입력을 추가하겠습니다. 축맵핑에서 Turn 이라는이름으로 하나 추가하고 Q, E 로 회전하게끔 하겠습니다. 
그 전에 Tick이벤트에서 Get Actor Transform 의 Rotation 을 출력하도록 해서 실습중에 로테이션을 확인 할 수 있게끔 했습니다. 
한번 실행해보면 P=0 , Y=0, R=0 이라고 출력되는데 x,y,z가 아닌 P, Y, R 는 로테이션을 뜻하는 다른 용어가 있기 때문입니다. 
각각 Pitch, Yaw, Roll 이라는 용어인데 구글링해보면 비행기를 예로 들어서 비행기 코를 축으로 회전하는것을 Roll 이라고 하고 비행기 날개를 기준으로 코와 꼬리의 위아래로 들리는것을 Pitch라고 합니다. 
또 날개의 가운데 지점을 기준으로 비행기가 옆으로 도는 것을 Yaw 라고 합니다. 
사람 얼굴로 치면 고개를 위아래로 까딱이는게 Pitch, 좌우로 도리도리 하는게 Yaw, 고개를 갸웃하는게 Roll 이라고 합니다. 
이 용어가 되게 안외워 질텐데 잘 기억이 안날때는 다시 검색해보면 될겁니다. 

Pitch, Roll, Yaw 중에서 3D 게임을 만들때 가장 많이 사용하게될 것은 Yaw라고 합니다. FPS 를 하면서 조준선은 좌우로 훑는 행동이 많을것이기 때문입니다. 

이제 BP_Player 의 이벤트 그래프로 돌아가 Turn 의 축맵핑 이벤트를 배치하고 좌우 턴을 구현해볼겁니다. 
이전시간에 Location을 세팅하는방법이 두가지 가 있었습니다. Set Actor Location으로 직접 이동할 좌표를 계산하는 방법과 Add Movement Input으로 이동할 방향만 주고 무브먼트 컴포넌트에 계산을 넘기는 방법이었습니다. 
마찬가지로 로테이션도 똑같습니다. Set Actor Rotation이라는 함수가 있습니다. 이 함수도 변경할 로테이션을 우리가 직접 계산해 넘겨주는 방법입니다. 
그렇다는것은 결국 회전할 속도를 저장해뒀다가 이 속도에 델타 세컨드를 곱해주고 이 값을 원래 객체의 로테이션 값에 더해주면 될겁니다. 
굳이 한번 해보았습니다. 

먼저 TurnSpeed 라는 플로트 변수를 만들어 어느정도의 속도로 회전하고 싶은지를 세팅해주고 Get World Delta Seconds 를 불러와 곱해줍니다. 여기에 Turn 축맵핑 값도 같이 곱해줘서 좌우로 볼 수 있게 해줍니다. 
이제 이 값을 Get Actor Rotation 에다가 더해줄건데 그냥 로테이터에 더해줄 수 없고 핀 분할을 한 다음 Z축인 Yaw에 더해줍니다. Set Actor Rotation에는 x, y 로테이터 값은 그냥 넣어주고 z축 값만 
계산해준 값을 넣어줍니다. 이정도면 될것 같아 게임을 실행해 Q,E를 눌러보았습니다.

하지만 캐릭터가 의도한대로 회전하질 않습니다. 
이때 일단 신기하게도 계산한 회전값을 Z축 Yaw 가 아니라 Y축 Pitch 에 더해서 넘겨줘 보겠습니다. 이러면 굉장히 이상하게도 Pitch는 Turn 입력을 받습니다. 
이런 부분이 언리얼 엔진에 에서 어려운 점입니다. 이미 구조가 타이트하게 잡혀있고 많은 코드들이 역여있기때문입니다.

다시 Pitch에 더해주던걸 Yaw에 더해주게끔 복원해줍니다. 

Yaw가 제대로 동작하지 않는 이유는 굉장히 단순한데 이게 변하지 않게끔 하는 설정이 하나 있습니다. 
BP_Player의 디테일즈를 살펴보다 보면 Pawn 옵션중에 Use Controller Rotation Yaw 라는 옵션이 켜져있습니다. 이 옵션이 어떤 의미이냐면 게임이 실행되었을때 플레이어 컨트롤러라는게 BP_Player에 
빙의되어서 조종을 하고 있는중인데 이 Use Controller Rotation Yaw라는 옵션을 키면 이 컨트롤러의 Yaw 값을 이 플레이어의 Yaw 값으로 인정하겠다 라는 뜻입니다.
즉 플레이어 컨트롤러의 Yaw 값과 BP_Player의 Yaw 값을 동일화 하겠다는것입니다. 그래서 플레이어의 로테이션을 수정하려고 해도 플레이어 컨트롤러의 로테이션이 바뀌지 않아서 그렇다는겁니다.

한마디로 Use Controller Rotation Yaw 이 옵션을 끄고 게임을 실행하면 정상적으로 좌우 회전이 되는걸 볼 수 있습니다.

그런데 위의 Set Actor Rotation을 사용하는 방법보다 더 간단한 함수가 있습니다. 그 함수는 Add Actor Local Rotation 입니다. 
이 Add Actor Local Rotation 함수에서는 델타 로테이션이라고 해서 이후에 바뀔 로테이션 값을 넣어주면됩니다. 

이렇게 해서 캐릭터 회전을 시켰습니다. 

그런데 우리가 이동과 관련된 학습을 할때 Set Actor Location 함수와 비슷하게 Add Actor Local Offset 이라는 함수가 있었습니다. 
이 함수와 Set Actor Location 대신에 Add Movement Input 을 사용하는 이유는 이동하는 코드와 BP_Player에 관한 데이터를 따로 관리하는게 나중에 게임이 복잡해졌을때 더 좋기 때문입니다. 

이것과 유사하게도 로테이션에서도 지금 로테이션값을 BP_Player에서 계산해 넣어주지 않고 분리해 넣어주는 방법이 하나더 있습니다. 
Add Controller 시리즈 함수들을 검색해보면 Pitch, Roll, Yaw 세가지가 다 있다는걸 볼 수 있는데 이 세가지를 모두 꺼내 보겠습니다. 

이 함수의 설명을 읽어보면 컨트롤러에다가 Input 로테이션을 더한다고 되어있는데 아직을 무슨 말인지 모르겠으니 Turn 축맵핑 반환값들을 연결해주고 게임을 실행해보겠습니다. 
Q,E를 눌러도 아무런 반응이 없습니다. 이번엔 뭐가 문제일까요? 이 Add Controller 시리즈의 설명을 유심히 보면 위의 Location 을 수정할때 같이 BP_Player의 값을 바꿔주는게 아니라는걸 알 수 있습니다. 
게임을 실행하면 BP_Player 라는 Pawn 뿐만 아니라 이 Pawn에 빙의되는 컨트롤러가 자동으로 생성되었습니다. 그런데 플레이어 컨트롤러도 결국 액터이기 때문에 로테이션 값이 있을겁니다. 
게임을 실행하고 F8을 눌른 상태에서 자동 생성된 플레이어 컨트롤러의 디테일즈를 보겠습니다. 다시 게임에 들어가 Q,E를 누르면 이 플레이어컨트롤러의 로테이션 값이 바뀐다는걸 알 수 있습니다. 
그래서 Pawn을 조작하지 않고 엉뚱한 플레이어 컨트롤러를 조작하고 있던겁니다. 

그러면 왜 이런식으로 만들었던걸까요 사실을 우리가 이동과 관련된 부분을 캐릭터 무브먼트 에서 처리했던 것과 유사하게도 사실 게임을 할때 마우스를 움직이면 그에 따라 캐릭터가 바로 이동하는 
FPS 게임같은것도 있겠지만 와우 같은 게임을 보면 카메라 위치와 플레이어가 바라보고 있는 방향이 완전히 다를 수도 있습니다. 
그래서 카메라 방향과 캐릭터의 방향이 일치하지 않을 수 있기때문에 플레이어 컨트롤러와 캐릭터를 분리한다고 할 수 있습니다. 

Add Controller 시리즈 같은 경우는 어떻게 사용해야할지는 게임마다 너무 다르기 때문에 여러가지 방법이 있습니다. 
아까 BP_Player의 Pawn 옵션중에 Use Controller Rotation Yaw를 건드렸었는데 이것은 컨트롤러의 로테이션을 이 폰의 로테이션으로 삼는다고 했었습니다. 
이 옵션을 다시 키고서 Add Controller Yaw Input에 Turn 축맵핑을 연결해주면 Q, E를 누르면 회전을 한다는걸 확인 할 수 있습니다. 

위의 내용을 가시적으로 확인하기 위해서 Tick 이벤트의 PrintText를 포맷텍스트로 플레이어의 로테이션과 플레이어 컨트롤러의 로테이션을 같이 출력해주겠습니다. 
Player : {0} , Controller : {1} 이렇게 포맷 텍스트의 내용을 만들고 0번에는 Get Actor Rotation을 , 1번에는 Get Controller-> Get Actor Rotation 을 연결해주었습니다. 
포맷 텍스트에 로테이터를 바로 연결하지 못해 핀분할해서 Yaw만 출력해줬습니다. 

게임을 실행해보면 플레이어와 컨트롤러의 Yaw 값이 정확히 일치하면서 회전하는걸 볼 수 있습니다. 

다시 Turn 이벤트에 연결된 코드로 돌아가 실습을 해보자면 지금은 사실 축맵핑 값을 막바로 Add Controller Yaw Input에 꽂아 줬었지만 사실은 원래는 이렇게 꽂아주면안됩니다. 
Location을 예로 들면 어디로 이동할지 의도를 넘겨주는 경우와 직접 계산해서 이동할 죄표를 직접 넘겨주는 경우 두가지가 있다고 했었습니다. 
Add Controller Yaw Input 의 입력핀 같은경우는 어디로 이동할지 의도라기보다는 실제로 이동할 값을 연결해줍니다. 그래서 이 함수에 입력에는 
회전할 속도와 월드 델타 세컨드를 곱한 값을 연결해주는것이 정석입니다. 

지금은 컨트롤러와 플레이어의 Yaw를 일치시키는 사양인것이고 두 로테이션을 분리해 관리하는 장점으로는 컨트롤러의 로테이션을 곧바로 따라가는게 아니라 좀 더 천천히 따라가도록 
만들고 싶을 수 있습니다. 

예를 들어서 지금은 Use Controller Rotation Yaw 를 쳐서 무조건 컨트롤러와 플레이어의 Yaw 값이 일치하도록 하였는데 이걸 끈다음에 실행헤보면 초반에 했던것처럼 컨트롤러의 Yaw는 변하지만 
플레이어는 변하지 않습니다. 
이 상태에서 플레이어가 컨트롤러의 로테이션을 좀 더 부드럽게 따라가는 방법이 있습니다. 

캐릭터 무브먼트 컴포넌트의 디테일즈 중에서 이동관련 말고 회전관련 옵션도 있습니다. Rotation을 검색해 보면 Character Movement(Rotation Setting) 이라는 란이 있습니다. 
이 안에 회전 속도라는 옵션은 말 그대로 플레이어가 회전할 속도를 말합니다. 또 Use Controller Desire Rotation 이라는 옵션이 있는데 이 옵션의 의미는 
아까 BP_Player 의 Use Controller Rotation Yaw 처럼 딱 일치하지는 않겠지만 그래도 컨트롤러가 바뀐 값까지 플레이어의 로테이션을 회전하겠다 라는 것입니다. 

이렇게 자신이 만들려고하는 사양에 따라 이런 옵션들 선택하면 되겠습니다. 

이번시간에 결국 회전과 관련된 내용을 알아봤고 프로젝트는 Use Controller Rotation Yaw를 킨 사양으로 복원 시켜주겠습니다. 

우리 프로젝트와 또 대부분의 프로젝트에서는 Yaw를 회전하는 사양이겠지만 시간이 나면 Roll이나 Pitch 도 움직이는 실습을 해보면 좋을겁니다. 

대부분의 강의나 언리얼 책을보면 그냥 Add Movement Input을 사용하시오, Add Controller Yaw Input 을 사용하시오 라고 만 말해주는데 
이게 어떤걸 건드리고 왜 사용하는지를 생각해보는 것이 중요할겁니다. 

이동과 회전에 대한 내용은 여기서 마무리 할건데 다시한번 요약해보겠습니다.
언리얼의 설계에 대해 유심히 봐야할 필요가 있습니다. Set Actor Location 함수가 있는데 굳이 캐릭터 무브먼트를 사용하는 Add Movement Input 함수를 만든이유와
컨트롤러의 로테이션을 사용하는 Add Controller Yaw Input을 사용하고 또 컨트롤러와 플레이어의 로테이션을 일치하던가 아니면 서서히 따라오도록 해주는 설계를 하는이유를 생각해보면 좋습니다. 
나중에 블루프린트 말고 C++로 언리얼을 다루게 되면 이런 함수들을 뜯어볼 수 있는데 
예를들어서 Add Controller Yaw Input 이 컨트롤러의 로테이션을 조절하는데 그것뿐만이 아니라 추가적인 사양이 있을 수 있는데 예를 들어 화면을 돌리면 카메라가 흔들리는 효과가 있어야 한다던지 
그런 사양대로 코드를 조절할 수 있어야 합니다. 

