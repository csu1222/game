


    데이터 바인딩


앵커를 어느정도 잡아 줬다면 만들려는 게임이 모바일 게임이 아닌 이상 어느정도 어색하지 않게 화면을 띄우는건 가능할겁니다. 

참고로 캔버스 패널을 줄일때 디자이너창 오른하단에 있는 DPI Scale 값을 잘 봐야합니다.
만약 지금 DPI 스케일을 1.0 으로 맞췄다면 왼하단에 써있듯이 1920 * 1080 (16:9 비율) 픽셀로 고정이 됩니다. 
그런데 캔버스 패널을 줄여서 DPI 스케일을 줄인다면 그 때의 DPI 스케일과 배치된 UI 들이 정비례하지 않을 수 있습니다. 
DPI 스케일 옆에 톱니바퀴를 눌러보면 DPI 스케일에 대한 세팅을 볼 수 있습니다. 
그 중에 DPI 커브라는 것이있는데 이 커브값에 따라 UI의 위치와 크기를 결정하기 때문에 
처음 UI 작업을 할때는 DPI 스케일을 1.0 으로 맞춰두고 작업을 하는것을 권장합니다. 

이어서 말 해볼 내용은 계층구조에 대한 것입니다. 
우리가 인게임에 배치하는 오브젝트들도 컴포넌트끼리의 계층구조, 메쉬나 뼈 끼리의 계층구조가 서로 영향을 주던 것 처럼 
UI끼리도 계층구조가 서로 영향을 줍니다. 예를 들어서 버튼 안에 텍스트로 이 버튼이 어떤 버튼인지를 설명하려먼 버튼 UI 계층 아래로 
Text 를 넣어서 설명해주면 됩니다. 

일단 간단한 UI 테스트를 위해서 앵커는 상단 중앙에 두고 그 앵커 아래쪽으로 적당히 버튼크기를 조절해주겠습니다. 
그리고 이 버튼은 클릭했을때 무언가 일어났으면 좋겠습니다.

UI 바인딩을 할때 먼저 해당 UI 에 목적에 합당한 이름을 지어주는게 좋습니다. 계층 창에서 F2 로 이름을 바꿔도 되고 아니면 버튼의 디테일즈에서 이름을 바꿔줘도 됩니다. 
버튼 이름을 TestButton으로 수정하겠습니다. 

일단 이 것들을 인게임 내에 띄우도록 하겠습니다. 어디서 이 위젯 블루프린트를 들고 있을지 생각을 해보니 다른 클래스도 공통적으로 용이하게 접근할 수 있는 BP_GameMode 에서
들고 있게 해주겠습니다. 

BP_GameMode 의 이벤트 그래프로 왔습니다. 여기서 코드가 시작될 때 인 Event BeginPlay 에서 Create Widget 함수를 호출해주겠습니다. 그리고 이 함수에 WBP_UI 를 만들어 준다고 골라줍니다.
이어서 Add to Viewport 함수 도 호출해 줘야 게임에서 보이게 될겁니다. 
Create Widget 으로 생성한 오브젝트는 따로 사용할 예정이니 변수화를 시켜 들고 있겠습니다.

이상태에서 게임을 실행해보면 게임에 아까 만들었던 버튼이 있습니다. 그렇지만 이 버튼을 누르려니 커서도 안보이고 또 만약 보여서 누른다고해서 딱히 어떤 동작을 하고 있지 않습니다. 

이 부분이 유니티와 언리얼의 차이점이라고 합니다. 
어떤 게임을 실행해서 UI 입력을 받는다거나 키보드 입력을 받는거 같은 입력을 받는다 라는 것 자체가 Player Controller 와 밀접한 관련이 있습니다. 
지금프로젝트에서는 BP_GameMode 에 UI 를 생성하고 뷰포트에 추가만 했지 따로 PlayerController 에는 다른 작업을 하지 않았었습니다. 

그래서 게임모드에서 Input Mode 라고 검색해보면 세가지 버전의 함수들이 있습니다. 
Set Input Mode UI Only, Set Input Mode Game Only, Set Input Mode Game And UI 이렇게 세가지 입니다. 

만약 게임중에 esc 를 눌러 게임 화면은 멈추고 설정이나 저장 같은 UI만 사용자 입력에 반응 하도록 하고 싶다면 Set Input Mode UI Only 를 사용하면 될겁니다. 
실습해보자면 이것을 우리 게임에서 사용하면 입력으로 Player Controller 와 Focus 할 Widget 을 받아주고 있습니다. 위젯은 아까 변수화 해서 들고 있던 걸 넘겨주면 될것이고 
플레이어 컨트롤러는 Get Player Controller 함수로 가져와 넘겨주면 됩니다. 1인 만 조작하는 게임에서는 Player Index 0 번이 플레이어 컨트롤러였습니다.
이외에도 In Mouse Lock Mode , Flush Input 이라는 입력값들이 있는데 일단 건드리지 않고 게임을 실행해보겠습니다. 

이번 게임 실행했을때는 이제 마우스를 움직여도 플레이어 컨트롤러의 로테이션과 카메라가 움직이지 않고 버튼 있는쪽을 예상해 커서를 가져다 대면 이제 버튼에만 반응이 있습니다.

테스트할때 방금 넘겨주었던 Widget 을 안 넘겨줘도 똑같이 동작을 한다고 합니다. 
왜 그게 되는지 알아보겠습니다. In Widget to Focus 라는게 어떤 의미이냐면 UI 중에서 언젠가 롤이나 MMORPG 같은 게임을 만든다고 하면 하단에 단축키 1234, 혹은 QWER 단축키가 
있을겁니다. UI 중에서도 키보드 입력을 받아서 처리되야하는 UI 가 있는데 그런 상태의 UI를 Focus 상태라고 합니다. 

그러니까 UI 중에서도 따로 키보드 입력같은걸 받아서 동작하는 UI 에서나 필요한게 In Widget to Focus 라는 입력인겁니다.

다음으로 게임모드와 UI 동시에 집중하겠다는 Set Input Mode Game And UI 함수로 실행핀과 플레이어 컨트롤을 연결해 보면 이제 버튼도 누를 수 있고 우클릭 드래그로 
카메라도 조작할 수 있는걸 알 수 있습니다. 하지만 아직 아까 처럼 게임만 조작하는 방식은 아닙니다. 

세번재로 Set Input Mode Game Only 함수를 사용해보겠습니다. 
이러면 UI 는 먹통이 되고 Player 만 입력을 받는걸 확인 할 수 있습니다.
하지만 RPG 게임의 경우에서는 그 중에서도 액션 RPG 는 플레이어 입력에만 집중하고 UI 에 올려놓은 스킬이나 동작들은 키보드 입력같은걸로 받는 방식이 많을겁니다. 

마우스 커서를 보이게 하는 함수도 있습니다. Get Player Controller 핀을 당겨서 Set Show Mouse Cursor 함수를 거치면 마우스 커서를 보여줄건지 아닌지를 정해 줄 수 있습니다. 
이런것들은 내가 만들 게임의 사양에 따라 옵션을 골라주면 됩니다. 

위의 내용들은 한번 언리얼 공식문서를 쭉 읽어보는것을 권장합니다. 

일단 앞으로 진행할 내용에서는 Set Input Mode UI Only 를 사용하는 사양으로 작업해보겠습니다. 일단 UI에 집중하기위해서입니다.


이제 버튼을 눌렀을때 어떤 동작을 일으키고 싶은데 어떻게 해야할까요 이 UI 에 데이터를 바운드 해주는 과정이 블루프린트로 작업할 때와 C++ 로 작업하는 과정이 조금 바뀐다고 합니다.

WBP_UI 로 돌아가서 Test Button 을 눌렀을 때 무엇인가가 일어나야 한다고 하겠습니다. 
버튼을 눌렀을때와 관련된 것이니까 Test Button 의 디테일즈를 내리다 보면 관련된 이벤트가 있지 않을까 싶습니다. 
버튼 디테일즈에서 Is Variable 이라는 변수화 체크박스에 체크를 하고 밑으로 내려보면 이벤트 란이 있습니다. 이 중에서 클릭 시 (On Click) 이벤트가 있는데 이것을 추가해보면 
자동으로 이벤트 그래프쪽으로 넘어가 On Click(TestButton) 이벤트가 배치됩니다. 

여기서 코드를 추가할 수 있습니다. 일단 이벤트가 잘 작동하는지 TestButton 이라는 로그를 찍어보겠습니다. 게임을 실행해보면 잘 작동합니다.

이제 이 버튼이 단순히 로그만 찍는게 목적은 아닐겁니다. 인 게임내에 어떤 동작을 해줬으면 할것인데 그러면 이 위젯 블루프린트에서 플레이어 오브젝트의 레퍼런스를 가져와 이리저리 필요한 정보
를 꺼내 사용해야합니다. 이것은 게임엔진들에서 서로 다른 여러가지 클래스들을 분산 관리하다가 어떤 동작을 할 때 이 동작에 연관된 다른 클래스들에 연관되는 것은 어쩔 수 없습니다. 
다만 항상 모든 정보들을 가져오지 않고 동작에 꼭 필요한 정보들만 가져와서 사용하는것이 더 좋을겁니다.

두번째로 간단하게 버튼을 눌렀을때 실행되는것 뿐만아니라 특정 수치에 따라 UI가 변하는 것도 자주 사용할겁니다. EXP 바, HP MP 바 같은게 그런 예시가 될 수 있습니다.
캔버스에 임의로 UI 를 더 추가 하겠습니다. 왼 상단에 Text Block 을 배치합니다. 참고로 이 텍스트 UI 는 다른 워드 프로세서 같은데서 지원하는 기능들이 다 있습니다.
좌우 정렬이나 폰트 크기 폰트 종류 색상 등등 기능이 다 디테일즈에 준비되어 있습니다.

새로 추가한 텍스트를 계층화 창에서 이름을 바꿔 줄건데 ShootCountText 라고 이름 지어주겠습니다. 이 위치에서 우리가 게임에서 총을 쏜 횟수를 카운팅해주는 실습을 해줄것입니다. 
지금은 이 텍스트에 대한 내용이 컨텐츠라는 옵션에 적혀 있습니다. 처음에는 Text Block 이라고 되어있는데 ShootCount : 1 이라고 바꾸면 그대로 화면에 적용됩니다. 
하지만 지금같이 하드 코딩하는것은 의미가 없고 변수와 연결시켜줘야 할겁니다. 

이 변수와 연결시키는것을 바인딩이라고 하는데 바인디에는 두가지 방법이 있습니다. 

첫번째는 외부에서 이 WBP_UI 를 찾아서 ShootCountText 라는 것을 직접 고치는 방법입니다. 
ShootCountText 를 그냥 추가했을때는 WBP_UI 의 그래프쪽에 변수로 나오지 않고 변수화를 해줘야합니다. 이 변수화 된 ShootCountText 를 가지고 데이터를 수정해줘도 되고 
아니면 BP_GameMode 같은 밖에서 TextUI 변수에서 다시 Get ShootCountText 를 가져오고 또 다시 Set Text(Text) 같은 함수를 꺼내서 컨텐츠 텍스트를 수정해 줄 수 있을겁니다.

결국 BP_GameMode 가 우리 게임에서 중앙 관리자 같은 기능을 겸 하고 있기 때문에 우리가 버튼을 클릭 할 때마다 카운트가 하나씩 올라가야 한다면 
BP_Player 나 BP_PlayerController 같은데서 변수하나를 관리해주면 될것입니다. 예를 들어세 BP_PlayerController 에서 Input Action Fire 이벤트에서 Fire Weapon 을 호출한 다음 
위치에서 코드를 추가해 주면 될것 같은데 
ShootCount 라는 인티저 변수를 만들고 코드에 이어서 ++ 하도록 해줍니다. 여기서 이 변수 정보를 증가 시킬때 마다 UI 에서 갱신해 출력해야 할 텐데 
두가지 방법이 있을 수 있습니다. 

만약 BP_PlayerController 에서 BP_GameMode 를 가져와 텍스트를 수정하는 정책이라고 하면 이렇게 진행 될겁니다. 
ShootCount 를 증가 시킨 이후에 Get GameMode 로 게임의 디폴트 게임모드를 가져오고 다시 BP_GameMode 로 캐스팅을하면 BP_GameMode 를 사용할 준비가 되고 이어서 아까처럼 
Get TestUI -> Get ShootCountText -> Set Text(Text) 이렇게 함수들을 호출합니다. Set Text(Text) 에 입력할 텍스트는 Format Text 함수로 ShootCount 변수를 적용한 텍스트를 만들어 넘겨주면 될겁니다.
지금은 Set Input Mode UI Only 를 사용하고 있는 상태여서 총을 쏠 수 가 없으니 잠시 끊어주고 테스트 해보겠습니다. 

게임을 실행해보면 총을 쏠 때 마다 카운트가 하나씩 증가하는 걸 확인 할 수 있습니다.
이렇게 발사 횟수를 카운팅하는 기능은 남은 탄환을 구현할때 사용할 수 있는 기능일겁니다.

이렇게 발사 카운팅을 하는 실습을 해봤는데 사실 지금처럼 BP_PlayerController 에서 이것을 관리해주는게 맞는 방식인지는 좀 더 생각해볼 문제입니다. 
조작을 담당하는 컨트롤러 클래스에서 UI와 관련된 코드도 포함시키면 나중가서는 결국 관련된 코드끼리 모여있지 않아서 개발하는데 혼동이 생길 것입니다. 

그래서 두번째 방식인 ShootCount 라는 정보를 BP_PlayerController 에서 관리하고 증가시켜주되 데이터를 WBP_UI 로 넘겨서 UI 관련된 코드를 여기서 처리해주는 방법입니다. 

방금 했던 코드들을 ShootCount 를 증가시키는것 까지만 남기고 날리겠습니다
다시 두번째 방식으로 작업을 해볼겁니다. WBP_UI 로 가서 ShootCountText 의 디테일즈->콘텐츠 에 가보면 아까 직접 텍스트를 입력해주는 칸 옆에 바인드 라고 써있는 창이 있습니다. 
이것을 클릭해보면 바인드 생성을 할 수 있는데 생성을 해줍니다. 그러면 또 그래프쪽으로 자동으로 넘어오고 Get_ShootCountText_Text 라는 함수가 만들어집니다. 
이 함수의 이름은 언제든 수정해줄 수 있고 이 함수내에서 BP_PlayerController 의 슛 카운트 변수를 가져와 직접 콘텐츠 텍스트를 수정해주면 되는것입니다. 
참고로 이 UI 에 바인딩 함수를 만들면 매 프레임마다 호출이 될것이기 때문에 왠만하면 부담스러운 코드를 사용하면 안됩니다.

먼저 플레이어 컨트롤러를 가져와 보겠습니다. Get Player Controller 함수를 호출하고 0번 인덱스가 우리가 사용하는 컨트롤러 였습니다. 가져온 컨트롤러를 한번 BP_PlayerController 로 캐스팅 해줍니다.
다음으로 Get ShootCount 로 변수를 가져오고 포멧 텍스트로 텍스트를 만들어주던가 아니면 그냥 곧바로 리턴 노드에 연결해주겠습니다.

실행해보면 의도한대로 카운팅이 잘 되고 있겠습니다

결국 UI 에 데이터를 연동하는 방법은 여러가지가 있는데 데이터가 갱신될때 자동으로 UI를 찾아 UI 도 갱신해주는 방법이 있는가 하면 
거꾸로 위젯 블루프린트 쪽에서 바인딩 함수에서 데이터를 긁어와 갱신하는 방법도 있습니다. 둘의 차이는 관련된 코드를 한번에 관리하는대신 매 프레임 호출하는 함수를 사용하는것과 
코드의 통일성은 없지만 그래도 갱신 될때만 함수를 호출하는 방식의 차이일겁니다.

여기 까지 블루프린트에서 UI 데이터 바인딩을 하는 방법이었습니다. 
꼭 텍스트 뿐만 아니라 다른 UI 체크박스나 이미지파일등 이리저리 다뤄보다 보면 다 알 수 있습니다. 