

    에임 오프셋


이번시간에 알아볼 기능은 에임 오프셋입니다. 이 기능을 가지고 우리 게임에서 하고 싶은 일은 지금까지 캐릭터를 두고 카메라를 움직여도 
캐릭터는 원래 바라보던 방향만 보게끔 했지만 슈팅게임에서는 카메라 방향이 곧 크로스헤어, 조준점이고 캐릭터는 항상 이 조준점을 겨누고 있어야 자연스럽지만 
지금은 그냥 캐릭터의 정면만 조준하고 있습니다.

언리얼에서 이런 기능을 만들고 싶을 때 사용하는 것이 에임 오프셋입니다.
이름 조차도 조준과 관련되어 보입니다. 

사용하는 방법은 그다지 어렵지 않고 이전에 알아 봤던 블렌드 스페이스와 비슷합니다.

에임 오프셋이라는 에셋을 만들기 위해서 Animations 폴더에 우클릭으로 찾아보면 애니메이션 란에서 에임오프셋과 에임오프셋1D 라는 것이 있습니다. 블렌드 스페이스와 마찬가지로 
1D 가 붙은 건 메쉬 회전에 관여하는 요소가 1개뿐일때 사용하는 것입니다. 우리는 그냥 에임오프셋을 만들어주겠습니다. 
그러면 사용할 스켈레톤을 골라주는데 당연히 Belica_Skeleton 을 고릅니다. 이름은 AO_Hip 이라고 지어주겠습니다. 
보통 리소스를 보면 총을 쏘는것은 Fire 라고 하고 그냥 총을 들고 가만히 있는것은 Hip 이라고 많이 부릅니다. 

AO_Hip 을 열어보면 블렌드 스페이스와 유사하게 되어 있는걸 알 수 있습니다. 먼저 어떤 값에 영향을 받을지는 왼쪽 에셋 디테일에서 Axix Setting 이라는 곳에서 정해줍니다. 
먼저 가로 축 Horizontal Axis 는 이름을 Yaw 라고 지어줍니다. 최소, 최대범위는 -180 에서 180 으로 정하고 또 Snap to Grid 라는 옵션을 켜주겠습니다. 
이 Snap to Grid, 그리드에 스냅 옵션은 나중에 이 에임 오프셋을 사용했을때 마우스 커서 가 가로 세로 격자에 알아서 적절히 조절되어 따로 범위 조절을 안해줘도 됩니다. 
Vertical Axis 세로축은 이름을 Pitch 라고 하고 범위는 -90에서 90 까지만 합니다. 역시 그리드에 스냅 옵션을 켜주겠습니다.

그러면 이 상태에서 에셋 브라우저에서 AO_ 라고 검색하면 벨리카 리소스들 중에서 이미 제공하는 애니메이션 리소스들이 AO 시리즈가 있는걸 볼 수 있습니다. 
먼저 AO_CC 라는 에셋은 Center Center 정 중앙이라는 뜻입니다. 프리뷰 창 밑에 있는 격자 창 정중앙에 AO_CC 를 배치합니다. 
또 AO_CD 는 Center Down 이니까 중앙 밑에 CU는 Center Up 이니까 중앙 위쪽에 배치하겠습니다. 이 AO_ 시리즈 에셋들의 이름이 이런식으로 지어져있습니다.

LBC, LBD, LBU 는 Left Back ~~ 라는 뜻입니다. 왼쪽끝 Yaw 가 -180 일때 위 중간 아래에 각각 배치합니다.
LC 같이 중간에 Back 이 안붙은 에셋들은 Yaw 가 -90 일때입니다. 

이런식으로 오른쪽도 다 배치를 해준 다음 격자창을 클릭하고 Ctrl 을 누른상태에서 마우스를 움직여 보면 프리뷰에서 상체가 마우스 움직임대로 이동하는걸 볼 수 있습니다.

이제 AO_Hip을 만들었으니 이것을 적용시켜줘야겠습니다.
ABP_Player 를 열어줍니다. 이 에임 오프셋은 상체와 관련된 애니메이션입니다. AnimGraph의 Locomotion 에서 하체를 담당하고 있고 
상체는 AM_Fire 라는 애니메이션 몽타주의 Fire 슬롯을 Cache 로 만들어 사용하고 있었습니다. Cached Fire 에서 Layerd blend per bone 에 연결해주고 있는 사이에 
AO_Hip을 끼워 넣어주겠습니다. 

AO_Hip 으로 검색해보면 Aim Offset 'AO_Hip' 이라는 노드를 배치할 수 있습니다. 이 노드는 Yaw, Pitch, Base Pose, Alpha 를 입력 받는데 Base Pose 에다가 
Cached Fire 를 연결해줍니다. 그리고 Yaw 와 Pitch 값을 넣어주면 됩니다. Yaw 값같은 경우에는 이미 있는 RootYawOffset 에 -1 을 곱해 부호만 뒤집으면 됩니다. 
왜 그러냐면 RootYawOffset 라는 값은 캐릭터 메시의 Yaw를 카메라가 움직인 만큼 반대로 움직여 원래 위치를 유지하기 위한 값이었는데 여기서 다시 부호를 뒤집으면 
원래 카메라의 Yaw 값이 나오게 되는겁니다. 
지금 하려는것도 캐릭터 상체만 카메라의 방향을 따라 움직이려고 하는것입니다. 

아직 Pitch 는 구하지 않았으니 변수로 관리를 해줘야 겠습니다. ABP_Player 에서 새로 Pitch 변수를 Float 타입으로 추가하겠습니다.
이 Pitch 값을 어디서 구해줄것이냐면 회전을 업데이트하는 UpdateTurn 함수에서 관리해주겠습니다. UpdateTurn 을 시작하면서 이미 들고있던 Player 변수에서 Get Base Aim Rotation 
이라는 함수를 호출합니다. Aim Rotation 이 컨트롤러의 방향을 뜻합니다. 플레이어의 컨트롤러 방향은 곧 카메라의 방향과 같습니다. 그렇게 만들어 뒀기 때문입니다.
반환 로테이터 값을 핀 분할을 하고 Pitch 값만 ABP_Player 의 Pitch 에 넣어줍니다. 

값이 셋팅된 Pitch 변수의 값을 AO_Hip 의 입력에 연결해줍니다.

게임을 실행해 확인해보면 아직 제대로 적용되는지 잘 안보이는데 화면이 너무 캐릭터 바로뒤에 위치해있어서 그렇습니다. 나중에 크로스 헤어를 적용시키면 어짜피 카메라의 위치를 조절해야
합니다. 안그러면 크로스헤어에 계속 캐릭터 등이 위치하게 됩니다. 

그런 의미에서 BP_Player 로 돌아가서 스프링 암의 위치를 조금 바꿔주겠습니다. 지금은 그냥 캐릭터 메쉬 정 뒤쪽으로 거리만 조금 조절하고 말았는데 이제는 
캐릭터의 살짝 오른쪽에 위치하도록 해주고 싶습니다.

하는김에 카메라가 너무 먼거 같아서 타겟 암 길이를 700 에서 500으로 줄여줍니다. 그리고 나서 스프링암의 위치를 변경하고 싶은데 그를 위해서 스프링암의 Rotation 을 조절하려고 해봤자 
어짜피 옵션중에 컨트롤러의 로테이션을 스프링암의 로테이션으로 사용한다는 옵션을 사용하고 있어서 회전이 안됩니다. 그렇다고 이 옵션을 끄면 지금까지 작업한 것들이 꼬이니까 올바른 방법이 
아닐겁니다. 그래서 다른 방법을 찾아보겠습니다. 

스프링 암의 디테일즈를 보다 보면 소켓 오프셋 이라는 옵션이 있고 이것은 Float 를 3개 받고 있습니다. 일단 이 값을 0, 100.0, 100.0 으로 세팅해 보겠습니다. 
이러면 카메라가 입력한 좌표만큼 이동하는데 이것은 스프링암의 회전을 건드리지 않고 오프셋 값 만큼 카메라를 떨어트려 놓을 수 있습니다.

이대로 게임을 실행해보면 이전보다 훨씬 더 슈팅 게임같은 화면인 것을 볼 수 있습니다. 

여기까지 스프링암과 카메라를 소켓 오프셋을 활용해 수정하는것을 성공했습니다.


그런데 여기까지만 만들면 문제가 생깁니다. 어디가 문제냐면 지금 애니메이션 중에서 상체 애니메이션을 AM_Fire의 Fire 소켓을 사용하고 있었는데 이것을 Cached Fire 를 하고 
이 Cached Fire를 AO_Hip 을 적용 시키다 보니까 왼클릭을 할때 재생되어야 하던 총을 쏘는 애니메이션이 동작을 안합니다. 
이 문제는 다음에 고쳐볼것이고 일단은 이번 시간에는 에임 오프셋에 대해 좀 더 집중해보겠습니다.


에임 오프셋에 대해 다른 이야기를 해보겠습니다 
일단은 에임 오프셋을 사용하는 방법은 이제 실습을 했습니다. 

그런데 따지고 보면 블렌드 스페이스도 굉장히 비슷한 기능이었습니다. 물론 지난시간에 사용한 블렌드 스페이스는 1D 버전으로 사용해서 그렇지 일반 축을 두개 사용하는 버전을 사용하면 
정말 비슷해질겁니다.

그러다 보니 에임오프셋과 블렌드 스페이스가 무슨 차이가 있는지가 궁금해집니다.

이런 궁금증은 언리얼 공식 문서를 찾아보는게 가장 좋은 방법입니다. 에임 오프셋 문서를 찾아보면 에임 오프셋은 블렌드 스페이스 종류중 하나이긴 합니다. 
그런데 애니메이션 샘플들이 Additive 하다 덧붙여 질 수 있다 라고 합니다. 이 부분이 중요합니다. 
다른 블렌드 스페이스와 에임 오프셋의 차이를 설명하는 글들에서도 비슷하게 설명합니다. 

그러면 Additive Animation 이 무엇인지를 살펴봐야 합니다.
이걸 실습하기위해서 폴더를 하나 파주겠습니다. 이름은 그냥 Test 라고 지었습니다. 
실습할 애니메이션을 가져올겁니다. 받아온 리소스 폴더에서 Belica 쪽 Animation 폴더에서 그냥 Idle 류 애니메이션 하나를 골라줬습니다. HeroSelct_Belica 라는 파일을 가져왔습니다. 
아마 캐릭터 선택창에서의 애니메이션 같습니다. 이 애니메이션은 에임오프셋 실습에 사용할것이니 파일 이름을 AO_Test_Base 라고 지어주겠습니다.
그리고 나서 이 파일을 두번 복사를해서 AO_Test_Blend, AO_Test_Additive 라고 각각 이름 지어주겠습니다. 

AO_Test_Base 는 그냥 가만히 있는 애니메이션이고 이걸 토대로 AO_Test_Blend 는 우리만의 애니메이션으로 만들어 줄겁니다. 
뭘 할까 생각하다가 AO_Test_Blend의 스켈레톤 트리에서 그냥 spine_01 이라고 상체와 하체를 나누는 척추 뼈를 앞으로 숙여 봤습니다. z축 로테이션을 70도 정도로 줬습니다.
이렇게 값을 수정하고 저장한뒤 창을 닫습니다. 그리고 나서 다시 AO_Test_Blend 를 열어보면 방금했던 작업이 날라갔다는걸 볼 수 있습니다.

이전에 애니메이션의 커브를 수정할때 Key를 배치하고 그 Key를 가지고 어떤 값을 조절했던적이 있습니다. 
그런것처럼 우리가 spine_01 에 대해 어떤 작업을 할것이다 라고 하면 그것을 저장하기 위해서는 spine_01 이 선택된 상태에서 AO_Test_Blend 창의 상단에 있는 +Key 버튼을 눌러줍니다. 
그 순간 밑에 Additive Layer Tracks 라는 곳에 spine_01 이라고 뭔가가 추가되는데 이 상황에서 이제 spine_01 을 조작한걸 추가해줄 수 있습니다.
예를 들어서 처음에는 허리를 세운 상태에서 90프레임 쯤에서 허리를 굽히게 하려면 90 프레임 쯤에서 spine_01의 z축 로테이션값을 수정하고 다시 +Key 버튼을 눌러주어야 적용이 됩니다. 
추가적으로 180 프레임 쯤에 한번 더 숙여주는 모션을 넣어 봤습니다.

이런식으로 간단한 애니메이션은 애니메이터가 작업하지 않아도 키 하나 추가해 수정해도 되는 작업입니다.
그런데 여기서 우리가 만든 새 애니메이션을 블렌딩 해서 사용해보겠습니다.

ABP_Player 로가서 AnimGraph의 Output Pose 를 잠시 테스트용으로 사용해보겠습니다. 
AO_Test_Base 와 AO_Test_Blend 두가지 애니메이션을 가져오고 이 둘을 섞어 보겠습니다. 이전에 Layered blend per Bone 처럼 특정 뼈를 기준으로 나눠서 블렌드 해주는 함수도 있고 
다른 Blend 함수를 찾아보면 기본적인 Blend 함수도 있고 Blend Poses by Bool 이라고 해서 불리언 값에 따라서 뭔가 해주는 함수도 있습니다. 이 중에서 기본 Blend 함수로 테스트해보겠습니다.

기본 Blend 는 단순한데 A 애니메이션과 B 애니메이션을 넣고 Alpha 값에 따라 어느 애니메이션에 더 비중을 줄지를 정합니다.
만약 A에 AO_Test_Base, B에 AO_Test_Blend 를 넣고 알파값을 0을 주게되면 그냥 가만히 있는 애니메이션이 재생될것입니다. 반대로 알파값을 주면 AO_Test_Blend 의 인사하는 애니메이션이 재생됩니다. 
이 알파를 가지고 두 애니메이션을 적절히 섞어서 재생할 수 있는걸 알 수 있습니다.
원리는 애니메이션을 재생할때 A, B 두 애니메이션의 뼈 위치를 두 좌표의 중간정도로 사용하게 되면 그것이 애니메이션이 섞이는 결과가 될겁니다.

이것이 일반적인 애니메이션 블렌드 실습입니다. 여기서 이제 아까 알아봤던 에임 오프셋의 중요한 컨셉인 Additive 에 대해 알아보겠습니다.
AnimGraph 에서 Additive 함수를 검색해보면 Apply Mesh Space Additive 라는 함수가 있습니다. 이것을 아까 Blend 함수처럼 똑같이 이용해보겠습니다.

컴파일을 해보면 프리뷰 화면이 이상하게 캐릭터가 확대가 되어있습니다. 알파값을 수정한다고 해서 딱히 해결이 되지 않습니다.
왜 이런 일이 생기냐면 Blend 는 두 애니메이션의 결과물을 Alpha 에 비례한 중간값으로 사용한다면 Additive는 Base를 기반으로 Additive 한 정보가 덧붙혀서 추가가되는 결과물이 됩니다.
비유를 하자면 Blend에서 A의 어떤 정점이 10이라는값을 가지고 B의 어느 정점이 20이라는 값을 가지고 있다고 하고 알파값을 0.5 로주면 15라는 결과값이 나오는 식입니다. 
그런데 Apply Mesh Space Additive 는 결과가 30이 되버리는 느낌입니다. 

그러면 이것을 제대로 사용하려면 어떻게 해야하는가 하면 아까 미리 만들어 놓은 AO_Test_Additive 파일로 가보겠습니다. 여기서 에셋 디테일을 내리다보면 Additive Settings 라는 옵션에서 
Additive Anim Type 을 고를수 있게 되어있는데 기본적으로는 No Additive 가 골라져있습니다. 이게 무슨 옵션인지 궁금하다면 커서를 가져다 대고 Ctrl + Alt 를 누르면 설명이 뜹니다.

하고 싶은 이야기는 Additive Anim Type 을 Mesh Space로 골라줍니다. 여기서 메쉬 스페이스는 그래픽쪽 내용입니다. 자세한건 생략하고 대략적으로는 메쉬 기반의 좌표계를 사용한다는 의미입니다. 
기본적인 애니메이션이 아니라 Additive 애니메이션을 만들고 있는 중이라고 생각하겠습니다. 

다음은 기준으로 할 애니메이션을 골라주는 Base Pose Animation 을 AO_Test_Base 를 기준으로 한다고 해보겠습니다. 
기준 애니메이션을 골랐으면 여기서 변경할 점을 추가할텐데 방금 설정한 애디티브 애님 타입과 베이스 포즈 애니메이션 때문에 이제 이 애니메이션은 독립적인 애니메이션이라기 보다는 
베이스가 되는 애니메이션 기준으로 얼마나 바뀌었는지를 기록하는 개념의 특수 애니메이션이 됩니다. 

여기서 아까 했던 대로 스켈레톤 트리로 가서 spine_01을 수정해 인사하는 애니메이션을 만들어 보겠습니다.
먼저 spine_01 을 선택한 후 +Key 를 눌러서 spine_01 키를 추가하고 0 프레임에 한 50도 인사를 추가, 90 프레임쯤에서 90도 인사, 130프레임 쯤에서는 아예 120도 인사까지 추가해보았습니다.

다시 ABP_Player의 AnimGraph 로 돌아가 보겠습니다. AO_Test_Additive 를 배치해보면 다른 애니메이션과 노드 색깔부터가 다릅니다.
이 노드를 Apply Mesh Space Additive 에 연결하고 컴파일을 하면 프리뷰 화면이 정상적으로 돌아옵니다. 
알파값을 이리저리 수정해 테스트를해보면 정상적으로 적용되는걸 볼 수 있습니다.

테스트 해보다 보면 Additive나 Blend 나 개념적으로 유사하긴 합니다. 다만 평균값을 사용하는 Blend 인지 아니면 그냥 추가적인 변경될 값을 추가해주는 건지가 가장 큰 차이입니다.

이제 원래 프로젝트의 Animations 폴더로 가서 살펴보면 지금까지 Blend Space 를 사용할때는 사용하는 애니메이션이 일반 애니메이션이었습니다. 
일반 애니메이션을 MovementOffsetYaw 같은 인자에 따라 섞어주는 역할을 하던것입니다. 결국 Blend Space도 일반 Blend 함수와 비슷한 일을 하고 있던겁니다.

반면 AO_Hip 을 보면 디테일즈중에 에디티브 세팅에 프리뷰 베이스 포즈라는 옵션이 있습니다. 기준이 되는 애니메이션이 있고 그것에 따라 추가적으로 더해질 수치들인 AO_ 시리즈 애디티브 애니메이션을 
배치해주고 있었습니다.

이 AO 시리즈 애니메이션이 제공되지 않아서 직접 만든다고 해도 아까 실습했던것처럼 애니메이션을 복사하고 Additive Anim Type을 Mesh Space로 고르고 또 Base Pose Animation 도 골라준 다음 
1프레임으로 결과가 될 포즈를 만들어 주면 그것이 AO 애니메이션입니다.

결국 Additive 애니메이션은 길이가 길 필요도 없는것입니다. 