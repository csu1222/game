


        네비게이션 메쉬 

    

이전 시간까지 몬스터와 인공지능을 만들어 적용해봤습니다. 사실 충돌과 애니메이션, 인공지능이 들어가면 어지간한 게임을 만들 준비가 다 되었다고 할 수 있습니다.
물론 UI 나 사운드, 이펙트를 추가해야 더 완성도 있는 게임이 될테지만 그 외에 기본적인 게임 로직은 이게 전부라고 볼 수 있는 겁니다. 

여기서 추가로 이전 파트 2D 실습때 사용했던걸 거의 공통적으로 사용할 수 있습니다. 피격판정 같은 것 이전 시간에 만들었던 코드식으로 만들 수 있고 
또 스포닝 풀도 따로 매니저 클래스로 만들어 줄 수도 있고 다른 클래스에서 공통으로 사용할 만한 정보들은 게임모드 클래스를 만들어 거기서 관리를 할 수도 있습니다.

그러면 이번 시간에는 무엇에 대해 알아볼것이냐면 
지간 Behavior Tree 시간에 이동가능한 지점을 구하기 위해서 맵에 배치했던 NavMeshBoundsVolum 이라는 것에 대한 내용입니다. 
더 언급해보자면 현재 배치한 NavMeshBoundsVolum 를 보면 몬스터 주위로는 영역이 제외되서 갈수 없는 영역 처럼 표시되는데 
이것을 좀 더 테스트 하기 위해서 맵에 10*10*10의 큐브도 배치해보고 Plane 이라고 평명 모양 메쉬도 10*10*10 으로 배치하고 평면은 한번 기울여서 경사로 만들어봤습니다. 
그러면 NavMeshBoundsVolum 의 갈 수 있다는 의미의 초록색 영역이 큐브의 상단에도 표시되고 경사면의 면에도 갈 수 있다고 표시됩니다.

이게 어떤 의미인지 알아보자면 
어디는 갈 수 있고 어디는 갈 수 없는지를 Collision 을 가지고 판별합니다. 결국 네비게이션 메쉬가 플레이어가 움직일때 갈 수 있는지 여부에 밀접한 연관을 가집니다. 

방금 배치한 큐브를 선택하고 이 큐브의 디테일드의 콜리전 쪽을 보겠습니다. 콜리전 프리셋이 Default 인데 이걸 Custom 으로 바꿔서 테스트에 써먹어보겠습니다.

그러면 이제 충돌 규칙을 정해줄 수 있는데 이 중에서 Pawn 과 Vehicle 두가지가 Block 으로 되어있으면 네비게이션 메쉬가 갈 수 없는 곳으로 판별합니다.
거꾸로 Pawn 이나 Vehicle 둘 중 하나를 Overlap이나 Ignore 로 설정해주면 이제 네비게이션 메쉬에서는 이 큐브를 이동 할 수 있는 영역이라고 판별하게 됩니다.

게임내에서 어떤 메쉬가 있는데 그곳을 통과할 수 있는 신기루 같이 사용하려면 이렇게 충돌 규칙을 수정해주면 되겠습니다.

그리고 이제 큐브의 윗면이 이동가능한 영역으로 판별되는게 신경쓰인다면 네비게이션 메쉬의 범위를 조절하면됩니다. 
네비게이션 메쉬의 범위를 그냥 커다랗게 만들어 두고 그 안에서 갈 수 있는 영역을 판별 하고 있었는데 일정 고도 위로는 판별하지 않도록 네비게이션 메쉬 크기를 조절하는 것입니다.


또 한가지는 몬스터나 큐브의 주변에 애매하게 갈수 없게 판별되는지 또 경사로 만든 Plane 은 왜 이동가능하다고 판별되는지를 알고 싶습니다. 
사실 이 경사를 좀 더 급하게 해서 43 정도 이상이되면 갈 수 없다고 뜹니다. 

분명 이런 부분을 조절하는 옵션이 어딘가 있을겁니다. 어디에 있냐면 프로젝트 세팅에서 네비게이션 메쉬와 관련된 부분이 있습니다. 여기서 설정을 해도 되고 
아니면 우리가 맵에 네비게이션 메쉬를 배치하면 자동으로 RecastNavMesh-Default 라는 오브젝트가 생깁니다. 아웃라이너 창에서 확인 할 수 있는데 이것을 선택하고 
디테일즈를 보면 디스플레이라고 해서 프리뷰에서 선택한 옵션을 시각적으로 보여주는 옵션들도 있고 그 아래쪽으로 Generate 생성 이라는 곳에서 
여러 옵션 값들을 조절해줄 수 있습니다. 여기의 값들을 건드리면 프로젝트가 전체 재빌드된다고합니다.
그리고 Agent Radius 라는 옵션이 있는데 이게 몬스터나 큐브 의 근처에 갈수 없는 범위를 조절하는 옵션인데 이 옵션은 움직일 물체의 부피를 감안해서 이동가능한 범위를 계산하는것입니다.
또 Agent Max Slope 라는 것은 말 그대로 갈 수 있다고 판별하는 최대 각도를 뜻합니다. 

이런 것들을 필요에 따라 이리지러 조절하면 되겠습니다.

다음으로 알아볼것은 이런 상황입니다. 큐브를 배치하고 큐브를 어느정도 크게 만들면 이 큐브 자체가 어떤 언덕 지형처럼될겁니다. 이 위에 몬스터를 배치하고 실행하면 
언덕위에서 못내려오고 그 안에서만 배회하고 있을겁니다. 

그런데 이 언덕의 고저차가 작은 지형이라 뛰어 내릴 수 있게 하려면 어떻게 해야할까요 물론 다른 Plane 같은 물체를 적절히 배치해 다리를 만들어 줄 수도 있지만 
이 방법말고도 알아보겠습니다. 다시 액터 배치 창에서 Nav Link Proxy 라는 것이 있습니다. 

네브 링크 프록시를 배치한걸 보면 왼쪽 오른쪽 두가지 물체가 있는데 한 물체를 지면에 두고 하나는 언덕위에 둬보겠습니다. 
지금 상태에서는 Left 가 붙은 물체가 언덕위 Right 이 지면에 있습니다.

그리고 네브 링크 프록시 오브젝트를 선택하고 디테일즈를 보면 단순링크, 포인트 링크, 인덱스 [0] 을 차례대로 화살표를 열어봅니다. 그러면 
왼쪽 오른쪽 이 상대좌표가 어떤지 그리고 더 밑쪽을 보면 Direction 이라고 양방향 혹은 어느 방향으로만 움직일 수 있는지를 골라 줄 수 있습니다. 
언덕에서 내려가는건 될것같은데 아래에서 올라오는건 이상한거 같아서 Left to Right 로 골라줬습니다.

언덕위의 몬스터가 네브 링크 프록시 왼쪽에 곂쳐서 실행되고 각 왼쪽 오른쪽 물체도 지면에 포함되도록 땅에 붙혀서 배치했습니다.

게임을 실행해보면 몬스터가 언덕에서 내려오는걸 볼 수 있습니다. 

이런식으로 경우에 따라 점프해 줄 수 있도록 할 수 있습니다. 

그리고 상용엔진을 공부할때 툴에서 할 수 있는것은 코드로 다 구현할 수 있다라는 믿음을 갖고 있어야 합니다. 
예를들어 어느 좌표에서 다른 좌표까지 갈 수 있는지를 체크한다거나 또 갈 수 있다면 이동을 한다라는 코드들은 함수에서 마련은 해줄겁니다. 구글링으로 찾아보거나 아니면 다 외우고 있다거나 
방법을 찾아 사용할 수 있을겁니다.

지금 만든 이동방식이 몬스터는 네비게이션 메쉬가 판별하는 이동 가능영역을 이동하겠지만 플레이어같은경우는 언덕 벽에 부딛혀 못지나가는걸 볼 수 있습니다.
왜냐면 지금 우리가 플레이어 이동하는 코드를 BP_PlayerController 에서 Add Movement Input 이라는 Character Movement Component를 사용해 이동하고 있었습니다. 
이 무브먼트 컴포넌트는 네비게이션 메쉬를 사용해 이동하는게 아니라 진짜 충돌 영역을 가지고 이동하고 있어서 그렇습니다. 

물론 슈팅게임에서 이렇게 벽에 막혀 못움직이는것은 괜찮습니다.
그런데 RPG나 스타 크래프트 같은 게임에서는 내가 맵을 클릭하면 그 위치로 플레이어가 이동하는 사양일겁니다. 이런것도 당연히 샘플을 찾아보거나 함수를 찾아보면 다 준비되어있습니다.

그 중 한가지 분석을 해보겠습니다.
프로젝트에 기본 제공 프로젝트 중 Top Down 프로젝트를 추가해보겠습니다. 
추가된 프로젝트의 맵을 들어가서 게임을 실행해보면 프로젝트 이름처럼 Top 시점에서 바라보면서 마우스를 클릭한 방향으로 플레이어가 움직이는 게임입니다.

어떤 지점을 클릭하면 그 곳으로 이동하고 아니면 클릭 다운 한 상태에서 커서를 움직이면 해당 방향으로 움직이게 됩니다.
드래그로 방향을 지정할때 막다른 곳을 지정하면 벽에 막히게 되고 클릭으로 움직일때는 곧바로는 막혀있더라도 다른곳에서 이어진 길이 있다면 그 길을 찾아서 이동하고 언덕에서 점프도 하는 걸 
볼 수 있습니다. 

이런 기본 제공 Top Down 프로젝트도 다 해석할 수 있어야합니다. 여기서 사용된 기술들은 다 배웠지만 어떻게 응용해야 이런 게임을 만들 수 있는지를 알아보겠습니다. 
TopDownMap 에서 P 를 눌러보면 역시 네비게이션 메쉬가 설정이 되어있는걸 볼 수 있고 또 언덕에서 뛰어 내린것처럼 네브 링크 프록시가 배치되어있습니다. 

그리고 프로젝트의 폴더내에 블루프린트를 보면 캐릭터 블루프린트 클래스와 캐릭터 컨트롤러 클래스 그리고 게임모드 클래스 들이 있습니다. 
캐릭터 블루프린트에서는 별로 코드가 많지 않고 다른 블루프린트들을 다 연결해 있을겁니다. 예를들어서 컨트롤러 블루프린트와 애니메이션 블루프린트 같은것은 여기서 설정했었습니다.

그럼 이동에 대한 코드들은 다 캐릭터 컨트롤러 블루프린트 클래스에 있을겁니다. 
들어가보면 여러 구역으로 나뉘어 있는데 코드를 살펴보면 마우스를 클릭하면 Stop Movement 를 호출해줍니다. 왜 클릭을 했는데 이동을 멈출까요? 
이것은 이런 의미입니다. 어디로 이동하고 있던 현재 이동을 멈추고 현재 입력한 위치로의 이동을 준비하는겁니다. 그래서 클릭을 때는 이벤트일때는 Move To Hit Location 이라는 
함수를 호출해줍니다. 이 함수는 Simple Move to Location 함수를 또 호출하고있는데 이 함수는 따로 만든게 아니라 언리얼에서 제공하는 함수입니다.
간단하게 목표 로케이션만 주면 길찾기까지 포함해서 움직임을 해주는 함수입니다. 다음으로 Spawn System at Location 이라는 함수인데 이것은 클릭했을때 이펙트를 표시하는 용도로 사용하고 있습니다.

그래서 이제 단순히 맵을 클릭하는 조작에서는 Simple Move to Location 으로 이동하는 함수가 실행되는것이었습니다.
하지만 그냥 사용하는것은 아니고 플레이어 클래스에서 무브먼트 컴포넌트 옵션들 중 네비게이션 무브먼트 중에서 Update Nav Braking Distance, Use Acceleration for Paths 라는 옵션이 켜져있는데 
이게 필요합니다. 이것들을 건드리면 애니메이션이 제대로 작동안한다던지 뚝뚝 끊긴다던지 합니다. 
이런걸 다 외워야 하는것은 아니고 구글링을 해결할 수 있는 것이긴합니다.

다시 컨트롤러로 돌아가서 클릭 다운하고 있을때 사용되는 로직을 보겠습니다. InputPress 라는 불리언 변수에서 내가 지금 키를 누르고 있는지 아닌지를 관리하고 있는것 같으니 
이 변수의 레퍼런스를 찾아보면 Follow Moves or Finger 함수로 연결되는걸 볼 수 있습니다. 이 함수에서는 Add Movement Input 이라는 지금까지 많이 사용했던 함수를 사용해 이동하고 있습니다.

마지막으로 눈여겨 볼 것은 이전에 말했든 충돌 없이는 게임을 만들 수 없다고 했습니다. 
TopDown 방식의 클릭으로 이동할 위치를 찍는게 너무나 당연해 보이지만 절대 당연한 것이 아닙니다. 마우스를 클릭한 스크린 좌표를 게임 월드 좌표계에서 이동할 위치를 얻어오는 충돌의 일종입니다. 
이 프로젝트에서는 컨트롤러 클래스에서 Get Location Under Cursor , Get Location Under Finger 함수입니다.
이 함수을 열어모면 안에서 Get Hit Result Under Cursor by Channel 을 호출하고 있는데 by Channel 이라는 이름은 충돌관련 함수에서 사용하던것이니 이것도 충돌 함수임을 알 수 있습니다.
해서 충돌을 했다면 그 위치의 로케이션을 반환하는 함수임을 알 수 있습니다. 제공되는 함수로 충돌을 처리하고 있으니깐 이렇게 간편한데 
직접 C++ 로 코드를 만들면 정말 골치가 아픈 기능입니다.

이런식으로 게임을 만들면서 막히는 곳이 잇으면 비슷한 샘플 게임들을 다운받아 로직을 열어보면 참고할만한 것들이 많습니다.