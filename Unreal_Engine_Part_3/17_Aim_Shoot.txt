


    조준 발사


이전시간중 블랜드 스페이스인지 에임 오프셋 작업중에 총을 쏘는 모션이 사라졌었는데 그 것의 복구와 크로스헤어를 도입하는 
조준 발사에 대한 시간입니다. 

먼저 뭐부터 시작할것이냐면 ABP_Player 의 AnimGraph 에서 에임 오프셋을 적용하면서 Fire 라는 애니메이션 몽타쥬가 무시되고 있습니다. 
이 코드들의 순서를 바꿔줘볼겁니다. 
현재 AnimGraph 의 흐름은 먼저 Locomotion 이라는 상태머신에서 Idle 상태와 Move 상태를 오가면서 애니메이션을 골라주고 있엇는데 이 결과물을 
Cached Locomotion 으로 캐싱한 후 캐싱된 Locomotion 에서 Slot 'Fire' 를 더해주고 있었습니다. 이 Fire 슬롯은 애니메이션 몽타쥬로 총을 쏘는 애니메이션이고 
BP_Player 의 FireWeapon 함수를 호출할때 실행하는 애니메이션 몽타쥬 AM_Fire 의 슬롯입니다. 이 Fire 도 캐싱합니다. 
그 후 RootYawOffset 과 Pitch 값만큼 캐싱 Fire를 에임오프셋을 해주고 있었습니다. 마우스에 따라 상체를 움직이는 에임 오프셋이었습니다. 
이 에임오프셋과 캐싱 Locomotion 을 Layered blend per bone 으로 상체는 마우스를 따라 움직이는 애니메이션 하체는 Idle 과 Move 에 따라 움직이는 애니메이션을 섞고 그것을
Output Pose 에 연결해주고 있었습니다. 

바꿀 코드 순서는 일단 Locomotion 을 캐싱하는것 까지 똑같은데 그 후 캐싱 Locomotion 과 Fire 슬롯을 더하지 않고 에임 오프셋에 캐싱 Locomotion 을 넣어줍니다. 
Layered blend per bone 다음에서야 Slot 'Fire' 를 연결하고 이어서 Rotate Root Bone 이어서 Output Pose를 연결해줍니다. 
즉, Slot 'Fire' 를 에임오프셋, Layered blend per bone 연산 이후에 호출해주는 것입니다.

이제 게임을 실행해 테스트 해보면 다시 클릭시 총을 쏘는 모션이 나갑니다. 여기에 이제 라인 트레이스를 추가해 사격을 구현해주면 될겁니다. 

잠깐 테스트 하다보니 거슬리는게 한가지 있는데 게임에서 이동을 시작할때 그리고 이동을 멈추는 애니메이션이 자연스럽지 않습니다.
큰 문제는 아니고 우리가 작업하던 ABP_Player 의 UpdateTurn 함수에서 자연스러운 회전을 위해 이런 저런 변수들을 구해주고 있었습니다. 
이때 움직임을 멈출때 RootYawOffset은 0으로 밀어주었지만 PrevCharacterYaw 와 CharacterYaw를 0으로 밀어주지 않았기 때문에 1프레임에 남은 쓰레기 값들이 문제가 되는겁니다. 
간단히 말해서 초기화와 관련된 코드를 Speed가 0일때에 추가해주면 됩니다. 
Speed가 0일 때 RootYawOffset을 0으로 세팅해주는 코드 뒤로 Player 변수로부터 Get Actor Rotation 함수를 호출하고 그 Yaw 값을 CharacterYaw 에 세팅합니다. 
이어서 이 CharacterYaw 값을 PrevCharacterYaw 에도 세팅해줍니다. 

이렇게 잠시 UpdateTurn 의 초기화하느 코드를 추가해 봤습니다.


이어서 본격적으로 이번시간의 내용을 시작해보겠습니다. 
강의 자료에 소스코드와 크로스헤어 리소스들이 있습니다. 여기서 맘에 드는 크로스 헤어를 사용하면 될것입니다. 크로스 헤어 파일을 프로젝트 컨텐츠 브라우저에 드래그 드랍으로 
추가합니다. 
이미지 리소스를 열어서 디테일중 Compression Setting 압축 세팅이라는 옵션의 값을 UserInterface2D(RGBA) 로 바꿔주고 저장해줍니다.
UI용도로 사용하기 위해서 해준 작업입니다. 그리고 파일 이름도 적당히 CrossHair 정도로 수정합니다. 

리소스 관리는 필요에 따라 수정할 수 있는데 지금까지 블루프린트 클래스들을 관리하는 Blueprints, 애니메이션관련을 관리하는 Animations 는 있었지만 우리만의 아트 리소스를 관리하는 
무언가는 딱히 없었습니다. 프로젝트 마다 팀 마다 아트 리소스를 지칭하는 용어가 다 다릅니다. Asset, Resources, Graphics 등등 으로 부르는데 일단 저희는 Assets 라고 부르겠습니다.

Assets 에 CrossHair 를 담아주겠습니다. 물론 아트리소스는 이미지 뿐만아니라 사운드 같은 것들도 있을 것이니 이후 다시 분류를 해줘야 겠지만 지금은 아니기 때문에 일단 사용하겠습니다. 
크로스 헤어 UI를 만드는것은 이전 2D 페이퍼 게임을 만들때도 해봤지만 따로 블루프린트 위젯을 만들어 사용해도 되고 아니면 예전 방식인 HUD 방식으로 사용해도 됩니다. 

여기서는 간단한 UI이므로 HUD 방식을 사용해보겠습니다. 
Blueprints 폴더에서 새 블루프린트 클래스를 만들어주는데 HUD 를 상속받고 BP_AimHUD 라는 이름을 지어주겠습니다.
BP_AimHUD 의 이벤트 그래프로 가보겠습니다. 기본 이벤트들은 모두 날려줍니다. 그리고 UI 용으로 사용하는 업데이트 이벤트인 
Event Receive Draw HUD 이벤트를 배치합니다. 이게 매 프레임 UI를 그려주는 기본적인 이벤트입니다. 
이 이벤트에는 Draw Texture 라는 함수를 연결해 줄 건데 그려줄 텍스쳐를 고르고 그려줄 좌표들을 넣어주면 됩니다. 일단 잘 출력되는지를 알아보기 위해 적당한 값을 넣었습니다. 
Screen X = 300, Screen Y = 300, Screen W = 64, Screen H = 64, Texture U = 0, Texture V = 0, Texture YWidth = 1, Texture VHeight = 1 
이라는 값들을 넣어주고 DevMap 에서 월드세팅 HUD를 BP_AimHUD 로 설정해줍니다.

그리고 게임을 실행해보면 왼쪽부분에 아까 골라줬던 크로스 헤어가 표시됩니다. 

값으로 준 (300, 300) 좌표에 크로스 헤어가 위치하고 있는건데 이 좌표는 월드 좌표계가 아니라 스크린 좌표계를 말합니다. 
그리고 UV 좌표계는 어떤 식이냐면 우리가 텍스쳐를 그려줄 범위로 Screen W, Screen H 의 64 * 64 픽셀을 설정했는데 
이 영역에 CrossHair 의 좌상단 픽셀을 (0, 0) 좌표라고 하는데 그 곳부터 64*64 픽셀에 차례대로 매핑해주는 게 UV 좌표 입니다. 시작하는 좌표가 Texture U, Texture V 좌표이고 
여기서 부터 어디까지 를 매핑할건지가 Texture UWidth, Texture VHeight 입니다. 1.0, 1.0 을 줬다는건 텍스쳐 전부를 매핑한다 라는 말이고 만약 0.5, 0.5 를 줬다면 
텍스쳐의 4분의 1 만큼의 이미지를 64*64 크기에 맞게끔 매핑한다는 뜻입니다.

대충 이런 의미이고 그러면 다음으로 구해야할것은 우리 게임 화면 정중앙 좌표를 가져와야 할겁니다. 
어떻게 화면 중앙 좌표를 구할 수 있냐면 마침 Event Receive Draw Texture 이벤트의 출력 핀 Size X, Size Y 가 사실 화면의 사이즈를 말하는것입니다. 
각각 2로 나눠서 좌표로 사용하면 화면 중앙을 말하는것 같습니다. 

이 상태에서 게임을 실행해보면 크로스 헤어가 거의 중앙까지는 왔는데 아직 정중앙은 아니고 좀 오른 아래로 내려간것 을 보니 화면 중앙에서 부터 텍스쳐를 그려주는 것 같습니다.
우리가 원하는것은 크로스 헤어 자체가 화면 중앙으로 오는걸 원합니다. 

Size 들을 2로 나눈뒤 64픽셀의 절반인 32 만큼씩을 빼주면 될것 같습니다.  
보정을 하고 다시 게임을 실행해보면 이제야 화면 중앙에 위치합니다. 

지금 처럼 화면 중앙에 크로스헤어를 두는것도 괜찮고 이후 UI를 더 추가하면서 화면 중앙이 아니라 좀 더 위쪽에 크로스 헤어를 둔다면 원하는대로 움직이면 될겁니다.
그리고 크로스 헤어를 추가하니 카메라가 좀 멀리 있는것 같기도 합니다. 이런 수정은 BP_Player 의 Spring Arm 디테일즈에서 수정 할 수 있었습니다. 소켓 오프셋 값은 (0.0, 50.0, 50.0) 
정도로 주겠습니다.

여기까지 설정은 잘 됐는데 이제 이 크로스헤어가 조준하는 위치에 적군이 있는지를 판별해줘야 합니다. 
이것이 애매한데 일단 총구 자체는 월드에 3D 물체로서 좌표로 존재하는데 하지만 크로스헤어는 2D 화면에 고정된 위치인데 이게 3D 월드에서 어느곳을 가리키는지가 모호합니다.
이전 시간에 알아봤던 것 처럼 레이 캐스팅을 사용해서 크로스헤어가 가리키는곳으로 레이저를 쏠겁니다. 
일단 1차로 카메라 위치에서 크로스헤어 중앙 위치까지 레이저를 한번 쏠겁니다. 그곳에 일단 피격 가능한 물체가 있는지를 체크합니다.

BP_Player 의 FireWeapon 함수로 가보겠습니다. 사격을 어떤식으로 구현할지 계획을 말해보자면 먼저 카메라위치에서 크로스헤어를 향한 벡터와 충돌을 하는 물체가 있는지를 판별 해 주겠습니다.
당장 구해야 할 것은 화면의 크기를 가지고 화면 중앙이라는 좌표를 구하고 그 좌표를 향해서 레이저를 날리는 함수를 만들어야 합니다.
이 기능이 다행히도 이미 언리얼에 만들어져 있습니다.

먼저 화면의 사이즈를 가져오는 함수 Get Viewport Size 입니다. 반환은 어떤 벡터 2D 구조체라고 하는데 핀 분할을 하면 float 두개로 나뉩니다. 아까 봤던 Event Receive Draw HUD 의 반환 값과 
같은걸 가져오는것 같습니다.
각 값을 2로 나눠줘서 화면 중앙 좌표를 계산합니다.
이제 이 스크린 좌표에서 월드 좌표로 변환해주는 함수가 필요합니다. Deproject Screen to World  라는 함수인데 입력으로 플레이어 컨트롤러와 벡터 2D 구조체를 받습니다. 
플레이어 컨트롤러는 현재 BP_Player 에서 작업하는 중이니 Get Player Controller 를 통해 가져와 꽂아주고 벡터 2D 구조체는 Get Viewport Size 의 반환 값이었던 타입입니다. 
Make Vector 2D 함수를 가지고 아까 계산한 float 두개를 넣어주면 다시 벡터 2D 구조체로 만들어 줍니다. 
이 벡터 2D 구조체로 변환해주기 전에 다른 보정을 하고 싶다면 예를 들어 위에서 처럼 화면 정중앙보다 좀 더 위쪽을 조준하고 있다면 그 계산은 해주고 벡터 2D 구조체 변환을 하면됩니다. 

Deproject Screen to World 의 입력값들을 다 넣었으면 출력값을 보겠습니다. World Position , World Direction, Return Value 세가지를 반환하고 있는데 Return Value 는 성공적으로 함수가 동작했는지
불리언값으로 반환해줍니다. World Position 은 스크린에서 월드좌표계로 변환한 그 좌표를 반환하고 World Direction 은 입력한 벡터 2D 지점에서 카메라로부터 멀어지는 방향 벡터입니다.

먼저 Return Value 를 가지고 브랜치를 해줍니다. 만약 참이라면 이전시간에 알아봤던 Line Trace by Channel 함수를 호출해줍니다. 
Line Trace by Channel 의 입력값인 Start 는 World Position 을 넘겨줍니다. End는 World Direction 에 원하는 거리를 곱해줘서 입력합니다.
사용할 Trace Channel 은 이전에 만들었던 MyAttackRange 를 삭제했기 때문에 기본 채널인 Visibility 로 사용할것이지만 나중에 트레이스 채널을 하나 파서 피격할 몬스터를 대상으로 Block 하도록 만들어 주겠습니다.
디버깅을 위해 For Duration 에 1초 동안 유지되도록 설정해줍니다.

이제 한번 게임을 실행해 테스트를 해보겠습니다. 그러면 역시 레이져가 쏴지는걸 볼 수 있습니다. 캐릭터부터 쏴지는게 아니라 카메라 위치로부터 쏴지는 궤적이 보입니다.

여기까지 1차적인 과정입니다. 우선 우리가 조준한 곳에 피격가능한 물체가 있는지를 판별부터 하는데 이후 사실 총알이 카메라로부터 나가는것은 아니니깐 피격하는 물체가 있으면 
그 물체를 목표로 캐릭터의 총구에서 2차 광선을 날려서 레이 캐스팅 판정을 하는겁니다. 2차 판정중에 총구와 피격물체 사이에 벽같은게 위치해 있으면 피격 실패가 되는 식입니다.

현재 FireWeapon 에서는 1차적으로 카메라에서 크로스 헤어까지의 물체를 판정했고 이어서 총구에서부터 피격 물체를 향한 레이 캐스팅을 한번 더 해줘야합니다. 
그런데 총구 위치라는것을 어떻게 가져올 수 있을 까요? 

총구 위치를 가져오는 방법으로 소켓이라는것을 이용하는 방법이 있습니다. 
잠시 paragon 리소스 쪽에서 Belica 메쉬를 열어보겠습니다. 여기서 스켈레톤 트리를 살펴보면 weapon 이라는 뼈아래로 smg_butt 라는 뼈가 있고 또 그아래로 LaserSight, SMG_Barrel 라는것들이 있는데 
이것을 소켓이라고 합니다. 소켓은 뼈는 아니지만 이 위치에 뭔가를 배치할 수 있게끔 위치만 잡아놓은것입니다. 이 소켓들을 사용해도 되지만 
소켓을 직접 만들어 사용할 수 도 있습니다.
weapon 위치 바로 앞에 만들어야하고 또 총이 움직이면 따라서 이동해야 합니다. 결국 계층구조에서 weapon 산하에 만드는게 합리적입니다.
weapon 뼈 를 우클릭하면 add Socket 을 할 수 있습니다. 기본적으로 weapon Socket 이라고 이름이 붙는데 당연히 맘에 드는 이름으로 바꿔줄 수 있습니다. GunSocket 이라고 이름을 바꿔주겠습니다.
이렇게 만든 소켓은 우리가 위치를 가져올 수도 있고 이 위치에 새로운 메쉬를 붙힐 수도 있습니다. 굉장히 기능이 다양합니다. 

만든 소켓의 위치를 지정하기에 앞서 방향을 맞춰주겠습니다. 보통 x 축이 앞을 가리킬것이니까 적절히 회전시켜주겠습니다. 회전후에는 적당히 총구위치로 옮겨줍니다.

지금은 총구 소켓을 만드는 중이지만 언젠가 캐릭터가 무기를 쥐어줘야하는 경우도 있을 겁니다. 다른 RPG 게임이라고 할때는 장비를 교체하면 각 장비의 메쉬를 사용할겁니다.
칼도 들 수 있고 도끼도 들 수 있을 텐데 각 장비를 쥘 손 위치에 소켓을 두고 거기서 메쉬를 붙혀주면 됩니다. 그렇게되면 이후 캐릭터 메쉬가 무기를 휘두르는 애니메이션을 재생하면 소켓을 
따라 무기도 같이 휘둘러집니다. 

지금도 GunSocket 에서 만약 다른 메쉬를 붙혀주고 싶었다면 GunSocket을 우 클릭해서 Add Preview Asset 을 하면 에셋 메쉬를 붙여볼 수 있는데 실제로 적용되는건아니고 미리보기 같은겁니다.

이제부터 GunSocket 에서 총알을 발사하는 애니메이션을 사용한다거나 레이 캐스팅을 시작하는 위치로 삼는다거나 할 수 있게 된겁니다.

다시 BP_Player FireWeapon 으로 돌아가서 1차 레이캐스팅에 이어서 총구부터 시작하는 2차 레이캐스팅을 시작해보겠습니다. 
소켓의 위치를 가져오는 함수가 Get Socket Transform(Mesh) 라고 있습니다. Mesh로 부터 소켓의 Transform 정보를 가져오는겁니다. 이 함수에서 가져오고 싶은 소켓의 이름을 입력해 가져옵니다.
그러면 출력으로 Transform 타입을 반환하는데 우리가 필요한것은 Location 이니 핀 분할을 해줍니다. 가져온 Location이 결국 총구위치입니다. 
여기서부터 두번째 Line Trace by Channel 을 해주겠습니다.

Start에는 GunSocket 의 로케이션을 넘겨주고 End는 피격에 성공한 곳으로 지정해줘야하는데 그것은 1차 레이 캐스팅의 출력 핀에서 가져올 수 있을것입니다. 
일단 성공했는지 부터 브랜치를 해주고 Out Hit 을 Break Hit Result 를 하면 많은 정보들을 가지고 있는데 이 중에서 Location 을 2차 레이 캐스팅의 End로 삼아줍니다.
디버그 옵션들도 다 설정해주고 테스트 해보겠습니다.

테스트를 위해 DevMap 에 몇개의 구 메쉬를 배치하고 게임을 실행해 봤습니다. 그러면 총이 충돌한 경우 총구에서부터 시작하는 레이도 표시됩니다.



이렇게 해서 성공적으로 총을 쏘는것을 구현했습니다. 이후에 사운드같은걸 붙여야 더 실감나겠지만 그것은 디테일을 붙힐때 추가하면 될겁니다.