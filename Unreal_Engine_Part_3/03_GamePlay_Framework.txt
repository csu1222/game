

    게임플레이 프레임워크



지난 시간까지 예제로 사용했던 스타터 컨텐츠는 더 이상사용하지 않을것이기 때문에 삭제해주고 시작하겠습니다. 
삭제를 시도하면 뭔가 에러 메세지가 뜨면서 깔끔하게 삭제되지않고 두번째 시도해야 제대로 삭제되는데 이건 스타터 컨텐츠 내부적으로 서로서로 참조하면서 물려있어서 그렇습니다. 

본 내용을 시작해보겠습니다. 
시작부터 자그마한 미니 프로젝트를 만들어보겠습니다. 먼저 컨텐츠 폴더 아래로 Blueprints 라는 폴더를 새로 만들어 줍니다.
이때 언리얼의 재미있는 기능으로 폴더의 색상도 바꿀 수 있습니다. 블루프린트 폴더를 우클릭하고 Set Color 를 하면 색상 파레트가 나오는데 이름이 블루 프린트니까 파란색으로 설정해 주었습니다. 

이 폴더에서 C++코드를 대신해 블루프린트 코드로 작업을 해볼건데 목표는 간단한 비행기를 배치하고 날려보는 실습을 해볼겁니다. 

유니티 엔진은 빈 오브젝트에서 필요한 컴포넌트를 추가해가면서 객체를 만들기 때문에 학습하기 편한데 
언리얼의 경우는 이미 기존의 상속구조가 꽉 잡혀있는 상태여서 익숙해지는데 시간이걸릴겁니다. 

비행기를 만들어 볼건데 기본 메쉬들을 이리 저리 조합해서 비행기 모양을 만드는것도 가능하지만 이번에는 우선 Blueprints 폴더 안에서 블루프린트 클래스를 하나 만들어 줄겁니다. 
블루프린트 클래스를 만들때는 상속받을 부모 클래스를 정해주게되는데 가장 기본적인 부모클래스로는 액터, 폰, 캐릭터가 있습니다. 
액터는 인게임에 배치하거나 코드로 스폰할 수 있는 클래스입니다. 그래서 사실상 인게임에 등장하는 모든 물체들은 다 액터라고 할 수 있습니다. 
폰은 액터를 상속받고 거기에 더해 기능을 추가한 클래스입니다. 어떤 기능을 추가 했냐면 물체에 컨트롤러를 빙의해서 입력을 받아 움직이도록 할 수 있습니다. 
캐릭터는 폰에 더해 걸어다니는 기능이 추가된 클래스라고 합니다. 

우리가 만들 비행기는 어떤 클래스를 상속받을거이냐면 비행기는 날아 다닐것이기 때문에 움직이는 기능이 필요합니다. 그러면 폰으로 만들지 캐릭터로 만들지 고민이 되는데 
일단 이번에는 폰을 상속받은 비행기를 만들어 보겠습니다. BP_Plane 이라는 이름으로 만들었습니다. 

C++에서 클래스를 만들면 멤버 변수와 멤버 함수를 추가해줘서 기능을 만드는것과 마찬가지로 블루프린트 클래스도 내부의 코드를 작성해나가야 합니다.

BP_Plane에서 가장먼저 해볼것은 비행기의 형태를 만들어 보겠습니다. 클래스 창을 열면 상단에 뷰포트, Construction Screen, Event Graph 라는 탭들이 있는데 
여기서 뷰포트는 이 클래스가 설계하는 객체의 외형을 로컬 좌표계에서 볼 수 있습니다. 여기서 비행기 형태를 추가해줄건데 
클래스 컴포넌트 추가로 일단 큐브 메쉬를 배치하겠습니다. 이 비행기의 앞이 어딘지를 정해줘야하는데 x축을 앞방향이라고 정해주겠습니다. 
큐브의 스케일을 건드려 길쭉하게 늘려줍니다. 이 큐브를 Body 라고 이름을 짓습니다. 
다음은 비행기에게는 날개가 필요할겁니다. 새로 큐브를 하나더 추가해 주고 형태를 조절해주겠습니다. 

이제 클래스의 컴포넌트 창을 보면 기본적으로 DefaultSceneRoot 라는 노드가 있는데 이것은 루트라고 해서 언리얼에서 기본적으로 추가해주는 노드입니다. 
우리가 만든 비행기를 드래그드롭해 BP_Plane 바로 아래로 위치하면 DefaultSceneRoot가 사라지고 Body가 루트로 설정됩니다. 

여기까지 만들면 새로운 블루프린트 클래스를 만들어 Pawn을 상속받고 비행기 형태의 메쉬를 추가했습니다. 빈 클래스가 아니라 폰을 상속받은 기능들이 이미 있는겁니다. 

이 비행기 객체를 월드에 배치해 공중에 띄워줘 보겠습니다. 색이 그냥 흰색인게 심심하니 이전시간에 배웠던 머티리얼을 만들어이름은 M_Blue 정도로 정한 뒤 파란색을 베이스 컬러로 세팅하고
BP_Plane의 디테일즈에서 머티리얼을 방금 만든 M_Blue로 설정해주면 이제 파란색 비행기가 됩니다.  

이상태에서 게임을 실행해보면 공중에 배치했던 비행기가 그대로 공중에 떠 있습니다. 게임 실행중인 상태에서 F8을 누르면 창밖으로 마우스를 움직일 수 있는데 이 때 아웃 라이너를 살펴보면 
직접 배치하지 않았던 AIController 라던지 Default Pawn0 같은게 알아서 배치되어있습니다. 

언리얼 엔진이 까다로운 점이 이런곳에 있습니다. 이미 정해진 규칙에 따라 움직인다는것입니다. 

다음으로 어떤 작업을 할것이냐면 우리가 월드에 배치한 BP_Plane 을 선택하고 디테일즈를 보겠습니다. 디테일즈에서는 옵션을 검색할 수 있는 검색 창이 있는데 
여기에 Possess 를 검색해보면 Auto Possess Player 라는 옵션이 Disabled 라고 되어있는데 이것을 Player0 으로 해주고 다시 게임을 시작하면 이번엔 시점이 비행기시점으로 시작합니다. 
그리고 이동도 불가능합니다. 

이 Possess 라는것은 어떤 의미인지를 알아보자면 언리얼엔진 구조상에서 게임을 시작하면 알아서 다양한 객체들이 만들어 지는걸 볼 수 있는데 이중에 PlayerController 라는 객체가 
자동으로 생성된 Default Pawn에 빙의되는데 그래서 우리는 기본적으로 이 Default Pawn의 시점에서 게임 세상을 보고 있었던겁니다. 
이것을 우리가 강제로 BP_Plane 에 빙의되도록 설정한겁니다. 

그런데 이 빙의 설정은 DevMap 에 배치된 BP_Plane 객체에 하게 되면 이 해당 객체만 적용되고 삭제후 다시 실행할때는 따로 다시 설정해주어야 합니다. 
그러기 싫다면 아예 설계도인 BP_Plane의 블루프린트 클래스에서 설정을 해주면됩니다. 이게 첫번째 방법이고 

또 하나의 방법은 프레임워크를 사용하는 방법입니다. 언리얼의 상단 옵션창중 Window 옵션을 클릭하고 거기서 World Setting 이라는 옵션을 클릭해줍니다. 그러면 디테일즈가 있는 창 위에 
월드 세틱이라는 탭이 하나 추가 되는데 이곳에서는 게임모드라는것을 설정해 줄 수 있었고 또 우리만의 게임모드를 만들어 그걸로 덮어쓸 수도 있었습니다. 

그러므로 새로 블루프린트 클래스를 만들면서 게임모드 베이스를 상속받아줍니다. 이름은 BP_GameMode로 해줬는데 이것을 월드세팅에 BP_GameMode를 사용하도록 바꿔 주었습니다. 
이러면 이제 밑에 선택된 게임모드를 수정할 수 있게 되는데 이중에 Default Pawn Class를 BP_Plane으로 바꿔주겠습니다.
언리얼엔진에서 게임이 실행되면 디폴트 폰이 있기를 기대하는데 그것을 BP_Plane으로 설정해주면 월드에 아무 물체가 없더라도 게임실행시 비행기 하나가 자동 생성되어 Possess됩니다. 

만약 이 자동생성되는 위치를 바꾸고 싶다면 Player Start라는 물체의 위치를 원하는 위치에 배치하면 다음실행때는 그 위치에서 물체가 생선되는걸 볼 수 있습니다. 

갑자기 게임모드가 무엇인지 알아보았냐면 이전 파트에서 다뤘던 내용인데
언리얼 엔진 자체가 FPS 게임을 개발하다가 엔진자체가 괜찮아서 배포해서 다른 게임들도 사용하는것인데 FPS게임은 점령전이라던지, 데스매치라던지, 아니면 좀비모드같은 다양한 게임모드가 있을 수 있는데 
이런 각 게임모드에 따라 게임에서 사용하는 디폴트 클래스들이 변화할 수 있기때문에 게임모드라는 기능이 있는겁니다. 

다음으로 해볼것은 게임을 실행하면 너무 비행기에 딱 달라붙은 1인칭 시점인데 이것말고 약간 뒤에서 비행기를 보는 3인칭 시점으로 바꾸고 싶다고 하겠습니다. 
그러기 위해서 클래스에서 카메라를 추가해줄겁니다. 그냥 추가하는게 아니라 3인칭 시점으로 보고 싶다면 스피링 암이라는 일종의 셀카봉 같은것을 달고 거기에 카메라를 설치하면됩니다. 

스프링암을 비행기 Body아래로 위치하고 이어서 이 스프링 암 밑으로 카메라 컴포넌트를 추가합니다. 그러고 나서 스프링암의 Rotate를 조절해 위에서 비스듬하게 볼 수 있도록 설정후 
타겟 암 길이를 1000.0 값을 주어 좀 더 멀리서 촬영하도록 했습니다. 

이렇게 해서 게임을 시작해보면 이제는 비행기의 시점이 아닌 뒤에서 비행기를 보는 시점이 됩니다. 

다음으로 하고 싶은것은 비행기가 가만히 떠있는게 아니라 앞으로 이동하는것을 만들어 보고 싶은데 클래스에 기능을 넣을때는 이벤트 그래프에서 작업을 하면 되었습니다. 

매 프레임 실행되는 Tick 이벤트에서 코드를 작성해줄건데 액터의 위치를 수정하는 대표적인 함수가 Set Actor Location 함수였습니다. 이 함수에 이동할 월드 좌표를 넘겨주면 
틱마다 그 위치로 객체가 이동하게 됩니다. 비행기 자신의 로케이션에다가 이동할 방향의 벡터를 더해주면 될거 같은데 이동하고 싶은 방향은 우리가 비행기 형태를 만들때 
x 축을 앞이라고 만들었으니 그냥 (1.0, 0, 0) 이런식으로 하드코딩할수도 있지만 이것보다 앞으로 가는방향을 알 수 있는 방법이 있지 않나 싶습니다. 

무작정 Forward 를 검색해보면 Get Actor Forward Vector 라는 함수가 있습니다. 설명을 읽어보면 타겟(Self)의 월드 스페이스에서 이 액터의 정방향(x축) 벡터 1.0 길이를 구합니다. 
우리가 찾던 그 함수입니다. 이 1.0짜리 단위 벡터에 우리가 한 프레임당 이동하고 싶은 거리를 곱해주면 되겠습니다. 
이럴때 보통 틱이벤트의 출력핀인 Delta Seconds와 따로 속도를 변수로 관리해 둘을 곱한 값을 넘겨줍니다. 왜냐하면 프레임이란 것은 컴퓨터마다 성능차이 때문에 달라지기 때문에 
누가 보던지 같은 속도로 움직이게 하고 싶으면 델타 세컨드를 곱해줘야합니다. 
Float 변수를 하나 추가해서 MoveSpeed라고 이름짓고 100.0 정도 값을 준다음 Delta Seconds와 곱한 후 또 Get Actor Forward Vector 와 곱해줍니다. 
이렇게 구한 포워드 벡터와 비행기 자신의 로케이션을 더한 값을 Set Actor Location에 꽂아주겠습니다. 

여기사 한번 게임을 시작 해보면 배치했던 비행기가 앞으로 천천히 움직이는걸 알 수 있습니다. 

이 다음으로 하고 싶은것은 이 비행기가 날면서 q, e를 누르면 해당 방향으로 회전하면서 나는 것을 구현하고 싶습니다. 

그러면 키보드 입력을 받으려면 KeyBoard Event 로 어떤 키에 대한 입력을 받을 수 있기는합니다. 그런데 이것은 일종의 하드 코딩이 됩니다. 
왜냐면 이 입력에 이어지는 기능들을 다른 키에 매핑하고 싶다거나 아니면 아예 게임패드로 조작하고 싶다면 거기서 사용하는 키에 다시 코드를 작성해야합니다. 
그 전에 좀 더 우월한 방법은 프로젝트 세팅에서 입력 매핑을 하는 방법이 있습니다. 

프로젝트 세팅에서 입력 옵션에 갑니다. 거기서 축 매핑을 하나 추가하고. Turn 이라고 이름짓겠습니다.  Q E 를 각각 1.0, -1.0 스케일로 해줍니다. 

BP_Plane으로 돌아가서 Turn을 검색해보면 Input Axis Turn 이라는 이벤트가 있습니다. 이 이벤트는 매 프레임마다 호출되는데 아무 입력이 없으면 0 Q를 누르면 1, E를 누르면 -1을 
반환합니다. 이제 이 반환값을 가지고 비행기의 회전을 구현할 수 있습니다. 

먼저 아무 입력이 없다면 그냥 무시해주기 위해서 Turn의 값이 0이 아닐때 부터 좌우 회전 코드를 넣어주겠습니다. 
회전을 구현하는 방법은 여러가지가 있는데 그 중에서 이번에 사용해 볼 방법은 Add Local Rotation 이라는 함수입니다. 이 함수의 타겟에는 Body를 꽂아주겠습니다. 
입력 값으로 로테이터를 받고있는데 이 입력값에 따라 비행기를 회전해줄 것이라고 예상할 수 있습니다. 
어느 축으로 이동하면 되는지를 알아보려면 월드에 비행기를 배치해보고 로테이션 축을 만져보면 알 수 있습니다. 
여기서는 비행기 회전을 날개가 기울어지는 식으로 할것이기때문에 x축 회전을 하면됩니다. 

이때 회전하는 로테이터 값은 위의 MoveSpeed와 마찬가지로 따로 변수로 관리하는게 좋습니다. 한 3정도 값을 주겠습니다. 그런데 Q,E 입력에따라 음양이 바뀌는 값을 이용해 
회전 속도와 입력값을 곱해주면 자연스럽게 좌우 회전을 구현할 수 있을것같습니다. Add Local Rotation의 입력핀을 분할해 X축 값에 연결해줍니다. 

잘 실행되는지 게임을 실행해서 Q, E를 눌러보면 비행기가 좌우로 기울어지는걸 볼 수 있습니다. 그런데 카메라도 Body를 따라 같이 움직여서 약간 멀미가 납니다. 
왜 카메라도 같이 움직이냐면 스피링암과 카메라를 애초에 Body 아래로 계층구조를 해놔서 Body의 Rotation에 영향을 받는겁니다. 
이것을 수정해주기 위해서는 계층구조를 조금 수정해주면 됩니다. 

스프링암을 바디와 같은 계층으로 하고 싶은데 지금 상태에서는 스프링암이 루트 노드가 되어버립니다. 아까 클래스를 만들면서 DefaultSceneRoot 가 있으면 그 루트 아래로 바디와 같이 같은 계층이 될수 있기
때문에 다시 DefaultSceneRoot를 복원해주고싶습니다. 바디 이하의 모든 컴포넌트들을 복수 선택후 ctrl + x 를 하면 잘라내기가 되면서 BP_Plane이 텅비어 버리지 않고 다시 
DefaultSceneRoot가 생성되는데 그 아래로 ctrl + v 를 해 붙여 넣으면 구조 그대로 DefaultSceneRoot를 복원할 수 있습니다. 여기서 스프링 암을 바디 밖으로 빼내어 같은 계층이 되도록 해줍니다. 

다시 게임을 실행해보면 카메라는 가만히 있고 비행기만 기울어지는걸 볼 수 있습니다. 

일단 여기까지가 이번시간의 결과물입니다. 

왜 이런 내용을 실습해봤냐면 언리얼엔진은 정해진 구조를 지켜가면서 동작하는걸 반복적인 연습을 하면서 익숙해질 필요가 있습니다. 
그래서 이번 파트에 실습했던 내용들을 굳이 한번더 실습해보았습니다. 