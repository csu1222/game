


        Lock 기반 스택과 큐 



지금 까지 배운 내용들을 복습하면서 락 기반의 스택과 큐를 만들어 보겠습니다. 

먼저 일반적인 단일쓰레드 환경에서 사용해 봤던 스택, 큐를 멀티쓰레드에서 사용해봤습니다. 

queue<int32> q;
stack<int32> s;

void Push()
{
	while (true)
	{
		int32 value = rand() % 100;
		q.push(value);
		
		this_thread::sleep_for(10ms);
	}
}

void Pop()
{
	while (true)
	{
		if (q.empty())
			continue;

		int32 data = q.front();
		q.pop();
		cout << data << endl;
	}
}

int main()
{
	thread t1(Push);
	thread t2(Pop);

	t1.join();
	t2.join();
}

이렇게 기존 스택, 큐 같은 자료구조를 사용하면 동시에 접근이 되지 않기 때문에 당연히 크래시가 납니다. 실행해보고 생각보다 크래시가 
나지 않는다면 중간에 sleep_for를 해두었기 때문입니다. 

젼역 변수에 다수의 쓰레드에서 동시에 접근하면 문제가 일어나는건 이전에 알아 보았었습니다. 
해결하기에는 Push, Pop 함수에 mutex를 추가해서 lock을 하면 해결이 된다고 알아 보았었습니다.

그런데 스택, 큐는 매우 자주 사용하는 컨테이너다 보니까 매번 mutex를 추가하는 것보다 클래스 자체에 락을 끼워넣어서 하나의 클래스로 만들면 어떨까 
생각이 듭니다. 

게임에서는 큐 자료구조를 생각보다 자주 사용됩니다. 클라이언트에서 보낸 네트워크 패킷을 순차적으로 처리 해줘야 하기 때문인데 

그러면 스택, 큐에 락 기능을 합친 클래스를 만들어 보겠습니다. 

프로젝트에 새로운 클래스를 추가해줄건데 ConcurrentStack, ConcurrentQueue 라고 이름 지었습니다. 

먼저 ConcurrentStack부터 입니다. 

들고 있을 변수는 우선 두가지 입니다. 

private:
	stack<T> _stack;
	mutex _mutex;

스택을 새로 구현할 수도 있고 지금 처럼 이미 있는 컨테이너를 래핑해서 사용해도 됩니다. 그리고 멀티쓰레드 환경에서 사용할 스택이기 때문에 
mutex도 같이 들고 있을겁니다. 

다음은 생성자들입니다. 
	LockStack() { }

	// 복사생성자 대입연산자 막기
	LockStack(const LockStack&) = delete;
	LockStack& operator= (const LockStack&) = delete;
기본 생성자가 아무것도 안하지만 굳이 명시적으로 만든것은 아래의 복사생성자와 대입연산자로 복사하는 걸 막기 위해서 입니다. 

다음은 Push와 Empty 메소드입니다. 

	void Push(T value)
	{
		lock_guard<mutex> lock(_mutex);
		_stack.push(std::move(value));	
		// std::move를 사용하면 Lvalue 인 데이터도 Rvlaue 처럼 사용할 수 있습니다. 								
	}

	bool Empty()
	{
		lock_guard<mutex> lock(_mutex);
		reture _stack.empty();
	}

Push와 Empty 둘 다 멤버 변수 _mutex를 가지고 lock_guard를 만든다음 하려던 작업을 랩핑합니다. 

Empty는 보통 컨테이너에서 값을 꺼낼때 조건으로 컨테이너가 비었는지를 체크하는 용도로 사용하였었습니다.
하지만 지금은 멀티쓰레드 환경에서 사용할 겁니다. 그러다 보니 싱글쓰레드에서 하던것처럼 
if (stack.Empty())
	continue;

stack.Pop();
이런식으로 체크한다면 처음 Empty()를 체크할때는 데이터가 있을 수 있지만 Pop() 을 실행하는 사이에 다른 쓰레드에서 stack에 접근해 
데이터를 꺼내면 말짱도루묵입니다. 
그래서 이 동작이 하나의 lock_guard 안에서 이뤄져야 합니다. 
	bool TryPop(T& value)
	{
		lock_guard<mutex> lock(_mutex);
		if (_stack.empty())
			return false;

		value = std::move(_stack.top());
		_stack.pop();
		return true;
	}
TryPop에서는 반환으로 Pop이 성공했는지 여부를 반환하고 Pop을 한 데이터 자체는 인자에 참조 값으로 돌려주겠습니다. 

/*
C++에서 top과 pop으로 나눠서 동작하는 이유
다른 언어에서는 top이나 front 처럼 데이터를 확인하는 동작과 pop과 같이 데이터를 꺼내는 동작이 한번에 이뤄지는 경우가 많습니다. 
그런데 유독 C++에서는 두 동작을 나눠놓았는데 그 이유는 엄격한 방식이긴 한데 데이터를 외부에 복사 혹은 꺼내오고 난 다음 
컨테이너에서 그 데이터를 없애는 동작사이에 혹시라도 크래시가 날 수 있다는 문제가 있는겁니다. 
거의 드물겠지만 복사 과정에서 메모리가 부족해서 예외가 발생한다면 이 스택이나 큐 같은 컨테이너의 자료구조가 와장창 깨지기 때문에 
그런걸 막기 위해서 두단계에 거쳐서 사용하도록 만들어 놨습니다. 

지금처럼 배우고 실습하는 단계에서는 와닿지 않을 수 있지만 게임에서는 데이터를 꺼내다 예외가 발생해서 프로그램이 꺼진다면 
그냥 그대로 프로그램이 꺼지게 두는게 낫습니다. 왜냐면 어짜피 그 상태에서는 어디선가 크래시가 낫을것이기 때문에 
억지로 TryPop 처럼 스택이 비었는지 체크를하면서 프로그램이 동작하도록 유지하면 다른곳에서 더 큰 문제가 발생할 수 있을것이기 
때문입니다. 
*/

하여튼 이렇게 따로 Empty() 를 사용해서 예외처리를 하지 않고 TryPop 메소드 안에서 한번에 처리되도록 만들어 봤습니다. 

여기까지 기본적인 Lock을 적용한 Stack을 만들어 봤는데 이대로만 사용하기는 조금 아쉬운 점이 
실제 프로그램에서 이 LockStack을 사용할때 안에 데이터를 계속 처리해 나갈텐데 데이터가 들어올때 까지 무한 루프를 돌면서 
데이터가 있는지 없는지를 체크하는것은 CPU 점유율을 낭비할겁니다. 
이런 문제를 이전에 배워봤었습니다. 
Event와 Condition variable 이었습니다. Event는 커널영역까지 사용하는 방식이었고 Condition variable은 유저영역에서만 동작하는 방식이었습니다. 
여기서는 Condition Variable을 사용하겠습니다. 
클래스의 멤버변수로 조건변수를 추가해주었습니다. 
	condition_variable _condVar;

	void Push(T value)
	{
		lock_guard<mutex> lock(_mutex);
		_stack.push(std::move(value));
		_condVar.notify_one();
	}

	void WaitPop(T& value)
	{
		unique_lock<mutex> lock(_mutex);
		_condVar.wait(lock, [this]() {return _stack.empty() == false; });
		value = std::move(_stack.top());
		_stack.pop();
	}

그리고 사용하는 방법은 데이터를 하나 넣을때 마다 _condVar.notify_one() 으로 하나의 쓰레드만 깨워서 다시 실행해보라고 연락을 줍니다. 

연락을 받는 쪽인 WaitPop 을 따로 만들었습니다. 여기서 락은 유니크 락으로 만들어야 하는데 왜냐면 
유니크 락은 락 가드와 달리 락을 잠그는 시점을 따로 명시적으로 정 할 수 있기 때문입니다. 
또 _condVar.wait() 는 첫번째로 락을 받고 두번째로 계속 진행하는 조건을 람다식으로 받습니다. 여기서 조건에 부합되지 않는다면 
락을 풀어버리고 멈춥니다. 나중에 notify_one으로 깨워질때 까지 멈추는데 깨워졌으면 다시 람다식을 체크해서 통과 한다면 다음의 
코드로 넘어갑니다. 여기서는 Push() 한번에 notify_one 하나씩을 하기 때문에 통과가 바로바로 될겁니다.


다음은 ConcurrentQueue 만들기 인데 이것도 대칭적입니다. 

#include <mutex>

template<typename T>
class LockQueue
{
public:
	LockQueue() { }

	LockQueue(const LockQueue&) = delete;
	LockQueue& operator= (const LockQueue&) = delete;

	void Push(T& value)
	{
		lock_guard<mutex> lock(_mutex);
		_queue.push(std::move(value));
		_condVar.notify_one();
	}

	bool TryPop(T& value)
	{
		lock_guard<mutex> lock(_mutex);
		if (_queue.empty())
			return false;

		value = std::move(_queue.front());
		_queue.pop();
		return true;
	}

	void WaitPop(T& value)
	{
		unique_lock<mutex> lock(_mutex);
		_condVar.wait(lock, [this]() {return _queue.empty() == false; });
		value = std::move(_queue.front());
		_queue.pop();
	}

	bool Empty()
	{
		lock_guard<mutex> lock(_mutex);
		reture _queue.empty();
	}

private:
	queue<T> _queue;
	mutex _mutex;
	condition_variable _condVar;
};

LockStack과 차이점은 _stack 대신 _queue이고 큐에서는 최상위 데이터를 top이 아니라 front로 꺼낸다는 점입니다. 


이제 만든 클래스들을 실습해보겠습니다. 
원래 실습하던 GameServer.cpp로 돌아가서 
#include "ConcurrentQueue.h"
#include "ConcurrentStack.h"


LockQueue<int32> q;
LockStack<int32> s;

방금 만든 클래스들을 만들어 주겠습니다. 이 클래스들의 메소드도 기존과 다르기 때문에 수정해줘야 합니다.


void Push()
{
	while (true)
	{ 
		int32 value = rand() % 100;
		q.Push(value);
		
		this_thread::sleep_for(100ms);
	}
}

void Pop()
{
	while (true)
	{
		int32 data = 0;
		if (q.TryPop(OUT data))
			cout << data << endl;
	}
}

int main()
{
	thread t1(Push);
	thread t2(Pop);
	thread t3(Pop);

	t1.join();
	t2.join();
	t2.join();
}

메소드이름도 바꿔주고 Pop 에서 이전에는 empty 체크도 하던걸 TryPop안으로 포함시켰으니 정리를 해주었습니다. 

이렇게 실행을 해보면 이전에는 Pop 역할의 쓰레드가 두개일 때 부터는 크래시가 나던게 잘 돌아 갑니다. 

그리고 TryPop은 컨테이너에 데이터가 들어올때까지 계속 무한루프를 돌고 있는 버전이었고 WaitPop은 데이터가 들어올때 마다 신호를 줘서 
동작하도록 하는 버전도 있었습니다.

이정도 까지만 랩핑을 해놔도 실전에서 유용하게 사용할수 있습니다. 
이 작업의 이점은 Push 할때 락을 잡아주고 Pop할때 락을 잡아주고를 자동으로 해줘서 실수로 락을 잡지않는걸 방지해줍니다. 

사실 오늘 내용은 쉬운 편이었고 다음시간부터 배울 LockFreeStack, LockFreeQueue 를 만들어 볼건데 이게 많이 어렵다고 합니다.
마음 단단히 먹고 다음 스탭으로 나아가 보겠습니다. 