


        Server Service 


이전 시간 까지 만들어본 코드는 소켓생성과 그 옵션을 조절하기 위한 SocketUtils, 우리가 사용할 주소 프로토콜인 IPv4 의 구조체인 SOCKADDR_IN 을 
래핑한 NetAdress 클래스, IOCP 통신의 주체를 만들어줄 IocpCore, IocpCore 안에 만든 CP에 등록할 객체들이 들고 있어야할 IocpObject, 
CP에 등록되는 일감들이 어떤 목적인지를 표현하는 IocpEvent들, 또 이전 시간에 접속 테스트를 하기위해 서버쪽의 문지기라고 할수 있는 Listener, 
그리고 앞으로 소켓과 함께 주소정보, 접속여부를 같이 들고있을 Session까지 만들고 
접속테스트 까지 해봤습니다. 

오늘도 여기서 많은 진전을 하진 않을것이지만 테스트했던 GameServer.cpp 의 파일을 수정해볼겁니다. 

지난시간에 가벼운 테스트를 하기위해 넘긴 몇몇 문제들이 있었습니다. 
우리가 IocpCore::Register 를 하면서 CreateIoCompletionPort 의 세번째인자로 Key 값을 IocpObject의 주소를 넣어줬습니다. 
그걸이용해서 GetQeueuCompletionStatus 에서 복원을 시켜서 IocpObject->Dispatch를 호출해줬었습니다. 

이 순간에 Dispatch 하던 IocpObject가 아직 살아 있는지 궁금합니다. 통신을 하면서 Recv나 Send를 하는 도중에 사용하던 IocpObject가 삭제될수도 있는
문제가 있었습니다. 

그러면 이걸 어떻게 수정할것이냐면 여러가지 방법이 있습니다. 
CreateIoCompletionPort 때 넘겨주는 IocpObject와 GetQeueuCompletionStatus 때 넘겨주는 IocpEvent 둘다 살아있어야 제대로 동작 할텐데 
사실 IocpEvent는 어떤 데이터를 담고 있다기 보다는 어떤 IocpObject가 이번에는 어떤 작업을 할지에 대해 설명해주는 정도의 역할만을 하기때문에 
진짜 중요한것은 IocpObject 입니다.

지금까지의 코드에서는 Listener와 Session이 사실상 사용하고 있는 IocpObject 객체들이라고 볼 수 있는데 이것들을 어떻게 해결할지가 오늘의 주제라고 할 수 있습니다.

-- Reference Counting
첫번째 방법은 Reference Counting을 하는 것입니다. 
예전에 만들어 뒀던 RefCountable 을 상속받아서 참조 카운팅을 할 수 있게 해준 IocpObject가 실질적으로 어떤 행동을 하기 전에 예를들면 
비동기 IO함수를 호출하기전에 참조 카운트를 증가시키면 될것입니다. 그리고 진행중 문제가 있어서 반환되거나 제대로 동작해서 마무리가 될때 참조 카운팅을 줄여도 될것입니다. 

그런데 이 방법의 문제가 있다고 한다면 RefCountable을 상속받은 채로 Listener, Session 객체를 만들때 shared_ptr 이나 다른 수단으로 2중 레퍼런스 카운팅을 하게 된다면 
모순이 생길수 있습니다. shared_ptr로 래핑한 시점에서는 IocpObject는 참조 카운트가 0일때 RefCountable에서는 참조 카운트가 1일될것이고 
참조 카운트의 불일치 때문에 이 객체를 삭제할수 있는지 없는지를 판별할수 없게 될겁니다. 

그러면 아예 처음부터 객체를 shared_ptr로 관리한다고 해보면, shared_ptr는 직접적으로 레퍼런스카운트를 증가시키는 방법이 존재 하지 않습니다. 
물론 여러가지 꼼수로 자기자신을 참조하면서 카운트를 늘린다거나 하는 식으로 우회할수는 있지만 깔끔한 방법이라고 볼수는 없습니다. 

보다 직관적인 방법 중 하나는 CreateIoCompletionPort 에서 Key 값을 사용하지 않고 모든 데이터를 IocpEvent에다 물려주는겁니다.
지금까지는 IocpEvent에서는 자신의 타입만 들고 있고 그나마 AcceptEvnet에서나 자신과 연동된 세션의 포인터를 들고 있었는데 
지금부터는 IocpEvent클래스 부터 자기 자신을 만든 주인을 기억하도록 하는겁니다. 

    IocpCore::Register (IocpObject* iocpObject)
{
	// 이제는 Key값을 사용하지 않을것이기 때문에 0으로 밀어줍니다. 
	return ::CreateIoCompletionPort(iocpObject->GetHandle(), _iocpHandle, /*Key*/0 , 0);
}

이전에는 reinterpret_cast<ULONG_PTR>(iocpObject) 로 넣어줬던 Key값 자리에 그냥 0을 넘겨 주었습니다. 마찬가지로 Dispatch 도 수정합니다. 
bool IocpCore::Dispatch(uint32 timeoutMs)
{
	DWORD		numOfBytes = 0;
	// key 값을 사용하지 않게 되면서 의미없는 변수를 만들어 넘겨줍니다. 
	ULONG_PTR	key = 0;
	IocpObject* iocpObject = nullptr;
	IocpEvent*	iocpEvent = nullptr;

	if (::GetQueuedCompletionStatus(_iocpHandle, OUT & numOfBytes, OUT &key, OUT reinterpret_cast<LPOVERLAPPED*>(&iocpEvent), timeoutMs))
	{
        // 이후 생략 
    }
}

어짜피 CreateIoCompletionPort 에서 넘겨주는 키값도 0일것이고 받는 쪽에서도 key값이 0입니다. 
이 상태에서는 IocpEvent를 예약한 Session과 연결고리가 사라졌고 아깔 말했던 대로 IocpEvent에서 Session을 shared_ptr로 들고 있게끔 만들어 주겠습니다. 

그전에 먼저 매번 shared_ptr<IocpObject> 라고 하나하나 타이핑하는것이 귀찮을 수도 있기때문에 
Types.h에 매크로를 만들어 보았습니다. 

// shared_ptr 을 간편히 
using IocpCoreRef = std::shared_ptr<class IocpCore>;
using IocpObjectRef = std::shared_ptr<class IocpObject>;
using SessionRef = std::shared_ptr<class Session>;
using ListenerRef = std::shared_ptr<class Listener>;
using ServerServiceRef = std::shared_ptr<class ServerService>;

하는김에 IocpObject 뿐만아니라 이후로 사용할만한 것들을 미리 만들어 두었고 ServerService는 이번강의 안에 만들 클래스인데 미리 만들었습니다. 

이어서 IocpEvnet 코드를 보겠습니다. 

class IocpEvent : public OVERLAPPED
{
public:
	IocpEvent(EventType type);

	void		Init();

	// private에서 public으로 열어줬는데 멤버 변수에 자주접근할 예정이다 보니 열었습니다.
public:
	EventType	eventType;
	// 이벤트의 주인 객체를 shared_ptr로 들고 있습니다. 
	IocpObjectRef owner;
};

그리고 이전 시간에 AcceptEvent에서도 Session을 생 포인터로 들고 있었는데 SessionRef로 들고 있게 해줬습니다.

class AcceptEvent : public IocpEvent
{
public:
	AcceptEvent() : IocpEvent(EventType::Accept) { }

	
	// 멤버 변수를 그냥 public으로 열어서 직접 건드리겠습니다. 
public:
	// Session을 연동받아서 나중에 이 이벤트가 어떤 세션에 대한 이벤트인지를 기억합니다.
	// shared_ptr로 들고 있게 해서 참조 카운팅을 해줍니다.
	SessionRef	session = nullptr;
};

이제 IocpEvent는 자신의 owner 가 누군지 항상 물고 있어야 하는것입니다. 
일단 owner가 누군지는 물고 있다고 치고 아까 수정하고 있던 IocpCore::Dispatch 코드를 보면 
bool IocpCore::Dispatch(uint32 timeoutMs)
{
	// GetQueuedCompletionStatus에 필요한 인자들
	DWORD		numOfBytes = 0;
	// key 값을 사용하지 않게 되면서 의미없는 변수를 만들어 넘겨줍니다. 
	ULONG_PTR	key = 0;
    // IocpObject = nullptr;  여기있던 IocpObject는 이제 Key로써 사용하지 않기 때문에 없어도 됩니다. 
	IocpEvent*	iocpEvent = nullptr;

	if (::GetQueuedCompletionStatus(_iocpHandle, OUT & numOfBytes, OUT &key, OUT reinterpret_cast<LPOVERLAPPED*>(&iocpEvent), timeoutMs))
	{
        // 여기서 IocpEvent가 이미 물고 있는 owner로 IocpObject를 복원해줍니다. 
		IocpObjectRef iocpObject = iocpEvent->owner;
		iocpObject->Dispatch(iocpEvent, numOfBytes);
	}
    else
	{
		int32 errorCode = ::WSAGetLastError();
		switch (errorCode)
		{
		case WAIT_TIMEOUT:
			return false;
		default:
            // 여기서도 마찬가지로 IocpEvent->owner 로 IocpObjectRef를 복원합니다. 
			IocpObjectRef iocpObject = iocpEvent->owner;
			iocpObject->Dispatch(iocpEvent, numOfBytes);
			break;
		}
	}
	return true;
}


IocpEvent 에서 수정한 코드가 있으니 당연히 프로젝트 이곳저곳에 에러가 발생할것입니다. 찾아서 수정해보겠습니다. 먼저 Listener.cpp 파일입니다. 

void Listener::Dispatch(IocpEvent* iocpEvent, int32 numOfBytes)
{
    // 이전에는 type을 꺼낼때 따로 Get 함수를 사용해서 꺼냈지만 이제는 public으로 열어주면서 eventType 멤버 변수를 직접 꺼낼수 있습니다.
	ASSERT_CRASH(iocpEvent->eventType == EventType::Accept);

	AcceptEvent* acceptEvent = static_cast<AcceptEvent*>(iocpEvent);
	
	ProcessAccept(acceptEvent);
}

void Listener::ProcessAccept(AcceptEvent* acceptEvent)
{
	// 여기서도 마찬가지로 Session을 복원할때 SessionRef를 사용합니다.  
	SessionRef session = acceptEvent->session;

	if (false == SocketUtils::SetUpdateAcceptSocket(session->GetSocket(), _socket))
	{
		RegisterAccept(acceptEvent);
		return;
	}

	SOCKADDR_IN sockAddress;
	int32 sizeOfSockAddr = sizeof(sockAddress);
	if (SOCKET_ERROR == ::getpeername(session->GetSocket(), OUT reinterpret_cast<SOCKADDR*>(&sockAddress), &sizeOfSockAddr))
	{
		RegisterAccept(acceptEvent);
		return;
	}

	session->SetNetAddress(NetAddress(sockAddress));

	cout << "Client Connected!" << endl;


	RegisterAccept(acceptEvent);
}

void Listener::RegisterAccept(AcceptEvent* acceptEvent)
{
    // acceptEvent에서는 Session 포인터를 물고 있었는데 이번에 그냥 생포인터가 아닌 shared_ptr를 사용하는 SessionRef 로 바꾸고 또 public 으로 열면서 직접 꺼낼수도 있게 했었습니다. 
    // 또 shared_ptr 을 사용하면서 동적할당도 표준 make_shared 대신 커스텀 A_new, A_delete를 사용하는 MakeShared 를 사용했습니다. 
	SessionRef session = MakeShared<Session>();
	acceptEvent->Init();
	acceptEvent->session = session;

	DWORD bytesReceived = 0;
	if (false == SocketUtils::AcceptEx(_socket, session->GetSocket(), session->_recvBuffer, 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, OUT & bytesReceived, static_cast<LPOVERLAPPED>(acceptEvent)))
	{
		const int32 errorCode = ::WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			RegisterAccept(acceptEvent);
		}
	}
}

이렇게 수정점이 있었습니다.  

다음으로 볼것은 아까 IocpCore::Dispatch를 수정하면서 일단 IocpEvent가 owner인 IocpObject를 일단 물고 있다고 치고 진행했었습니다.
실제로 어디서 IocpEvent에 IocpObject를 물릴건지를 생각해보겠습니다. 
IocpEvent 란 비동기 IO 함수를 호출하는데 CP에 일감을 꺼내면서 EventType에 따라 동작을 달리해주기 위한 표시와 OVERLAPPED 구조체를 들고 있게 해줄 클래스였습니다. 
여기에 이제 owner 까지 더해진것입니다. 

그러므로 Session이나 Listener 에서 비동기 IO 함수를 호출할때 만들어 인자로 넣어주게되는데 지금 우리 프로젝트에서 사용하고 있는 비동기 IO 함수는 AcceptEx 밖에 없습니다. 

StartAccept 에서 Listener 소켓 생성, 소켓 옵션 설정, 주소 bind, listen, accept까지 해주고 있었습니다. 
AccentEvent 에 owner를 물려주려면 여기서 해야합니다. 

bool Listener::StartAccept(NetAddress netAddress)
{
	_socket = SocketUtils::CreateSocket();
	if (_socket == INVALID_SOCKET)
		return false;

	if (GIocpCore.Register(this) == false)
		return false;

	if (SocketUtils::SetReuseAddress(_socket, true) == false)
		return false;

	if (SocketUtils::SetLinger(_socket, 0, 0) == false)
		return false;

	if (SocketUtils::Bind(_socket, netAddress) == false)
		return false;

	if(SocketUtils::Listen(_socket) == false)
		return false;

	const int32 acceptCount = 1;
	for (int32 i = 0; i < acceptCount; i++)
	{
		AcceptEvent* acceptEvent = A_new<AcceptEvent>();
        /*
		여기서 _acceptEvents에 push_back 하기 전에 this를 acceptEvnet->owner로 넣어줍니다.
		그냥 make_shared로 넣어주면 Sptr이 두개가 생기기 때문에 
		IopcObject에 enable_shared_from_this를 상속 시켜주고 
		shared_from_this() 로 넣어주었습니다. 
		*/
		acceptEvent->owner = shared_from_this();
		_acceptEvents.push_back(acceptEvent);
		RegisterAccept(acceptEvent);
	}

	return false;
}

여기서 _acceptEvents에 push_back 하기 전에 this를 acceptEvnet->owner로 넣어줍니다.
그런데 owner는 share_ptr<IocpObject> 이기 때문에 this 도 shared_ptr<IocpObject>(this); 
이렇게 넣어준면 되지 않나 생각할 수도 있습니다. 하지만 이러면 난리가 납니다. 
위와 같이 shared_ptr을 만들게 되면 이 Listener를 누군가 참조하고 있던 아니던간에 
새로운 share_ptr이 하나 더 생기게 되면서 하나의 Listener를 두개의 shared_ptr이 참조하고 
있는 형태가 될수도 있습니다. 

그러면 어떻게 하느냐 하면 Listener나 Session이나 IocpObject를 상속받습니다. 이 IocpObject에 enable_shared_from_this<Type> 을 상속시켜줍니다. 
enable_shared_from_this<Type> 은 어떻게 되어있는지를 살펴보면 자기 자신에 대한 weak_ptr 을 들고 있습니다. 
즉 사실상 이런코드가 추가되는겁니다. 
class IocpObject
{
private:
	weak_ptr<IocpObject> _Wptr;

// 이하 내용 생략 
}

그리고 자신을 가리키고 있던 weak_ptr에 lock() 이라는 멤버 함수를 호출해주면 가르키던 자신에 대한 shared_ptr을 반환합니다. 
이과정을 enable_shared_from_this 에서는 shared_from_this(); 라는 함수로 꺼낼수 있게 되어있습니다.

이 방법을 꼭 숙지하고 언제든 이렇게 클래스 내부에서 자기자신을 shared_ptr 로 들고 있으려면 enable_shared_from_this를 자연스럽게 사용할 수 있어야합니다. 
맨땅에 해딩한다고 있는 라이브러리를 안쓰고 생포인터로 처음부터 하나씩 만들어 나가는것은 공부용으로는 괜찮지만 실제 업무에서는 시간 낭비가 됩니다. 

이대로 한번더 빌드를 해보면 에러메세지가 뜰텐데 왜냐하면 enable_shared_from_this 를 상속받은 뒤로는 프로젝트 전체에서 IocpObject를 상속받은 객체는 
모두 shared_ptr로 사용해야합니다. 우리 테스트 코드에서는 어느 부분이었냐면 GameServer 의 테스트 코드입니다. 

int main()
{
	// Completion Port에 등록된 중간에 삭제 되지 않기 위해 shared_ptr 로 만듭니다. 
	ListenerRef listener = MakeShared<Listener>();

	// Listener 객체를 shared_ptr로 다루기 시작한 만큼 . 대신 ->을 사용합니다. 
	listener->StartAccept(NetAddress(L"127.0.0.1", 7777));

	for (int32 i = 0; i < 5; i++)
	{
		GThreadManager->Launch([=]()
			{
				while (true)
				{
					GIocpCore.Dispatch();
				}
			});
	}

	GThreadManager->Join();
}

이렇게 해서 지난시간에 문제였지만 그냥 넘어갔던 레퍼런스 카운팅 부분을 이렇게 해결했습니다. 지금은 Listener 만 사용하고 있지만 
나중에 Session도 마찬가지로 SessionRef 로 객체를 만들어야 할것입니다. 

지금은 따로 다루지 않고 있지만 Session이 사실 네트워크 프로그래밍 내용이 50 퍼센트를 차지한다고 할 수 있을정도로 많은 역할을 할것입니다. 
Connect, Send, Recv 등 하는 일이 많기 때문입니다. 그래서 좀 미뤄뒀다가 각잡고 다룰것입니다. 


오늘 내용이 여기서 끝은 아니고 좀 더 다듬어 줄 것이 있습니다. 
IocpCore.h 에서 전역 IocpCore 객체를 만들어 주고 있는데 이 방식이 꼭 문제라기 보다는 IocpCore 같은 IOCP를 다루는 객체가 지금처럼 하나만 사용하는 경우도 있지만
여러 IocpCore객체를 만들어 사용하는 경우도 있다고 합니다. 

또 서버 라이브러리를 만들고 게임서버에서 Listener를 맨처음 딱한번만 만든다고 보장할 수 없습니다. 
이게 무슨 말이냐면 MMORPG 를 서비스한다고 했을때 분산서버를 사용하는 경우가 많습니다. 예를들어 서버각각 게임 플레이 서버, AI서버, DB 관리 서버 로 분리해서 
관리하는 경우도 많은데 
그런 경우에 Listener 도 각 서버마다 담당하기 위해서 붙어야 하고 또 서버 끼리도 데이터를 주고 받아야 합니다. 

네트워크 통신이 꼭 클라이언트 서버간의 통신뿐만아니라 서버간에도 통신이 이뤄지는 경우도 생길수 있다는 것입니다. 

그래서 지금처럼 Listener 객체를 직접 작성해 만들기 보다는 묶어서 관리하는 방법이 좋습니다. 
지금같은 경우에는 Listener 객체를 IocpCore에 강제로 밀어넣고 Session도 따로 돌아다니고 있고 심지어 나중에 깨닿게 될만한 문제인데 
Listener::RegisterAccept 를 할때 session을 직접 만들고 그 세션은 acceptEvent에 물리기도 하고 클라이언트 소켓으로 쓰기도 합니다.

이 Session 클래스는 ServerCore 프로젝트에서 관리하고 있는 클래스입니다. 하지만 컨텐츠 단에서는 이 Session을 어떻게 활용할지 정해지지 않았습니다.
예를들어서 게임서버에서는 이 Session 을 상속받아서 GameSession 이런식으로 확장해서 넣고 싶은 정보들을 추가하고 SessionManager를 만들어 세션들을 관리하는 식으로
한다면 다양한 형태의 Session을 사용할 수 있는데 이럴때 지금처럼 Listener::RegisterAccept 안에서 그냥 기본 Session을 만들어 사용한다거나 하는건 
정상적인 라이브러리라고 볼 수 없는것입니다. 

그래서 함수 내부에서 세션을 만들어 주는것도 커스터마이징 할 수 있도록 결정할수 있어야 합니다. 

지금말한 이런저런 내용들을 한곳에 모아서 관리하는것을 Service라는 이름으로 부른다고 합니다. 

***

-- Service
ServerCore 프로젝트 Network 필터 아래에 Service라는 cpp,h 파일을 만들었습니다.
이 Service 라는 것은 네트워크 서비스인것은 맞지만 클라이언트 서비스 일 수도 있고 서버 서비스 일 수도 있습니다. 
심지어 같은 역할의 서비스라고 해도 정책이 갈릴수도 있습니다. 예를들어 한번 연결시도 후 실패했을때 5초마다 반복해서 시도하게끔 한다던가
아니면 한번 연결시도해서 실패하면 바로 멈춘다건나 하는 정책이 갈릴 수 있습니다. 

기본이 되는 서비스 클래스 입니다. 

// 일단 서비스 타입은 서버, 클라 두가지가 있습니다.
enum class ServiceType : uint8
{
	Server,
	Client,
};

/*
------------------
	Service 선언부 
------------------
*/

/*
std::function 클래스는 함수 포인터, 함수 객체를 만듭니다.
<> 안에 들어오는 타입을 반환하고 () 안에는 어떤 인자를 받아주는지를 뜻합니다.
밑의 코드의 의미는 앞으로 
SessionFactory() 을 호출하면 SessionRef 객체를 생성해줍니다.
*/
using SessionFactory = function<SessionRef(void)>;

class Service : public enable_shared_from_this<Service>
{
public:
	// 인자목록이 많습니다.
	// 1) 이 서비스가 어떤 타입의 서비스인지
	// 2) 주소 구조체인데 서버는 자신의 주소, 클라이언트의 경우는 접속하려는 서버의 주소
	// 3) IocpCore의 Shared_ptr, IocpCore를 꼭 하나만 사용하지는 않을것이기 때문에 어떤 코어를 사용할지를 받습니다. 
	// 4) SeesionFactory 라고 세션을 만들어주는 함수를 받습니다. 
	// 5) 마지막으로 최대 세션은 몇개인가? 최대 동접수를 정해줍니다.
	Service(ServiceType type, NetAddress address, IocpCoreRef core, SessionFactory factory, int32 maxSessionCount = 1);
	virtual ~Service();

	virtual bool	Start() abstract;
	// CanStart의 조건으로 일단 _sessionFactory가 있는지만 체크하겠습니다. 
	bool			CanStart() { return _sessionFactory != nullptr; }

	virtual void	CloseService();
	// SetSessionFactory 는 생성자에서 넣어줬던 SessionFactory가 맘에 안들면 새로 설정해줍니다.
	void			SetSessionFactory(SessionFactory func) { _sessionFactory = func; }

	// 새로 세션을 만들어 줌과 동시에 IocpCore에 등록해줍니다. 
	SessionRef		CreateSession();
	// 이미 만들어진 세션을 추가하는 함수
	void			AddSession(SessionRef session); 
	// 어떤 세션을 더이상 사용하지 않는다고할때 꺼내주는 함수
	void			ReleaseSession(SessionRef session);
	int32			GetCurrentSessionCount() { return _sessionCount; }
	int32			GetMaxSessionCount() { return _maxSessionCount; }

public:
	ServiceType		GetServiceType() { return _type; }
	NetAddress		GetNetAddress() { return _netAddress; }
	// GetIocpCore만 반환타입을 참조값으로 했는데 괜히 IocpCore 객체의 참조 카운트를 늘리지 않기 위함
	// IocpCore를 외부에서 꺼내는 동작을 자주하게 될것인데 그러면 딱히 사용하지 않아도 참조 카운트가 메모리를 점유하고 있습니다. 
	IocpCoreRef&	GetIocpCore() { return _iocpCore; }

protected:
	// 멤버 변수들 
	USE_LOCK;	// 여러 스레드에서 sessions에 접근할것이니 락을 사용할것입니다.

	// 생성자에서 받는 인자들을 저장할 변수들 
	ServiceType		_type;
	NetAddress		_netAddress = {};
	IocpCoreRef		_iocpCore;

	Set<SessionRef> _sessions;
	int32			_sessionCount = 0;	// 테스트 출력할때 사용할 지금 사용하는 세션의 수
	int32			_maxSessionCount = 0;	// 최대 동접수 
	SessionFactory	_sessionFactory;
};


/*
------------------
	Service 정의부
------------------
*/
Service::Service(ServiceType type, NetAddress address, IocpCoreRef core, SessionFactory factory, int32 maxSessionCount)
	: _type(type), _netAddress(address), _iocpCore(core), _sessionFactory(factory), _maxSessionCount(maxSessionCount)
{
}

Service::~Service()
{
}

bool Service::Start()
{
	return false;
}

void Service::CloseService()
{
	// TODO
}

SessionRef Service::CreateSession()
{
	SessionRef session = _sessionFactory();
	if (_iocpCore->Register(session) == false)
		return nullptr;
	return session;
}

void Service::AddSession(SessionRef session)
{
	// _sessions 를 여러스레드에서 접근할것입니다. 
	WRITE_LOCK;
	_sessionCount++;
	_sessions.insert(session);
}

void Service::ReleaseSession(SessionRef session)
{
	WRITE_LOCK;
	
	ASSERT_CRASH(_sessions.erase(session) != 0);
	_sessionCount--;
}

이렇게 일단 만들고 나중에 수정할 일이 있으면 수정하겠습니다. 
위의 기본 서비스는 그냥 이대로는 사용할 수 없고 ClientService, ServerService 라고 위의 Service 클래스를 상속받아서 사용할겁니다. 

먼저 ClientService 를 만들어 주겠습니다. 그냥 형태만 만들어 두고 구현은 나중에 할것입니다. 

/*
--------------------------
	ClientService 선언부
--------------------------
*/

class ClientService : public Service
{
public:
	ClientService(NetAddress targetAddress, IocpCoreRef core, SessionFactory factory, int32 maxSessionCount = 1);
	virtual ~ClientService() {}

	virtual bool Start() override;
};
/*
--------------------------
	ClientService 정의부
--------------------------
*/
// 생성자 인자를 대부분 그대로 넘겨주면 됩니다. 
ClientService::ClientService(NetAddress targetAddress, IocpCoreRef core, SessionFactory factory, int32 maxSessionCount)
	: Service(ServiceType::Client, targetAddress, core, factory, maxSessionCount) 
{
}

bool ClientService::Start()
{
	//TODO
	return true;
}


다음은 오늘의 주제인 ServerService입니다. 
선언부의 내용이 ClientService 와 비슷한데 다른점은 서버쪽에서 사용할 서비스이다보니 Listener를 들고 있을겁니다. 
/*
--------------------------
	ServerService 선언부
--------------------------
*/

class ServerService : public Service
{
public:
	ServerService(NetAddress address, IocpCoreRef core, SessionFactory factory, int32 maxSessionCount = 1);
	virtual ~ServerService() {}

	virtual bool Start() override;
	virtual void CloseService() override;
private:
	ListenerRef _listener = nullptr;
};

/*
--------------------------
	ServerService 정의부
--------------------------
*/
ServerService::ServerService(NetAddress address, IocpCoreRef core, SessionFactory factory, int32 maxSessionCount)
	:Service(ServiceType::Server, address, core, factory, maxSessionCount)
{
}

bool ServerService::Start()
{
	// ServerService가 시작할수 있는지 체크
	if (CanStart() == false)
		return false;
	
	// 서버쪽 서비스인만큼 listener를 가지고 있습니다. 
	_listener = MakeShared<Listener>(); 
	if (_listener == nullptr)
		return false;

	// 이제부터는 Listener::StartAccept 의 인자로 NetAddress를 직접 받지 않고 ServerServicr의 멤버변수로써의
	// NetAddress를 사용할겁니다. 즉, 여기서는 ServerService 자기 자신의 shared_ptr을 인자로 줍니다.
	// 그러기 위해서 shared_from_this를 호출하려고 하는데 부모 클래스인 Service의 shrard_ptr로 반환이된다고 합니다. 
	// 그래서 캐스팅을 통해 ServerService로 바꿔줍니다. 
	ServerServiceRef service = static_pointer_cast<ServerService>(shared_from_this());
	if (_listener->StartAccept(service) == false)
		return false;

	return true;
}

void ServerService::CloseService()
{
	// TODO
	Service::CloseService();
}


다음은 ServerService::Start() 내부에서 소출한 Listener::StartAccept를 수정해야합니다. 이전까지는 NetAddress를 인자로 받아 사용했지만 
이제부터는 ServerServiceRef를 인자로 받고 그 안에 있는 NetAddress 를 추출해 사용하는 식으로 사용할겁니다.

Listener 파일에 새로운 멤버 변수로 _service 를 추가했습니다. 

// StartAccept 에서 받은 ServerService를 변수로 들고 있을겁니다.
// 하지만 ServerService 에서도 Listener를 들고 있고 여기서도 ServerService를 들고 있게되면 
// shared_ptr 로는 서로 순환 문제를 격을 수 있습니다. 이걸 유념해서 구현하겠습니다. 
ServerServiceRef _service;

// Listener를 만든 다음 그 소켓으로 Accept를 호출합니다.
bool Listener::StartAccept(ServerServiceRef service)
{
	// _service를 채워줍니다. 
	_service = service;
	if (_service == nullptr)
		return false;

	_socket = SocketUtils::CreateSocket();
	if (_socket == INVALID_SOCKET)
		return false;
 
	/*
	지금까지는 임시로 IocpCore 객체를 그냥 extern 으로 만들고 있었는데 이부분을 수정해주겠습니다. 
	IocpCore 클래스에서 삭제를 했지만 이제는 _service에서 꺼내 사용할 수 있습니다. 
	그리고 IocpCore->Register() 의 인자로 그냥 this 를 넘겨주면 안되고 
	shared_from_this() 로 넘겨줘야합니다 
	*/
	if (_service->GetIocpCore()->Register(shared_from_this()) == false)
		return false;


	if (SocketUtils::SetReuseAddress(_socket, true) == false)
		return false;

	if (SocketUtils::SetLinger(_socket, 0, 0) == false)
		return false;

	// NetAddress 를 _service로 부터 꺼냅니다.
	if (SocketUtils::Bind(_socket, _service->GetNetAddress()) == false)
		return false;

	if(SocketUtils::Listen(_socket) == false)
		return false;

	// 이제 acceptCount도 ServerService의 maxSessionCount 값으로 주겠습니다. 
	const int32 acceptCount = _service->GetMaxSessionCount();
	for (int32 i = 0; i < acceptCount; i++)
	{
		AcceptEvent* acceptEvent = A_new<AcceptEvent>();
		acceptEvent->owner = shared_from_this();
		_acceptEvents.push_back(acceptEvent);
		RegisterAccept(acceptEvent);
	}
	return false;
}

Listener 에서 _service 를 활용하기 시작하면서 IocpCore 파일에 임시로 만들었던 

	extern IocpCore GIocpCore; 

는 삭제했습니다. 나중에 ServerService를 만들면서 IocpCore 객체를 세팅해주면 됩니다. 

또 중요했던게 Listener::RegisterAccept 함수입니다. 이 함수 내부에서 Session을 acceptEvent 에 연동하기위해 그냥 생으로 MakeShared로 생성했었습니다. 
이제부터는 _service->CreateSession() 으로 세션을 생성과 동시에 CP에도 등록을 해줍니다. 
이 방식에 좋은점이 또 있는데 위에서 다중 서버를 운영할때 각 서버의 Listener 의 Session을 한번에 수정하기가 어렵다고 했습니다. 
하지만 ServerService로 생성하는 Session 객체는 ServerService에서 코드를 고치면 일괄적으로 적용이 되기 때문에 관리하기 좋습니다. 

void Listener::RegisterAccept(AcceptEvent* acceptEvent)
{
	// 이전 MakeShared 로 생성해주던 session 객체는 _service->CreateSession() 으로 대체합니다.
	// CreateSession() 에서는 객체 생성뿐만아니라 그 세션을 CP에 등록까지 해줍니다. 
	SessionRef session = _service->CreateSession();
	acceptEvent->Init();
	acceptEvent->session = session;

	DWORD bytesReceived = 0;
	if (false == SocketUtils::AcceptEx(_socket, session->GetSocket(), session->_recvBuffer, 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, OUT & bytesReceived, static_cast<LPOVERLAPPED>(acceptEvent)))
	{
		// 실패했으면 에러코드를 봅니다.
		const int32 errorCode = ::WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			// Pending 상태가 아니라면 문제가 있는 상황입니다.
			// 이경우에는 RegisterAccept 호출하던게 끊긴 상황이니 직접 다시 걸어줘야 합니다.
			RegisterAccept(acceptEvent);
		}
	}
}


아직 처리하지 않은 부분은 IocpCore::Register 함수입니다. Service::CreateSession() 함수 내부에서 세션 생성과 함께 CP에 등록할때 그냥 생포인터 Session 객체가 아닌 
shared_ptr Session 을 넘겨주려고 합니다. 

IocpObject 는 이미 enable_shared_from_this를 사용하면서 shared_ptr로 사용하기로 했기 때문에 전 프로젝트에서 모두 shared_ptr로 받아줘야 합니다. 

bool IocpCore::Register(IocpObjectRef iocpObject)
{
	return ::CreateIoCompletionPort(iocpObject->GetHandle(), _iocpHandle, /*Key*/0 , 0);
}

***

이제 ServerService를 적용하는것은 끝이 났고 그러면 어떻게 사용해야하는지를 보겠습니다. 

GameServer.cpp 에서 테스트를 할것인데 
이전에는 Listener 객체를 직접 만들던 부분을 지금 부터는 ServerService객체를 만들면서 사용할것입니다. 

그전에 먼저 ServerService 의 생성자에서는 여러 인자들을 받아주고 있었고 또 share_ptr 인 만큼 MakeShared를 사용해 생성할것입니다. 
하지만 MakeShared 는 우리가 커스텀한 할당자 해제자를 사용하기 위해 만든 함수였습니다. 그리고 인자를 받지않는 기본 생성자 버전밖에 만들어 놓지 않았기때문에 
이번에 인자도 받는 버전의 MakeShared를 만들어 보겠습니다. 

Memory.h 파일에 정의 되어있던 MakeShared는 이렇습니다. 
template<typename Type>
shared_ptr<Type> MakeShared()
{
	return shared_ptr<Type>{ A_new<Type>(), A_delete<Type> };
}

템플릿에 Variadic Template 가변 길이 템플릿 이라고 하는 문법을 적용하겠습니다. 
template<typename T, typename... Args> 이런식으로 Arg가 가변길이 템플릿입니다. 아예 없을수도 있고 추가하자면 계속 늘일수 있는 템플릿입니다. 
이걸 MakeShared 의 인자쪽에도 받도록 하고  민의 A_new 의 인자안에도 추가해야합니다. 
여기서 A_new 안에 인자로 줄때는 std::forword<Arg>(arg)...  이렇게 줘야합니다.

즉, 이렇게 수정했습니다. 따로 만들 필요없이 그냥 Variadic Template 를 적용해도 기존방식대로도 사용할 수 있습니다. 

template<typename Type, typename... Args>
shared_ptr<Type> MakeShared(Args&&... args)
{
	return shared_ptr<Type>{ A_new<Type>(std::forward<Args>(args)...), A_delete<Type> };
}

추가적으로 메모리 풀링을 하기위해 만들었던 ObjectPool.h 에서도 자신만의 MakeShared 를 만들었었는데 겸사 겸사 같이 수정해줍니다. 

class ObjectPool
{
	// 생략

	template<typename... Arg>
	static shared_ptr<Type> MakeShared(Arg&&... arg)
	{
		shared_ptr<Type> ptr = { Pop(std::forward<Arg>(arg)...), Push };

		return ptr;
	}

	// 생략 
}

이제 MakeShared 가 준비 되었으니 마저 ServerService를 만들어 보겠습니다. 

/*
ServerServiceRef 를 동적생성할때 3번째 인자로 MakeShared<Session> 이렇게 ()없이 넘겨줍니다. 
이것은 MakeShared의 반환값을 넘겨주는게 아니라 이렇게 생성하는 함수자체를 인자로 넘겨주고 
이걸 함수 포인터라고 하고 우리 Service 클래스에서는 SessionFactory라고 불렀습니다. 

이런식으로 함수포인터를넘겨주는 이득은 나중에 Session을 상속받은 또다른 클래스를 넘겨줄 수 있다는 것입니다. 
예를들어 
class GameSession : public Session
{
}
이때 MakeShared<GameSession> 을 넘겨줄 수도 있습니다. 
*/

int main()
{	
	// 이제 부터 Listener를 직접 만들어 주지 않고 ServerService를 만들어 줄겁니다. 
	// ListenerRef listener = MakeShared<Listener>();
	// Service 객체들은 여러 인자들을 받아주었었는데 우리가 만들었던 MakeShared 에서는 인자를 받지 않는 기본 생성자 버전만 있었습니다. 
	// 그래서 추가했습니다.
	// 인자들은 순서대로 NetAddress, IocpCore 객체, SessionFactory, MaxSessionCount 입니다.
	ServerServiceRef service = MakeShared<ServerService>(
		NetAddress(L"127.0.0.1", 7777),
		 MakeShared<IocpCore>(),
		MakeShared<Session>,
		100);

	// service를 만들었으면 Start를합니다. 여기서 해주는것은 Listener 객체를 만들고 
	// 그 Listener 의 멤버 함수인 StartAccept를 자기자신을 넘겨주면서 AccpetEx를 호출합니다. 
	ASSERT_CRASH(service->Start());

	for (int32 i = 0; i < 5; i++)
	{
		GThreadManager->Launch([=]()
			{
				while (true)
				{
					service->GetIocpCore()->Dispatch();
				}
			});
	}

	GThreadManager->Join();
}

이제 테스트를 진행 해볼 차례입니다. 

하지만 위의 ASSERT_CRASH 에서 예외가 발생했습니다. 한번 들여다 보겠습니다. 쭉 진행하다가 어디서 크래시가 나는지를 살펴보니까 
Listener::StartAccept() 의 코드중 맨 마지막에 반환을 false로 해둬서 무조건 크래시가 날 수 밖에 없었습니다. true로 바꿔줬습니다. 

다시 테스트 시도해보면 잘 연결되는걸 볼 수 있습니다. 

사실 이전 시간에 비해 동작 자체는 바뀐게 없지만 구조를 좀더 다듬어서 share_ptr 를 사용할 수 있도록 수정하고 
NetAddress, IocpCore, SessionFactory 등을 한번에 관리할수 있는 Service를 도입한것입니다. 

이제 가장 기본이 되는 구조를 만들었습니다. 

세션을 지금은 Listener::RegisterAccept 함수의 시작부분에서 CreateSession으로 만들어 주고 있습니다. 꼭 이렇게 하지 않고 여기서는 소켓만 만들고 
ProcessAccept 에서 세션을 만들어도 됩니다. 이건 선택의 문제이고 우리 프로젝트에서는 RegisterAccept 에서 세션을 만드는 방식으로 갈겁니다 .

또 CreateSession 에서 세션을 만드는것 뿐만아니라 만듦과 동시에 IOCP에 등록을 해주고 있습니다.
그러다 보니 이 Session을 이용해 Recv를 호출하거나 Send를 호출하게 되면 알아서 IOCP에 일감이 등록됩니다. 
일감을 관찰하면서 실제 동작하게 되는 Session::Dispatch 에서 이제 Recv, Send를 처리해주게 될것입니다. 