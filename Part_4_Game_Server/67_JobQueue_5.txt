


        JobQueue 5


지난 시간까지 내용을 요약해보면 잡큐에 일감을 밀어 넣음과 동시에 만약에 내가 처음으로 잡을 밀어넣은 스레드라고 하면 실행까지 내가 담당하도록 만들어 줬습니다.
이렇게 만들면 따로 실행을 담당하는 스레드가 있는게 아니라 잡을 밀어 넣는 스레드 중 상황에 맞는 스레드가 할당 되도록 해서 관리가 좀 더 쉽게 만들었습니다. 

하지만 이 방법도 아쉬운점이 있다고 했습니다. 
첫번째로는 일감이 너무 많이 몰렸을때 일감을 실행하는 속도 보다 일감이 쌓이는 속도가 더 빠르게 되면 
한번 실행 함수로 들어간 스레드는 사실상 다시 실행 담당 스레드가 되면서 균등하게 부하가 걸리는게 아닌 어느곳에만 부하가 걸리는 상황이 될겁니다.
두번째가 더 큰 문제인데 내가 어떤 Job을 Execute 하다가 내부에서 또 다른 Job의 Execute를 하게 이어지고 이게 반복된다면 하나의 잡 큐를 실행하려다 
여러 잡큐의 Execute를 호출해 하나의 스레드가 전부 감당해야 할 수 있습니다. 
하나의 스레드가 한 50개의 잡큐를 선점하는동안 다른 스레드들은 그 잡큐들에는 잡을 밀어넣기밖에 못하고 하나의 스레드가 모두 감당하는건 낭비일 수 밖에 없습니다. 

우리가 원하는것은 모든 스레드가 균등하게 일감을 부여받아 일하는걸 원하는겁니다.

이 상황을 어떻게 해결할지 생각해보자면 여러 방법중 가장 간단한 방법은 
내가 현재 잡큐를 호출하고 있는지 아닌지를 추적해서 이미 호출하고 있는 상태라면 설령 내가 어떤 잡큐에 처음으로 일감을 넣었다고 해도 당장 Execute하지 않고 
다른 스레드에 떠넘기게 될겁니다.

***

그래서 이번시간에 새로운 클래스 파일들을 추가할건데 일단 이름은 GlobalQueue 라고 하겠습니다. 
내용은 별건 없을겁니다. 

/*----------------------
	GlobalQueue
-----------------------*/
class GlobalQueue
{
public:
	GlobalQueue();
	~GlobalQueue();

	void Push(JobQueueRef jobQueue);
	JobQueueRef Pop();
private:
	LockQueue<JobQueueRef> _jobQueues;

};

생성자 소멸자는 일단 만들어 두고 Push와 Pop이 있는데 JobQueueRef 를 LockQueue로 관리하는 형태입니다. 
여기서 JobQueueRef 는 또 Types.h 에 추가해줘야합니다. 그런데 지금껏 많은 shared_ptr 매크로를 만들어 왔는데 계속 직접 하나하나 추가하는 방법도 있지만 자동화 하는 방법도 있습니다. 

#define USING_SHARED_PTR(name) using name##Ref = std::shared_ptr<class name>;

이런 define을 추가하는겁니다. USING_SHARED_PTR(name) 여기서 name에 새로 shared_ptr 매크로를 만들 클래스의 이름을 넣어줍니다. 
그러면 뒤의 using 문 에서 name 위치에 대입되고 이어서 다른 문자열이 올경우 (여기서는 클래스 명 뒤의 Ref) ## 을 붙혀 구분을 해줍니다. 

예를 들어서 
USING_SHARED_PTR(IocpCore);

이렇게만 만들면 이전 코드인 
using IocpCoreRef			= std::shared_ptr<class IocpCore>;

이 코드와 똑같은 의미를 지닙니다. 

기왕 매크로를 만든 김에 기존 코드들을 바꿔 보겠습니다. 

USING_SHARED_PTR(IocpCore);
USING_SHARED_PTR(IocpObject);
USING_SHARED_PTR(Session);
USING_SHARED_PTR(PacketSession);
USING_SHARED_PTR(Listener);
USING_SHARED_PTR(ServerService);
USING_SHARED_PTR(ClientService);
USING_SHARED_PTR(SendBuffer);
USING_SHARED_PTR(SendBufferChunk);
USING_SHARED_PTR(Job);
USING_SHARED_PTR(JobQueue);

그건 그렇고 다시 GlobalQueue 코드로 돌아가보겠습니다. 

코드를 보면 job 이 아니라 JobQueue 자체를 담아 뒀다가 다른 스레드에서 이어받아 실행하도록 해준다는것이 컨샙입니다.

구현부도 간단합니다.

GlobalQueue::GlobalQueue()
{
}

GlobalQueue::~GlobalQueue()
{
}

void GlobalQueue::Push(JobQueueRef jobQueue)
{
	_jobQueues.Push(jobQueue);
}

JobQueueRef GlobalQueue::Pop()
{
	return _jobQueues.Pop();
}

이전시간에 만들었던 LockQueue의 기능을 그대로 사용하고 있습니다.

그리고 GlobalQueue 라는 이름답게 전역으로 사용할것입니다. 그 이유는 나중에 나올것인데 
전역으로 사용하는 객체들은 CoreGlobal에서 관리하고 있었으니 추가해줍니다. 

-- CoreGlobal.h
#pragma once

extern class ThreadManager*		GThreadManager;
extern class Memory*			GMemory;
extern class SendBufferManager* GSendBufferManager;
extern class GlobalQueue*		GGlobalQueue;

extern class DeadLockProfiler*	GDeadLockProfiler;

-- CoreGlobal.cpp
#include "pch.h"
#include "CoreGlobal.h"
#include "ThreadManager.h"
#include "Memory.h"
#include "DeadLockProfiler.h"
#include "SocketUtils.h"
#include "SendBuffer.h"
#include "GlobalQueue.h"

ThreadManager*		GThreadManager = nullptr;
Memory*				GMemory = nullptr;
SendBufferManager*	GSendBufferManager = nullptr;
GlobalQueue*		GGlobalQueue = nullptr;

DeadLockProfiler*	GDeadLockProfiler = nullptr;

class CoreGlobal
{
public:
	CoreGlobal()
	{
		GThreadManager = new ThreadManager();
		GMemory = new Memory();
		GSendBufferManager = new SendBufferManager();
		GGlobalQueue = new GlobalQueue();
		GDeadLockProfiler = new DeadLockProfiler();
		SocketUtils::Init();
	}

	~CoreGlobal()
	{
		delete GThreadManager;
		delete GMemory;
		delete GSendBufferManager;
		delete GGlobalQueue;
		delete GDeadLockProfiler;
		SocketUtils::Clear();
	}

} GCoreGlobal;

그리고 한가지 준비가 더 필요한데 TLS 영역에 추가할겁니다. 

-- CoreTLS.h
#pragma once
#include <stack>


extern thread_local uint32				LThreadId;
extern thread_local std::stack<int32>	LLockStack;
extern thread_local SendBufferChunkRef	LSendBufferChunk;
extern thread_local class JobQueue*		LCurrentJobQueue;

-- CoreTLS.cpp
#include "pch.h"
#include "CoreTLS.h"

thread_local uint32 LThreadId = 0;
thread_local std::stack<int32>	LLockStack;
thread_local SendBufferChunkRef	LSendBufferChunk;
thread_local JobQueue* LCurrentJobQueue = nullptr;

다시 JobQueue 로 돌아가 보겠습니다. 
어떻게 해줄거냐면 이전에는 JobQueue에 Job을 밀어넣을때 prevCount라고 지금까지 JobQueue에 일감이 몇개나 있었는지를 뜻하는 변수가 있었습니다. 
그 prevCount가 0일때 즉 내가 가장 처음들어 왔다면 바로 Execute() 를 호출해주고 있었는데 이제는 그렇게하지않고 먼저 조건을 체크합니다.


void JobQueue::Push(JobRef&& job)
{
	const int32 prevCount = _jobCount.fetch_add(1);
	_jobs.Push(job); // WRITE_LOCK

	// 첫번째 Job을 넣은 스레드가 실행까지 담당
	if (prevCount == 0)
	{
		// 이미 실행중인 JobQueue가 없으면 실행
		if (LCurrentJobQueue == nullptr)
		{
			Execute();
		}
		else
		{
			// 여유 있는 다른 스레드가 실행하도록 GlobalQueue에 넘긴다
			GGlobalQueue->Push(shared_from_this());
		}
	}
}

만약 현재 실행중인 잡큐가 없어서 Execute로 들어갔을 경우는 함수 시작시 이제 잡큐를 실행하고 있다고 표시해줍니다.
그리고 Execute가 종료 할때는 다시 호출이 끝났다고 밀어줍니다.
void JobQueue::Execute()
{
	LCurrentJobQueue = this;

	while (true)
	{
		Vector<JobRef>	jobs;
		_jobs.PopAll(jobs);

		const int32 jobCount = static_cast<int32>(jobs.size());
		for (int32 i = 0; i < jobCount; i++)
			jobs[i]->Execute();

		// 남은 일감이 0개 라면 종료
		if (_jobCount.fetch_sub(jobCount) == jobCount)
		{
			LCurrentJobQueue = nullptr;
			return;
		}
	}
}


여기까지는 알겠는데 Push에서 GlobalQueue에 밀어넣은 JobQueue는 결국 누군가는 실행해줘야 할겁니다. 
물론 여러가지 방법이 있을텐데 이번시간에는 그 중 간단하고 효과적인 방법을 알아보겠습니다.

먼저 ThreadManager 쪽에서 함수를 하나 만들어 줄겁니다. 

-- ThreadManager.h

	static void DoGlobalQueueWork();

이런 멤버 함수를 하나 추가했습니다. 
글로벌 큐의 일을 하겠다 라는 뜻입니다. 

-- ThreadManager.cpp

void ThreadManager::DoGlobalQueueWork()
{
	while (true)
	{
		uint64 now = ::GetTickCount64();

		if (now > LEndTickCount)
			break;

		JobQueueRef jobQueue = GGlobalQueue->Pop();
		if (jobQueue == nullptr)
			break;

		jobQueue->Execute();
	}
}

어떤 식이나면 이 DoGlobalQueueWork을 호출하면 무한루프를 돌면서 GCoreGlobal에서 Pop 한 JobQueue를 실행할것입니다. 
하지만 무제한으로 실행하지는 않고 제한시간을 둘건데 그것을 LEndTickCount 만큼을 제한시간으로 둘겁니다. 
이 LEndTickCount는 각 스레드의 로컬저장소 TLS에 들고 있게 해줬습니다. 
위의 코드를 작업하면서 몇가지 에러가 

제한시간이 넘지 않았다면 JobQueueRef 를 꺼내와 nullptr 인지 체크후 실행합니다. 

***

다시한번 순서대로 훑어보겠습니다. 
원래는 어떤 스레드에서 일감을 Push 하면서 처음으로 밀어 넣는 스레드라면 바로 Execute를 호출하게 되고 이미 다른 다른 JobQueue를 실행중에 들어온 차이면 
이 JobQueue는 GGlobalQueue에 Push 해주고 나갑니다. 
이렇게 GGlobalQueue에 들어온 JobQueue는 다른 누군가가 챙겨서 실행해주는 흐름입니다. 

그럼 누군가 GlobalQueue를 챙겨주는 ThreadManager::DoGlobalQueueWork 은 어디서 호출해줄것인지는 다시 서버쪽으로 가보겠습니다. 

-- GameServer.cpp

여기서 지금까지 ClientPacketHandler도 초기화 하고 ServerService 도 생성해 실행하면서 워커 스레드들을 만들어 service->GetIocpCore()->Dispatch() 
를 통해 워커스레드들이 클라이언트에서 들어오는 send 나 recv 같은 iocoEvent가 있는지를 체크하고 있었습니다. 

여기에 GGlobalQueue에서 꺼낸 JobQueue를 실행해줄 스레드를 찾아 맞겨야 합니다. 

먼저 main 함수 위에서 새로 함수를 하나 만들어 줄건데 이름은 DoWorkerJob입니다. 이 함수는 인자로 ServerService& 를 받아줍니다. 무한 루프를 돕니다.
그리고 이제 LEndTickCount을 설정 해줄겁니다. 직접 하드 코딩하기 보다는 위에서 Enum으로 WORKER_TICK을 64라고 하고 
LEndTickCount은 GetTickCount64 + WORKER_TICK 으로 설정해주었습니다. 

다음 부분이 중요한데 원래 지금까지 일감을 어떻게 처리하고 있었냐면 워커 스레드를 람다식으로 만들면서 ServerService->GetIocpCore()->Dispatch(); 
를 호출해주고 있었습니다. 이 Dispatch가 무엇인지 핵심은 GetQueueCompletionStatus를 호출하면서 대기를 하는데 
Iocp에 있는 Recv나 Send 같은 네트워크 입출력 이벤트가 통과 되었다면 빠져나와 입출력 이벤트가 물고 있는 owner IocpObject->Dispatch() 를 호출하고 있었습니다.
이 IocpObject->Dispatch() 를 호출해 타고 들어가 보면 Session 그 중에서도 PacketSession의 OnRecv 로 타고 들어가 받은 버퍼와 패킷헤더의 사이즈를 비교도 하고 
헤더를 때서 컨텐츠 코드 쪽으로 넘어 갔습니다. 

이 긴 작업의 시작은 워커 스레드 에서 호출하던 IocpCore->Dispatch() 였습니다. 이 것을 지금 만드는 DoWorkerJob 에서 호출해줄건데 
지금은 우리가 네트워크 입출력 처리를 위해 호출하고 있었고 그게 겸사 겸사 인게임 로직까지 호출하고 있던 상황입니다. 

이 부분은 여러 가지 방법이 있습니다. 어떤 프로젝트에서는 Dispatch로 입출력 처리를 한 다음 패킷을 파싱하고 Room에 Job을 넣어주고 빠져 나오는 식으로 구현하는 경우도 있습니다.
즉, 네트워크 전달만 담당하는 스레드를 배치하고 인게임 로직을 담당하는 스레드는 따로 담당하도록 굴릴 수 있습니다. 

우리 프로젝트에서는 서버에서 5개의 스레드만 사용하고 있는데 나중에 컴퓨터 CPU 사양에 따라 스레드를 10개 20개 까지 사용할 수 있을겁니다.
그러면 진짜 중요한부분은 이 스레드들을 어떻게 관리해서 일감을 어떻게 적절히 분배할 것인지가 되는겁니다.

우리는 이 여러 방식중 네트워크 입출력 처리와 인게임 로직을 한번에 처리하는 방식인겁니다. 
이 방식에서도 문제가 있는데 지금 코드에서는 IocpCore->Dispatch의 인자인 timeOut 값을 기본값인 무한대로 넣고 있습니다. 
이것은 네트워크 입출력 함수를 관찰하는 함수인 GetQueueCompletionStatus에서 따로 빠져나올 시간을 정하지 않고 무작정 기다릴것이란 말입니다. 

이번에 IocpCore->Dispatch() 에 timeOut 값을 10 을 줄겁니다. 그러면 GetQueueCompletionStatus에서 무한정 대기하지 않고 10이라는 시간동안 빠져나온 네트워크 입출력 이벤트가 없다면 
else 문으로 빠지고 WSAGetLastError() 로 가져온 에러 코드가 WAIT_TIMEOUT 으로 뜨고 IocpCore->Dispatch() 를 빠져나오게 됩니다.

이렇게 시간이 되면 빠져나오게 유도를 할 수 있습니다. 
왜 이 Dispatch를 빠져나와야 하냐면 사실은 Room을 살펴보면 지금까지는 간단한 채팅 프로그램만 만들고 있었으니까 네트워크 입출력 명령이 Room의 Enter, Leave, Broadcast 같은 작업만 했었지만
나중에 진짜 MMO게임의 Room 이라고 가정하면 패킷을 받아 처리하는 기능뿐 만 아니라 Room 자체적으로 계속 로직을 돌려야 하는 기능이 생길겁니다. 
예를 들어서 Room안에 몬스터가 있다거나 아니면 날아가는중인 화살이 있다고 했을때 그런 경우 딱히 그 오브젝트가 움직이는걸 클라이언트에서 패킷을 받아 처리하는게 아니라 
룸을 뺑뺑이 돌면서 그 로직을 실행 시켜야 합니다. 결국 룸의 모든 기능이 네트워크단에서 받은 패킷만으로 모든 기능을 처리 할 수 없다는 말입니다. 
누군가는 JobQueue를 추적하면서 호출해줄 필요가 있습니다.

그래서 DoWorkerJob 함수내에서 LEndTickCount 값을 설정하고 IocpCore->Dispatch(10); 을 호출 해준 다음 
ThreadManager::DoGlobalQueueWork(); 를 호출해줄겁니다.  이 DoGlobalQueueWork 라는 함수를 DoWorkerJob 이라는 함수 내부에서 호출해주는것과 
main 함수 내에서 호출해주는것의 차이가 있는데 만약 main 함수에서 DoGlobalQueueWork를 호출한다면 다른 워커 스레드에서는 네트워크 입출력 요청을 처리하고 
메인스레드에서 전담해 나머지 전역에 예약된 JobQueue들을 처리해주겠다는 의미가 됩니다. 
그게 아니라 DoWorkerJob 에서 DoGlobalQueueWork을 호출해주는것은 워커 스레드들이 네트워크 입출력 처리를 하다가 타임아웃으로 빠져나온 스레드는 
마치 만능형 직원을 채용한것과 같이 네트워크 입출력 처리도 하고 너무 오래걸린다 싶으면 GlobalQueue에 있는 JobQueue까지 처리해줄겁니다 

식당의 예시를 들면 직원을 20명 고용했습니다. 그 중 카운터직원을 한명 배치하고 주방에 다섯명 주문을 받는 직원을 14명 배치한다는 식일겁니다. 
그런데 항상 문제가 되는상황은 정말 요리사를 5명 배치하는게 옳은 것인가 요리사가 더 필요할게 아닌지 아니면 주문 받는 직원을 줄여야 하는게 아닌지 하는 상황이 올겁니다. 
원하는것은 모든 직원이 알뜰하게 일을 하는 상황을 원합니다. 

프로그래밍으로 보면 네트워크 처리를 하는 스레드와 일반적인 로직 실행 스레드가 따로 라면 상황에 따라 네트워크 통신 부하보다 로직이 더 부하가 심하면 로직쪽으로 스레드를 더 배치해야 하고 
아니면 반대로 네트워크 처리가 부하가 되면 또 스레드 배치를 해줘야 하는데 이렇게 유동적으로 스레드 배치를 해야할때 
가장 무식하면서 효율적인 방법이 이번시간의 방법인 모든 스레드들이 만능형으로 동작하는것입니다. 모든 스레드가 네트워크 통신 처리를 하다 일감이 없어 10ms가 지나면 바로 빠져나와 
로직쪽에서 할 일이 있는지를 확인하고 이어서 실행해주도록 하였습니다.

하지만 어떤 프로젝트에서는 모든 처리를 IOCP에서 해주는 경우도 있습니다.
Dispatch에서 호출하는 GetQueueCompletionStatus를 우리는 네트워크 통신 이벤트의 완료 통지를 받고 있지만 꼭 이렇게 사용해야만 하는것은 아닙니다.
문서를 찾아보면 GetQueueCompletionStatus에 일반적인 Queue를 사용하는것처럼 다른 일감의 완료 통지를 알려주도록 강제로 넣어 줄 수도 있습니다.
일반적인 게임 컨텐츠 로직을 넣어 줄 수 있다는 것입니다.


enum
{
	WORKER_TICK = 64,
};

void DoWorkerJob(ServerServiceRef& service)
{
	while (true)
	{
		LEndTickCount = ::GetTickCount64() + WORKER_TICK;

		// 네트워크 입출력 처리 -> 인게임 로직까지 (패킷 핸들러에 의해)
		service->GetIocpCore()->Dispatch(10);

		// 글로벌 큐
		ThreadManager::DoGlobalQueueWork();
	}
}


int main()
{	
	ClientPacketHandler::Init();

	ServerServiceRef service = MakeShared<ServerService>(
		NetAddress(L"127.0.0.1", 7777),
		 MakeShared<IocpCore>(),
		MakeShared<GameSession>,
		100);

	ASSERT_CRASH(service->Start());

	for (int32 i = 0; i < 5; i++)
	{
		GThreadManager->Launch([&service]()
			{
				while (true)
				{
					DoWorkerJob(service);
				}
			});
	}

	// Main Thread
	DoWorkerJob(service);

	GThreadManager->Join();
}

스레드 매니저를 통해 만든 워커 스래드들과 메인스레드도 만능 직원이 되어 일을 하게 됩니다.


우리가 채팅 실습을 했을때와 결과물은 달라 지지 않았지만 그 내부적인 코드는 많이 바뀌었습니다. 
코드가 복잡해진 만큼 한번 과정 복습을 다시 한번 해보겠습니다. 
어떤 스레드가 DoWorkerJob을 돌면서 IocpCore->Dispatch에서 빠져나와 DoGlobalQueueWork으로 들어와 JobQueue를 하나 가져와 실행하던가 
아니면 최초로 JobQueue::Push를 실행해 Execute까지 들어 와서 LCurrentJobQueue이 채워지면 다음에 이런저런 상황에 의해 다른 JobQueue를 호출하게 되었을때 
아직 작업중인 JobQueue가 있으니 두번째 만난 JobQueue는 GlobalQueue에 밀어넣고 빠져나올겁니다.
이후로는 다른 스레드에서 LCurrentJobQueue가 아직없다면 GlobalQueue에서 JobQueue를 하나 가져와 다시 실행해주게 됩니다. 

여기까지가 여러 JobQueue를 타고 들어가 일감이 몰리게 되는 문제를 해결하였습니다. 

하지만 아직 그냥 일감이 많이 밀려들어 Execute에서 빠져나오지 못하는 문제가 남아있습니다. 
이것도 적당히 빠져나오도록 수정할겁니다. 

JobQueue::Execute를 보면 while 루프를 돌면서 들고있는 일감의 갯수인 _jobCount와 실제 들고 있는 일감의 갯수인 jobCount를 비교해 
같지 않다면 계속 루프를 돌고 있었습니다.

여기서 한가지를 더 체크할겁니다. GetTickCount64를 가지고 시간을 체크합니다.


void JobQueue::Execute()
{
	LCurrentJobQueue = this;

	while (true)
	{
		Vector<JobRef>	jobs;
		_jobs.PopAll(jobs);

		const int32 jobCount = static_cast<int32>(jobs.size());
		for (int32 i = 0; i < jobCount; i++)
			jobs[i]->Execute();

		// 남은 일감이 0개 라면 종료
		if (_jobCount.fetch_sub(jobCount) == jobCount)
		{
			LCurrentJobQueue = nullptr;
			return;
		}

		const uint64 now = ::GetTickCount64();
		if (now >= LEndTickCount)
		{
			LCurrentJobQueue = nullptr;
			GGlobalQueue->Push(shared_from_this());
			break;
		}
	}
}

아까 ThreadManager::DoGlobalQueueWork 에서 시간 제한을 두듯에 여기서도 제한을 둔건데 만약 최대한 일감을 처리하다가 정해둔 시간인 LEndTickCount를 넘어서면 
내 현재 처리 잡큐를 비우고 다시 GlobalQueue에 밀어 넣은 다음 빠져나오도록 했습니다.


이렇게 해서 간단한 아이디어로 꽤 괜찮은 많은 트래픽 처리를 관리하는 요령을 배워봤습니다. 
여기서 또 좀 더 손을 댈만한 곳은 LEndTickCount를 초기화 하는 부분에서 WORKER_TICK을 64로 하드 코딩했었는데 이 부분을 어느 정도 테스트를 해서 
ThreadManager::DoGlobalQueueWork 을 다 처리하지 못하는 경우가 많아지면 자동으로 WORKER_TICK을 조금 씩 늘리는 보정 코드를 사용하기도 합니다.

지금처럼 소규모도 안되는 포트폴리오 준비하는 단계에서는 사실 티도 안날겁니다. 나중에 언리얼엔진을 붙히고 수십만의 몬스터를 뿌리는 것과 같은 게임에서야 
빛을 발하는 코드입니다. 워낙 최근 CPU 성능이 좋아졌기 때문입니다.

기초적인 아이디어만 얻어가면 성공입니다. 

아직 서버 코어를 만들어 봤지만 전체적인 서버 구조를 어떻게 만들어야 할지 감이 안올 수 있는데 
기본적으로 여기서 이해해야 할것은 두가지 인겁니다. IocpCore를 통해 네트워크 입출력 처리를 어떤 식으로 동작하는지 과정과 
네트워크 입출력과 별개로 게임 내에서 연산해야 하는 로직은 DoGlobalQueueWork를 통해 처리가 되는 것을 숙지해야합니다. 

GlobalQueue는 여러가지 용도가 있을건데 네트워크 처리중 다 처리하지못한 JobQueue를 처리하는 것도 있고 아니면 내부적으로 처리해야하는 일감도 있을겁니다. 

핵심은 세부적인 코드를 어떻게 짠다 이런게 아니고 어떤 컨샙으로 짜였는지가 중요합니다.

