

        Memory Model


이번 주제인 메모리 모델을 알아보기 위해서 이전에 캐시와 파이프라인에 대한 내용을 알아 봤다고 할 수 있습니다. 

지난시간에 굉장히 충격적인 사실에 대해 알게 되었습니다. 내가 작성한 코드가 사실은 컴파일러나 CPU에서 편의에 따라 알아서 
수정되어 실행되고 있었습니다. 이 사실은 단일 쓰레드 환경에서는 아무런 문제가 되지 않기때문에 보이지 않았던 것이었습니다. 

C++11 이라는 모던 C++에서 추가된 내용이 람다식 같은 일반적으로 사용되는 기능도 있지만 더 더욱 중요한 내용은 
메모리 모델에 대한 내용이 확립되었다는게 중요합니다. 

C++11 이전 까지는 싱글쓰레드 환경을 기준으로 언어가 지원 하였지만 C++11 이후로 멀티쓰레드 환경도 지원하기 시작한겁니다. 

메모리 모델의 주 내용으로 들어가기전에 먼저 잠시 복습을 하고 가겠습니다. 

- 복습 
. 여러쓰레드가 동일한 메모리에 동시 접근하고 그 중 하나는 write 연산을 한다면 문제가 발생합니다.
  그 결과는 Race Condition (경합 조건) 이 일어납니다. 
  이 때 일어나는 걸 영어로는 Undefined Behavior(정의되지 않은 행동) 이라고 합니다. 이게 정말 무서운 말입니다.
  정의 되지 않았으니까 컴퓨터가 그냥 꺼져도 할 말 없는겁니다. 

  그래서 이걸 해결하기 위해 지금 까지 배운 크게 두가지 방식을 사용했습니다.
  1 - Lock(mutex)를 이용해서 상호 배타적 (Mutual Exclusive) 접근을 한다 
  2 - Atomic(원자적) 연산을 이용한다 

  이 두가지 방법을 사용해야 해결이 된다고 배웠습니다. 이 중에 원자적 연산에 대한 내용을 심화해서 알아 볼겁니다. 
  사실은 원자적 연산이 문제를 바로 해결해 주지는 않습니다. 
  C++ 에서 유일하게 보증하는 하나의 법칙이 있는데 다음과 같습니다.

  [atomic 연산에 한해, 모든 쓰레드가 동일 객체에 대해서 동일한 수정 순서를 관찰]

  분명 한국어이긴 한데 어떤 말인지 알아 보기가 어렵습니다. 

  그래서 풀어서 다시 설명하면 동일 객체, 동일 순서라는 부분이 중요합니다. 
  
  먼저 동일한 수정 순서에 대해 설명해보겠습니다. 

  atomic<int64> num;

  void Thread_1()
  {
        // num = 1
        num.store(1);
  }

  void Thread_2()
  {
        // num = 2
        num.store(2);
  }

  void Thread_Observer()
  {
        while(true)
        {
                int64 value = num.load();
                // 관찰 결과는? 
        }
  }

  이런 함수들이 있고 Thread_1, Thread_2 둘 모두 각각 쓰레드에 할당하고 Thread_Observer도 마찬가지로 다른 쓰레드에 할당을 해서 
  동시에 실행한다고 했을때 Thread_1, Thread_2 둘중 하나가 간발의 차이로 먼저 실행될것이고 num의 값을 수정할겁니다. 

  그건 그렇고 동일한 수정 순서가 뭘 뜻하냐면 제 3의 쓰레드 Thread_Observer가 관찰자 역할을 하면서 계속 관찰을 하고 있을겁니다. 
  이때 이전에 배운 캐시에 대한 내용을 다시 떠올리면 CPU에는 각각 코어가 있고 옆에 레지스터, L1, L2 같은 캐시가 붙어 있다고 했습니다. 

  그래서 num의 값을 1이나 2로 수정을했다고 해도 다른쓰레드입장에서 관찰 했을때 그 수정된 캐시에 있는 값을 관찰할 수 있다고 보장 할 수 
  없습니다. 
  (실제 atomic은 더 많은 기능이 있기는 합니다. 설명하기 위해 예시를 드는겁니다.)
  num 객체의 값은 모르지만 동일한 객체의 동일한 수정순서를 관찰은 한다는 겁니다. 
  
  예를 들어서 num의 값이 변경되는 걸 선 그래프로 만들어 보겠습니다. 
  0 -> 2 -> 1 -> 5 
  처음에는 num의값이 0이었다가 어떤 이유에선지 2로 바뀌었다가 1로 바뀌고 마지막으로 5로 바뀌었다고 하겠습니다. 

  0에서 2로 값이 변하는 순간 관찰자도 값이 2로 바뀌는걸 관찰하는게 아닙니다. 보장할 수 있는건 num이라는 객체의 값이 수정되는 순서를 
  보장합니다.   

  다시 2에서 1로 값이 바뀌는 중간 시점에 관찰자가 관찰을 한다고 하면 num은 2일수도 있고 0 일수도 있습니다. 
  또 잠시 시간이 흘러서 num의 값이 1에서 5로 바뀌는 중간 시점에 관찰을 했을때는 관찰자는 0, 2, 1 중 하나의 값을 관찰할 수 있지만 
  만약 2를 한번 관찰했다면 다음 관찰때는 2, 1 중 하나를 관찰할 수 있지 0을 관찰하는 순서로는 갈 수 없습니다. 
  시간의 흐름에 따라 앞으로 흐르는 결과만 관찰할 가능성이 있고 시간을 거슬러 올라가는 값을 관찰 할 수 없습니다. 

  관찰자는 무조건 매 루프마다 앞으로 한칸씩 관찰을 해나가는것은 아니고 멀티쓰레드 환경에서 쓰레드의 스케쥴링이 어떻게 되느냐에 따라 
  000215 순 일수도 있고 011115 일 수도 있고 05 일수도 있습니다. 

  이런 개념이 낯설고 이해하기 어렵지만 현실에서도 비슷한 경우가 있습니다. 
  우주 관찰이 비슷한데 밤하늘을 보면서 별들을 관찰하고 있으면 내가 현재 저 별들을 동시에 보고 있는것 같지만 
  사실은 별에서 보내고 있는 빛이 현재 지구에 도달한걸 내가 관측했을 뿐입니다. 지금 보이는 별들이 관찰하는 동시에는 아예 없어져 있을 수 
  있고 움직여서 다른 곳에 있을 수 있습니다. 결국 과거의 별들을 보고 있다고 할 수 있습니다. 
  그리고 여기에 다시 다음날에 또 밤하늘을 보러 온다면 그때 보이는 별은 어제 본 별빛보다는 더 나중에 일어난 빛을 보고 있다는걸 알 수 있습니다. 

  결국은 동일한 수정 순서라는것은 한번 관측한 순간 부터는 미래로 만 관측할 수 있는것입니다. 

  여기서 또 한가지 더 언급하자면 위의 법칙에서 atomic 연산을 사용한다고 했는데 이 말이 실제 atomic 클래스를 사용한다는 뜻이 아닙니다. 
  원래 원자적연산의 뜻대로 더이상 쪼개질 수 없는 연산 CPU가 한번에 처리할수 있는 연산을 원자적 연산이라고 합니다.
  
  아까 위에서 int64 num에 1이나 2를 넣는 코드는 요즘 64bit 연산을 지원 하는 컴퓨터에서는 이 대입 연산이 원자적으로 진행될것입니다. 
  하지만 만약에 컴퓨터가 20년전 컴퓨터라서 32bit 연산을 하는 컴퓨터라면 대입연산을 실행하면 int64를 한번에 처리할 수 없기때문에 
  상위 32비트 하위 32로 나눠서 연산을 할겁니다. 이상황에서는 더이상 원자적이지 않은 연산이 됩니다. 

  이걸 실습해볼수 있는 코드는 이렇습니다.
  {
        atomic<int64> v;
        cout << v.is_lock_free() << endl;
        // 1
  }

  {
        class Knight
        {
                int32 hp;
                int32 mp;
                int32 stamina;
        };

        atomic<Knight> k;

        cout << k.is_lock_free() << endl;
        // 0
  }
  atomic 객체의 is_lock_free라는 메소드가 바로 만든 객체가 원자적으로 동작할수 있는지를 반환하는 메소드입니다. 
  Knight 같은 경우에는 그냥으로는 원자적으로 동작할 수 없기 때문에 atomic 클래스에서 의도적으로 lock을 잡아서 원자적으로 연산되게끔 하는겁니다.

  정리하면 atomic 클래스를 사용해서 이용하면 그 변수를 수정할때 원자적으로 수정이 된다는걸 보장해야하는데 애당초 원래 CPU에서 원자적으로 
  연산되는 타입이라면 그냥 실행해줄것이고 그게아니라 CPU자체적으로는 원자적 연산을 하기에 덩치가 크면 lock을 잡아서 값을 수정하고 lock을 풀어서 
  원자적 연산을 달성했다고 보면 됩니다. 

  atomic 원자적 연산은 꼭 atomic클래스를 거쳐야 한다는 오해가 생길까봐 설명을 하였습니다. 

  또 동일 객체, 동일 수정 순서라는 키워드중에 '동일 객체' 이부분도 중요한데 예를들어 
  int64 num이 하나만 있는게 아니라 num2, num3... 여러개가 있을때 num 하나 안에서는 동일한 수정 순서가 보장되지만 
  num, num2, num3 사에에서는 수정 순서가 보장되지 않습니다.

  그래서 이전에 멀티쓰레드 환경의 문제점인 가시성과 코드 재배치의 문제가 있었는데 atomic을 사용해도 해결이 되지 않습니다. 
  왜냐면 atomic을 사용해도 동일 객체가 아니라면 동일한 수정 순서 보장이 되지 않기 때문에 코드 재배치가 일어 날 수 있습니다.
  가시성 측면에서도 가시성은 여러 쓰레드가 관찰하기에 같은 값을 가지고 있어야 하는데 atomic은 수정순서만 보장할 뿐 같은 값을 관찰한다고 
  보장할 수 없습니다. 

  atomic 연산에 한해 모든 쓰레드가 동익 객체에 대해서 동일한 수정 순서를 관찰한다는 법칙만으로는 문제가 해결되지는 않지만 이걸 토대로 생각해서 
  진행해야 하기때문에 설명을 하고 있습니다. 


이제 이어서 코드로 실습을 해볼겁니다. 위에서 예시로 든 코드에서는 atomic<int64> num 에 값을 대입할때 num = 1 이런식으로 대입 할 수도 있고 
num.store(1) 이렇게 대입할 수도 있지만 사실 이 store는 
num.store(1, '대입할때 사용할 정책') 이것과 똑같이 동작합니다. 이 정책을 알아보는게 목적입니다. 
기본적으로 사용하는 메모리 정책은 memory_order::memory_order_sep_cst 라는 정책을 사용하는데 정책이 이거 하나만 있는게 아니고 
어떤 메모리 정책에 따라서 우리가 얘기한 가시성, 코드 재배치 문제가 해결이 되고 안되고 하기 때문에 이 것을 알아보겠습니다. 

- 코드 

코드 실습에서 가장먼저 우선 atomic을 다시 한번 복습 해보겠습니다. 

atomic<bool> falg = false;

이런 bool 타입 아토믹 객체를 만들고 이 bool 타입 객체가 자체적으로 원자적 연산이 되는지 아니면 atomic 클래스에서 lock을 잡아줘야 하는지 
를 알려면 flag.is_lock_free() 라는 메소드를 사용하면 된다고 했스빈다. is lock free 이것은 락이 없는지를 묻는겁니다. 
그래서 반환값이 1 true 라면 락이 없다는 뜻이고 락이 없다는것은 자체적으로 원자적 연산이 된다는 뜻이고 
반대로 반환값이 0 false 라면 락이 있다 즉 자체 원자적 연산이 안되니 atomic클래스에서 lock을 잡아줘야 한다는 뜻이 됩니다. 

다음은 아토믹 객체에 값을 대입하는 방법입니다. 

flag = true;
bool val = flag;

이렇게 값을 넣어줘도 되기야 하는데 이러면 flag 라는 변수가 그냥 bool 타입 변수인지 bool타입 atomic 객체인지를 알기 어렵습니다. 

flag.store(true);
bool val = flag.load();

이런 식으로 값을 집어 넣는다면 한눈에 atomic 객체인걸 알 수 있습니다.
그리고 이 것은 사실 두번째 인자를 생략한 버전입니다.

flag.store(true, memory_order::memory_order_seq_cst);
bool val = flag.load(memory_order::memory_order_seq_cst);

메모리 오더의 정책을 정해주고 있는데 이 내용은 좀있다 자세히 알아보고 

다음은 이전 flag 값을 prev 라는 변수에 넣고, flag 값을 수정하고 싶습니다.
{
        bool prev = flag;

        flag = true;
}
이렇게 하면 될것 같지만 이부분이 atomic 객체를 사용할 때 주의 해야 할 점입니다. 
우리가 가정해야할 상황은 멀티쓰레드 환경이고 prev에 flag값을 넣는 바로직전에 다른 쓰레드에서 flag의 값을 수정한다면 의도했던 prev가
유효하지 않을겁니다. 

그러니까 flag를 prev에 넣는 행위와 flag에 true 값을 넣는 행위도 원자적으로 일어나야한다는 것이고 그러기 위해서 따로 두가지 행동을 하는게 
아니라 읽고 쓰는걸 동시에 하는 atomic 메소드가 있습니다. 

flag 의 원래 값을 반환하고 flag에 넣을 값을 인자로 받습니다. 
{
      bool prev = flag.exchange(true);
}

그 다음은 CAS (Compare-And-Swap) 조건부 수정 입니다. 
	// CAS (Compare-And-Swap) 조건부 수정
	{
		bool expected = false;
		bool desired = true;
		flag.compare_exchange_strong(expected, desired);

		// compare_exchange_strong 을 의사 코드로 표현하자면 
		// if (flag == expected)
		// {
		// 	 flag = desired;
		// 	 reture true;
		// }
		// else
		// {
		// 	 expected = flag;
		//	 return false;
		// }
	}
이런 내용이었습니다. 
compare_exchange_strong 라는 메소드는 두가지 bool 타입 인자를 받는데 첫번째는 expected 예상한 값, 두번째로 desired 원하는 값입니다. 
메소드를 부른 flag라는 bool타입 atomic 객체의 값이 만약 expected값과 같으면 desired 값으로 바꿔주고 true를 리턴합니다. 
같지 않다면 expected 를 flag의 값으로 바꾸고 false를 리턴합니다. 
반환값은 compare_exchange_strong가 성공했는지 실패했는지를 판별합니다.

위의 과정을 의사코드로 표현하면 주석과 같은데 이 동작을 원자적으로 연산한다는 의미가 있습니다. 이 메소드를 이용해서 스핀락 같은것도 구현 할 수 
있었습니다. 

게다가 compare_exchange_strong에 커서를 가져다 대면 생략된 세번째 인자로 memory_order가 있습니다. 

그래서 오늘 계속 다룰 메모리 오더라는 인자 자체가 메모리에 대한 정책입니다. 

추가로 compare_exchange_strong 가 있고 또 compare_exchange_weak 가 있습니다. 이 두 메소드는 거의 똑같습니다. 
마찬가지로 expected 와 desired를 넣어주고 동작도 똑같이 하는데 
한가지 차이가 있는데 Spurious Failure 직역하면 가짜 실패라는게 일어납니다. 

어떤 상황이냐면 메소드를 호출한 객체의 값과 expected값이 같음에도 불구하고 그 안에서 다른 쓰레드의 간섭을 받게 되면 실패를 할 수 있게 됩니다. 
원래는 성공해야 하는데 묘한 상황이 일어나서 실패를 했다는 가짜 실패가 일어 날 수 있습니다.

compare_exchange_strong은 가짜 실패가 일어나지 않는 이유는 다른 쓰레드와 경합 상황이 일어나지 않게 수정 했다기 보다 그 상황이 되었다면 
다시 한바퀴를 돌아 재시도를 해가면서 원하는 결과가 나올때 까지 트라이를 하는 겁니다. 

그러니까 compare_exchange_weak가 기본적인 형태고 성공할때 까지 반복해주는 코드가 추가된게 compare_exchange_strong이니깐 strong 버전이 더 
무겁습니다. 

일반적으로 weak 버전을 사용한다면 결과가 false가 나올때도 가짜 실패일 수 있다보니까 while 문과 같이 사용하는게 일반적입니다. 

		while (true)
		{
			bool expected = false;
			bool desired = true;
			flag.compare_exchange_weak(expected, desired);
		}
이런식으로 루프를 돌리는데 사실 storng 버전으로 스핀락을 구현할때도 무한 루프를 사용했다보니 큰 차이는 없다고 볼 수 있습니다.

또 이 두 버전의 성능차이를 테스트 해봐도 사실 얼마 차이 안난다고 합니다. 컴퓨터 마다 다르다고는 하는데 요즘 인텔 컴퓨터에서는 거기서 거기라고 합니다.

이렇게 atomic 에 대해 잠시 복습을 해봤습니다. 


이제 아까부터 자꾸 등장한 memory_order 뭐시기 에 대해 알아보겠습니다. 
	// Memory Model (정책)
	// 1) Sequentially Consistent (sep_cst)
	// 2) Acquire_Release (consume, acquire, release, acq_rel)
	// 3) Relaxed (relaxed)

총 세가지 정책이 있고 괄호안은 코드에서 찾아 볼때 연관있는 정책에 묶어놓은겁니다. 
이중 consume은 문제가 있어서 C++17 에 수정을 할지 말지 했던 내용이기 때문에 잘 사용하지 않을것이고 
중요한건 sep_cst, acquire, release, relaxed 네가지가 중요합니다. acq_rel는 acquire 와 release 를 합쳐놓은것이기 때문에 잊어도 상관없습니다. 

	// 1) seq_cst           (가장 엄격 = 컴파일러 최적화 여지가 적음 = 코드가 직관적)
	// 2) acquire-release   
	// 3) relaxed           (자유롭다 = 컴파일러 최적화 여지 많음 = 직관적이지 않음)

이 세가지 정책들 사이에서 위쪽 정책일 수록 엄격하고 아래쪽일수록 자유롭습니다. 말만들으면 엄격한건 안좋은거고 자유로운건 좋을것 같은데 
엄격하다는 것은 컴파일러가 맘대로 우리 코드를 수정해서 최적화 할 여지가 적다는 말입니다. 우리가 적은 코드 그대로 동작할 확률이 높다는겁니다. 
자유롭다는건 반대로 우리가 적은 코드가 컴파일러가 개입해 최적화 할 여지가 많다는 말입니다. 

그래서 기본적으로 atomic 메소드를 사용할때 정책을 생략하면 가장 엄격한 버전인 seq_cst버전이 실행되었는데 그래서 지금까지는 메모리 모델을 신경쓰지 않아도 되었던 겁니다. 
사실 앞으로도 별 신경을 안써도될 확률이 높지만 

일단 이런 내용이 궁금하므로 알아보겠습니다. 

각 버전의 코드를 만들어 보겠습니다. 
실습 환경은 이렇습니다. 

atomic<bool> ready;
int32 value;

void Producer()
{
	value = 10;

	ready.store(true, memory_order::memory_order_seq_cst);
}

void Consumer()
{
	while (ready.load(memory_order::memory_order_seq_cst) == false)
		;

	cout << value << endl;
}

int main()
{
	ready = false;
	value = 0;
	thread t1(Producer);
	thread t2(Consumer);
	t1.join();
	t2.join();
}

memory_order::memory_order_seq_cst 부분은 사실 생략해도 됩니다. 그러니까 평소 그냥 사용하던 정책이라는 겁니다. 
이 seq_cst 버전을 사용하면 어떤 점이 좋은가 하면 가시성 문제 해결!, 코드 재배치 문제도 해결! 
즉, 우리가 알아보려던 해결책입니다. 그래서 이전에 atomic을 처음 배울때도 문제 없이 사용가능했던겁니다. 

그럼 이제 문제 상황이라고 알아봤던 가시성, 코드 재배치가 해결되지않은 가장 자유로운 정책이었던 relaxed 는 어떤지 보겠습니다.

void Producer()
{
	value = 10;

	ready.store(true, memory_order::memory_order_relaxed);
}

void Consumer()
{
	while (ready.load(memory_order::memory_order_relaxed) == false)
		;

	cout << value << endl;
}

이러면 컴파일러와 CPU가 판단하기에 Producer 함수에서 value에 값을 넣는 부분이 ready.store 보다 아래 있는게 낫겠다 싶으면 
알아서 옮겨서 해석한다는 말입니다.
사실상 relaxed 같은 경우는 거의 사용하지 않습니다. 

Acquire_Release는 딱 중간 입니다. 
어떻게 사용되냐면 

void Producer()
{
	value = 10;

	ready.store(true, memory_order::memory_order_release);

      // 절취선 ----------------
}

void Consumer()
{
      // 절취선 ----------------
	while (ready.load(memory_order::memory_order_acquire) == false)
		;

	cout << value << endl;
}

이렇게 release와 acquire 가 짝을 맞춰서 사용됩니다. 

어떤 일이 일어나냐면 release 명령 이전의 메모리 명령들이 , 해당 명령 이후로 재배치 되는 것을 금지 합니다.

그래서 절취선 위 쪽의 value = 10; 이라는 코드가 절취선 아래로 넘어갈 수 없도록 막아줍니다. 
절취선 위쪽에 다른 코드가 있었다면 그 코드 끼리 재배치가 일어나는건 상관하지 않습니다.    

두번째로 acquire로 같은 변수를 읽는 쓰레드가 있다면 release 이전의 명령들이 다른 쓰레드에서 acquire 하는 순간 관찰 가능해집니다.
즉, 가시성이 보장됩니다. 

그래서 seq_cst 버전 뿐만 아니라 acquire-release 버전에서도 Consumer 에서 value 의 값이 10으로 나온다고 보장할 수 있습니다.


정리하자면 
메모리 모델에 대한 정책이 세가지 있고 
	// 1) Sequentially Consistent (sep_cst)
	// 2) Acquire_Release (consume, acquire, release, acq_rel)
	// 3) Relaxed (relaxed)
생략하면 기본적으로 1번인 sep_cst 버전이 실행됩니다. 그리고 relaxed 버전은 atomic의 기본 조건(동일 객체에 대한 동일한 수정 순서 관찰)만 
보장하기 때문에 거의 사용할 일이 없고 
acq_rel 버전은 release , acquire 가 짝으로 사용되는데 release 이전의 명령들은 재배치가 될 수 있지만 release 명령을 한 후에는 재배치가 막힙니다.
그리고 acquire로 같은 변수에 접근하는 다른 쓰레드가 있다면 acquire를 한 순간 release 이전의 명령들을 관찰 가능해집니다. 
sep_cst 버전은 가장 엄격한 정책으로 기본적으로 가시성, 코드 재배치 문제가 해결되어있습니다. 

추가로 인텔, AMD CPU의 경우에는 애당초 순차적 일관성을 보장해서 
sep_cst를 써도 별다른 차이가 없습니다. 그래서 그냥 냅둬도 된다는겁니다. 
ARM 같은 경우에는 꽤 차이가 있어서 의미가 있다고 합니다. 

추가 내용 두번째로 그러면 release, acquire 로 절취선을 사용하려면 꼭 atomic 객체를 이용해야 하는가?
이런 질문에는 그렇지 않습니다. 기본적으로 CPU에 메모리 배리어라는 기능이 있다고 합니다. C++ 표준에서 atomic을 사용하지 않고 
절취선을 긋고 싶다고 한다면

std::atomic_thread_fence(momory_order::memory_order_release); 
std::atomic_thread_fence(momory_order::memory_order_acquire); 
이런식으로 직접 절취선을 사용할 수 있다고 합니다. 
이 방식도 atomic 객체에서 사용했듯이 release 이후로 코드 재배치를 멈추고 acquire 이후로는 가시성도 보장한다는 내용입니다. 
물론 이걸 알아보기는 했지만 실제로 사용할 일은 없을거라고 봐야 합니다.

조금 허무할 수 있는데 이번 시간에 알아본 내용을 알거나 모르거나 똑같이 동작할 수 있다는 얘기입니다. 
