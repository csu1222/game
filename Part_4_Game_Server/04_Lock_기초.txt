


        Lock 기초 


이전 시간에 멀티쓰레드 환경에서 공유 메모리를 동시에 수정할때 생길수 있는 문제 그리고 그걸 해결할 수 있는 
동기화 기법중 Atomic 에 대해 알아 봤습니다.

아토믹도 좋은 방법이기는 하지만 일반적으로는 Lock 을 걸어서 동기화 하는게 더 일반적이라고 합니다. 

오늘 주제를 시작할때의 문제 상황을 보겠습니다.

vector<int32> v;

void Push()
{
	for (int32 i = 0; i < 10000; i++)
	{
		v.push_back(i);
	}
}

int main()
{
	std::thread t1(Push);
	std::thread t2(Push);

	t1.join();
	t2.join();

	cout << v.size() << endl;
}

이번에는 공유하는 데이터가 단순한 변수 하나가 아니라 vector 처럼 자료구조, 컨테이너 인 상황입니다. 그리고 Push 라는 함수를 통해 한번 실행하면
10000 번 push_back을 하는 함수를 만들고 t1, t2 라는 두 쓰레드를 만들어서 같이 실행합니다. 

이 코드를 보고 멀티 쓰레드가 아닌 그냥 Push를 두번 실행한것처럼 생각하게 되면 v의 사이즈는 그냥 2만이 되는 결과가 출력되어야 합니다. 

하지만 실제 이 코드를 실행해보면 2만을 출력하기는 커녕 크래시를 내버립니다.

이제 알아야 할 것은 지금까지 배웠던 STL 컨테이너 들은 멀티쓰레드 환경에서 동작하지 않는다고 가정해야 합니다.

왜 문제가 생겼을지 생각해보겠습니다. 
먼저 이번에 사용한 컨테이너인 vector의 원리를 다시 떠올려 봅시다 vector는 다른 말로는 동적배열입니다. 동적 배열은 말그대로 동적으로 컨테이너 크기가 
달라지는 배열인데 vector에 원소를 추가하면서 기존 배열이 꽉 찼다면 기존 배열 크기의 1.5 혹은 2배의 크기에 달하는 새로운 배열을 할당받고 그 곳으로 
데이터를 복사해서 필요할때 마다 크기를 늘립니다. 그리고 원래 있던 꽉찬 배열은 날려줍니다. 

여기까지만 들어도 아차 싶습니다. 우리가 지금 배우고 있는 멀티쓰레드 환경에서는 다른 쓰레드의 동작을 기다려주지 않고 각각 알아서 진행합니다.
v에 t1, t2가 push_back을 동시에 하고 있는데 만약 간발의 차로 t1이 먼저 v의 기존 배열을 꽉 채웠다면 새로운 주소에 증설된 배열을 만들고 그곳으로 
데이터들을 옮기고 기존 배열은 날릴겁니다. 그런데 이 중간에 뒤따라 실행된 t2는 이미 메모리를 날리고 있는 이전 배열에 접근해서 push_back을 시도할것입니다. 
그러면 메모리 오염이 일어나게 됩니다. 그래서 크래시가 나게 될겁니다. 

멀티쓰레드를 list나 다른 컨테이너에서 실행했다면 지금과 다른 이유로 크래시가 났겠지만 일단 이번 예시인 vector 에서는 위와 같은 이유로 크래시가 나는 것입니다.
기본적인 동작방식이 싱글쓰레드 방식에서 동작하도록 되어있기때문에 어찌 됐든 문제가 생길겁니다. 

그러면 배열을 이사하면서 문제가 생긴다면 v를 처음부터 2만개의 원소가 들어갈 수 있도록 크게 할당해놓으면 어떨까요

int main()
{
	v.reserve(20000);

	std::thread t1(Push);
	std::thread t2(Push);

	t1.join();
	t2.join();

	cout << v.size() << endl;
}

이 상태로 실행해보면 크래시는 나지 않지만 v.size가 2만이 아니라 몇개가 분실되어서 출력됩니다. 게다가 실행할때 마다 분실된 원소의 갯수가 달라집니다.

이경우에 문제가 일어나는 이유는 벡터를 reserve로 넓개 메모리를 할당 받아 놓으면 이제 배열이 다른 곳으로 옮겨지는것은 예방이 될텐데
그 이후 데이터를 push_back 할때는 배열에서 다음에 데이터가 추가될 인덱스를 size라고 기억하고 있다가 그곳에 데이터를 저장하고 다음 인덱스를 기억하는 
방식인데 이때도 멀티쓰레드에서는 먼저 다른 쓰레드가 푸시를 하는 중임에도 상관하지 않고 자기 할 일을 합니다. 즉 어느 인덱스 i 에 t1이 데이터를 
저장하려는 중간에 t2도 i 인덱스에 저장을 하게되면 i 번째의 원소는 두번 곂쳐 저장됩니다. 그래서 2만개의 데이터가 온전히 채워지지 않습니다. 

결국 이번에는 크래시는 나지 않았지만 예상치 못한 문제가 생기고 각 문제점도 찾기가 어렵습니다. 아예 처음부터 크래시가 나서 
문제가 있다고 확실히 아는게 더 나을것 같습니다. 

그러면 이전시간에 배운 아토믹을 적용해보면 어떨까 라는 생각이 들기도 합니다. 

atomic<vector<int32>> v;

이런식으로 사용하면 어떨까? 싶은데 아토믹은 그냥 일반적인 데이터에 사용할 수 있는거지 vector같이 좀 더 복잡한 데이터에는 사용할 수 없습니다. 

그러면 어떻게 해야 되는가?

내가 푸시백을 하는동안에 다른 애들은 이 v를 건드리지 못하도록 서로 신호를 정해주는 것 처럼 순서를 정해서 한번에 한명만 접근하도록 해줘야 하는데 
이것이 Lock 의 개념입니다. 

Lock 또한 운영체제 마다 사용법이 달랐었는데 C++ 11 에서 마찬가지로 공통으로 사용하도록 추가 되어습니다.

#include <mutex>

mutex m;

이렇게 사용합니다.
이 뮤텍스는 일종의 자물쇠라고 생각하면 됩니다. 공용 화장실에 들어가서 자물쇠를 잠그면 밖에서 볼때 빨간색으로 사용중이라고 뜨고 안의 사람이 나오고 나서 
다음 사람이 사용할 수 있는 것 처럼 자물쇠같은 것이라고 생각하면됩니다. 


void Push()
{
	for (int32 i = 0; i < 10000; i++)
	{
		// 자물쇠 잠그기
		m.lock();

		v.push_back(i);

		// 자물쇠 풀기
		m.unlock();
	}
}

m 이라는 뮤텍스 객체를 어떻게 사용하냐면 코드에 들어가서 공용 데이터를 건드리기 전에 lock 함수로 잠그고 자기 할일을 한 다음 unlock으로 다시 열고 
나오면됩니다.
이때 다른 쓰레드가 Push 함수에 같이 접근하게 되면 먼저온 쓰레드가 m.unlock() 할때 까지 m.lock 코드 앞에서 기다리다가 열리면 진행하게 됩니다.

그런데 물론 이걸 막 사용해도 아무 문제가 없는건 아닌데 결국 한 쓰레드씩 진행되도록 잠가 버리면 멀티쓰레드 환경인데 실제 성능은 싱글 쓰레드 성능으로 
사용하고 있는겁니다.

이제 뮤텍스를 사용해서 동기화를 한다음 

int main()
{
	std::thread t1(Push);
	std::thread t2(Push);

	t1.join();
	t2.join();

	cout << v.size() << endl;
}

v.reserve를 없앤 코드를 다시 실행해보면 크래시도 안나고 v의 size가 2만이 되게끔 제대로 결과가 나옵니다.
결과는 나오지만 lock에 대한 쓰레드 간의 경합이 일어나고 그래서 일반적인 멀티 쓰레드 환경보다 느리게 동작할 수 밖에 없습니다. 


지금 배운 Lock 은 서버 프로그래밍을 하면서 멀티쓰레드를 위해 매우 중요하게 사용되는 기법입니다. 앞으로 어떻게 사용해야 하는지도 알아볼것이고 
다양한 Lock의 종류에 대해도 알아 볼것인데 

주의할 점도 있습니다. 

나중에 배울 내용인데 미리 스포일러를 하자면 Lock을 재귀적으로 걸 수도 있는지가 살펴볼 점인데 

void Push()
{
	for (int32 i = 0; i < 10000; i++)
	{
		// 자물쇠 잠그기
		m.lock();
        m.lock();

		v.push_back(i);

		// 자물쇠 풀기
		m.unlock();
        m.unlock();
    }
}

그런데 지금 이 mutex 같은경우는 재귀적으로 호출할 수 없습니다. 실행해보면 크래시가 납니다. 재귀적으로 락을 사용하려면 다른 종류의 락을 사용해야 합니다. 

지금이야 아주 단순한 함수내에서 실습을 했지만 실제 업무에서는 함수안에서 다른 함수를 호출할 때도 있고 함수 자체가 재귀함수일 수도 있어서 
Lock 을 재귀적으로 사용할 수 있는게 편리합니다. 
그래야 이미 만들어 놓은 함수를 재사용 할 수 있습니다. 
이게 주의할 점 첫번째 이고 

다음은 락을 잠그기는했는데 실수로 까먹고 unlock을 하지 않았을 경우입니다. 
실생활로 생각해보면 누군가 공용화장실에 들어가서 문을 잠근다음 문을 열지 않고 안에서 사람이 사라지는겁니다. 
그런데 이런 실수는 초보적인겁니다. 꼼꼼히 살피고 처음부터 lock 과 unlock을 세트로 입력해두고 시작해도 됩니다. 심지어 비주얼 스튜디오에서 잡아주기 까지합니다. 
하지만 그럼에도 불구하고 unlock을 하지 않는 실수가 나오는 이유가 있습니다.


void Push()
{
	for (int32 i = 0; i < 10000; i++)
	{
		// 자물쇠 잠그기
		m.lock();

		v.push_back(i);

        if (i == 5000)
            break;

		// 자물쇠 풀기
		m.unlock();
	}
}

어떤이유에서 중간에 조건에 따라 브레이크를 걸어야 하는경우도 있을겁니다. 

이 상황을 보니 뭔가 잘못된것이 느껴집니다. 비주얼 스튜디오도 이부분이 이상하다고 알려주기도 합니다. 

조건에 걸려 브레이크로 빠져 나가는 경우에는 미리 만들어 뒀던 unlock을 우회해서 함수가 종료되기 때문인데 이 상태에서 프로그램을 실행해보면
프로그램이 끝나지않고 멈춰 있습니다. m이 잠겨서 다음 번 for문으로 넘어가지 못하고 있는겁니다. 
	
    	if (i == 5000)
		{
			m.unlock();
			break;
		}

조건을 이렇게 줘야 제대로 m이 잠긴걸 풀게됩니다.
그런데 이 if else 가 여러 단계로 복잡해 질 수 도 있는데 그럴때 마다 한땀한땀 락이 풀렸는지 잠겨있는지를 체크하는것은 귀찮기도 하고 실수가 생길 확률이 매우 높아집니다. 
MMO 같은경우는 코드가 몇천줄 까지도 갈 수 있는데 모든 경우를 체크할 수는 없습니다. 

그래서 자동으로 관리를 해줘야 할 필요가 있습니다. 

이때 사용되는 C++ 유명한 패턴이 있습니다.

RAII(Resource Acquisition Is Initialization) 패턴인데 

이게 하려고 하는것은 어떤 랩핑 클래스를 만들어서 생성자에서 락을 잠그고 소멸자에서 락을 풀어주는 역할을 할겁니다. 
물론 이게 락에 대해서만 사용하는게 아니라 리소스나 DB 연결할때도 동일한 패턴으로 사용될겁니다. 
잘 이해가 안갈 수 있으니 코드로 살펴보겠습니다.

template<typename T>
class LockGuard
{
public:
	LockGuard(T& m)
	{
		_mutex = &m;
		_mutex->lock();
	}
	~LockGuard()
	{
		_mutex->unlock();
	}

private:
	T* _mutex;
};


대략적으로 이런 형태인데 템플릿을 사용했지만 지금 코드에서는 뮤텍스를 인자로 받아서 그 뮤텍스를 자동으로 잠그고 열어주는 역할을 할겁니다.

void Push()
{
	for (int32 i = 0; i < 10000; i++)
	{
		// 자물쇠 잠그기
		LockGuard<std::mutex> lockGuard(m);
		//m.lock();

		v.push_back(i);

		if (i == 5000)
		{
			// m.unlock();
			break;
		}

		// 자물쇠 풀기
		//m.unlock();
	}
}
사용하는 방법은 위와 같이 LockGuard 객체를 만들어 주게되면 이 lockGuard 라는 객체가 유효한범위인 for문 안에서 생성됨과 동시에 락을 잠가주고 
for문을 잘 돌아서 다음 반복으로 들어간다던가 조건에 걸려서 브레이크로 가던지 lockGuard가 유효범위를 넘어서면 객체가 소멸되면서 자동으로 락을 풀어주고 
소멸합니다.

이렇게 해서 자동문을 만들어 준상황입니다. 실행을 해봐도 정상적으로 작동합니다.
LockGuard라는 한겹 껍데기가 생기기 때문에 약간의 부하가 추가 되겠지만 확실하게 실수를 잡아주는것이 더 중요하기 때문에 이방법이 더 추천됩니다. 

그리고 이 LockGuard를 사용하는방법이 매번 직접 만들어야 하는것은 아니고 당연하게 이미 준비가 되어 있습니다. 

		std::lock_guard<std::mutex> lockGuard(m);
    
이렇게 사용해도 똑같이 동작합니다.

추가로 lock_guard 와 비슷한 게 있는데 unique_lock 입니다. 왜 같은 효과를 가진 클래스를 두개 만들었을까 궁금한데 
왜냐면 완전히 똑같은 기능을 하는건 아니기 때문입니다.

unique_lock은 lock_guard에 플러스 알파로 추가적인 세부기능이 더 있습니다. 

		std::unique_lock<std::mutex> uniqueLock(m, std::defer_lock);
		uniqueLock.lock();

이렇게 unique_lock을 생성하면서 두번째 인자로 defer_lock을 주게 되면 uniqueLock을 생성하자마자 잠그는게 아니고 밑의 코드처럼 
명시적으로 잠근 순간부터 RAII 패턴으로 동작을 시작합니다. 
잠그기 까지 유예를 둘 수 있는겁니다.

unique_lock이 추가 기능이 있고 추가기능을 사용하기 위해 추가적인 인자를 받고 변수도 필요하니만큼 lock_guard 보다도 약간 더 용량이 많고 부하도 큽니다.



-- 결론 

이렇게 기초적인 Lock 에 대해 알아 봤습니다.

하지만 Lock 은 좀 더 알아볼 내용이 있습니다. 

예를 들어서 for문 내부에서 lock 을 잡아도 되겠지만 for문 밖에서 크게 lock을 잡아도 될겁니다.

void Push()
{
    std::lock_guard<std::mutex> lockGuard(m);
	for (int32 i = 0; i < 10000; i++)
	{
		// 자물쇠 잠그기
		//std::lock_guard<std::mutex> lockGuard(m);
		//std::unique_lock<std::mutex> uniqueLock(m, std::defer_lock);
		//uniqueLock.lock();
		//m.lock();

		v.push_back(i);

		if (i == 5000)
		{
			// m.unlock();
			break;
		}

		// 자물쇠 풀기
		//m.unlock();
	}
}