

        소켓 프로그래밍 - 네트워크 프로그래밍 시작 


드디어 네트워크 파트로 넘어왔습니다. 
통신을 하고 데이터를 주고 받는 내용을 시작할건데 기본적으로 네트워크 이론을 먼저 배우고 소켓 프로그래밍을 배우는게 정석적이긴합니다.

그런데 이번 강의에서는 순서를 바꿔서 일단 소켓프로그래밍에 해딩을 해보고 그 다음에서야 네트워크 이론을 배워보겠습니다. 

본래 순서대로 네트워크 이론부터 배우면 어디에 사용해야 할지도 모르는 내용이기도 하고 양도 많다보니 집중이 잘 안될 수 있는데 먼저 
그 필요성부터 알게되면 좀 더 흥미롭게 배울 수 있을겁니다. 

서버프로그래밍에서는 네트워크 이론은 한번쯤은 공부해야하긴 하기때문에 너무 어렵게 생각하지 않아도 됩니다. 

한가지 더 유의할 점은 지금까지 C++ 문법이나 데이터 관리 같은 종류는 비교적 쉬운 내용이었고 그래픽스나 네트워크 같은게 좀 더 어려운 내용이기는 하지만
꼭 필요한 내용이니깐 포기하지 말고 배워보겠습니다. 

그래픽스때와 마찬가지로 네트워크에서는 매우 많은 함수들이 등장합니다. 
그래서 멘붕이 올지도 모르지만 솔직히 말해서 정신이 없는게 당연한겁니다. 그래픽스를 배울때 처럼 처음 보는 함수하나하나의 모든 동작원리를 
다 알면서 사용할 필요까지는 없습니다. 그냥 전체적인 흐름을 분석하는데 집중해야합니다. 이 분야를 정말로 주력으로 개발하시는 분들이나 전부 이해해야하는 것입니다. 


그래서 이 정신없을 수 있는 소켓 프로그래밍을 설명하기 위해 먼저 대략적인 비유를 통해 알아보겠습니다. 

다시 멀티쓰레드 시작할때 들던 비유인 식당의 이야기를 해보겠습니다. 
서버가 식당과 유사 하다고 했었는데 이번에는 추가로 식당에서 문의전화를 받아서 고객님들의 질문에 대답해주는 시스템을 구축하고 싶습니다.

질문을 보통 기본 상담사에 연결하고 거기서 문제 종류 같은거에 따라 분류를 하게 될겁니다. 

이제 고객 입장에서도 한번 생각해보고 식당 입장에서도 생각해볼겁니다. 

가장 먼저 해야할 일은 직원을 하나 고용해서 안내원으로 사용할건데 이 직원의 역할은 일단 중앙 전화를 받아서 해당 용무의 직원으로 넘겨주는 역할을 할겁니다. 
그러면 이제 일단 대표하는 전화번호를 배정 받아야 할겁니다. 010-1111-2222 라는 번호를 받았다고 해보겠습니다.

고객이 대표전화로 전화를 걸게 될거고 처음 직원은 상시 대기중이라 전화를 받을겁니다. 이 직원을 이제 '대리인' 이라고 하겠습니다. 
대리인에게 전화를 건다음 만약 테이블이라는 구역에 연락할 필요가 생기면 이전에는 테이블에 직원을 하나 더 둬서 연락을 했었는데 이제는 그냥 테이블 위치에 전화기를 하나 더 둬서 
연락을 합니다. 전화를 건 고객의 번호도 대리인의 전화에 찍히게 될것이고 고객의 전화번호도 테이블에 전달되기도 할겁니다. 
그리고 한번 전달된 이후로는 메인 대리인을 통하지 않고도 고객과 테이블 대리인간의 통신이 이루어 집니다. 

이렇게 고객과 식당간에 통신이 이루어 질것이고 이걸 다시 고객 입장에서 이 과정을 알아보겠습니다.

손님관점에서는 식당 관점보다 훨씬 간단합니다. 먼저 손님 자신의 전화번호가 있을거고 그리고 지금 전화하고 싶은 식당의 대표번호로 전화를 걸면 됩니다. 
이렇게가 끝입니다. 

이후로는 식당에서 알아서 테이블 대리인에게 고객 전화를 연결시키게 될겁니다. 


실제 현실과는 다른 비유가 될 수도 있지만 지금 이 설명의 흐름을 이해하는게 중요합니다. 

다시 정리해서 고객 입장과 식당입장을 구분하자면 

- 고객
- 1) 핸드폰 준비
- 2) 식당 번호로 문의 
- 대리인을 통해 식당특과 대화가능

- 식당 
- 1) 안내원 고용
- 2) 안내원 교육 (대표 번호 배정)
- 3) 영업 시작
- 4) 안내
- 대리인을 통해 손님과 대화 가능 

이 흐름을 잘 기억합니다. 그러면이게 앞으로 배워볼 소켓프로그래밍과 구조가 비슷합니다. 

결국 네트워크 통신에서도 클라이언트와 서버가 있을겁니다. 
클라이언트는 단어 그대로 고객, 전화를 거는쪽을 말하는것이고 서버는 서빙을 하는쪽 식당을 말합니다. 

클라이언트
- 1) 소켓 준비
- 2) 서버 주소로 Connect
소켓을 통해 서버와 패킷 송수신 가능

서버
- 1) Listener 소켓 준비
- 2) Bind(서버 주소/ Port를 소켓에 연동)
- 3) Listen
- 4) Accept
클라 세션을 통해 손님과 통화 가능 

위에서 소켓이라는게 핸드폰에 해당하는 단말이고 서버주소가 이제 식당 메인 번호입니다. 
안내원을 Listener 라고 하고 Listener 에게 가게 번호를 교육하는걸 Bind라고 합니다.

다른 세부 용어들은 앞으로 배울것이기 때문이 일단 넘어가겠습니다. 

클라이언트와 서버가 따로따로 동작하기는하지만 클라이언드가 통신을 시작하기 위해서는 서버쪽에 2) Bind 까지 완료가 되고 Listen 함수로 요청을 받고 
Accept으로 답을 리턴하게 될겁니다. 



        - 코드 실습

이번 시간 부터는 클라이언트와 서버를 둘 다 왔다 갔다 하면서 실습해야 하기 때문에 이번 파트 처음에 만들었던 DummyClient 프로젝트를 사용해 볼겁니다. 

DummyClient 프로젝트에서 먼저 WinSock2.h 라는 라이브러리를 추가해야합니다. 

이 라이브러리는 윈도우즈에서 네트워크 프로그래밍을 하기 위해서 필요한 것으로 윈도우즈 소켓이라는 뜻입니다. 
원래는 리눅스의 조상이라고 할 수 있는 유닉스에서 부터 시작되었습니다. 나중에 가가지고 마이크로 소프트에서 윈도우용 소켓 라이브러리를 만든게 이 WinSock2 입니다. 

// 윈도우즈에서 네트워크 시작하기 위한 라이브러리
#include <WinSock2.h>
#include <MSWSock.h>
#include <WS2tcpip.h>

#pragma comment(lib, "ws2_32.lib")

WinSock2, MSWSock, WS2tcpip 이 세가지 라이브러리가 네트워크 이고 그 밑에 #pragma comment(lib, "ws2_32.lib") 이라는 코드도 추가 하였는데 
이 코드는 이전에 ServerCore 에서 모든 헤더들을 모아 놓은 CorePch 를 GameServer나 DummyClient 에 링크 시키기 위해서 사용했던 코드입니다.
그런 코드를 ws2_32.lib 이라는 라이브러리 파일을 프로젝트에 링크시키고 있는겁니다. 이 코드가 없으면 나중에 에러가 뜬다고 합니다. 

->      DummyClient.cpp

        위에서 말했듯이 라이브러리들을 추가합니다. 
        // 윈도우즈에서 네트워크 시작하기 위한 라이브러리
        #include <WinSock2.h>
        #include <MSWSock.h>
        #include <WS2tcpip.h>

        #pragma comment(lib, "ws2_32.lib")

        int main()
        {
                /*
                WinSock 초기화 (ws2_32 라이브러리 초기화)

                WinSock2 를 사용하기 위해 먼저 초기화를 해야합니다. 
                WSAStartup 을 공식 문서에서 보면 인자를 두개 받는데 
                WORD  wVersionRequired,  LPWSDATA lpWSAData 를 받습니다. 
                첫번째 인자는 버전을 정하는 건데 1.0, 1.1, 2.0, 2.1, 2.2 가 있다고 하지만 현재 보통
                2.2 버전만을 사용한다고 합니다. 
                관련 정보가 두번째 인자인 wsaData 에 담기기는 하지만 딱히 따로 사용을 하지는 않을겁니다. 
                */

                WSAData wsaData;
                if (::WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
                        return 0;



                ::WSACleanup();
        }

        ws2_32.lib 을 초기화 하고 사용해야 하기 때문이 WSAStartup 이라는 초기화 함수를 실행 해줘야 합니다. 반환 값은 성공했다고 하면 0을 반환하고 
        이외의 경우에는 다른 값을 반환합니다. 인자는 첫번째로 어느 버전을 고를지를 WORD 타입으로 넣어 줍니다. 
        두번째 인자는 WSAData 로 ws2_32 관련 데이터가 담기는 객체입니다. 정보가 담기기는 하지만 직접 그 데이터를 다룰 일은 많이 없을겁니다. 

        WSAStartup 함수와 WSACleanup 함수 사이에서 우리가 하려고 하는 일을 하면 되는데 아까 배웠던 클라이언트 에서 할 일을 그대로 해보겠습니다. 

        먼저 클라이언트의 socket 을 준비 (손님의 전화를 준비) 하는 함수를 알아보겠습니다. 

        ::socket(int af, int type, int protocol) 

        이런 시그니쳐를 가지고 있는 socket 생성 함수입니다. 첫번째 인자인 af 는 Address Family 로 익히 아는 IPv4, IPv6 인데 어렴풋이만 아는 이것들은 
        커맨드 프롬프트 에서 ipconfig를 쳐보면 자신의 컴퓨터의 ip 를 확인할 수 있습니다. 
        IPv4 는 가장 흔히 아는 IP 주소의 형태인 000.000.000.000 형태의 세자리 정수가 네개 있는 형태이고 
        IPv6 는 0000::0000:0000:0000:0000%00 의 형태로 정수뿐만 아니라 각 자리가 16진수들로 이루어 져있습니다. 

        옛날에는 다들 IPv4 사양을 사용했습니다. 그런데 이제 서버 네트워크가 꼭 게임을 만드는것 뿐만아니라 여러 무선 장치에 명령을 내린다건가 
        온갖 기기 끼리 서로 통신을 해야될때 각각의 네트워크 통신에는 고유한 네트워크 주소를 발급받아서 연결을 해야하는데 
        기기가 하도 많아지다 보니 IPv4 주소가 고갈이 되어 버렸습니다. 그래서 더 많은 수의 기기를 수용할 수 있는 주소체계인 IPv6 를 사용하게 된겁니다.

        그렇지만 지금은 간단하게 IPv4 버전으로 사용하고 나중에 IPv6에 대한 내용을 알아볼겁니다. 
        IPv4 는 AF_INET 을 주면 됩니다. 

        두번째 인자인 type은 TCP로 통신할지 UDP로 통신할지를 골라주는 옵션입니다. 이게 많은 차이를 내지만 이 내용은 나중에 더 자세히 다룰겁니다. 
        일단 TCP 로 만든다고 생각하고 넘어가겠습니다. 보통 게임에서는 항상 TCP 타입으로 통신을 한다고 합니다. 
        TCP 방식을 한줄 요약을 하자면 통신을 안정적이게 해줍니다. 만약 통신하다 패킷을 잃어버렸다고 해도 TCP프로토콜 단계에서 따로 처리해주지 않아도 
        재전송을 해주고 데이터가 오염이 되었는지도 체크해주는 기능이 있다고 합니다.

        UDP 는 반면 무조건 재빨리 보내는 기능에 초점이 맞춰져 있습니다. 그렇다 보니 중간에 패킷이 유실되는 경우가 많습니다. 

        그런 이유로 일단 TCP 타입을 사용해볼겁니다. SOCK_STREAM 을 주면 됩니다. 

        마지막 세번째 인자로 protocol 을 넣어주는데 여러 옵션이 있지만 보통은 그냥 0을 준다고 합니다. 옵션마다 사용할 프로토콜을 정해주는데 
        0을 주면 알아서 정해주겠다는의미라고 합니다. 
        그런데 위에서 정해준 af, type 값들을 사용하면 사용할 수 있는 프로토콜이 하나 뿐이고 괜히 다른 프로토콜을 정해서 모순되게 하는걸 피하는겁니다. 

        ::socket(AF_INET, SOCK_STREAM, 0);

        여기서 이 socket 이라는 함수가 반환하는것은 socket descriptor 라는 걸 반환 해주고 있습니다. 
        
        SOCKET clientSocket = ::socket(AF_INET, SOCK_STREAM, 0); 

        이렇게 반환을 받아주고 있는데 SOCKET 이라는 매크로 타입에 커서를 대보면 사실 UINT_PTR SOCKET 즉 UINT 정수타입이었습니다. 
        이 정수를 이용해서 뭘 할 수 있냐면 나중에 운영체제에게 몇번에 해당하는 소켓을 이용하고 싶다고 요청하면 이 정수에 해당하는 소켓 리소스를 가지고 통신을 할 수 
        있게 될겁니다. 말 그대로 소켓을 구분할 수 있는 번호 같은 겁니다. 

        지금하고 있는 작업 자체가 유저 레벨에서 작업을 하고 있는것이기 때문에 여기서 중요한 부분을 직접 건드릴 수 는 없고 항상 운영체제에 요청해서 
        커널 레벨의 작업을 하게 됩니다. 

        ::socket 함수가 실패를 할 수 도 있는데 그때 반환하는 값은 INVALID_SOCKET이라는 사실 -1 인 값을 대신하는 매크로를 반환하게 됩니다. 
        if (clientSocket == INVALID_SOCKET)
	{
		int32 errCode = ::WSAGetLastError();
		cout << "Socket ErrorCode : " << errCode << endl;
		return 0;
	}
        왠만하면 실패하지 않을테지만 만약 ::socket 함수가 실패했다면 조건으로 체크를 해줍니다. 
        WSAGetLastError 라는 함수로 왜 실패했는지 에러 코드를 받아서 출력해주고 끝내줄겁니다. 

        이제 손님 입장에서의 첫번째 할일인 자신의 소켓 (자신의 전화번호)를  준비했습니다. 다음 단계는 전화를 걸 서버의 소켓 번호(식장의 대표번호) 를 받아오는겁니다. 
        
        // 이제 서버쪽의 소켓(대표전화번호) 를 받아와야 합니다. 
	SOCKADDR_IN serverAddr;	// IPv4 버전
	::memset(&serverAddr, 0, sizeof(serverAddr));	// serverAddr 일단 0으로 밀어줍니다.
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = ::inet_addr("127.0.0.1");
	serverAddr.sin_port = ::htons(7777);

        서버쪽 소켓 주소를 받아올때 SOCKADDR_IN 이라는 구조체로 받아올건데 이 구조체가 이번에 사용할 IPv4 용의 구조체입니다. 
        먼저 데이터를 담기전에 memset을 사용해 0으로 쫙 밀어주고 시작합니다. 

        SOCKADDR_IN 구조체를 따라 들어가보면 
        typedef struct sockaddr_in {
        #if(_WIN32_WINNT < 0x0600)
        short   sin_family;
        #else //(_WIN32_WINNT < 0x0600)
        ADDRESS_FAMILY sin_family;
        #endif //(_WIN32_WINNT < 0x0600)

        USHORT sin_port;
        IN_ADDR sin_addr;
        CHAR sin_zero[8];
        } SOCKADDR_IN, *PSOCKADDR_IN;

        이렇게 되어 있는데 sin_family, sin_port, sin_addr, sin_zero 라는 데이터들을 가지고 있습니다. 
        이중에 sin_zero 라는 데이터는 그냥 0으로 체워쳐 있는 8개 짜리 CHAR 배열입니다. 실질적으로는 sin_family, sin_port, sin_addr 을 채워주면 되는데 
        sin_family 에 커서를 가져다 대면 unordered short 타입이라는 걸 알 수 있고 sin_port 도 마찬가지 입니다. 
        sin_addr 은 타고 들어가보면 union 문법으로 조금 복잡하게 되어있습니다.  
        typedef struct in_addr {
                union {
                        struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                        struct { USHORT s_w1,s_w2; } S_un_w;
                        ULONG S_addr;
                } S_un;
        #define s_addr  S_un.S_addr /* can be used for most tcp & ip code */
        #define s_host  S_un.S_un_b.s_b2    // host on imp
        #define s_net   S_un.S_un_b.s_b1    // network
        #define s_imp   S_un.S_un_w.s_w2    // imp
        #define s_impno S_un.S_un_b.s_b4    // imp #
        #define s_lh    S_un.S_un_b.s_b3    // logical host
        } IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;
        결국은 ULONG S_addr 을 담고 있는 구조체인데 저 세세히 설정하자면 UCHAR 로 4개를 지정해주던가 
        USHORT 로 두개 를 지정해준다던가 해주는 구조체 입니다. 

        결국 sin_family, sin_port, sin_addr 는 각자 USHORT, USHORT, ULONG 의 정수를 뜻합니다. 

        sin_family 에는 AF_INET을 넣어주었는데 클라이언트에서 소켓을 만들때 도 IPv4를 사용하는 옵션이었고 서버도 같은 버전의 IP 를 사용한다고 알려주고 있는겁니다.
        sin_port 는 결국 내부적으로 받아주는 타입은 USORT 4바이트 정수를 담아주어야 합니다. 그런데 IP를 표현할때 정수로 표현하면 힘들다 보니 
        s_addr = ::inet_addr 에서 1바이트씩 끊어 표현해주고 있습니다. 문자열로 끊어서 인자로 주면 변환을 해주는 함수인데 
        그런데 이 inet_addr 이라는 함수를 이대로 빌드해보면 너무 구식이라고 사용하지 말라고 경고 메세지가 뜨는데 
        
        ::inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);
        
        이 버전을 사용하는게 좀 더 현대적인 버전이라고 할 수 있습니다. 

        그건 그렇고 IP주소를 줄때 하드 코딩으로 127.0.0.1 이라고 주고 있는데 컴퓨터 마다 IP주소가 다를텐데 이렇게 하드 코딩해도 되는가 의문이 생길 수 있는데
        기본적으로 127.0.0.1 이라는 주소는 루프 백 주소라고 스스로의 컴퓨터에 다시 요청을 보내는 주소입니다. 
        지금 우리 환경 자체가 클라이언트와 서버를 한 컴퓨터 내에서 주고 받고를 할것이기 때문에 사용할 수 있습니다. 

        나중에 실제로 온라인 게임을 배포하게 된다면 루프백 주소 부분을 실제 서버의 IP주소로 바꿔줘야 할것입니다. 
        지금처럼 하드하게 직접 입력하는 방법은 별로고 나중에는 DNS 서버를 이용해서 IP주소를 찾아주도록 유도 해줘야합니다. 
        DNS 란 www.naver.com 같은 도메인 네임 시스템 을 말합니다. 
        지금은 일단 이부분에 서버 IP주소를 입력한다는 것만 알고 넘어가면 됩니다. 

        sin_port 는 항구라는 의미대로 서버에서도 접근할 임의의 번호를 지정해주면 됩니다. 그런데 이 번호를 아무 번호가 아니라 서버에서도 똑같은 포트 번호를 
        지정해주게 될것입니다. 
        
        어떻게 보면 연결할 목적지는 서버의 IP 주소 + 포트번호 인겁니다. IP주소로 건물 주소를 찾고 port 로 동호수를 찾는 느낌입니다. 

        추가로 port 번호를 임의로 정한다고는 했지만 모든 번호를 그냥 사용할 수 있는건 아니고 80 번 포트의 경우는 웹통신(HTTP)을 위해서 예약이 되어있는 등
        일부 번호는 특정 목적으로 예약이 되어 있습니다. 그래서 곂치치 않을 것 같은 포트인 7777 을 이번에 사용해보는 겁니다. 

        그러면 sin_port 의 내용을 넣어줄때 사용한 ::htos 라는 함수는 무엇이냐면 host to network short의 약자인데 
        포트를 그냥 직접 7777로 넣어주면 안되는게 Endian 이슈라는게 있습니다.  

        Little-Endian vs Big-Endian  이렇게 두가지 가 있는데
        예를들어 0x12345678 라는 정수가 있다고 해보겠습니다. 이게 4바이트 정수인데 이걸 메모리에 저장할때 
        low [0x78][0x56][0x34][0x12] high       이렇게 저장하는 방법이 있고 
        low [0x12][0x34][0x56][0x78] high       이렇게 저장하는 방법이 있습니다.
        
        이 두 방법중 위쪽의 방법이 Little-Endian 이고 아래 방법이 Big-Endian 입니다. 딱히 어떤게 더 낫다는거는 아니고 각자 장단점이 있는데 
        각자의 환경에 따라 다른건데 요즘에는 보통 모바일 기기나 PC 에서는 Little-Endian 을 사용할 것입니다. 
        대부분 리틀 엔디언을 사용한다고 그냥 통신할때 모두 리틀 엔디언 방식으로 보내고 받으면 되는가? 하면 그건 또 아닙니다. 
        보내는 기기에서는 리틀 엔디언이라고 해도 받는 쪽 기기가 만약 빅 엔디언을 사용하고 있다면 보내는 쪽에서 의도한 데이터와 전혀 다르게 인식을 하게 됩니다. 
        또 네트워크에서는 빅 엔디언을 표준으로 생각한다고 합니다. 
        네트워킹을 할때 곧바로 클라이언트와 서버가 직접 통신하는게 아니라 중간에 끼인 여러 기기 들을 통해 주소에 맞는 기기가 통신을 하게 되는데 
        이 중간의 기기들의 표준이 빅 엔디언 이기 때문에 우리가 데이터를 보낼때 빅엔디언 방식으로 바꿔서 보내줘야합니다. 

        그것을 host(나의 컴퓨터의 엔디언 방식) to network(네트워크에서 사용하는 엔디언 방식) 으로 바꿔주겠다는 의미입니다. 
        실제로 제 컴퓨터에서 0x12345678 을 저장 한 변수를 메모리 에서 찾아보면 리틀 엔디언 방식으로 저장하고 있습니다. 

        htons 라는 함수를 달달 외워야 한다기 보다는 이름에서 어떤 일을 하는것 같은지를 유추해서 사용하면 되겠습니다. 
        당연히 반대로 네트워크에서 호스트로 변환 하는 함수도 있고 합니다. 

        여기까지해서 네트워크 목적지를 만드는 코드를 알아 봤습니다.  그럼 이제 이 목적지를 정해졌으니까 전화를 걸어야 할겁니다. 

        전화를 걸때는 connect 라는 함수를 이용하게 됩니다. 
        
        ::connect(SOCKET s, const sockaddr* name, int namelen);
        이런 시그니처를 가지고 있는데 첫번째 인자부터 전화를 거는 주체인 클라이언트의 소켓을 줍니다. 
        두번째 인자는 전화를 걸 서버의 주소를 주는데 어째서인지 sockaddr* 타입으로 줍니다. 세번째 인자는 두번째 인자의 크기를 줍니다. 

	::connect(clientSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr));
        우리가 만든 코드에서는 이렇게 주게 되는건데 두번째 인자를 보면 우리가 serverAddr를 그냥 SOCKADDR 이 아닌 SOCKADDR_IN 으로 만들었습니다. 
        이 SOCKADDR_IN 은 IPv4 버전의 아이피 주소를 위한 구조체였는데 

        connect 에서는 IPv4 뿐만아니라 다양한 주소 체계를 받아줄 수 있기 때문에 name 과 함께 namelen을 같이 받아주고 있습니다. 

        connect 함수를 시도했을때 실패 할 수도 있습니다. 그 경우에는 에러 코드를 반환하는 코드도 필요합니다. 아까 socket 함수와 비슷하게 
        만들 수 있습니다.
        
        if (::connect(clientSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
	{
		int32 errCode = ::WSAGetLastError();
		cout << "Connect ErrorCode : " << errCode << endl;
		return 0;
	}

        만약 이 조건문을 통과했다면 connect 함수가 잘 실행이 된것입니다. 

        이 말은 이때부터 클라이언트와 서버간의 데이터를 송수신 할 수 있다는 이야기입니다. 지금시점에서는 거기까지는 진행하지 않을것이지만 
        언젠가 포트폴리오 게임이나 실제 프로젝트에서는 그럴 것이라는 말입니다. 

        이런저런 통신이 끝나고 프로그램이 끝날때는 아까 WinSock을 종료하는 WSACleanup 이라는 함수를 미리 만들어 놨었는데 
        socket 도 마찬가지로 마무리로 밀어주는 함수가 있습니다. 

	// 소켓 리소스 반환 
	::closesocket(clientSocket);

        디테일을 좀더 말하자면 클라이언트에서 WSAStartup 을 한 횟수만큼 똑같이 WSACleanup 을 호출해주는 것까지 권고 사항입니다. 

이렇게 클라이언트 입장에서의 소켓 프로그래밍을 시작해 봤습니다. 이번 시간에 우르르 쏟아지는 새로운 함수들을 보면 하나하나 모두 한번은 이해를 하고 넘어가야 하지 않을까 
생각이 들 수 있습니다. 저는 그랬는데 코드를 따라 작성해보았고 대강 설명을 듣기는 했는데 내가 이해한 내용이 정확한지 확신이 안가는 상황입니다. 

그런데 다시 말하자면 프로그래밍에는 너무나 방대한 분야가 있고 각 분야의 깊이는 또 엄청나게 깊다보니 어떤 프로그램을 만들고자 할때 구성하는 모든 분야를 
섭렵하고 넘어가려면 끝이 없습니다. 그러다 보니 왠만한 프로그램은 모두 각자 담당하는 분야에서 최선을 다하는 것이기도 합니다. 

시작하는 입장에서는 대략적인 흐름, 손님이 전화를 준비하고 전화를 걸 가게의 대표번호를 알아내고 또 그곳에 연결한다는 흐름을 기억하는 것부터 시작하는게 좋을겁니다.

지금 시점까지는 클라이언트 입장에서 소켓프로그래밍을 시작했다고 했는데 현재는 아무것도 되지 않을겁니다. 서버에 커넥트는 했지만 받는 입장인 서버에서 이 커넥트를 
받아줘야 성공적으로 통신을 이루는 것일테니 클라이언트 코드만 만든 지금은 connect 함수가 실패하고 끝날겁니다. 


->      GameServer.cpp

        이제 서버쪽 코드도 배워볼건데 흐름쪽에서 말했듯이 서버쪽이 좀 더 복잡합니다. 하지만 곂치는 부분도 있습니다. 예를들어 WinSock을 시작하고 닫는 부분은 공통입니다. 
        그리고 클라이언트 소켓을 만드는 부분도 거의 비슷한데 이름만 clientSocket 에서 listenSocket 이라고 바꿔 줍니다. 
        서버의 이 listenSocket 은 식당에서 가장 처음 문의 전화를 받는 대리인과 대리인이 사용할 가게 대표번호를 할당하는 부분입니다. 

        {

                WSAData wsaData;
                if (::WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
                        return 0;

                SOCKET listenSocket = ::socket(AF_INET, SOCK_STREAM, 0);

                if (listenSocket == INVALID_SOCKET)
                {
                        int32 errCode = ::WSAGetLastError();
                        cout << "Socket ErrorCode : " << errCode << endl;
                        return 0;
                }


                // WinSock 종료
                ::WSACleanup();
        }

        클라이언트에서는 Socket 을 만든 다음은 연결할 목적지의 주소를 만들었는데 서버쪽에서는 조금 다르게 연결할 목적지가 아니라 나에 대한 주소
        즉 회사의 주소를 찍어줍니다. 

        // 나 자신 서버의 주소를 찍어줍니다. 
	SOCKADDR_IN serverAddr;	// IPv4 버전
	::memset(&serverAddr, 0, sizeof(serverAddr));	// serverAddr 일단 0으로 밀어줍니다.
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = ::htonl(INADDR_ANY); // << 니가 알아서 해줘
	serverAddr.sin_port = ::htons(7777);

        클라이언트 쪽 코드와 다른점은 serverAddr.sin_addr 의 내용을 넣어줄때 직접 127.0.0.1 로 넣어주던 것과 다르게 INADDR_ANY 라는 걸로 채워주고 있습니다. 
        무슨 의미냐면 주소를 알아서 해달라고 요청하는 것인데 클라이언트 처럼 직접 그 주소를 입력하면 딱 그 주소로만 통신이 가능하지만
        INADDR_ANY 은 가능한 모든 주소를 알아서 연결해줍니다. 클라처럼 루프백 주소로 연결해도 서버에서는 연결이 될것이고 아니면 실제 이 컴퓨터의 IP 주소로 연결해도 
        연결이 될겁니다. 그렇게 유동적으로 연결이되는데 

        클라는 연결할 서버가 하나뿐이니 그냥 주소를 직접 적어도 되었지만 서버는 연결을 받을 곳이 특정되지 않고 여러 곳에서 올 수 있기 때문에 어느 주소로 와도 대응 가능한게 
        좋을것입니다.

        다음으로 할 일은 이제 안내원과 대표 번호를 연결하는 작업인데 이걸 bind 라고 했었습니다. 같은 이름의 함수를 사용합니다. 

        // 안내원의 폰 개통! 식당의 대표번호 
	if (::bind(listenSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
	{
		int32 errCode = ::WSAGetLastError();
		cout << "Binding ErrorCode : " << errCode << endl;
		return 0;
	}

        bind의 사용법은 connect 와 매우 유사합니다. 다른점은 내가 연결을 시도할 주소를 받는게 아니라 나 자신의 주소를 받아서 외부에서의 통신을 받을 준비를 하는것입니다. 

        bind 까지는 아직 연결을 시작한게 아니라 안내원인 소켓과 서버의 주소를 연결해준 시점이고 실제로 연결을 시작하는걸 listen 이라고 합니다. 

        // 영업 시작!
	if (::listen(listenSocket, 10) == SOCKET_ERROR)
	{
		int32 errCode = ::WSAGetLastError();
		cout << "Listen ErrorCode : " << errCode << endl;
		return 0;
	}

        listen 함수의 인자 목록은 이렇습니다. 
        ::listen(SOCKET s, int backlog); 
        
        연결을 받을 안내인인 소켓을 주는건 알겠는데 backlog 라는 int를 추가로 받고 있습니다. 이게 뭐냐면 일종의 식당 대기줄 인데 
        식당에서도 손님이 몰리면 대기줄을 받기는하는데 무한정 받지는 않고 매장에서 감당 가능할 만큼만 받고 이후로는 돌려보내듯이 네트워크 통신에서도 한번에 수많은 클라이언트에서 
        연결이 들어오게되면 밀리는 연결요청들을 backlog 의 수만큼을 대기 시켜두고 그 이후로는 연결시도를 취소 시킵니다. 

        지금 만드는 이 코드에서는 backlog를 10만 주었지만 나중에는 이것보다는 훨씬 큰 수를 주게 될겁니다 이런 저런 테스트를 거쳐서 감당 가능한 backlog 수를 찾을 것입니다. 
        또 listen 함수도 마찬가지로 실패 케이스에서는 에러코드를 출력하고 종료할것입니다. 

        listen 에서 연결을 시작한다고 했지만 이 코드를 식당의 예시에서 보면 메인 대리인이 전화를 받은 순간이 listen 이고 이 전화를 담당하는 부서로 넘겨주고 그때부터 
        담당부서와 고객간의 직접 통화를 시작할건데 이부분은 accept 라고 합니다. 
        
	while (true)
	{
		SOCKADDR_IN clientAddr;
		::memset(&clientAddr, 0, sizeof(clientAddr));
		int32 addlen = sizeof(clientAddr);
		SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addlen);
		if (clientSocket == INVALID_SOCKET)
		{
			int32 errCode = ::WSAGetLastError();
			cout << "Accept ErrorCode : " << errCode << endl;
			return 0;
		}

		// 손님 입장
		char ipAddress[16];
		::inet_ntop(AF_INET, &clientAddr.sin_addr, ipAddress, sizeof(ipAddress));

		cout << "Client Connected! IP = " << ipAddress << endl;

		// TODO
	}

        accept 부분을 while(true) 로 돌고 있는 이유는 실제로 통신시도가 올때 까지 기다리는 것입니다. 
        이 부분의 주요함수인 ::accept 함수의 시그니처를 보겠습니다. 
        
        ::accept(SOCKET s, sockaddr* addr, int* addrlen);  이고 반환은 SOCKET을 반환합니다. 
        
        언뜻 보기에는 connect, bind, listen 같은 함수들과 얼추 비슷해 보입니다. 하지만 분명히 다른점이 있는것이 
        첫번째 인자인 소켓은 서버 자신의 소켓을 주는것은 맞습니다. 두번째 인자가 받는 addr 가 특이한데 serverAddr 의 포인터를 받는게 아니라 통신 요청을 한 쪽
        클라이언트의 주소가 들어올 주소입니다. 또 특이한게 세번째 인자가 왜인지 모르겠지만 주소의 길이를 직접 넣어주는게 아니라 그 주소를 넘겨줘야합니다. 

        이 두가지 유의할점을 위해 먼저 0으로 밀어놓은 clientAddr 를 만들었고 그 사이즈를 addrlen을 미리 만들어 놨습니다.

        그리고 반환 타입인 SOCKET 은 통신연결된 클라이언트의 소켓을 반환합니다. 반환된 클라이언트 소켓이 INVALID_SOCKET 이라면 accept 가 실패한 것이기 때문에 체크해줍니다.

        디테일로 accept 의 두번째 세번째 인자들은 사실 옵션이라서 지금처럼 꼭 변수를 만들어 받아주지 않아도 됩니다. 지금은 이후에 클라이언트의 아이피를 출력할것이기 때문에 
        따로 받아주고 있습니다. 

        이후 말한대로 클라이언트의 아이피를 꺼내는 방법은 우선 char 16개 짜리 배열 16바이트를 만들어서 보기 편한 문자열로 만듭니다. 
        이후 inet_ntop 함수를 사용해 아이피를 추출하는데 
        인자는 순서대로 IPv4 라는 IP 주소체계, addr 의 포인터 여기서는 아까 accept에서 받은 clientAddr.sin_addr의 주소, 아이피를 받을 변수인 ipAddress, ipAddress 의 크기를 
        인자로 줍니다. 

        출력하면 끝입니다. 

일단 서버쪽 소켓 프로그래밍은 여기서 마칩니다. 클라이언트 보다는 좀 더 복잡했지만 막상 따라 해보면 그렇게 까지 어렵다는 느낌은 아닙니다. 

테스트를 해볼건데 우리 솔루션인 Server의 속성에 들어가면 실행할때 하나의 프로젝트만 실행할지 아니면 여러 프로젝트를 같이 시작할지를 고를수 있습니다. 
DummyClient 와 GameServer를 같이 실행하도록 설정합니다. 

제대로 따라왔으면 두개의 커맨드 프롬프트가 뜰겁니다. 한쪽은 Connected to Server, 다른쪽은 Client Connected! IP = 127.0.0.1 이라고 뜹니다. 

오늘 내용에서 중요한것은 전체적인 흐름입니다. 꼭 한번 다시 복습을 해보면 좋겠습니다. 