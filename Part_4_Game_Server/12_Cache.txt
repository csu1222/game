

        컴퓨터 구조 원리 : 캐시와 파이프라인


이번시간에는 뜬금없긴하지만 컴퓨터 구조에 대해 알아보고 그 중에서도 캐시와 파이프라인에 대해 집중적으로 알아보겠습니다. 
왜 갑자기 컴퓨터 구조를 배우냐면 다음 주제인 메모리 모델을 이해하기 위한 기초 지식입니다. 


먼저 캐시 부터 시작하겠습니다. 

- 캐시 cache
실제 컴퓨터를 뜯어 보면 가장 중요하고 연산을 하는 장치인 CPU 와 저장공간인 RAM 이라는게 있습니다. 
RAM에 저장되어있는 데이터를 꺼내서 CPU에 주고 CPU에서 연산을 해줄겁니다. 우리가 배우던 스택메모리니, 데이터 영역이니 하는
것들이 다 RAM에 위치합니다.

그런데 실물 컴퓨터 보드를 보면 생각보다 CPU와 RAM사이에 거리가 꽤 있습니다. 그런데 프로그램을 실행하면서 RAM과 CPU 간의
통신이 수없이 일어날텐데 그때 마다 이 거리를 왕복해야하는게 비효율적으로 보입니다. 

CPU는 동작이 굉장히 빠른데 CPU혼자서 동작하는 경우는 거의 없고 저장장치 RAM에서 여러가지 데이터를 가져와서 동작합니다. 

대강 CPU가 4~50회 연산하는동안 데이터를 가져오는것은 한번정도 동작하기 때문에 데이터 전송하는 비용이 CPU연산에 비해 
되게 큽니다.

그래서 이 문제를 어떻게 우회 했냐면 '캐시'라는 개념을 도입했습니다. 
캐시는 임시저장소라고 보면되고 저장된 데이터가 영구히 보관되는건 아니고 일종의 메모장이라고 보면 되겠습니다. 

그리고 캐시는 하나만 있는것이 아니라 여러개를 두고 있습니다. 레지스터, L1 캐시, L2 캐시 등으로 이뤄져 있는데
각각이 피라미드 구조로 되어있고 앞의 캐시일 수록 용량이 적고 고급인 저장소입니다. 
이 캐시까지 뒤져서 필요한 데이터가 없아고 하면 그때서 RAM으로 가서데이터를 찾게됩니다. 
RAM에서 한번 가져온 데이터는 혹시 또 사용될 수 있으니 캐시에 저장하게되고 다음 CPU의 동작때 필요한 데이터를 찾으러 RAM으로 
바로 가지 않고 혹시 가까운 캐시에 있을 수 있으니 한번 찾아본 다음 없다면 RAM으로 갑니다. 

물론 캐시의 용량이 크지는 않기 때문에 프로그램이 실행되면서 용량이 다 차면 가장 오래되고 가장 사용 빈도수가 낮은 데이터 부터 
점차 비우면서 진행이 됩니다. 

캐시를 설계할때 두가지 철학을 고려합니다. 
1) TEMPORAL LOCALITY
- 시간적으로 보면, 방금 주문한 테이블에서 추가 주문이 나올 확률이 높다.
  방금 주문한걸 메모해 놓으면 편하지 않을까?
2) SPATIAL LOCALITY
- 공간적으로 봄ㄴ, 방금 주문한 사람 근처에 있는 사람이 추가 주문을 할 확률이 높다.
  방금 주문한 사람과 함석하고 있는 사람들의 주문 목록도 메모해 놓으면 편하지 않을까?

사용한지 두시간 지난 데이터 보다는 5초전에 사용한 데이터가 다시 사용할 확률이 높을것이고, 동떨어진 데이터 보다는 인접한 데이터를 
사용할 확률이 높을거라는 기준으로 캐시를 설계합니다. 

물론 왠만한 프로그래머가 직접 캐시를 만드는 일은 없고 사용만 할것이기는 한데 그래도 이런 기준들에 대해서는 알아두는게 좋을겁니다. 

이제 우리들의 컴퓨터에 있을 캐시를 좀 더 직접적으로 느껴보도록 실습해보겠습니다. 


int32 buffer[10000][10000];


int main()
{
	memset(buffer, 0, sizeof(buffer));

	{

		uint64 start = GetTickCount64();

		int64 sum = 0;

		for (int32 i = 0; i < 10000; i++)
		{
			for (int32 j = 0; j < 10000; j++)
				sum += buffer[i][j];
			
		}

		uint64 end = GetTickCount64();

		cout << "Elapsed Tick" << (end - start) << endl;
	}

	{

		uint64 start = GetTickCount64();

		int64 sum = 0;

		for (int32 i = 0; i < 10000; i++)
		{
			for (int32 j = 0; j < 10000; j++)
				sum += buffer[j][i];

		}
		uint64 end = GetTickCount64();

		cout << "Elapsed Tick" << (end - start) << endl;
	}
}

이게 실습해볼 코드입니다. buffer라는 변수는 컴퓨터 그래픽스에서 이미지를 숫자로 표현하는 방식입니다. 지금은 일단 이차 배열이라고 알아두겠습니다.
main 함수에서는 buffer 안에 혹시 다른 쓰레값이 들어 있을 수 있으니 범위의 모든데이터를 0으로 밀어버렸습니다. 

중괄호로 영역 두개를 집어 줬는데 각 영역에서 buffer를 이중 for문으로 순회를 하고 있습니다. 그런데 두 영역에 차이점은 buffer에 접근하는 순서가 
[i][j] 이냐 [j][i] 이냐의 차이입니다. 그리고 각 영역의 연산이 걸리는 Tick 을 구해서 출력합니다. 
컴퓨터 구조를 고려하지 않고 생각한다면 어떤 순서든간에 똑같이 끝나야 합니다. 

하지만 실질적으로 실행해보면 