

        UDP 서버 실습


지난번에 실습해봤던 TCP 서버를 UDP로 적용해보는 실습을 해볼겁니다. 
잠시 복습해보면 TCP 서버에서는 일단 WinSock을 실행 한다음 listenSocket을 만들게 됩니다.
이 소켓은 bind, listen, accept 세가지 함수 세트를 실행해줄건데 bind에서는 listenSocket 에 서버 자신의 주소인 serverAddr 을 지정해 줍니다. 
listen 에서는 어떤 소켓으로 통신 접속을 기다릴지, 또 한번에 몇개의 접속을 기다려 줄 지도 정해주었습니다.
마지막 accept는 실제 서버와 클라간의 연결이 되는 시점인데 이함수의 반환값이 어떤 소켓을 반환하고 이 소켓은 연결이 된 클라이언트의 소켓입니다. 
이후로 실제 데이터를 주고받는 동작은 이 클라이언트 소켓을 통해 진행됩니다. 
이것이 TCP 통신의 개요였습니다. 

이어서 이걸 UDP로 바꿔볼겁니다.
순서대로 서버 소켓을 만들어 주는 부분부터 조금 달라지는 점이 있습니다. TCP에서는 listenSocket 하나와 이후로 listen 함수의 backlog 개수만큼 
accept를 할 수 있고 만약 10개로 설정했다면 listenSocket과 10개의 clientSocket 으로 총 11한개의 소켓이 생성됩니다. 
하지만 UDP에서는 그냥 소켓 하나만 만들면 됩니다. 

    SOCKET serverSocket = ::socket(AF_INET, SOCK_DGRAM, 0);
	if (serverSocket == INVALID_SOCKET)
	{
		HandleError("Socket");
		return 0;
	}

차이점은 socket 함수의 두번째 인자가 UDP를 의미하는 SOCK_DGRAM으로 바뀌었다는겁니다. 
또 HandleError 라는 함수는 이전에 에러코드를 찍어주는 코드가 너무 반복되길레 인자로 이유를 적어주면 이유와 에러코드를 출력해주는 함수를 만들었습니다. 

void HandleError(const char* cause)
{
	int32 errCode = ::WSAGetLastError();
	cout << cause << " ErrorCode : " << errCode << endl;
}

서버 소켓을 만든 다음은 자신의 주소를 bind 할 차례입니다. 
그전에 먼저 자신의 주소를 SOCKADDR_IN serverAddr 로 만들어 주겠습니다. 

	SOCKADDR_IN serverAddr;	// IPv4 버전
	::memset(&serverAddr, 0, sizeof(serverAddr));	// serverAddr 일단 0으로 밀어줍니다.
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = ::htonl(INADDR_ANY);
	serverAddr.sin_port = ::htons(7777);

이 코드는 TCP에서도 똑같이 사용했었습니다. 

	if (::bind(serverSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
	{
		HandleError("Bind");
		return 0;
	}

바인드 코드도 똑같습니다. 다른것은 에러 출력을 HandleError 함수로 하고 있다는 것입니다. 

다음으로 TCP 에서는 listen , accept 까지 했었습니다. UDP에서는 사실 이게 준비의 끝입니다. 바로 데이터를 받아주면됩니다. 

	while (true)
	{	
		SOCKADDR_IN clientAddr;
		::memset(&clientAddr, 0, sizeof(clientAddr));
		int32 addrLen = sizeof(clientAddr);

		char recvBuffer[1000];
		int32 recvLen = ::recvfrom(serverSocket, recvBuffer, sizeof(recvBuffer), 0,
			(SOCKADDR*)&clientAddr, &addrLen);

		if (recvLen <= 0)
		{
			HandleError("RecvFrom");
			return 0;
			// 나중에 클라이언트가 여러개가 된다면 서버를 그냥 끄면 안되고 에러가 난 
			// 클라만 끊어 줘야 합니다.
		}

		cout << "Recv Data! Data = " << recvBuffer << endl;
		cout << "Recv Data! Len = " << recvLen << endl;

		int32 errorCode = ::sendto(serverSocket, recvBuffer, sizeof(recvBuffer), 0,
			(SOCKADDR*)&clientAddr, sizeof(clientAddr));

		if (errorCode == SOCKET_ERROR)
		{
			HandleError("SendTo");
			return 0;
			// 여기도 마찬가지로 에러가 났다고 서버 프로그램을 그냥 종료하는게 아니라 
			// 해당하는 클라의 연결을 끊어주는 처리를 해야합니다. 
		}


		cout << "Send Data! Len = " << recvLen << endl;
	}

데이터 처리를 지속하도록 무한 루프문 안에서 동작합니다. TCP 에서 사용하던 데이터 받는 함수였던 recv 대신 recvfrom 이라는 함수를 사용합니다. 
recvfrom이 반환하는것은 받은 데이터의 크기를 정수로 받아주고 있고 만약 함수 실행이 실패했다면 -1 을 반환합니다. 
시그니처는 이렇습니다. 

	int recvfrom(SOCKET s, char* buf, int bufLen, int flag, sockaddr* from, int* fromlen);

익숙한 형태입니다. 보통 recv 함수에다가 accept 함수를 섞은것 같은 형태입니다. 위 코드에서 볼수 있듯이 recvfrom을 사용하기 위해 데이터를 받은 빈 버퍼인 
recvBuffer 를 만들어서 사용했습니다. 그리고 어디로 부터 왔는지 from 을 받아 줄 수 있는데 이전 accept 에서는 이 부분을 그냥 nullptr 로 두고 신경쓰지 않을 수 도 있었습니다.
여기서는 SOCKADDR clientAddr; 을 만들어 받아주고 있습니다. recvfrom이 잘 실행되면 clientAddr 에 데이터를 보내온 클라의 주소가 담길겁니다. 
만약 에러가 뜬다면 에러 코드를 출력하고 return 0 을 하고 있는데 사실 이렇게 그냥 서버를 종료하는게 아니고 
에러가 있는 클라이언트만 연결을 끊던가 해야합니다. 괜히 잘 동작하는 다른 클라까지도 다 연결을 끊기는 좀 아닙니다. 

또 이전 TCP 서버에서도 그랬듯이 받았던 데이터를 그대로 클라이언트에 보내는 미러 서버를 만들어 줄 겁니다. 이때도 그냥 send 함수를 사용하는게 아니라 
sendto 함수를 사용하는데 이 함수는 반환 값이 보낸 데이터의 크기가 아니라 에러코드를 받습니다. 
시그니처는

	int sendto(SOCKET s, const char* buf, int len, int flag, const sockaddr* to, int tolen);

사용할 소켓, 보낼 데이터와 크기, flag는 0으로 두었고 어디로 갈건지 recvfrom에서 받아준 clientAddr을 가지고 정해주었습니다. 이것도 마찬가지로 
원래는 에러가 났을시 그 해당 클라와의 연결만 끊어야 합니다. 


이제 서버말고 클라쪽 코드도 작성해보겠습니다. 에러메세지 출력을 도와줄 HandleError함수를 클라이언트 쪽 프로젝트에 복사 했습니다. 

	SOCKET clientSocket = ::socket(AF_INET, SOCK_DGRAM, 0);
	if (clientSocket == INVALID_SOCKET)
	{
		HandleError("Socket");
		return 0;
	}

socket 함수의 두번째 인자만 UDP를 뜻하는 SOCK_DGRAM 으로 바꾸고 똑같습니다. 다음으로 해야 할 일은 연결을 할 서버의 주소를 받아오는것입니다. 
서버에서는 먼저 클라쪽에서 데이터를 보내오면서 그 주소를 가지고 다시 데이터를 되돌려 보냈지만 클라에서는 처음으로 보낼 주소가 필요합니다. 

	SOCKADDR_IN serverAddr;
	::memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	::inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);
	serverAddr.sin_port = ::htons(7777);	

주소 구조체를 만드는것은 그냥 TCP 때와 달라진게 없습니다. 

이후 TCP 에서는 connect 함수로 서버와 클라를 연결 했었는데 UDP는 연결 같은 개념이 아니라 상대의 주소만 알면 그냥 아무렇게나 데이터를 보내버린다고 했습니다. 
따라서 UDP에서는 connect 함수 없이 바로 데이터를 보냅니다. 

	char sendBuffer[100] = "Hello World!";

	int32 resultCode = ::sendto(clientSocket, sendBuffer, sizeof(sendBuffer), 0, 
		(SOCKADDR*)&serverAddr, sizeof(serverAddr));
	if (resultCode == SOCKET_ERROR)
	{
		HandleError("Send");
		return 0;
	}

	cout << "Send Data! Len : " << sizeof(sendBuffer) << endl;

보낼 데이터를 준비하고 send 대신 sendto 함수를 사용합니다. 인자에 보낼 주소와 그 크기를 추가적으로 넣어줘야하는데 위에서 미리 serverAddr에 만들었습니다. 

다음은 서버에서 다시 돌려보낸 데이터를 받아주는 코드입니다. 

	SOCKADDR_IN recvAddr;
	::memset(&recvAddr, 0, sizeof(recvAddr));
	int32 addrLen = sizeof(recvAddr);

	char recvBuffer[1000];
	int32 recvLen = ::recvfrom(clientSocket, recvBuffer, sizeof(recvBuffer), 0,
		(SOCKADDR*)&recvAddr, &addrLen);
	if (recvLen <= 0)
	{
		int32 errCode = ::WSAGetLastError();
		cout << "Recive ErrorCode : " << errCode << endl;
		return 0;
	}

	cout << "Recv Data! Data = " << recvBuffer << endl;
	cout << "Recv Data! Len = " << recvLen << endl;

recv 대신 recvfrom을 사용할때는 데이터자체와 그 발신인의 주소도 받아올 수 있습니다. 지금이야 더미 클라이언트와 서버둘 사이에서 왔다 갔다 한다고 알고 있으니
그냥 위에서 만들었던 serverAddr 에 받아도 되겠지만 왠만하면 새로 주소를 받아줄 구조체를 만들어 받아주면 좋습니다. 
괜히 serverAddr를 덮어버렸다간 좋을게 없습니다. 


그래서 TCP와 UDP의 흐름이 굉장히 비슷하다는걸 알 수 있습니다. 서버와 클라사이에 connect, listen, accept 같은 연결 과정이 없지만 
비슷합니다. 
오늘 코드를 실행해보면 서버 클라가 사이좋게 데이터를 주고 받을겁니다. 


그런데 여기서 몇가지 추가로 언급을 해보자면 TCP 에서도 마찬가진데 서버에서는 소켓에 자신의 주소를 bind 해주는데 클라이언트의 소켓에서는 bind라는 과정이 없습니다. 
사실은 내부적으로 sendto 함수를 호출하는 과정에서 클라이언트 소켓에 나의 IP주소와 포트번호가 설정이 됩니다. 
IP주소는 그렇다 치는데 포트번호는 따로 정하지 않았습니다. 서버쪽 코드중 recvfrom 이 실행된 후에 중단점을 잡고 실행 해보면 데이터를 보내온 clientAddr의 포트번호가
따로 지정하지 않은 번호로 알아서 정해져있는걸 볼 수 있습니다. 

클라이언트에서는 서버의 주소를 명시적으로 적어주었었는데 서버쪽에서는 따로 주소를 명시적으로 적지않고 그냥 수신한 데이터를 받는것 밖에 없었습니다. 
또 이것은 TCP에서도 마찬가지 였습니다. 서버의 포트는 정해져있는데 클라이언트의 포트는 중간에 데이터를 보내는 과정에서 알아서 정해지는데 
물론 TCP는 send에서 결정되는게 아니라 connect 를 할때 연결을 하면서 설정이 될것입니다. 

두번째로 이전 TCP 실습때도 했던 내용인데 클라이언트에서 데이터를 한번에 열개를 보낼때 어떻게 될지알아보겠습니다. 

클라쪽 sendto를 for문으로 열번 반복하도록 하고 서버에서는 recvfrom 을 실행하기 전에 this_thread::sleep_for(1s); 로 1초 동안 기다려 주었습니다. 
이 테스트를 TCP실습 시간에서는 100바이트 열번 보내고 한번에 1000바이트를 받았었는데 
이걸 UDP에서는 어떻게 동작할지 한번 테스트 해보면 클라쪽 콘솔에서 100바이트 데이터를 열번 보내고, 서버에서는 이상하게 100바이트 데이터를 받았다고 나오고 있습니다. 

왜 이러냐면 이전시간에 TCP vs UDP 차이점을 알아보면서 데이터 바운더리 관련해서 TCP 는 데이터 바운더리가 없고 UDP는 데이터 바운더리가 있다고 했습니다. 
그래서 한번 recvfrom을 하면 바운더리에 따라 100바이트 데이터 하나만 받아줄 수 있습니다. 

여기까지가 보통 UDP의 기본 사용법이긴한데 추가적으로 한가지 더 알아 볼게 있다면 
UDP 에서 데이터를 보내는 sendto 함수를 보면 매번 함수 호출때 마다 이 데이터를 어느 주소로 보낼건지를 인자로 받고 있습니다. 
UDP 자체가 서버와 클라간 연결한다는 개념이 아니고 이 데이터라는 화물을 택배처럼 보내는 식이다 보니 매번 목적지 주소를 주고 있는데 
이것을 개선해서 매번 주소를 주지 않아도 되는 버전이 따로 있습니다. 

이 버전을 'Connected UDP' 라고 하는데 connected 라는 이름이 붙었다고 진짜 TCP 처럼 클라,서버 간에 연결이 되었다기 보다는 UDP와 똑같은데 
한번 정한 목적지의 주소가 등옥이 된다라는 느낌으로 봐야 합니다. 
반대로 오늘 배웠던 sendto 함수로 매번 데이터를 보낼 주소를 적는 방법을 'Unconnected UDP' 라고 합니다. 

어떻게 사용해야 하냐면 TCP에서 사용했던 connect 를 먼저 똑같이 사용합니다. 그리고 sendto 가 아니라 TCP 처럼 send를 사용합니다. 

	// connected UDP
	::connect(clientSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr));

	// Connected UDP
	int32 resultCode = ::send(clientSocket, sendBuffer, sizeof(sendBuffer), 0);

이 쌍을 이용한다는 건데 그냥 TCP 에서 사용하는것과 거의 비슷하지만 다른점은 clientSocket을 만들때 두번째 인자인 통신 프로토콜을 UDP로 정해주었던 점이 
다릅니다. 

데이터를 받았던 recvfrom 도 마찬가지로 위에서 connect 함수를 호출한 상태라면 그냥 recv 함수를 사용하면 Connected UDP 가 됩니다.

UDP 통신을 하겠다고 해도 통신을 오래 유지할것이라고 하면 기본 UDP인 Unconnected UDP를 사용하는것보다 Connected UDP 방식으로 통신을 하면 좀 더 코득가독성이 좋아 질겁니다.
그래도 두 방식모두 동작자체는 변함이 없습니다. Connected UDP 방식으로 통신한다고 해도 TCP 처럼 연결하는 개념이 아니라 그냥 보낼 주소 받는 주소가 고정만 해주는 느낌입니다. 


- 결론 
UDP 서버를 실습해보았는데 코드 자체는 TCP에서 크게 달라지지 않았고 다만 UDP는 서버의 소켓을 데이터를 보내는 클라마다 만들어서 바인딩해주는게아니라 
메인 서버 소켓 하나로 다 처리하고 send, recv 함수 대신 sendto, recvfrom 이라는 함수를 사용하면서 데이터를 받는 그때 그때마다 데이터를 보낸 쪽의 주소를 받아 오고 있습니다. 
클라 주소를 비 연결적으로 받고 있기 때문에 실행할때 마다 클라쪽 포트가 달라지는데 즉, 아무대서나 이 서버에 접속할 수 있다는 겁니다. 
당연히 보안적으로 좋지 않을것이기 때문에 실제 사용할때는 방화벽을 사용할것입니다. 