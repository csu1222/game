



        DB Connection



이번시간부터 또 새로운 단원으로 들어와 데이터 베이스에 대해 알아보겠습니다. 


C++에서 DB 연동을 어떻게 해서 데이터를 저장하고 꺼내올지를 다룰 시간입니다. 

DB 제품군이 다양하게 존재합니다. MS에서 제공하는 MS SQL(SQL Server) 이나 아니면 My SQL, Oracle 같은 다양한 DB가 있습니다. 
그러면 실무에서는 보통 어떤 DB를 사용하는가 하면 윈도우즈를 기반으로 하면 SQL Server 를 보통 사용한다고 합니다.

그건 그렇고 다양한 제품군마다 각기 연동하는 방법이 다르다면 고생일겁니다. 
그래도 파트 2 시간에 Direct X 를 다룰때도 그래픽 카드도 각 제조사 마다 생산하는 제품이 다르지만 우리는 자세히 어떻게 연동되는지는 모르고 
DirectX 코드만 사용해서 연동했었습니다.

이것과 비슷하게 지금 DB에서도 우리는 ODBC를 가지고 연동을 할겁니다. DB마다 세부적인 연동은 각 제조사가 알아서 처리해줄것입니다. 

DirectX 때와 같이 일단 코드를 먼저 만들고 설명은 이후에 하는게 이해가 빠를것같습니다. 

***

ServerCore 프로젝트 밑으로 DB 라는 필터를 추가합니다. 또 그 안에 DBConnection, DBConnectionPool 이라는 두가지 클래스파일들도 추가합니다. 
DBConnection은 말그대로 DB랑 연결하는 하나의 단위를 말하는거고 이걸 풀링해서 재사용하기 위한 클래스입니다. 

다시 말하지만 오늘 내용은 모든걸 전부 이해해야 할 필요는 없고 ODBC라는 걸 이용하는 것이기 때문에 그때 그때 필요할때 다시 잠깐알아봐서 사용하는정도로 
알면 되는 내용입니다. 

우선 DBConnection에 sql.h, sqlext.h 라는 라이브러리를 추가합니다. 그리고 DBConnectionPool에서는 DBConnection을 추가합니다. 

-- DBConnectionPool
/*-----------------------
	DBConnectionPool
------------------------*/

class DBConnectionPool
{
public:
	DBConnectionPool();
	~DBConnectionPool();

	bool				Connect(int32 connectionCount, const WCHAR* connectionString);
	void				Clear();

	DBConnection*		Pop();
	void				Push(DBConnection* connection);

private:
	USE_LOCK;
	SQLHENV					_enviroment = SQL_NULL_HANDLE;
	Vector<DBConnection*>	_connections;
};

이렇게 간단하게 만들겁니다. 우선 DBConnectionPool은 락을 사용할것이기 때문에 USE_LOCK; 을 멤버 변수로 들고 있고 
또 SQLHENV 라는 타입의 변수는 아까 DBConnection에서 추가한 sql.h, sqlext.h 쪽에 있던 타입으로 SQL Handle Enviroment 라고 합니다. 
알기 쉽게 _enviroment라고 이름 붙혔고 또 Pool 이다 보니 원소인 DBConnection의 포인터를 Vector로 들고 있겠습니다. 

멤버 함수는 Connect는 몇개의 DBConnection을 만들어줄지, 두번째 인자는 DB에 연결을 할때 어떤 DB와 어떤 조건으로 연결을 할지를 받아주는 부분입니다.
Clear는 말 그대로 비우는 함수 꺼내는 Pop 함수 밀어 넣는 Push 함수가 있습니다. 

여기서 DBConnection을 모두 생 포인터로 들고 있습니다. 굳이 스마트 포인터를 사용하지 않는 이유는 단순하게 이 Pool에서 Pop을 해 DBConnection을 사용한 다음 곧바로 
반납을 할것이기 때문에 굳이 참조 카운트를 늘리고 줄이는 과정은 필요없습니다. 

구현부는 이렇습니다. 
/*-----------------------
	DBConnectionPool
------------------------*/

DBConnectionPool::DBConnectionPool()
{
}
생성자에서는 딱히 해주는게 없습니다.

DBConnectionPool::~DBConnectionPool()
{
	Clear();
}
소멸자에서는 Clear를 호출하긴하지만 사실 프로그램을 종료할때 까지 직접 DBConnectionPool을 종료할 이유가 없다보니 구색 맞추기용입니다. 

bool DBConnectionPool::Connect(int32 connectionCount, const WCHAR* connectionString)
{
	WRITE_LOCK;

	if (::SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &_enviroment) != SQL_SUCCESS)
		return false;

	if (::SQLSetEnvAttr(_enviroment, SQL_ATTR_ODBC_VERSION, reinterpret_cast<SQLPOINTER>(SQL_OV_ODBC3), 0) != SQL_SUCCESS)
		return false;

	for (int32 i = 0; i < connectionCount; i++)
	{
		DBConnection* connection = A_new<DBConnection>();
		if (connection->Connect(_enviroment, connectionString) == false)
			return false;

		_connections.push_back(connection);
	}

	return true;
}
이 Connect 함수의 내용이 생소할것인데 위에서 말도 했듯이 이번 코드를 하나하나 뜯어봐서 이해하려하기 보다는 대충 이렇게 사용하고 이런 용도이구나 만 알고 넘어가면 좋습니다. 

void DBConnectionPool::Clear()
{
	WRITE_LOCK;

	if (_enviroment != SQL_NULL_HANDLE)
	{
		::SQLFreeHandle(SQL_HANDLE_ENV, _enviroment);
		_enviroment = SQL_NULL_HANDLE;
	}

	for (DBConnection* connection : _connections)
		A_delete(connection);

	_connections.clear();
}

DBConnection* DBConnectionPool::Pop()
{
	WRITE_LOCK;

	if (_connections.empty())
		return nullptr;

	DBConnection* connection = _connections.back();
	_connections.pop_back();
	return connection;
}

void DBConnectionPool::Push(DBConnection* connection)
{
	WRITE_LOCK;
	_connections.push_back(connection);
}

Clear, Pop, Push 함수들은 간단하게 만들었습니다. 

이어서 DBConnection 코드를 만들어줄겁니다. 

-- DBConnection

class DBConnection
{
public:
	bool			Connect(SQLHENV henv, const WCHAR* connectionString);
	void			Clear();

	bool			Execute(const WCHAR* query);
	bool			Fetch();
	int32			GetRowCount();
	void			Unbind();

public:
	bool			BindParam(SQLUSMALLINT paramIndex, SQLSMALLINT cType, SQLSMALLINT sqlType, SQLULEN len, SQLPOINTER ptr, SQLLEN* index);
	bool			BindCol(SQLUSMALLINT columnIndex, SQLSMALLINT cType, SQLULEN len, SQLPOINTER value, SQLLEN* index);
	void			HandleError(SQLRETURN ret);

private:
	SQLHDBC			_connection = SQL_NULL_HANDLE;
	SQLHSTMT		_statement = SQL_NULL_HANDLE;
};

이 함수들을 사용해 DB에 연동시킬겁니다. 

DirectX에 비하면 생각보다 어마어마하게 어렵지는 않아 보입니다. 생소한 SQL 이라는게 붙은 타입들을 인자로 받는게 좀 그렇지만 그냥 그렇구나 하고 넘어가도 되는 부분입니다. 

먼저 Connect 함수입니다. 이 Connect는 아까 DBConnectionPool::Connect에서도 사용했던 함수를 이제 구현하는것입니다.

bool DBConnection::Connect(SQLHENV henv, const WCHAR* connectionString)
{
	if (::SQLAllocHandle(SQL_HANDLE_DBC, henv, &_connection) != SQL_SUCCESS)
		return false;

	WCHAR stringBuffer[MAX_PATH] = { 0 };
	::wcscpy_s(stringBuffer, connectionString);

	WCHAR resultString[MAX_PATH] = { 0 };
	SQLSMALLINT resultStringLen = 0;

	SQLRETURN ret = ::SQLDriverConnect(
		_connection,
		NULL,
		reinterpret_cast<SQLWCHAR*>(stringBuffer),
		_countof(stringBuffer),
		OUT reinterpret_cast<SQLWCHAR*>(resultString),
		_countof(resultString),
		OUT & resultStringLen,
		SQL_DRIVER_NOPROMPT
	);

	if (::SQLAllocHandle(SQL_HANDLE_STMT, _connection, &_statement) != SQL_SUCCESS)
		return false;

	return (ret == SQL_SUCCESS || ret == SQL_SUCCESS_WITH_INFO);
}

잘 모르겠는 외계어가 이리저리 있는데 위부터 차례대로 알아보자면 먼저 SQLAllocHandle이라는 함수를 호출하고 있습니다. SQL핸들에 어떤 용도로 어느 핸들에 할당을 할것인지입니다. 
첫번째 호출하는 SQLAllocHandle에서는 SQL_HANDLE_DBC 라는 핸들 타입을 지정하고 있습니다. 두번째 인자는 인풋 핸들로 핸들 타입이 SQL_HANDLE_DBC 인경우는 환경 핸들이어야 합니다.
세번째 인자는 아웃풋 핸들로 결과물의 포인터가 옵니다. 그래서 이 함수가의 반환값이 SQL_SUCCESS가 아닌경우는 Connect가 실패했으니 false를 리턴합니다. 

아니라면 다음은 stringBuffer, resultString, resultStringLen 이라는 WCHAR 배열들과 SQLSMALLINT 타입 변수를 만들었습니다. 
그 밑의 SQLDriverConnect 라는 함수에서 사용되는 변수들입니다. 이 함수는 실제로 DB와 우리 서버를 연결시켜주는 함수입니다. 
인자는 순서대로 연결 핸들, 윈도우 핸들, 인풋 연결 문자열, 인풋 연결 문자열의 길이, 아웃풋 연결 문자열, 아웃풋 연결 문자열의 길이, 아웃풋 문자열의 최대 글자수, 드라이버관리자 에서 추가 
연결 정보를 묻는 메세지를 표시할지에 대한 플레그 
이렇게 입니다. 아주 긴 내용인데 역시 하나하나 다 숙지해야하진 않고 그냥 넘아가겠습니다. 

하여튼 다음은 또 SQLAllocHandle이 한번더 호출됩니다. 이번에는 할당하는 핸들 타입이 statment 입니다. 

SQLDriverConnect의 반환값을 SQLRETURN ret 에 받아주고 이 값에 따라 Connect함수의 반환 값이 달라집니다. 

다음은 Clear 함수입니다. 사실 이 Clear 함수도 서버를 실행하는동안 따로 핸들들을 밀어줄 일이 없을 것이기 때문에 별 필요는 없지만 
구색을 맞추기 위해서라도 만들어 보겠습니다.

void DBConnection::Clear()
{
	if (_connection != SQL_NULL_HANDLE)
	{
		::SQLFreeHandle(SQL_HANDLE_DBC, _connection);
		_connection = SQL_NULL_HANDLE;
	}

	if (_statement != SQL_NULL_HANDLE)
	{
		::SQLFreeHandle(SQL_HANDLE_STMT, _statement);
		_statement = SQL_NULL_HANDLE;
	}
}

다음은 Execute 함수입니다. 이것은 자주 사용되는 중요한 함수입니다. 

bool DBConnection::Execute(const WCHAR* query)
{
	SQLRETURN ret = ::SQLExecDirectW(_statement, (SQLWCHAR*)query, SQL_NTSL);
	if (ret == SQL_SUCCESS || ret == SQL_SUCCESS_WITH_INFO)
		return true;

	HandleError(ret);
	return false;
}
인자로 DB에 넘겨줄 명령어인 쿼리를 받고 있습니다. DB에 이 쿼리를 전달해주는 함수가 SQLExecDirectW입니다. 같이 넘겨줄 여러 인자들이 _statement에 담겨 있고 쿼리도 SQLWCHAR* 로 캐스팅해
넘겨줍니다. 세번째 인자는 쿼리의 길이를 줍니다. 

그 반환값을 ret에 받고 SQL_SUCCESS 혹은 SQL_SUCCESS_WITH_INFO 라면 true를 리턴 아니라면 HandleError에 ret을 넘겨주고 false를 리턴합니다.

다음은 기왕이면 이어서 HandleError를보겠습니다. 

void DBConnection::HandleError(SQLRETURN ret)
{
	if (ret == SQL_SUCCESS)
		return;

	SQLSMALLINT index = 1;
	SQLWCHAR sqlState[MAX_PATH] = { 0 };
	SQLINTEGER nativeErr = 0;
	SQLWCHAR errMsg[MAX_PATH] = { 0 };
	SQLSMALLINT msgLen = 0;
	SQLRETURN errorRet = 0;

	while (true)
	{
		errorRet = ::SQLGetDiagRecW(
			SQL_HANDLE_STMT,
			_statement,
			index,
			sqlState,
			OUT & nativeErr,
			errMsg,
			_countof(errMsg),
			OUT & msgLen
		);

		if (errorRet == SQL_NO_DATA)
			break;

		if (errorRet != SQL_SUCCESS && errorRet != SQL_SUCCESS_WITH_INFO)
			break;

		// TODO : Log
		wcout.imbue(locale("kor"));
		wcout << errMsg << endl;

		index++;
	}
}

가장먼저 ret 값이 SQL_SUCCESS 인지를 체크하고 있습니다. Execute에서도 한번 체크하긴 했지만 혹시 모르게 잘못들어오는 경우에는 여기서 그냥 리턴으로 빠져나갈겁니다.

그 다음은 여러 변수들을 만들어 주고 있는데 SQL 에러코드를 받아오는 SQLGetDiagRecW 함수에 필요한 인자들입니다. 
에러코드는 한번 HandleError를 호출했을때 꼭 하나뿐이라고는 할 수 없으니까 while을 돌고 index를 카운팅하면서 반복 호출해줍니다. 그리고 그때 마다 wout 으로 출력도 하고 있습니다.

다음 함수는 Fetch 입니다. 이 함수는 DB로 부터 원하는 데이터를 긁어오는 함수입니다.

bool DBConnection::Fetch()
{
	SQLRETURN ret = ::SQLFetch(_statement);
	
	switch (ret)
	{
	case SQL_SUCCESS:
	case SQL_SUCCESS_WITH_INFO:
		return true;
	case SQL_NO_DATA:
		return false;
	case SQL_ERROR:
		HandleError(ret);
		return false;
	default:
		return true;
	}
}

다음 함수는 GetRowCount 입니다. Row는 행이란 뜻입니다. 

int32 DBConnection::GetRowCount()
{
	SQLLEN count = 0;
	SQLRETURN ret = ::SQLRowCount(_statement, OUT & count);

	if (ret == SQL_SUCCESS || ret == SQL_SUCCESS_WITH_INFO)
		return static_cast<int32>(count);

	return -1;
}

나머지 함수들 Unbind, BindParam, BindCol 코드를 한번에 보겠습니다.

void DBConnection::Unbind()
{
	::SQLFreeStmt(_statement, SQL_UNBIND);
	::SQLFreeStmt(_statement, SQL_RESET_PARAMS);
	::SQLFreeStmt(_statement, SQL_CLOSE);
}

bool DBConnection::BindParam(SQLUSMALLINT paramIndex, SQLSMALLINT cType, SQLSMALLINT sqlType, SQLULEN len, SQLPOINTER ptr, SQLLEN* index)
{
	SQLRETURN ret = ::SQLBindParameter(_statement, paramIndex, SQL_PARAM_INPUT, cType, sqlType, len, 0, ptr, 0, index);
	if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO)
	{
		HandleError(ret);
		return false; 
	}

	return true;
}

bool DBConnection::BindCol(SQLUSMALLINT columnIndex, SQLSMALLINT cType, SQLULEN len, SQLPOINTER value, SQLLEN* index)
{
	SQLRETURN ret = ::SQLBindCol(_statement, columnIndex, cType, value, len, index);
	if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO)
	{
		HandleError(ret);
		return false;
	}

	return true;
}

Unbind는 DB의 파라미터들을 싹 밀어주는 함수입니다.

BindParam은 DB에 파라미터를 bind, 묶어주는 함수입니다. 인자로 어느 파라미터 인덱스에 어떤 타입의 데이터를 넣어줄지를 받고 있습니다. 

BindCol은 column을 추가할때 사용합니다. 어느 columnIndex에 어떤 내용으로 채울지를 인자로 받고 있습니다. 


이렇게 해서 DB를 연동해 사용할 준비가 끝났습니다.

*** 

테스트 준비로 DBConnectionPool 객체는 전역으로 하나만 들고 있을겁니다. 
어느 스레드에서 DB에 접근할 필요가 생기는지 모르기 때문에 그렇습니다.
전역 객체는 이전과 마찬가지로 CoreGlobal에 추가해주면 됩니다. 

이쯤에서 한번 ServerCore를 빌드해서 문제가 없는지 체크를 하겠습니다.

이제 어떻게 사용할것이냐면 지금 만든 전역 DBConnectionPool 객체의 Connect를 호출하면서 몇개의 DBConnection 객체를 사용할것인지 또 어떤 문자열을 가지고 연결할지를 
인자로 주면서 호출할겁니다. 

그 다음은 Pop을 호출해 만들어진 DBConnection을 꺼내 이런저런 연동을 해준다음 Bind 함수들을 통해 이런저런 Column, Param을 추가한 다음 Execute를 때려주면 실질적으로 실행 될겁니다. 
거기서 이제 Fetch를 통해 하나씩 받아오면됩니다. 

이 내용을 코드로 실습해보겠습니다. 

그런데 먼저 DB가 있어야 활용을 하던가 할겁니다. 사실 아무 DB에도 연동이 되긴 할겁니다. 이번 실습에서는 Visual Studio를 설치하면 같이 설치되는 내장 DB인 SQL Server를 활용해보겠습니다.

Visual Studio의 보기 메뉴 -> SQL Server 개체 탐색기를 열어보면 SQL Server가 있을겁니다. 그 중 MSSQLLocalDB밑으로 ServerDB라는 데이터 베이스를 추가합니다. 
이 ServerDB의 속성을 들어가보면 (localdb)\MSSQLLocalDB 이런 문구가 있는걸 볼수 있는데 이것을 기억해두겠습니다. 

이제 GameServer.cpp 로 가서 DB를 연결하고 사용하는 실습을 해보겠습니다. 
먼저 DBConnectionPool을 include 해줘야합니다. 

main 함수내에서 

GDBConnectionPool 의 Connect 함수를 호출할겁니다. 인자는 DB를 몇개 사용할지 그리고 ODBC Connection String을 넘겨주면 됩니다. 
ODBC Connection String 은 구글에 검색해보면 표준연결이라고 ID와 Password를 입력하는 버전과 Trusted Connection 이라고 ID와 Password를 생략한 버전인 있습니다. 
지금은 테스트용이니 Trusted Connection 으로 하겠습니다. 


	GDBConnectionPool->Connect(1, L"Driver={SQL Server};Server=myServerAddress;Database=myDataBase;Trusted_Connection=Yes;");

이게 양식이라고 보면됩니다. 
커넥션 스트링에서 Driver 라는 부분이 있습니다. 어느 DB 제품을 사용하는지를 말하는데 이것은 윈도우즈 시작에서 ODBC를 찾아보면 ODBC 데이터 원본이라는게 나옵니다. 
그중 드라이버항목에 있는 것들의 이름이 ODBC로 연동할수 있는 DB 드라이버 목록들입니다. 
또 myServerAddress, myDataBase 라고 되어있는곳을 아까 기억해뒀던 주소로 수정해줘야합니다. 

제 환경에서는 이렇게 되었습니다.

	GDBConnectionPool->Connect(1, L"Driver={SQL Server};Server=(localdb)\\MSSQLLocalDB;Database=ServerDB;Trusted_Connection=Yes;");

나중에 실제 서버를 라이브로 만든다면 커넥션 스트링을 하드코딩으로 넣는게 아니라 옵션을 빼서 서버 주소, 서버 데이터 베이스 이름, 비밀번호등등을 별도의 파일로 관리하면서 그걸로 
접근하는 식으로 만들면 되겠습니다. 

다음은 쿼리를 만들겁니다. 데이터 베이스에 테이블이 없으면 만들어주고 어떤 데이터를 저장할건지 정합니다. 
이번 테스트에는 별 의미없지만 어떤 플레이어의 id와 gold를 얼마나 가지고 있는지를 표현해보겠습니다.  그리고 DBConnection을 하나 빼와서 이 쿼리를 곧바로 Execute해주겠습니다.

	//Create Table
	{
		auto query = L"									\
			DROP TABLE IF EXISTS[dbo].[Gold];			\
			CREATE TABLE [dbo].[Gold]					\
			(											\
				[id] INT NOT NULL PRIMARY KEY IDENTITY, \
				[gold] INT NULL							\
			);";

		DBConnection* dbCon = GDBConnectionPool->Pop();
		ASSERT_CRASH(dbCon->Execute(query));
	}

그리고 이어서 생성한 테이블에 데이터를 넣어줄겁니다. 
실습에서는 3개의 데이터를 넣어주기 위해 for문으로 3번 반복합니다. 

	// Add Data
	for (int32 i = 0; i < 3; i++)
	{
		DBConnection* dbCon = GDBConnectionPool->Pop();
		// 기존에 바인딩 된 정보 날림
		dbCon->Unbind();

		// 넘길 인자 바인딩
		int32 gold = 100;
		SQLLEN len = 0;

		ASSERT_CRASH(dbCon->BindParam(1, SQL_C_LONG, SQL_INTEGER, sizeof(gold), &gold, &len));

		ASSERT_CRASH(dbCon->Execute(L"INSERT INTO [dbo].[Gold]([gold]) VALUES(?)"));
	}

DBConnection을 하나 꺼내와서 기존에 바인딩 되어있을 지도 모르니 일단 Unbind를 한번합니다. dbCon->BindParam으로 파라미터를 세팅하는데 
1번 인덱스 부터 시작한다, SQL_C_LONG은 C++에서 사용하는 정수 타입이고 또 SQL 쪽에서는 이걸 SQL_INTEGER 라고 합니다. 즉 바인드할 정보가 정수 타입이라는 뜻입니다. 
그리고 그 크기가 sizeof(gold) 인것입니다. 이어서 실제 그 데이터가 어디있는지 참조 값으로 넘기고 다음으로 추가적인 옵션정보를 &len으로 넘겨줍니다. 

다음은 Execute입니다. 쿼리를 넘겨주는데 여기서 ?의 위치에 바인드된 파라미터가 들어가게 될것입니다. 

지금 3번에 걸쳐 데이터를 밀어 넣고 있습니다. 각 id는 PRIMARY KEY 이니까 1씩 증가하면서 할당될것이고 
gold 부분에 바인드된 gold 값인 100이 들어갑니다.


다음은 밀어넣은 데이터를 읽어보는 시간입니다.

	// Read
	{
		DBConnection* dbCon = GDBConnectionPool->Pop();
		
		dbCon->Unbind();

		// 넘길 인자 바인딩
		int32 gold = 100;
		SQLLEN len = 0;

		ASSERT_CRASH(dbCon->BindParam(1, SQL_C_LONG, SQL_INTEGER, sizeof(gold), &gold, &len));

		int32 outId = 0;
		SQLLEN outIdLen = 0;
		dbCon->BindCol(1, SQL_C_LONG, sizeof(outId), &outId, &outIdLen);

		int32 outGold = 0;
		SQLLEN outGoldLen = 0;
		dbCon->BindCol(2, SQL_C_LONG, sizeof(outGold), &outGold, &outGoldLen);

		ASSERT_CRASH(dbCon->Execute(L"SELECT id, gold FROM [dbo].[Gold] WHERE gold = (?)"));

		while (dbCon->Fetch())
		{
			cout << "id: " << outId << " Gold: " << outGold << endl;
		}
	}

데이터를 쓸때와 비슷한데 추가된 부분이 있습니다. Execute 에서 변경점은 INSERT 쿼리가 아닌 SELECT 쿼리라는것이고 그중에서 gold값이 ? 인 데이터를 가져온다는 것입니다. 
여기서 ?에 해당하는 값은 역시 dbBindParam으로 바인드 해줍니다. 여기는 아까와 비슷합니다. 

그런데 이제 SELECT 한 내용에서 필요한 정보는 id와 gold 값입니다. 여기서 BindParam 함수를 사용합니다. 1번 column에 있는 SQL_C_LONG 타입의 데이터를 outId에 받아주고 
2번 column에 있는 SQL_C_LONG 타입의 데이터를 outGold 에 받아줄겁니다. 

그런데 여기서 끝이 아닙니다. 우리가 총 3번 데이터를 넣었기 때문에 Execute에서는 3행의 데이터를 가져올겁니다. 각각 한줄씩 데이터를 받아와야하는데 
이때 사용하는 함수가 Fetch 입니다. 


**여기서 빼먹은 점이 있는데 GDBConnectionPool에서 DBConnection을 하나씩 꺼내 사용하고 다시 돌려보내야 했었는데 이 코드들이 빠졌었습니다. 
테이블 만들기, 데이너 쓰기, 데이터 읽기 각각에 GDBConnectionPool->Push(dbCon); 코드를 추가해줍니다.

이제 제대로 빌드가 될겁니다. 다른 부분은 놔두고 오늘 작업한 코드 직후까지만 중단점을 잡고 테스트 해보았습니다.