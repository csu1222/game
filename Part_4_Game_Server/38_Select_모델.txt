


            Select 모델


이번시간에는 여러가지 소켓 입출력 모델중 가장 기본이 되는 Select 모델에 대해 알아보겠습니다. 

우선 이전 시간에 알아본 블로킹과 논블로킹에 대한 내용은 숙지해야합니다. 블로킹에는 너무 많은 접속이 몰리면 하나씩 처리할때 까지 나머지 소켓들은 
기다리고 있어야 한다는 문제가 있었고 그걸 보완하겠다는 시도로 논블로킹을 배웠습니다. 
하지만 논블로킹이 소켓을 멈춰두지는 않지만 그런만큼 중간에 체크할 코드들이 늘어서 결과적으로 성능상 더 이득이라고 볼 수 없다는걸 배웠습니다. 

결국은 connect, accept, send, recv 등 함수들이 처리해줄 준비가 되지 않았음에도 시도를 반복하고 또 체크코드를 계속돌면서 
의미없는 CPU점유율을 낭비하고 있었습니다. 

그러면 함수들이 처리가능한지를 알 수 있고 가능할때에 논블로킹 소켓을 동작시키면 어떨까 라는 생각이 오늘 주제인 Select 모델의 골자입니다.
나중에 결국에는 게임서버를 만들때는 통상적으로 iocp로 만들게 될것입니다. 그러면 그냥 처음부터 iocp만 배워서 써먹으면 되지 않을까 생각이 들기도 하는데 
서버만의 입장에서는 그게 맞을 수도 있기는 하지만 나머지 방법들도 알아야 하는게 교양적인 이유도 있지만 클라이언트도 서버에 붙여봐야 하는데 
클라이언트에서는 서버랑 1대1 통신만 하면 되기때문에 iocp 같은 고급 기법까지 알 필요가 없습니다. 닭 잡는데 소 잡는 칼을 쓰는 격입니다. 
그러다 보니 클라이언트에서는 select 나 다른 방법을 통해 비동기적으로 통신할 방법을 사용할 수 있는데 그런의미에서 오늘 그리고 또 이후의 시간에 배우는 
소켓 모델이 의미가 있다고 할 수 있습니다. 

서버 코드부터 시작할것인데 이전 시간 코드중 소켓만들기, ioctlsocket 함수를 호출해 논블로킹 소켓으로 만들기, 서버 주소 구조체 만들기, bind하기 
까지는 똑같은 코드라서 그 이후 부터 시작하겠습니다. 

    // Select 모델 
    Select 모델 이라고 부르는 이유는 select 함수가 핵심이 되는 방법이라서 그렇습니다. 
    컨셉을 다시 보면 소켓 함수 호출이 성공할 시점을 미리 알 수 있다. 라는게 컨셉입니다. 
    그러면 소켓함수가 성공한다는 것이 무엇이냐면 

    문제 상황) 
    수신 버퍼에 데이터가 없는데, read를 한다거나
    송신 버퍼가 꽉차있는데 , write를 한다거나

    이런게 소켓 함수가 성공하지 못하는 시점입니다. 
    또 select 모델은 블로킹 소켓이나 논블로킹 소켓을 따지지 않고 사용할 수 있습니다. 중요한건 소켓 함수 호출 성공 시점을 안다는 것입니다. 

    - 블로킹 소켓 : 조건이 만족되지 않아서 블로킹되는 상황을 예방
    - 논블로킹 소켓 : 조건이 만족되지 않아서 불필요하게 반복체크 하는 상황을 예방

    사용하는 방법을 보겠습니다. 
    먼저 socket set 라는걸 만들어 줍니다. 
    
    socket set
    1) 읽기[ ] 쓰기[ ] 예외[ ] 관찰 대상 등록
    읽기,쓰기,예외 에 해당하는 소켓들을 배열 비슷하게 필요한 곳에 담아줄겁니다. 

    읽기, 쓰기는 알겠는데 예외(OOB, OutOfband)는 무엇인지 궁금합니다. send 함수에서 마지막 인자에 MSG_OOB 로 설정할 수 있습니다. 
    이렇게 보내는 데이터는 특별한 데이터가 됩니다. 
    받는쪽에서도 똑같이 recv 함수의 마지막 인자를 MSG_OOB 를 해야 데이터를 받을 수 있습니다. 특이상황, 긴급상황을 알릴때 사용된다고 하는데 
    우리 상황에서는 쓸일이 없다고 봐도 되기때문에 나중에 필요해지면 더 자세히 알아보면 좋겠습니다. 

    그러니깐 읽기, 쓰기 두가지 세트에 사용할 소켓들을 담아서 쓴다고 알면 되겠습니다. 

    2) select(readSet, writeSet, exceptionSet);
    위의 괄호처럼 세가지 인자를 받는데 꼭 다 넣어줘야 하진않고 read랑 wirte만 사용할것이라고 하면 세번째 exceptionSet는 nullptr 로 넣어줘도 됩니다. 
    select 함수를 호출하면 이때 부터 관찰을 시작합니다.

    3) 적어도 하나의 소켓이 준비되면 리턴 -> 낙오자는 알아서 제거됨
    낙오자는 제거된다는게 무슨말이냐면 만약 readSet 에 [1, 2, 3] 이렇게 1,2,3 이라는 소켓이 있다고 했을때 
    이 소켓들을 체크 하고 싶은겁니다. 읽을 수 있는 상황인지 즉, 수신버퍼에 데이터가 있는지를 체크한다는겁니다. 그렇게 소켓들을 체크하고 있다가 
    만약 어떤 소켓이 준비가 된다면? 
    예를 들어 2번 소켓에 수신 버퍼에 데이터가 들어왔다고 하면 select가 반환을 하면서 준비된 소켓의 수를 반환합니다. 
    이 예시에서는 2번 소켓만 준비되었으니 1이라는 수를 반환 할겁니다. 
    그리고 나서 재밌는점이 2번 외의 나머지 소켓들은 낙오, 제거가 됩니다. read[2] 이렇게 남을겁니다. 

    4) 남은 소켓 체크해서 진행
    최종적으로 readSet에 남은 소켓은 읽을 수 있는 상태가 되고 readSet 안에 있는 소켓을 대상으로 send() 를 호출해주면 호출 성공 조건이라는걸 체크후 
    호출 한것이기 때문에 불필요하게 대기를 한다거나, 반복체크를 하면서 마지막 에러코드가 WSAEWOULDBLOCK 인지를 계속 확인하지 않아도 됩니다. 

    이런 순서로 이루어져있습니다. 
    추가로 select set 들을 만들때 방법으로 fd_set 이라는 구조체를 사용합니다. 
    
    fd_set set; 

    이 fd_set 구조체를 만들때 식별자로 보통 어떻게 사용할지 용도를 read, write 이런식으로 이름을 지어줍니다. 
    이름만 지어준다고 그에 맞게 동작하는것은 아니고 따로 어떤 가공을 해줘야 하는데 비트 플레그를 직접 이리저리 조작하는건 아니고 
    전용 함수 비슷한 것이 있습니다. 

    FD_ZERO : 비운다 
    ex) FD_ZERO(&set);

    이 FD_ZERO는 인자로 들어온 set를 비워줍니다.

    FD_SET : 소켓 s를 넣는다
    ex) FD_SET(s, &set);

    FD_SET 는 첫번째 인자로 소켓 s를 주고 두번째 인자로 set를 주면 s를 set에 넣어줍니다. 
    그러면 이제 set에서는 소켓 s에 대해 관찰을 하게됩니다. 

    FD_CLR : 소켓 s를 제거
    ex) FD_CLR(s, &set);

    FD_CLR 는 FD_SET과 반대로 소켓 s를 set에서 제거합니다. 

    FD_ISSET : 소켓 s가 set에 들어있으면 0이 아닌값을 리턴한다 
    ex) FD_ISSET(s, &set);
    
    FD_ISSET는 소켓 s가 set 안에 있는지를 체크합니다. 

    이제 위의 내용들을 실습해보겠습니다. 지금까지 소켓 실습을 GameServer, DummyClinet 양쪽에서 하고 있었는데 이번엔 GameServer쪽에서만 실습해보겠습니다. 
    어짜피 대칭적으로 사용하면 되었습니다. 


    먼저 시작하기전에 Session 이라는 구조체를 만들어 주겠습니다. 
    
    const int32 BUFSIZE = 1000;

    struct Session
    {
        SOCKET socket = INVALID_SOCKET;
        char recvBuffer[BUFSIZE] = {};
        int32 recvBytes = 0;
        int32 sendBytes = 0;
    };

    나중에 클라이언트가 서버에 접속하게 되면 이 세션이라는 구조체를 통해서 정보를 관리하게 될겁니다. 클라이언트 마다 관리하게 될것이니까 이 세션은 동시 접속자 수 마다 
    생기게 될것입니다. 
    각 클라이언트 마다 클라이언트 소켓, 받은 데이터 버퍼, 받은 데이터의 크기, 보낼 데이터의 크기등을 각각 관리 해주는데 지금이야 그냥 1대1 로 통신하다 보니까 너무 유난이지 
    않은가 싶지만 결국 온라인게임을 만들려고 하다 보니 접속이 많은 경우를 상정해서 처리하는 연습을 해야 합니다. 

	vector<Session> sessions;
	sessions.reserve(100);

	fd_set reads;
	fd_set writes;

    먼저 이렇게 세션들을 담아둘 sessions 도 만들고 reads, writes 소켓 세트들도 만듭니다. 
    이후 while(true) 를 돌면서 매 루프마다 통신을 해줄것입니다. 

    while(true)
    {
		// 소켓 셋 초기화 : 루프의 가장 처음에 reads, writes 를 전부 밀어주면서 시작합니다. 
		FD_ZERO(&reads);
		FD_ZERO(&writes);

        // ListenSocket 등록 : 초기화된 reads 에 listenSocket을 담아줍니다. listenSocket 은 accept를 하기위해 클라이언트의 접속을 기다리고 있는 소켓입니다. 접속을 받는 입장이다 보니
        // reads 쪽으로 넣어줍니다. 
		FD_SET(listenSocket, &reads);
        
		// 소켓 등록 : sessions에 담겨있는 소켓들을 reads, writes에 분류해 넣어줍니다. 
		for (Session& s : sessions)
		{
            // 분류하는 기준이 아까 Session 구조체에 만들어 놓았던 recvBytes와 sendBytes를 비교해 주고 있습니다. 그 이유는 이후에 나옵니다. 
			if (s.recvBytes <= s.sendBytes)
				FD_SET(s.socket, &reads);
			else
				FD_SET(s.socket, &writes);
		}

        // 이제 select 함수를 호출해줍니다. select 함수는 인자로 들어온 reads, writes, exceptionSet 를 관찰하면서 준비된 소켓이 있으면 그것만 남기고 나머지를 다 제거해 준다고 했습니다. 
        // 그런데 인자 갯수가 5개나 되는 이유는 첫번째인자와 다섯번째 인자가 아직 알아보지 않은 내용입니다. 
        // 첫번째 인자는 select 함수가 리눅스 환경에서도 동작하는데 리눅스에서 쓰이는 인자수를 맞추기 위한 자리입니다. 현재 윈도우에서는 사용하지 않으니 0을 줍니다. 
        // 다섯번째 인자는 timeout 옵션값을 줄 수 있습니다. timeout(대기시간)은 select 함수를 호출한 다음 소켓들이 준비되는걸 얼마나 기다릴지를 넣어주는데 
        // timeval 이라는 구조체를 받아줍니다. timeval 은 초단위를 나타내는 tv_sec, 마이크로초 단위를 나타내는 tv_usec 으로 이루어져 있습니다. 
        // timeout 인자 칸에 nullptr 을 주면 어떤 소켓이 준비될때까지 쭉 기다리겠다는 말입니다. 
		int32 retVal = ::select(0, &reads, &writes, nullptr, nullptr);
		if (retVal == SOCKET_ERROR)
			break;

        // select 를 통과했다는 이야기는 준비된 소켓만 남고 나머지는 다 제거되어있다는 이야기


		// Listener 소켓 체크 : 가장 먼저 reads 에 listenSocket 이 있는지를 체크합니다. 만약 listenSocket이 있다면 이미 누군가 접속을 요청한 클라가 있어 accept 를 할 준비가 다 되어있다는 이야기입니다. 
		if (FD_ISSET(listenSocket, &reads))
		{
			SOCKADDR_IN clientAddr;
			int32 addrLen = sizeof(clientAddr);
			SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addrLen);
			if (clientSocket != INVALID_SOCKET)
			{
				cout << "Client Connencted!" << endl;
                // 클라이언트의 소켓을 sessions 에 push_back 하고 있습니다. Session 구조체중 가장 앞에 있는 SOCKET 을 accept의 반환값인 clientSocket으로 초기화해 넣어줍니다.
				sessions.push_back(Session{ clientSocket });
			}
		}

        // 이 시점에서 만약 첫번째 루프여서 listenSocket 만 있었다면 아무리 sessions 에 소켓이 있어도 다음 루프때나 되어야 reads, writes 세트에 들어가 select를 할 수 있습니다.

        
		// 나머지 소켓 체크 : select 후 소켓 세트들에 남은 소켓이 listenSocket 이외의 소켓일 경우입니다. (즉, 클라이언트 소켓인 경우)
		for (Session& s : sessions)
		{
			// reads 체크
			if (FD_ISSET(s.socket, &reads))
			{
                // recv의 인자로 들어갈 데이터들이 이미 Session 구조체 안에 담겨있습니다. 
				int32 recvLen = ::recv(s.socket, s.recvBuffer, BUFSIZE, 0);
				if (recvLen <= 0)
				{
					// 연결이 끊긴 상태
					// TODO : sessions 에서 제거
					continue;
				}

                // Session::recvBytes 는 recv의 결과물인 실제 수신한 데이터의 크기입니다. 
				s.recvBytes = recvLen;
			}
            // 서버이다 보니 모든 데이터는 recv 부터 거치게 되므로 recv도 안한 소켓은 recvBytes 와 sendBytes 가 0으로 같습니다. 
            // 아까 reads, writes 에 분류하는 기준이 s.recvBytes <= s.sendBytes 이었는데 이 기준을 만족하려면 처음 recv도 안한 소켓이거나 아니면 
            // 이후 나오듯이 recv한 데이터를 다시 다 send 해서 다음 recv를 기다리는 소켓이거나 합니다. recv를 기다리는 소켓들이 reads로 옵니다.

			// writes 체크
			if (FD_ISSET(s.socket, &writes))
			{
				// 블로킹 모드 -> 모든 데이터 다 보냄
				// 논블로킹 모드 -> 일부만 보낼 수가 있음 (상대방 수신버퍼 상황에 따라)
				// 밑의 send 인자를 준이유가 논블로킹 모드에서 이전 시도에 온전히 데이터를 보내지 못했을 수도 있어서
				int32 sendLen = ::send(s.socket, &s.recvBuffer[s.sendBytes], s.recvBytes - s.sendBytes, 0);
				if (sendLen <= 0)
				{
					// 연결끊김
					// TODO : Sessions 에서 제거
					continue;
				}

				// 받은만큼(recvBytes) 보냈으면(sendLen) 정상적으로 동작했으니 다시 처음부터 시작
				s.sendBytes += sendLen;
				if (s.sendBytes == s.recvBytes)
				{
					s.recvBytes = 0;
					s.sendBytes = 0;
				}
			}
		}
    }

    여기까지가 이번 select 모델 코드입니다. 

    이제는 여기서 중요한것은 이 코드들을 어떻게 사용하는지를 유심히 봐야합니다. 
    내가 관찰(select)하고 싶은 소켓 세트인 reads, writes 각각 만들어 두고 while(true) 루프를 돌면서 매번 두 소켓 세트를 밀어주면서 등록을 반복합니다. 
    왜 굳이 매 루프마다 다시 밀고 다시 등록하는가 하면 select 함수의 동작이 관찰하다가 준비가 된 소켓이 보이면 그 소켓만 남기고 나머지는 다 제거해버린다고 했습니다. 
    그러니 매 루프마다 내가 의도했던 모든 소켓들이 소켓 세트안에 있지 못합니다. 그냥 다시 넣었다가는 이전 루프에 살아님은 소켓은 중복되어 있을 수 있으니
    깔끔하게 다 밀고 다시 채워주는 것입니다.

    또 다음 유심히 봐야할 코드는 sessions 에 들어있던 소켓들을 reads, writes 에 분류하는 부분입니다. 지금이야 소켓을 reads 혹은 writes 둘 중 하나에만 넣어주고 있는데 
    이것은 지금 만들고 있는 서버가 에코 서버이기 때문이고 
    나중에 필요에 따라서 두 소켓 세트 모두 들어갈 수도 있습니다. 


다음은 작성한 코드를 테스트 해보는것입니다. 오늘은 GameServer 코드만 작성하고 DummyClinet는 건들지 않았습니다. 그래도 클라이언트 쪽에서 받아올 데이터들이 그대로 사용할 수 
있도록 만들었습니다. 이렇게 해서 select 모델을 실습해봤습니다. 

지금이야 주고받는 데이터가 얼마 안되기 때문에 그냥 괜히 좀 더 복잡하게 만든 코드처럼 보이는데 이 모델의 장점을 생각해보겠습니다.
우리가 queue 를 사용할때 queue안에 데이터가 있는지 없는지를 모르기 때문에 queue안의 데이터를 사용할때 먼저 pop을하는게 아니라 
조건문으로 queue 가 empty인지 아닌지를 체크한 후에 데이터를 사용하던지 말던지를 정합니다. 
그런것처럼 소켓에 대해 accept, send, recv 를 그냥 막 호출하는게 아니라 호출될 준비를 했는지 아닌지를 먼저 판단을 한 다음에 호출을 하는 방식인겁니다. 

특징은 이렇고 장점이라고 하면 비교적 구현하기가 쉽다, 낭비가 없어진다 정도가 있겠고 
반대로 단점도 물론있습니다. 매 루프마다 소켓 세트를 밀고 다시 채우고 한다는 점도 있지만 사실 이 모델의 한계가 있습니다. 

FD_SETSIZE 라는 define이 있는데 의미는 소켓 세트의 최대 갯수를 뜻하고 그 값이 64 입니다. 
이것은 하나의 소켓 세트에 들어올수 있는 소켓의 최대 크기라고 할 수 있습니다. 생각보다 작다는걸 알 수 있는데
그러면 온라인에서 동시접속자를 한번에 64명 밖에 못한다는 이야기 인가 할 수 있는데 그런것은또 아닙니다. 만약 640명의 동시접속자를 처리하려고 하면 
열개의 소켓 세트를 만들면 가능해집니다. 
fd_set 의 코드를 열어보면 어떤 fd_count라고 카운팅을 하나 하고 있고 또 소켓을 FS_SETSIZE(64) 의 크기의 배열로 들고 있기 때문에 최대 크기가 정해져 있다는걸 알 수 있었습니다. 


