

            Reference Counting


이번 강의 부터 멀티쓰레드를 마무리 하고 데이터 관리에 대한 내용을 배울것입니다. 

다른 프로그래밍언어와 달리 C++ 에서는 메모리를 직접 관리하다 보니 꼭 배우고 지나가야합니다. 
스마트 포인터를 활용할것인지? 한다면 직접 만들어 사용할것인지, 아니면 표준 스마트 포인터를 활용할것인지 
메모리 관리를 기본할당기를 사용할것인지 메모리 풀링해서 사용할것인지를 정해줘야합니다. 

그런데 이런 옵션들을 고르기 위해서는 각각 이 무슨 의미인지는 알고 있어야 할겁니다. 그것을 알아보는 시간입니다. 

메모리 관리 첫시간은 스마트 포인터입니다. 
스마트 포인터는 part 1 C++ 언어 시간에 배웠던 적이 있습니다. 그런데 서버쪽 특히 멀티쓰레드 환경에서는 달라지는 점이 있을겁니다. 

오랜만에 다시 보는 개념이다 보니 일단 간단하게 복습을 해보겠습니다. 

        
        -- 스마트 포인터 복습 -- 

보통 스마트 포인터의 필요성을 어디서 느끼냐면 게임 프로그래밍 학원을 다녀보면 첫번째 포트폴리오를 만들때 여러 게임모작을 많이 한다고 합니다. 
와우 같은 MMORPG를 만들어 본다거나, 스타크래프트 같은 실시간 시뮬레이션 게임을 만들어 본다거나 하는데 
그럴때 햇갈리는 일이 생깁니다. 

스타크래프트를 예시로 들겠습니다. 레이스 라는 클래스와 미사일 클래스가 있다고 해보겠습니다. 레이스는 자신의 체력과 자신의 X,Y 좌표를 가지고 있습니다.
미사일은 타겟이 있어야 할것이기 때문에 레이스 객체를 포인터 타입으로 타겟을 가지고 있고 처음에 타겟을 지정하는 함수와 
왜인지 모르지만 타겟인 레이스의 좌표를 가져오는 업데이트 함수가 있다고 해보겠습니다. 

main 함수에서는 레이스와 미사일을 new 를 이용해 동적할당해서 만들었습니다. 그리고 미사일의 타겟을 레이스로 설정했습니다. 
그리고 무한루프를 돌면서 미사일이 업데이트 함수를 계속 실행하고 있다고 해보겠습니다. 

이 상황은 지금은 아무런 문제가 되지 않습니다. 

그런데 스타크래프트라는 게임은 레이스가 하나 뿐인 게임이 아닙니다. 다른 여러 유닛들이 있고 서로를 공격 하면서 진행하는 게임이니까 미사일이 타겟인 레이스를 
향해 날아가는 도중에 레이스가 다른 유닛에게 먼저 처치 될 수도 있을겁니다. 그러면 미사일의 타겟이 중간에 처치되서 없어질겁니다. 
이걸 코드로 표현하면 이렇습니다. 
{
	Wraight* wraight = new Wraight();
	Missile* missile = new Missile();

	missile->SetTarget(wraight);

	// 레이스가 피격 당함
	wraight->_hp = 0;
	delete wraight;

	while (true)
	{
		if (missile)
		{
			missile->Update();
		}
	}
        delete missile;
}

C++ 에서는 따로 가비지컬렉터가 없기 때문에 동적할당을 사용할 때 new delete 를 짝으로 사용해서 일일히 관리해줘야합니다. 
그래서 이렇게 코드를 작성하면 문제가 되는게 무엇이냐면

wraight는 따로 heap영역에 객체 데이터가 위치하고 그 주소를 wraight 변수에 담아서 가지고 있는것이고, missile도 마찬가지로 포인터를 가지고 있고 그 주소에는 
heap영역의 객체가 있습니다. 여기까지는 각자 따로 존재 하고 있지만 이후 missile의 SetTarget으로 wraight 를 들고 있게 하면 missile->_target 이 wraight를 
같이 들고 있게 됩니다. 그런데 중간에 wraight가 피격당해서 사라집니다. 이후 missile->_target을 참조해서 업데이트하는 함수를 실행하는데 이미 _target인 
wraight가 삭제 되어 있어서 문제입니다. 

Missile::Update() 는 _target의 _posX, _posY 라는 좌표를 함수 스택메모리에 임시변수에 담아주는 함수입니다. 
_target이었던 wraight의 객체가 있던 메모리는 delete를 하면서 언제든지 덮어 씌여질수 있게 되었지만 delete와 동시에 아예 접근을 할수 없는것은 
아닙니다. 물론 해제된 메모리에 접근하는것은 위험합니다. 그래도 지금 코드에서는 Update를 무한 루프돌면서 따로 하는 작업이 없다 보니 프로그램 자체는 크래시가 안나고 
실행이 됩니다. 다만 그 메모리에 있는 값은 이미 밀려서 의미없는 데이터일겁니다. 
이게 사실 크래시가 나는 것보다 더 안좋은 상황입니다. 크래시가 나면 어디가 문제인지 찾아서 고칠텐데 크래시도 안나고 의도하지 않은 대로 계속 실행되면 점점 문제가
확산될 수 있습니다. 

이런 문제가 일어나는 이유는 한 객체를 여러 포인터가 참조하고 있을때 멋대로 삭제를 했기 때문인데 이 문제를 해결하자고 객체를 하나도 삭제하지 않고 쌓아둔다면 
점점 쓸대 없이 메모리만 차지하는 객체들이 쌓이면 쌓였지 어디론가 없어지진 않을겁니다. 

이걸 해결하기 위해서는 객체를 다룰때 항상 nullptr 체크를 하면서 조심하던가 아니면 어떤 포인터가 이 객체를 참조하고 있다면 삭제하지 않도록 해야합니다. 
이 코드를 매번 작성할 수도 있겠지만 그것은 매우 비효율적일것이고 그래서 만들어진게 스마트 포인터입니다. 

참조하는 포인터의 수를 세는걸 Reference Counting이라고 합니다. 

-- 본 주제 -- 

오늘의 주제인 Reference Counting을 실습하기 위해 우리 프로젝트에 새로 파일들을 만들어 줄건데 먼저 ServerCore 프로젝트아래에 Memory 라는 이름의 필터를 만듭니다. 
또 그 안에 RefCounting 이라는 이름의 cpp, h 파일들을 추가합니다. 

->      RefCounting 

        RefCounting.h 파일에서 자동으로 생성된 클래스 이름을 RefCountable 이라는 이름으로 바꿔 보겠습니다. 하나의 클래스만 만들어 둘게 아니라 필요에 따라 여러 
        클래스를 만들것이기 때문입니다. 

        참조 카운팅을 하는 방법이 여러가지가 있는데 그 중 오늘 배울 방법은 어떤 최상위 클래스를 하나 만들어 여기서 참조 카운팅을 하고 Wraight, Missile 클래스 
        같은데서 이 최상위 클래스를 상속받아 관리하는 방법이 있습니다. 

        class RefCountable
        {
        public:
                RefCountable() : _refCount(1) { }
                virtual ~RefCountable() { }
                // 메모리릭을 방지하기 위해 상위 클래스 소멸자에는 virtual을 붙였어야 했습니다. 

                int32 GetRefCount() { return _refCount; }

                int32 AddRefCount() { return _refCount++; }

                int32 ReleaseRefCount()
                {
                        int32 refCount = --_refCount;
                        if (refCount == 0)
                        {
                                delete this;
                        }
                        return refCount;
                }
        protected:
                int32 _refCount;
        };

        멤버 변수로 카운트가 있고 객체를 생성하면서 1로 초기화 해주게 됩니다. 그리고 소멸자에는 앞에 virtual이 붙어있는데 상속을 받은 클래스가 소멸할때 부모
        객체의 데이터 까지 삭제하기 위한 키워드입니다. 

        간단하게 카운트를 가져오는 함수, 카운트를 더하는 함수, 카운트를 빼는 함수가 있을것입니다. 

        이제 이 RefCountable 클래스를 Wraight, Missile에서 상속받도록 추가해주면 공통적인 참조 카운트가 생기게 되고 앞으로는 
        객체를 삭제할때 바로 delete를 하는게 아닌 ReleaseRefCount를 하면서 카운팅을 1 줄여 주고 그 값이 0이 되면 그때서야 delete를 하는 방식으로 사용할겁니다. 


->      GameServer.cpp

        기존에 만들었던 클래스들에 RefCountable 클래스를 상속 시키기 위해서 먼저 RefCounting.h 를 include 합니다. 
        
        #include "RefCounting.h"
        class Wraight : public RefCountable
        {
        public:
                int _hp = 150;
                int _posX = 0;
                int _posY = 0;
        };

        class Missile : public RefCountable
        {
        public:
                void SetTarget(Wraight* target)
                {
                        _target = target;
                        target->AddRefCount();
                }
                
                void Update()
                {
                        if (_target == nullptr)
                                return;

                        int posX = _target->_posX;
                        int posY = _target->_posY;

                        // TODO : 쫓아가기

                        if (_target->_hp == 0)
                        {
                                _target->ReleaseRefCount();
                                _target = nullptr;
                        }
                }
                Wraight* _target = nullptr;
        };

        Missile 클래스에서 이제 SetTarget을 하게 되면 그 객체를 참조하는 포인터가 하나 늘게 되는거니까 AddRefCount를 호출해주고, Update에서 이제는 
        매번 _target의 _hp를 체크해서 0이되면 ReleaseRefCount를 호출하면서 참조 카운트를 줄여주고 이제는 이 미사일은 타겟이 없으니 nullptr로 밀어줍니다. 
        그리고 다음 루프에서 nullptr 접근 에러를 방지하기 위해 빠져나가는 조건문도 추가해주었습니다. 

        또 main 함수에서는 delete 를 하던 코드를 이제 ReleaseRefCount() 호출과 nullptr로 밀어주는 코드로 대체합니다. 


이렇게 레퍼런스 카운트를 활용해서 메모리 누수나 오염된 메모리를 읽는 문제를 해결했습니다. 
하지만 이 코드는 싱글쓰레드에서는 문제가 없지만 멀티쓰레드 환경으로 넘어오면 여러 문제가 발생합니다. 대부분의 코드가 원자적으로 동작하지 않을것이기 때문에 
여러 쓰레드가 변수를 동시에 수정하면서 에러가 날것입니다. 

그리고 가장 문제인점은 AddRefCount, ReleaseRefCount를 손수 관리하고 있다는 점입니다. 이러면 제일 첫번째로 귀찮고(효율이 낮음), 두번째로는 실수를 할 확률이 
있습니다. 

카운팅을 하는 RefCountable 클래스의 멤버 변수인 _refCount 부터가 값을 1 늘리고 줄이는 동작이 사실 어셈블리 수준에서 보면 원자적으로 동작하지 않습니다. 
이걸 멀티 쓰레드에서도 동작할 수 있도록 수정하는 가장 쉬운 방법은 _refCount를 atomic 객체로 만들어 주는것입니다. 

그러면 참조 카운트만 아토믹 객체로 수정하면 그대로 멀티쓰레드에서 사용할 수 있느냐? 그것은 아닙니다. 

GameServer.cpp 에 만들었던 Wraight, Missile 클래스도 손을봐야 합니다. 

->      GameServer.cpp

        예시로 Missile::SetTarget(Wraight* target) 함수를 보면 
        {
                _target = target;
                target->AddRefCount();
        }

        

        이렇게 타겟을 설정하고 레퍼런스 카운트를 하나 늘려줍니다. 이제는 이 코드의 문제가 무엇인지 알것입니다. 멀티쓰레드 환경에서는 저 두줄 사이에 다른 쓰레드가
        개입할 수 있는것이 문제인데 

        이걸 동시다발적으로 한 쓰레드는 SetTarget() 을 하고 있고 다른 쓰레드는 Wraight 객체의 ReleaseRefCount를 하고 있다고 해보겠습니다. 
        SetTarget에서 _target = target; 코드를 실행함과 동시에 아직 AddRefCount를 실행하기 전에 다른 쓰레드에서 
        wraight->ReleaseRefCount를 실행해버리면서 refCount가 0이 되서 바로 delete 가 되버리면 _target은 유효하지 않은 메모리를 들고 있게 됩니다. 

        위의 문제를 해결하려고 먼저 AddRefCount를 해서 카운트를 하나 늘려놓으면 어떨까 생각이 들 수도 있지만 이 경우도 돌도 돌아서 동일하게 AddRefCount하기전에 
        ReleaseRefCount가 실행되면 마찬가지로 유효하지 않은 메모리를 건들고 있는셈이 됩니다. 

        그래서 수동으로 포인터를 다루는것 특히 멀티쓰레드에서는 위험하고 어렵습니다. 그래서 자동으로 처리해줄 무언가가 필요한데 그게 기본적인 스마트 포인터의 개념입니다.



-- 스마트 포인터 -- 

본격적으로 스마트 포인터를 알아볼것입니다. 아까 만들었던 RefCounting.h 파일에서 RefCountable 밑에 Shared Pointer 클래스를 만들겠습니다. 

Shared Pointer는 말 그대로 공유하면서 사용하는 포인터로 아까 만든 RefCountable 클래스를 래핑해서 사용할 것입니다. 

->      RefCounting 안의 TSharedPtr 클래스 

        우리가 만들 SharedPtr은 템플릿을 사용해서 만들것이기 때문에 이름을 TSharedPtr 이라고 지었습니다. 
                
    template<typename T>
        class TSharedPtr
        {
        public:

                TSharedPtr() { }
                TSharedPtr(T* ptr) { Set(ptr); }

                // 복사
                TSharedPtr(const TSharedPtr& rhs) { Set(rhs._ptr); }
                // 이동
                TSharedPtr(TSharedPtr&& rhs) { _ptr = rhs._ptr; rhs._ptr = nullptr; }
                // 상속 관계 복사
                template<typename U>
                TSharedPtr(const TSharedPtr<U>& rhs) { Set(static_cast<T*>(rhs._ptr)); }

                ~TSharedPtr() { Release(); }

        public:
                // 복사 연산자 
                TSharedPtr& operator= (const TSharedPtr& rhs)
                {
                        if (_ptr != rhs._ptr)
                        {
                                Release();
                                Set(rhs._ptr);
                        }
                        return *this;
                }

                // 이동 연산자
                TSharedPtr& operator=(TSharedPtr&& rhs)
                {
                        Release();
                        _ptr = rhs._ptr;
                        rhs._ptr = nullptr;
                        return *this;
                }

                // 비교 연산자 
                bool		operator==(const TSharedPtr& rhs) const { return _ptr == rhs._ptr; }
                bool		operator==(T* ptr) const { return _ptr == ptr; }
                bool		operator!=(const TSharedPtr& rhs) const { return _ptr != rhs._ptr; }
                bool		operator!=(T* ptr) const { return _ptr != ptr; }
                bool		operator<(const TSharedPtr& rhs) const { return _ptr < rhs._ptr; }
                bool		operator>(const TSharedPtr& rhs) const { return _ptr > rhs._ptr; }
                
                // 생 포인터 반환 연산자
                T*			operator*() { return _ptr; }
                const T*	operator*() const { return _ptr; }
                                        operator T* () const { return _ptr; }
                T*			operator->() { return _ptr; }
                const T*	operator->() { return _ptr; }

                bool IsNull() { return _ptr == nullptr; }

        private:
                inline void Set(T* ptr)
                {
                        _ptr = ptr;
                        if (ptr)
                                ptr->AddRefCount();
                }

                inline void Release()
                {
                        if (ptr != nullptr)
                        {
                                _ptr->ReleaseRefCount();
                                _ptr = nullptr;
                        }
                }

        private:
                T* _ptr = nullptr;
        };

        먼저 멤버 변수는 T타입 데이터를 가리키는 포인터인 _ptr 뿐입니다. 
        내부적으로는 Set() 함수와 Release() 함수를 사용하는데 Set은 인자로 받은 포인터를 멤버 변수 _ptr에 대입하고 인자 ptr이 
        nullptr이 아니라면 RefCountable::AddRefCount() 를 호출합니다. 반대로 Release() 에서는 _ptr->ReleaseRefCount() 를 호출한 다음
        nullptr로 밀어줍니다. 

        다음은 생성자 소멸자 부분인데 기본 생성자는 그냥 nullptr로 생성하는 생성자이다보니 그냥 그대로 둡니다. 
        그리고 인자로 포인터를 주는 생성자는 말 그대로 Set을 해줍니다. 
        또 인자로 다른 TSharedPtr을 주는 복사 생성자와 이동 생성자, 상송관계에서 캐스팅해서 복사하는 생성자 마지막으로 소멸자에서는 
        Release() 를 실행하면서 참조 카운트를 줄여주고 있습니다. 

        다음으로는 직접만든 TSharedPtr를 표준 처럼 편리하게 사용하기 위해서 연산자 오퍼레이팅을 만들어 두었습니다. 
        서로 비교하는 연산자들, 복사 연산자, 이동연산자, 생 포인터를 꺼내는 연산자 등을 만들어 두었습니다. 


앞으로는 이번 실습에서 포인터를 생으로 사용하는 경우는 없어야 하고 꼭 TSharedPtr 통해 사용하겠습니다. 


using WraightRef = TSharedPtr<Wraight>;
using MissileRef = TSharedPtr<Missile>;

int main()
{
	WraightRef wraight(new Wraight());
	wraight->ReleaseRefCount();
	MissileRef missile(new Missile());
	missile->ReleaseRefCount();

        // ...
}

이런식으로 RefCountable을 상속 받았던 Wraight, Missile 클래스를 TSharedPtr로 한번더 감싸고 있습니다.

앞에서 RefCountable의 생성자에서 참조 카운트를 1로 설정하고 있었는데 TSharedPtr에서도 Set을 하면서 다시 한번 AddRefCount를 하기 때문에 
생성하자마자 참조 카운트가 2인 상황입니다. 그래서 한번씩 ReleaseRefCount를 호출해줘야 우리 정책에서는 참조 카운트가 정상적으로 동작할겁니다. 
이건 TSharedPtr의 생성자에서 따로 참조 카운트가 늘게 하지 않았어도 되고 지금처럼 한번 참조 카운트를 줄여줘도 됩니다. 

지금까지 실습내용에서 레이스가 격추되어 객체가 삭제되는 부분도 있었는데 이전까지 직접 ReleaseRefCount를 호출하였는데 이제는 그냥 
wraight = nullptr; 만 해줘도 됩니다. 

어째서 
wraight = nullptr;
이 코드만으로 충분하냐면 이미 = 연산자의 오버로딩이 되어 있기 때문인데 
다시 보면 
	TSharedPtr& operator= (const TSharedPtr& rhs)
	{
		if (_ptr != rhs._ptr)
		{
			Release();
			Set(rhs._ptr);
		}
		return *this;
        }

wraight의 알맹이와 nullptr이 같지 않을때 Release를 해주고 Set(nullptr) 을 해줍니다. 여기서 참조 카운트가 1개 였다면 알아서 delete까지 되는겁니다.


그런데 지금 이 SharedPtr을 만들어 사용해본 이유가 있었습니다. 멀티 쓰레드 환경에서 포인터를 사용하기 위함이었는데 
방금한 이 코드가 멀티쓰레드 환경에서 문제에 어떤 의미가 있는지 햇갈립니다. 아까 발생한 중간에 개입하는 문제를 해결해줄 수 있는지 아리송한데 

아까 문제의 예시였던 Missile::SetTarget() 함수를 보면 여기도 인자로 생포인터를 받던걸 TSharedPtr을 받게 되는데 그리고 그 내용은 
	void SetTarget(WraightRef target)
	{
		_target = target;
		//target->AddRefCount();
	}

이렇게 될겁니다. 직접 _target에 타겟을 대입한 다음 참조 카운트를 늘렸던것을 이제는 복사연산자를 오버로딩했기 때문에 스마트 포인터 특성상 
알아서 Set을 하면서 레퍼런스카운팅을 늘려주게 됩니다. 그래서 최소한 레퍼런스 카운팅이 1 이상이라는것을 확신할 수 있게 됩니다. 



-- 정리 -- 

오늘의 내용을 정리해보겠습니다. 스마트 포인터의 필요성은 여러 객체가 서로를 가리키는 변수를 들고 있을때 발생합니다. 
A 객체가 B객체를 타겟으로 가리키는 포인터를 들고 있다고 했을때 타겟의 데이터를 읽는 함수도 있다고 하겠습니다. 
그런데 만약 중간에 B객체가 어떤 이유에서 메모리 해제가 되어 삭제 되었는데 A객체는 그것도 모르고 B객체가 있던 주소의 데이터를 읽게 되면 
전혀 엉뚱한 데이터를 가져오는 데이터 오염이 일어납니다. 

이 문제를 해결하기 위해서 이번 실습에서는 사용하는 클래스들이 상속받을 상위 클래스 하나를 만들어서 atomic 하게 참조 카운트를 관리하였습니다. 
기본적으로 A, B 객체를 만들게 되면 참조 카운트가 1 이 되고 A가 B를 타겟으로 참조하게 되면 B객체의 참조 카운트가 하나 해서 2가 됩니다. 
그리고 어떤 이유에서 B객체가 삭제 될때 바로 삭제하지 않고 참조 카운트를 1 줄이고 nullptr로 밀고 참조 카운트가 0이라면 그때 서야 진짜 delete해주도록하면 
A에서는 오염된 메모리가 아닌 nullptr을 참조하면서 안전하게 이상을 알아 챌 수 있을겁니다. 

그런데 이 방식의 문제는 손수 참조카운트를 늘리고 줄이는것을 매번 해야 한다는 것에 있습니다. 그럴경우 실수할 여지가 생기는데 아무리 꼼꼼하더라도 
큰 프로젝트에서 참조 카운트에 실수가 생기면 심각한 문제로 이어지기 때문에 자동으로 참조 카운트를 관리해주는 스마트포인터가 꼭 필요합니다. 

또 단순히 실수의 문제 뿐만아니라 위에서의 가정들은 모두 싱글쓰레드 기준으로 생각한 것이고 
멀티쓰레드에서는 병렬적으로 다수의 쓰레드가 동작하기 때문에 값을 대입하고 참조 카운팅을 늘리는 중간 중간에 다른 쓰레드에서 개입할 여지가 생깁니다. 

이 문제를 해결하기 위해 스마트 포인터를 사용하게 되는데 이후 모든 생 포인터의 사용을 금하고 항상 스마트 포인터로 래핑해서 사용해야합니다. 
스마트 포인터는 템플릿으로 각 클래스를 가리키는 포인터타입의 변수를 가지고 있습니다. 
이 포인터를 생성자, 소멸자, 연산자 오버로딩등으로 관리를 해줍니다. 

예를들어 스마트 포인터가 생성될때 참조 카운트가 늘어나도록 설계하고 
스마트 포인터 (A객체 생성) 
이렇게 스마트 포인터로 감싼 A객체를 만들게 되면 일단 A객체가 생성되면서 참조 카운트가 1이 되고 이 객체의 주소를 스마트 포인터가 받아서 저장하고 그 과정에 
또 참조 카운트가 1 증가합니다. 즉 객체를 스마트 포인터로 만들자 마자 참조 카운트가 2인상태인데 이런 설계에서는 매번 
생성후 Release를 해줘서 객체의 소유권을 온전히 스마트 포인터가 가지도록 해줍니다. 

그렇게 해서 스마트 포인터 객체를 멀티쓰레드 환경에서 사용하게 되면 어느 쓰레드에서는 타겟으로 지정해 참조 카운트를 늘리고 어느 쓰레드에서는 객체를 Release 해서 
참조 카운트를 줄인다고 했을때 
먼저 Release가 일어나면 후에 실행된 Add 는 객체의 위치가 nullptr이기 때문에 실행이 되지 않고 에러가 날겁니다. 그래도 에러가 나는게 메모리 오염이 일어나고도 모르는
것보다는 낫습니다. 
반대로 Add가 먼저 일어나게 되면 참조 카운트가 2가 되고 이후 Release로 참조 카운트가 1이 되므로 잘 동작하게 됩니다. 

그런데 이 과정이 어째서 멀티쓰레드환경에서 중간에 다른 쓰레드의 개입없이 가능하는가는 스마트 포인터의 대입연산자에서 한번에 참조 카운트 관리를 해주기 때문입니다. 
이전에는 포인터의 값 대입과 참조 카운트의 관리 코드가 따로 떨어져서 동작하기 때문에 중간 개입이 일어날 수 있지만 스마트 포인터는 대입과 관리 동시에 
일어나기때문에 멀티쓰레드 환경에서도 잘 동작하게 됩니다. 
이것은 스마트 포인터를 복사 방식으로 인자에 받아주어서 가능한데 이 복사 방식은 생각보다 많은 리소스가 들어갑니다. 

참조 카운트 자체가 아토믹 객체이고 이 아토믹객체는 멀티쓰레드 환경에서 동작이 생각보다 많이 무겁습니다. 

그렇기 때문에 스마트 포인터에서도 아주 짧은 시간 가져다 사용하는때에는 복사 방식이 아닌 참조 방식을 사용하는 경우도 있다고 합니다. 


마지막으로 오늘 학습한 내용처럼 각 프로젝트마다 직접 스마트포인터를 만들어 사용할 수도 있고 아니면 표준의 스마트 포인터를 그대로 사용하는 경우도 있습니다. 
각기 입맛에 맞게 수정할수 있는지 없는지, 따로 만들어야 하는지 아닌지에 따라 선택할 수 있을것입니다. 