#include "pch.h"
#include "Listener.h"
#include "SocketUtils.h"
#include "IocpEvent.h"
#include "Session.h"
#include "Service.h"


/*
--------------------
	Listener 정의부
--------------------
*/
Listener::~Listener()
{
	// 소멸 시점에 Listener가 들고있던 소켓을 닫아줍니다. 
	SocketUtils::Close(_socket);

	// 반복문을돌면서 들고있던 AcceptEvent 들도 정리합니다.
	for (AcceptEvent* acceptEvent : _acceptEvents)
	{
		// TODO 

		A_delete(acceptEvent);
	}

}

// Listener를 만든 다음 그 소켓으로 Accept를 호출합니다.
bool Listener::StartAccept(ServerServiceRef service)
{
	// _service를 채워줍니다. 
	_service = service;
	if (_service == nullptr)
		return false;

	_socket = SocketUtils::CreateSocket();
	if (_socket == INVALID_SOCKET)
		return false;
 
	/*
	지금까지는 임시로 IocpCore 객체를 그냥 extern 으로 만들고 있었는데 이부분을 수정해주겠습니다. 
	IocpCore 클래스에서 삭제를 했지만 이제는 _service에서 꺼내 사용할 수 있습니다. 
	그리고 IocpCore->Register() 의 인자로 그냥 this 를 넘겨주면 안되고 
	shared_from_this() 로 넘겨줘야합니다 
	*/
	if (_service->GetIocpCore()->Register(shared_from_this()) == false)
		return false;

	if (SocketUtils::SetReuseAddress(_socket, true) == false)
		return false;

	if (SocketUtils::SetLinger(_socket, 0, 0) == false)
		return false;

	if (SocketUtils::Bind(_socket, _service->GetNetAddress()) == false)
		return false;

	if(SocketUtils::Listen(_socket) == false)
		return false;

	// 이제 acceptCount도 ServerService의 maxSessionCount 값으로 주겠습니다. 
	const int32 acceptCount = _service->GetMaxSessionCount();
	for (int32 i = 0; i < acceptCount; i++)
	{
		AcceptEvent* acceptEvent = A_new<AcceptEvent>();
		acceptEvent->owner = shared_from_this();
		_acceptEvents.push_back(acceptEvent);
		RegisterAccept(acceptEvent);
	}

	return true;
}

// 이 함수는 별건아니고 그냥 이 lisnteSocket을 닫아줍니다.
void Listener::CloseSocket()
{
	SocketUtils::Close(_socket);
}

// _socket을 HANDLE로 캐스팅해 반환
HANDLE Listener::GetHandle()
{
	return reinterpret_cast<HANDLE>(_socket);
}

// IocpCore::Dispatch 에서 GetQueuedCompletionStatus 를 통과한후 IocpEvent->Dispatch를 호출한게 이곳으로 옵니다.
void Listener::Dispatch(IocpEvent* iocpEvent, int32 numOfBytes)
{
	// 현재까지 테스트중인 Event 타입이 Accept 뿐이니까 에러체크해줍니다.
	ASSERT_CRASH(iocpEvent->eventType == EventType::Accept);

	// iocpEvent를 AcceptEvent로 복원해주겠습니다. 
	AcceptEvent* acceptEvent = static_cast<AcceptEvent*>(iocpEvent);
	
	// 이제 이 AcceptEvent를 실행하기위해 ProcessAccept 를 호출합니다
	ProcessAccept(acceptEvent);
}

void Listener::RegisterAccept(AcceptEvent* acceptEvent)
{
	SessionRef session = _service->CreateSession();
	acceptEvent->Init();
	acceptEvent->session = session;

	DWORD bytesReceived = 0;
	// AcceptEx의 인자로 버퍼를 줄때 Accept와 동시에 받을 데이터가 있다면 그 데이터를 받아줄 주소의 시작점을 
	// 넘겨 줬어야 합니다. 이전에는 그냥 매번 배열의 시작주소를 주었지만 
	// 이제는 RecvBuffer의 WritePos라는 커서를 넘겨주면 됩니다. 
	if (false == SocketUtils::AcceptEx(_socket, session->GetSocket(), session->_recvBuffer.WritePos(), 0, sizeof(SOCKADDR_IN) + 16, sizeof(SOCKADDR_IN) + 16, OUT & bytesReceived, static_cast<LPOVERLAPPED>(acceptEvent)))
	{
		const int32 errorCode = ::WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			RegisterAccept(acceptEvent);
		}
	}
}


void Listener::ProcessAccept(AcceptEvent* acceptEvent)
{
	// AcceptEvent에 보관해뒀던 세션을 꺼냅니다. 
	SessionRef session = acceptEvent->session;

	// SetUpdateAcceptSocket 이라는 함수는 인자 소켓과 listen 소켓의 옵션을 똑같이 맞춰줍니다.
	if (false == SocketUtils::SetUpdateAcceptSocket(session->GetSocket(), _socket))
	{
		// 실패했으면 리턴하기전에 꼭 RegisterAccept를 호출해줘서 다음 예약을 해줍니다. 
		RegisterAccept(acceptEvent);
		return;
	}

	// 데이터를 추출해보겠습니다. getpeername 함수를 통해 sockAddress에 주소를 가져오고있습니다. 
	SOCKADDR_IN sockAddress;
	int32 sizeOfSockAddr = sizeof(sockAddress);
	if (SOCKET_ERROR == ::getpeername(session->GetSocket(), OUT reinterpret_cast<SOCKADDR*>(&sockAddress), &sizeOfSockAddr))
	{
		RegisterAccept(acceptEvent);
		return;
	}


	session->SetNetAddress(NetAddress(sockAddress));
	session->ProcessConnect();
	

	RegisterAccept(acceptEvent);

}