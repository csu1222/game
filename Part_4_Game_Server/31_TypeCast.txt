

        Type Cast


이번시간은 캐스팅에 관련된 내용입니다. 

필수로 알아야할 내용은 아니지만 이번 시간을 배우면 프로그래밍에 대해 많은 부분을 배울 수 있는 시간이라고 합니다. 

참고로 오늘 내용은 2003년 나온 Mordern C++ Design 이라는 책에서 발취한 내용이라고 합니다. 굉장히 유명한 책이라고 합니다. 

이전시간에 알아본 Memory Pool 나중에 알아볼 Job Queue , 오늘 주제인 TypeCast 같은 내용들이 모두 이책에서 착안한 내용들이라고 합니다. 


- 필요성
일단 오늘 주제인 TypeCast의 필요성에 대해 알아보겠습니다. 

게임을 만들면 다양한 클래스들이 생기게 될겁니다. 예시로 플레이어 캐릭터 부터 상위 클래스가 될 Player도 있을것이고 
플레이어들의 직업들도 하위 클래스로 Knight, Mage 같은 구조로 되어 있을겁니다. 


class Player
{
public:

};

class Knight : public Player
{
public:

};

class Mage : public Player
{
public:

};

이런 클래스들이 있다고 하고 단순하게 Knight와 Mage 객체를 만들고 싶다고 하면

Knight* knight = new Knight();
Mage* mage = new Mage(); 

이렇게 만들면 된다고 생각할 수 있는데 의외로 이렇게 각자를 이용해서 관리하는 경우는 잘 없고 더 상위의 클래스로 한번에 관리하는게 보통이라고 합니다. 
나중에 PvP 같은 콘텐츠를 만든다고 할때 Knight 끼리만 PvP를 한다기 보다는 여러 직업들도 서로 PvP를 하는경우가 보통일겁니다. 그럴때는 공통된 Player 클래스를 
대상으로 실행하는게 유용합니다. 

void AttackPlayer (Player* player)
{

}
이런식으로 플레이어를 공격한다고 치면 인자를 Player포인터를 받는게 편한겁니다. 

그리고 나중에 NPC 나 몬스터 같은 클래스도 생긴다면 이 모든 클래스를 아우르는 더 상위 클래스 이름은 예를 들어 Creature 를 만들어서 공통으로 관리하면 될겁니다. 

그래서 Knight, Mage 객체들을 모두 상위 클래스인 Player로 관리하게 될 예정인데 

	Player* p1 = new Knight();
	Player* p2 = new Mage();

또 여기서 이번에는 AttackPlayer 에서 Knight 객체에게만 적용되는 어떤 일을 하고 싶다고 하면 다시 Player 포인터에서 Knight 포인터로 캐스팅해야 합니다. 

        Knight* k1 = static_cast<Knight*>(p2);

그런데 이 캐스팅의 문제점은 p1이나 p2 가 둘다 상위 클래스인 Player 였다보니까 원본이 Mage 였던 p2를 Knight로 캐스팅해버리면 메모리 오염이 일어나게 됩니다. 
만약 Mage와 Knight 가 접근할 수 있는 멤버 변수의 크기가 다르다고 하면 엉뚱한 메모리를 건들고 있을 수 있습니다. 

static_cast 의 대안으로 dinamic_cast 라는 것이 있었습니다. dynamic_cast같은 경우는 캐스팅을 하다가 캐스팅이 안되면 그냥 nullptr을 반환해줄겁니다.
하지만 dynamic_cast는 인자로 다형 클래스 형식이어야 한다고 합니다. RTTI (Run Time Type Information)라고 가상함수가 하나 있어야 한다는겁니다. 
그래서 상위 클래스인 Player 에 소멸자를 가상함수로 만들어 주겠습니다. 

class Player
{
public:
	virtual ~Player() { }
};

이러면 dynamic_cast 코드가 통과됩니다. 

아직 아쉬운 점이 있는데 dynamic_cast는 속도가 비교적 느리다고합니다. 그래서 성능적인 문제로 static_cast를 더 선호하고 있다고 하는데 대신 위험한게 있겠죠

그럼 나중에 규모가 좀 되는 게임에서는 어떻게 할것이냐면 성능이 중요하기 때문에 일단 static_cast를 사용하고 대신 메모리 오염의 위험성을 걸러주기 위해 
추가적인 기법이 들어갑니다. 

enum PLAYER_TYPE
{
	KNIGHT,
	MAGE,
};

class Player
{
public:
	virtual ~Player() { }

	int _type;
};

class Knight : public Player
{
public:
	Knight() { _type = KNIGHT; }

};

class Mage : public Player
{
public:
	Mage() { _type = MAGE; }

};

PLAYER_TYPE 라는 열거형을 하나 만들어 줬습니다. 거기에 이제 상위 클래스인 Player 클래스에서 _type을 들고 있게 했고 Knight, Mage에서 각각 생성자에서 _type에 
열거형에서 자신에 해당하는 타입값으로 초기화 해줍니다. 

이제 Knight, Mage 객체들은 생성하면서 자신의 타입을 int 변수에 들고 있을겁니다. 

	if (p1->_type == KNIGHT)
		Knight* k1 = static_cast<Knight*>(p1);

이렇게 Player 포인터로 캐스팅된 Knight 객체가 생성될때부터 초기화된 _type 정보를 체크해서 이 객체의 원본이 Knight 였다는것을 확인한 후에 Knight 포인터로 캐스팅을 
하고 있습니다. 

나중에 클래스가 많아지게 되면 일일히 타입 아이디를 지정해주는것도 일일겁니다. 거기다 혹시라도 타입 아이디 체크를 누락했다거나 아니면 당연히 그 클래스겠거니 생각했다가 
실수를 한다던가 아니면 프로젝트에서 이전에 이 파트를 개발하던 사람과 다음에 이 파트를 이어 받은 사람이 작업 방식을 잘 몰라서 이 방식을 유지 하지 않는다거나 하는 
일이 생길 수 있습니다. 

그 대책으로 타입 체크하는 코드를 함수로 빼서 동작하도록 만들어 주는 방법도 있을겁니다. 
	class Knight* PlayerToKnight()
	{

		if (this->_type == KNIGHT)
		{
			Knight* knight = static_cast<Knight*>(this);
			return knight;
		}
	}

이런 함수를 일일히 만드는것도 귀찮은 일이기는 합니다. 

그래서 오늘주제가 이런 부분에 대한 이야기를 하려고 합니다. 

언리얼 엔진에서도 dynamic_cast를 그대로 사용하지 않고 내부적으로 지원하는 캐스팅이 있어서 좀 더 빠르게 dynamic_cast를 할 수 있도록 합니다. 

이것들을 알아보기 위해 먼저 알아야 할 산이 있습니다. 
오늘 작업할 코드들을 따로 헤더 파일에 다 넣어줄겁니다. ServerCore 프로젝트>Memory필터 아래에 TypeCast.h 라는 헤더를 추가하였습니다. 

첫번째로 해볼 작업은 타입 리스트라는 것입니다. 
기본적인 list 는 템플릿으로 리스트 안에 담을 타입을 지정하고 지정한 타입에 맞는 데이터들만 리스트에 담을 수 있었습니다. 
그런데 지금 알아볼 타입 리스트라는 것은 여러타입의 데이터를 같이 리스트에 담아 관리하고 싶은것입니다.

list li {Player, Knight, Mage}
위의 코드는 지금까지 배운 list 문법과 맞지 않는 형태입니다. 의미는 li 라는 식별자의 list 객체를 만들고 그 안에 담고 싶은 타입들이 Player, Knight, Mage 클래스의 
데이터들을 담아 관리하고 싶은겁니다. 

지금부터 템플릿을 이리지러 활용해서 위와 같은 문법으로 동작하도록 만들어 보겠습니다. 

->	TypeCast.h

	// 타입 리스트
	#pragma region TypeList

	template<typename... T>
	struct TypeList;

	template<typename T, typename U>
	struct TypeList<T, U>
	{
		using Head = T;
		using Tail = U;
	};

	template<typename T, typename... U>
	struct TypeList<T, U...>
	{
		using Head = T;
		using Tail = TypList<U...>;
	};

	#pragma endregion

	타입 리스트의 코드인데 처음보면 이해가 안갑니다. 차근 차근 배워보겠습니다. 
	
	먼저 간단하게 시작하겠습니다. 

	template<typename T, typename U>
	struct TypeList
	{
		using Head = T;
		using Tail = U;
	};

	TypeList<Mage, Knight>::Head whoAMI;
	TypeList<Mage, Knight>::Tail whoAMI2;

	이 코드에서 TypeList의 Head 와 Tail 을 통해 각각 Mage와 Knight 를 가리키고 있습니다. 
	std::pair 같은 느낌으로 사용하고 있는겁니다. 그래서 TypeLsit 라는 구조체는 Head, Tail 이라는 걸로 템플릿으로 받은 두 타입을 
	고를 수 있게 됩니다. 여기까지는 간단합니다.

	그 다음 해보고 싶은건 이제 여러개 중에 골라줘야 한다 Knight, Mage 뿐만 아니라 새로운 직업 Archer를 추가해보겠습니다. 
	
	enum PLAYER_TYPE
	{
		KNIGHT,
		MAGE,
		ARCHER,
	};

	class Archer : public Player
	{
	public:
		Archer() { _type = ARCHER; }

	};

	이제는 TypeList 에는 두 쌍이 아니라 세개의 클래스를 담을 겁니다. 
	어떻게 할것이냐면 이전에 동적 이차배열로 bfs에서의 인접 정점들을 표현했었습니다. 
	
	vector<vector<int32>> v;

	이런식으로 말입니다. 이때도 vector 뒤의 <> 안에는 마찬가지로 템플릿입니다. 그리고 템플릿의 특성상 무엇만 템플릿으로 올 수 있다고 제한을 걸지 않습니다. 
	그러다 보니 이렇게 응용할 수 있습니다. 

	TypeList<Mage, TypeList<Knight, Archer>> list;

	이렇게 하면 조금 어려워 보이지만 Mage, Knight, Archer 순으로 세개의 클래스 타입을 저장하고있다고 볼 수 있습니다. 
	
	TypeList<Mage, TypeList<Knight, Archer>>::Head whoAMI3;			// Mage
	TypeList<Mage, TypeList<Knight, Archer>>::Tail::Head whoAMI4;	// Knight
	TypeList<Mage, TypeList<Knight, Archer>>::Tail::Tail whoAMI5;	// Archer

	각각의 타입들에 접근하려면 이렇게 접근 할 수 있을겁니다. 
	일단 이런식으로 동작한다는걸 알고 나서 다시 TypeCast 에 추가했던 TypeList 코드들을 보겠습니다. 

	template<typename... T>
	struct TypeList;
	맨 첫번째 TypeList 코드입니다. C++11 부터 등장한 가변 길이 템플릿(Variadic template)입니다. 하나 이상 갯수의 템플릿을 넣어줄 수 있다는 뜻입니다.
	
	여기서 두가지 길을 주고 있는겁니다. 
	
	template<typename T, typename U>
	struct TypeList<T, U>
	{
		using Head = T;
		using Tail = U;
	};

	template<typename T, typename... U>
	struct TypeList<T, U...>
	{
		using Head = T;
		using Tail = TypList<U...>;
	};

	이렇게 여러 가지 길을 만들어 놓으면 컴파일러가 여러 길중 가장 가까운 코드로 컴파일 됩니다. 

	만약 데이터가 두개밖에 없는 상황이라면 두 방법중 윗쪽 방법을 사용해서 Head = T, Tail = U 라는 버전으로 만들어 질겁니다. 아까 예시로 들었던것중 
	Mage 와 Knight 로 되어 있는 TypeList 입니다. 

	그게 아니고 데이터가 세개 이상들어오게 되면 이제 아랫 방법으로 컴파일 되고 Head = T 라는것으 같지만 Tail = TypeList<U...> 이라는 재귀적인 형태를 
	띄게 됩니다. 이것은 아까 예시에서 Mage, knight, Archer 세가지 클래스로 TypeList를 만들었던 부분입니다. 

	일단 어떤 의미인지 조금은 알았는데 그래서 이 것을 어떻게 활용하는가 이것이 궁금해집니다.

	방금 알아본 바대로 ::Head, ::Tail, ::Tail::Head ... 이런식으로 접근하는것은 매우 번거로운일 입니다. 


	// Length

	이어서 Length 를 만들겠습니다. 이름 그대로 TypeList 의 길이를 말합니다. 다른 컨테이너 vector, list 같은 것들도 다 길이를 구할 수 있었습니다. 
	그런데 TypeList 같은 템플릿을 통한 구조체의 길이는 컴파일 단계에서 계산이 됩니다. 다른 보통 컨테이너들은 런 타임에서 길이를 계산하는것과 다릅니다. 
	컴파일 단계에서 계산된다는 것은 거의 정수 타입 변수정도의 부하밖에 들지 않는다는 것입니다. 컴파일된 이후 프로그램이 실행되는 중에는 전혀 부담이 걸리지 않습니다.

	template<typename T>
	struct Length;

	template<>
	struct Length<TypeList<>>
	{
		enum { value = 0 };
	};
	/*
	TypeList 가 비어 있는 상황의 Length 입니다. TypeList가 비어있으니 value를 0이라고 반환할텐데 
	굳이 enum에 value를 담는 이유는 enum 또한 컴파일 타임에 결정되는 데이터 이기 때문입니다. 위의 TypeList 부터
	컴파일 타임에 결정되는 방식으로 만들었기 때문이 이후로도 모두 컴파일 타임에 결정되는 방법으로 만들어 줄겁니다. 
	*/

	template<typename T, typename... U>
	struct Length<TypeList<T, U...>>
	{
		enum { value = 1 + Length<TypeList<U...>>::value };
	};

	Length의 코드입니다. 맨 위는 Length 라는게 있다고 선언을 하는 부분이고 두번째, 세번째가 본 내용인데 두가지 방식으로 만들어 주었습니다. 
	먼저 TypeList 의 템플릿이 비어있는 버전입니다. 이때 Length의 의미 자체가 TypeList의 길이를 뜻하기 때문에 당연히 텅빈 TypeList의 길이는 0일것이기 때문에 value가 0입니다.

	그리고 나서 다음으로 올게 TypeList에 데이터가 있을 경우입니다. 템플릿으로 template<typename T, typename... U> 이렇게 받습니다. 이건 아까 TypeList 와 같은 형태입니다. 
	그리고 내용에서는 일단 value 를 1로 두고 거기에 Length<TypeList<U...>>::value를 더해주고 있습니다. 이 코드의 의미는 일단 이 버전의 Length로 들어왔다는 것은 
	하나 이상의 데이터가 포함된 TypeList의 길이를 구하고 있는겁니다. 
	만약 데이터가 하나라면 T가 그 하나인 데이터가 되고 가변 길이 템플릿인 U 에는 아예 아무런 데이터가 없다고 해도 잘 동작합니다. 
	이때 value 는 기본 1이고 다음은 데이터가 없는 TypeList의 길이를 더합니다. 즉 1이라는 겁니다. 
	이후로 데이터가 늘면 늘수록 value가 1씩 반환되면서 재귀적으로 더해져서 사실상의 TypeList의 길이를 구할 수 있습니다.

	결국 이 계산이 컴파일 단계에 다 계산되고 이후 프로그램 러닝할때는 부담이 없을것입니다. 
	

	// TypeAt

	다음으로 TypeAt 이라는 걸 만들어 보겠습니다. 무슨일을 하는 구조체 이냐면 현재 위에까지 만든 TypeList 에서는 원하는 데이터에 접근하기 위해서는 
	Head , Tail, Tail::Head, Tail::Tail 등등 이런 방법으로 접근해야합니다. TypeList에 얼마나 많은 데이터를 넣을지 모르겠지만 일단 3개부터 충분히 
	번거롭습니다. 

	그래서 지금 만들 TypeAt 을 통해 배열에서 인덱스로 접근하는것 처럼 몇번째에 위치한 데이터를 꺼내줄수 있는 기능을 만들겠습니다. 
	#pragma region TypeAt

	template<typename TL, int32 index>
	struct TypeAt;

	template<typename Head, typename... Tail>
	struct TypeAt<TypeList<Head, Tail...>, 0>
	{
		using Result = Head;
	};

	template<typename Head, typename... Tail, int32 index>
	struct TypeAt<TypeList<Head, Tail...>, index>
	{
		using Result = typename TypeAt<TypeList<Tail...>, index - 1>::Result;
	};

	#pragma endregion

	TypeAt 코드입니다. 지금까지 비슷한 작업을 많이 해왔습니다. 마찬가지로 재귀적으로 동작하는 원리인데 먼저 맨위에 만든 TypeAt을 보면 
	템플릿으로 TL 이라는 typename 하나와 int32 를 받습니다. 

	그 다음은 int32 부분이 0일때입니다. TypeList의 Head, Tail을 주고 나서 인덱스가 0일때는 가장앞의 데이터인 Head 를 반환할겁니다. 그래서 Result = Head 가 되는겁니다. 

	또 다음은 이제 인덱스가 0이 아닌 값일때 입니다. 이때는 Result 로 Tail 부터 시작하는 TypeList 를 받고 또 인덱스 - 1 로 재귀적으로 구합니다. 결국 
	인덱스가 0이 될때 까지 진행돠고 그 때의 Head를 반환하게 됩니다. 

	한번 Mage, Knight, Archer 를 담은 TypeList 에서 2번 인덱스의 데이터를 TypeAt으로 꺼내오는 과정을 묘사해보겠습니다. 
	TypeAt<TypeList<Mage, Knight, Archer>, 2>::Result 를 얻고 싶은것입니다.
	일단 TypeList<Mage, Knight, Archer> 에서는 Head는 Mage고 Tail... 에 해당하는게 Knight, Archer 입니다. 
	인덱스가 2 이다 보니 

	template<typename Head, typename... Tail, int32 index>
	struct TypeAt<TypeList<Head, Tail...>, index>
	{
		using Result = typename TypeAt<TypeList<Tail...>, index - 1>::Result;
	};
	이 버전의 TypeAt 이 호출 될겁니다. Result 는 TypeAt<TypeList<Knight, Archer>, 1>::Result 를 가져올것이고 이건또 다시 
	TypeAt<TypeList<Archer>, 0>::Result 까지 가게 될겁니다. 
	이제는 인덱스가 0이니까 
	
	template<typename Head, typename... Tail>
	struct TypeAt<TypeList<Head, Tail...>, 0>
	{
		using Result = Head;
	};
	이버전의 TypaAt이 호출되고 그러면 이 시점의 Head 인 Archer 가 Result 가 되어서 반환 되겠습니다. 

	배열처럼 메모리 상으로 연속적으로 그리고 같은 타입이다 보니 같은 크기의 데이터들로 이루어진 컨테이너가 아닌 이상 실제로 인덱스로 임의 접근은 할 수 없습니다. 
	TypeList 는 연속적인지는 둘째 치고 일단 같은 타입의 데이터가 아닌걸 같이 관리하기 위해서 만들어 졌기 때문에 진짜 인덱스 접근이 안되고 
	지금 처럼 재귀적으로 찾아 줘야 합니다. 

	TypeAt의 사용예를 한번 들어 보겠습니다. 
	
	using TL = TypeList<Mage, Knight, Archer>;
	TypeAt<TL, 0>::Result whoAMI6;
	TypeAt<TL, 1>::Result whoAMI7;
	TypeAt<TL, 2>::Result whoAMI8;

	타이핑하기 간편하게 using 을 사용해서 TypeList를 줄여 주고 TypeAt 에 줘 봤습니다. 0, 1, 2 번째의 인덱스로 접근하도록 변수들을 만들어 보면 
	아직 프로그램을 실행중이 아님에도 컴파일 단계에서 이미 다 연산이 되어있습니다.


	다음은 IndexOf 라는 기능을 만들어 보겠습니다. TypeAt 은 인덱스를 가지고 데이터를 찾는것이었다면 IndexOf 는 이 데이터가 몇번 인덱스인지를 찾는 기능입니다. 
	// IndexOf
	#pragma region IndexOf

	template<typename TL, typename T>
	struct IndexOf;

	template<typename... Tail, typename T>
	struct IndexOf<TypeList<T, Tail...>, T>
	{
		enum { value = 0 };
	};

	template<typename T>
	struct IndexOf<TypeList<>, T>
	{
		enum { value = -1 };
	};

	template<typename Head, typename... Tail, typename T>
	struct IndexOf<TypeList<Head, Tail...>, T>
	{
	private:
		enum { temp = IndexOf<TypeList<Tail...>, T>::value };
	public:
		enum { value = (temp == -1) ? -1 : temp + 1 };

	};

	#pragma endregion

	이것은 컴파일링이 될때 가장 가까운 버전으로 골라주는 원리를 이용하는것 같습니다. 

	기본적으로 IndexOf 는 TL 과 T 라는 typename 을 받는 형태라는걸 만들어 주고 시작합니다. 
	
	제일먼저 Tail, T 를 템플릿으로 받습니다. 그리고 TypeList 에서 Head 가 T 인 TypeList인 경우인데 그러면 가장 앞에 있는 데이터 이기 때문에 당연히 
	0번 인덱스가 value 일겁니다. 

	그다음 버전은 아예 TypeLsit가 비었을때 T를 찾는 경우인데 이 경우에는 value = -1 이 됩니다. 

	세번째 버전이 주요 내용인데 먼저 여기서는 TypeList 가 Head 부터 Tail... 까지 있는 경우이고 그 중 T 라는 데이터를 찾는겁니다. 
	그리고 private 와 public 이 나뉘어서 private 에서는 temp 라는 enum 을 계산하고 public 에서는 value 를 계산하고 있는데 두 가지로 나눈이유는 이렇습니다. 
	먼저 TypeList 가 비었거나 가장 앞의 데이터가 찾던 데이터인 경우는 위에서 이미 만들었으니까 이 버전까지 왔다는것은 TypeList 가 비어 있지 않고 가장 앞의 데이터가 
	찾는 데이터 T 가 아닌 경우입니다. 
	이때 일단 맨 앞의 데이터는 찾는 데이터가 아니니 때어내고 TypeList<Tail...> 로 재귀적으로 찾아 나가는데 그 중 value 값을 temp에 받아옵니다. 
	만약 TypeList가 비었다면 temp = -1 이 될 것이고 아니면 이번에 가장 앞 데이터가 찾는 데이터가 아니라면 다시 재귀 연산을 할것이고 
	찾는 데이터라면 temp = 0 일겁니다. 

	그리고 나서 이제 value를 보면 삼항 연산자에 의한 조건문이 있습니다.( 조건식 ? 반환값 1 : 반환값 2 ) 이런 형태인데 
	value = (temp == -1) ? -1 : temp + 1
	이 문장을 해석 해보면 value 는 temp가 -1 인지를 확인해서 맞다면 -1, 아니라면 temp 에 + 1 을 해서 받습니다. 

	지금까지 temp 을 연산하던것은 말 그대로 temp 의 값을 계산한는거고 value 가 아니었습니다. 
	찾는 데이터 T 가 TypeList의 가장 앞에 올때까지 1씩 더해지면서 결국 인덱스를 알 수 있게 됩니다. 

	사용 예시입니다. 
	
	class Dog
	{
	public:

	};

	using TL = TypeList<Mage, Knight, Archer>;
	int32 index1 = IndexOf<TL, Mage>::value;
	int32 index2 = IndexOf<TL, Knight>::value;
	int32 index3 = IndexOf<TL, Archer>::value;
	int32 index4 = IndexOf<TL, Dog>::value;

	뜬금 없지만 Dog 라는 클래스를 하나 만들었습니다. 각 Mage, Knight, Archer 는 자신의 인덱스가 나오게 될것이고 
	TL에 없는 Dog 를 찾아보면 값이 -1 이 나올것입니다. 

	
	// Conversion
	다음은 Conversion 이라고 좀 재미있는 기능입니다. 템플릿으로 typename 을 두개 받을건데 앞 타입이 뒷 타입으로 캐스팅이 가능한지를 체크하는 기능입니다. 

	#pragma region Conversion

	template<typename From, typename To>
	class Conversion
	{
	private:
		using Small = __int8;
		using Big = __int32;

		static Small Test(const To&) { return 0; }
		static Big Test(...) { return 0; }
		static From MakeFrom() { return 0; }

	public:
		enum
		{
			exists = sizeof(Test(MakeFrom())) == sizeof(Small);
		};
	};

	#pragma endregion

	코드를 보면 이게 어떻게 해서 변환이 가능한지를 알 수 있는 코드인지 이해가 가지 않습니다. 
	컴파일러는 자신이 보기에 가장 그럴싸 한걸 자동으로 골라주는 특징을 이용하고 있다고 합니다. 

	먼저 exists 를 보면 먼저 MakeFrom이라는걸 계산하고 있는데 From 이라는 타입을 반환해주고 있습니다. 그런데 이 From 이 만약 To로 변환가능하다고 판단이 되면 
	MakeFrom을 감싸고 있던 Test 함수에서 윗버전 Small을 반환하는 버전을 호출해줄것입니다. 만약 윗버전 Test가 호출된다고 하면 반환타입이 Small 이 될것이고 
	그 sizeof 끼리 비교하면 true 가 나올것이고 
	만약 From 이 To로 변환이 되지 않는다고 하면 Big을 반환하는 버전의 Test가 호출될것입니다. Big 과 Small 의 사이즈가 다르니 exists도 false가 될것입니다.

	Conversion 에서는 ... 이라는 인자 타입보다는 const To& 가 우선된다는 특징을 사용해 원하는 결과를 얻어오는 방식을사용하고 있습니다. 

	지금껏 생각해보지 못한 방식의 프로그래밍이었습니다. 함수에서는 반환타입, 함수식별자, 인자, 구현부 로 이루어져 있고 그 중에서 구현부에서 이런 저런 연산을하고 
	반환 값이 중요한게 보통이었는데 
	오늘 내용에서는 주로 컴파일러가 처리하는 부분이 중요하게 다뤄지고 Conversion에서도 구현부는 별 의미 없고 처음 함수 선언하는 부분에서 반환타입을 가지고 알아서 
	골라진다거나 하는 걸로 원하는 효과를 내고 있습니다. 
	
	bool canConvert1 = Conversion<Player, Knight>::exists;
	bool canConvert2 = Conversion<Knight, Player>::exists;
	bool canConvert3 = Conversion<Knight, Dog>::exists;

	사용 예시입니다. Player 에서 Knight 로 변환이 되는지는 원래 작은 클래스에서 큰 클래스로는 변환이 안되었습니다. 메모리 오염이 일어나기 때문입니다. 
	반대로 Knight에서 Player 로 변환이 되는지 아니면 아예 상관없는 Knight 에서 Dog 로 변환이 되는지를 체크할수 있겠습니다. 	


	// TypeCast 
	다음은 정말 마지막으로 오늘 강의 제목이기도 한 TypeCast 입니다. 
	여기서 하려고 하는 내용은 TypeList 를 템플릿으로 받을 것이고 그 안에 들어있는 데이터 들끼리 변환이 가능한지를 n x n 행렬로 테이블을 만들고 싶습니다. 

	#pragma region TypeCast

	template<int32 v>
	struct Int2Type
	{
		enum { value = v };
	};

	template<typename TL>
	class TypeConversion
	{
	public:
		enum
		{
			length = Length<TL>::value,
		};

		TypeConversion()
		{
			MakeTable(Int2Type<0>(), Int2Type<0>());
		}

		template<int32 i , int32 j>
		static void MakeTable(Int2Type<i>, Int2Type<j>)
		{
			using FromType = typename TypeAt<TL, i>::Result;
			using ToType = typename TypeAt<TL, j>::Result;

			if (Conversion<const FromType, const ToType>::exists)
				s_convert[i][j] = true;
			else
				s_convert[i][j] = false;
			
			MakeTable(Int2Type<i>(), Int2Type<j + 1>());
		}

		template<int32 i>
		static void MakeTable(Int2Type<i>, Int2Type<length>)
		{
			MakeTable(Int2Type<i + 1>(), Int2Type<0>());
		}

		template<int32 j>
		static void MakeTable(Int2Type<length>, Int2Type<j>)
		{

		}

		static inline bool CanConvert(int32 from, int32 to)
		{
			static TypeConversion conversion;

			return s_convert[from][to];
		}

	public:
		static bool s_convert[length][length];
	};

	template<typename TL>
	bool TypeConversion<TL>::s_convert[length][length];

	#pragma endregion 

	먼저 멤버 변수로 static bool 타입의 이중 배열인 s_convert가 있습니다. 각 길이를 length x length 크기로 만들었습니다. 
	그리고 length는 위에서 만들었던 Length를 사용해 템플릿으로 받은 TypeList의 길이입니다. 

	아래와 같이 구현하고 싶은겁니다. 
	하지만 이대로는 구동되지 않습니다. i, j 가 러닝 타임에 값이 결정되는 변수다 보니 그렇습니다.
	TypeConversion()
	{
		for (int i = 0; i < length; i++)
		{
			for (int j = 0; j < length; j++)
			{
				using FromType = typename TypeAt<TL, i>::Result;
				using ToType = typename TypeAt<TL, j>::Result;
				
				if (Conversion<const FromType, const ToType>::exists)
					s_convert[i][j] = true;
				else
					s_convert[i][j] = false;
			}
		}
	}

	i와 j 를 컴파일 타임에 정해지도록 하는 부분이 Int2Type 입니다. 템플릿으로 int32 를 넣으면 그것이 그냥 클래스 처럼 인식되도록 해줍니다. 
	대신 클래스화된 i, j는 추가적인 연산이 되지 않을것입니다. 

	생성자인 TypeConversion() 에서는 MakeTable(Int2Type<0>(), Int2Type<0>()); 을 해주고 있습니다. 이때 말하는 MakeTable이 주요 기능입니다. 
	0, 0 좌표부터 테이블을 만들기 시작한다는 의미이고 

	MakeTable 에서는 인자를 Int2Type<i>, Int2Type<j> 두가지를 받고 있습니다. 이렇게 받은 i, j 라는 int32 인자는 컴파일 타임에 계산이 되어서 
	TypeCast 코드들에 호환이 됩니다. 
	TypeConversion에서 템플릿으로 받은 TypeList 를 TypeAt으로 인덱스에 따른 타입을 FromType, ToType이라고 하겠습니다. 이 두 변수를 이용해서 
	Conversion을 계산해 변환가능하면 s_convert에 true를 변환 불가하면 false를 입력합니다. 

	여기까지 하면 생성자에서 실행된 0, 0 위치의 변환 가능을 체크한 것입니다. 하지만 우리가 하고 싶은것은 TL의 모든 원소들에 대해 변환이 가능한지를 알아보고 싶습니다. 
	그래서 MakeTable 안에서 재귀적으로 다시 자신을 부르는데 
	MakeTable(Int2Type<i>(), Int2Type<j+1>()); 
	이렇게 호출하게 되면 j 축으로 한칸 옮겨서 다시 변환 가능한지를 체크하고 또 한칸옮기고가 반복될 것입니다. Int2Type 으로 타입화 된 i,j 를 for문으로 사용할수 없기 때문에 
	이런 방법을 사용하는 겁니다. 그리고 이 MakeTable 도 static으로 만들어 졌기 때문에 사실 한 좌표마다 하나의 MakeTable 함수가 호출되는것입니다. 

	그렇지만 계속 j 축으로만 이동하는것도 문제가 있습니다. j 좌표가 length 까지 갔다면 이제 다음 줄으로 옮겨서 반복해야합니다. 
	
	template<int32 i>
	static void MakeTable(Int2Type<i>, Int2Type<length>)
	{
		MakeTable(Int2Type<i + 1>(), Int2Type<0>());
	}
	인자로 j 위치에 값이 length값이 되었을때는 이 버전의 MakeTable이 실행되도록 하고  i는 다음줄 j는 0부터 다시 MakeTable 을 재귀적으로 호출해줍니다. 
	이것이 반복되면 결국 [length][length] 까지 모두 Conversion 이 될것이고
	
	template<int32 j>
	static void MakeTable(Int2Type<length>, Int2Type<j>)
	{

	}
	i위치가 length까지 오게되면 이제는 아무것도 하지 않고 함수를 끝내서 재귀를 끊습니다. 

	여기까지 한다음 실제로 작동하는지 체크하려면 

	TypeConversion<TL> test;

	bool isCanConvert = test.s_convert[0][0]; 

	이렇게 테스트를 할 수 있을겁니다. 

	그런데 위 처럼 매번 TypeConvert 객체를 만들고 테스트를 하기보다는 한번에 알수 있도록 함수를 만들었습니다. 
	
	static inline bool CanConvert(int32 from, int32 to)
	{
		static TypeConversion conversion;

		return s_convert[from][to];
	}
	한번만 만들어 지게 static으로 만들었고 이때 생성자에서 MakeTable을 통해 테이블이 채워지고 그 중 알고 싶은 인덱스를 가지고 원하는 결과를 반환합니다. 

	이 CanConvert 를 실행하는 시점은 러닝 타임이라서 프로그램이 실행된 다음 계산이 들어가기는 할것이지만 그 전에 MakeTable 에서 사용할 인자들은 
	컴파일 타임에 미리 정해져 있게 될겁니다. 


	// 편의성 
	이제 지금까지 만들었던 TypeCast 코드들을 사용하기 편하도록 몇가지 추가해주겠습니다. 

	template<typename To, typename From>
	To TypeCast(From* ptr)
	{
		if (ptr == nullptr)
			return nullptr;

		using TL = typename From::TL;

		if (TypeConversion<TL>::CanConvert(ptr->_typeId, IndexOf<TL, remove_pointer_t<To>>::value))
			return static_cast<To>(ptr);
		return nullptr;
	}

	TypeCast 라는 함수는 From이라는 데이터를 To 타입으로 캐스팅하는 함수입니다. From::TL 이나 ptr->_typeId 는 아직 만들지 않아서 정확하게는 나중에 알아볼것이고 
	일단 TypeConversion::CanConvert 를 통해 From 타입이 To 타입으로 변환 가능한지를 체크한 후 가능하다면 캐스팅해서 반환 아니라면 nullptr을 반환할것입니다. 

	template<typename To, typename From>
	bool CanCast(From* ptr)
	{
		if (ptr == nullptr)
			return false;

		using TL = typename From::TL;

		return TypeConversion<TL>::CanConvert(ptr->_typeId, IndexOf<TL, remove_pointer_t<To>>::value);
	}
	CanCast는 변환까지 하지 않고 그냥 가능한지만 체크하는 함수입니다. 

	여기서 또 테스트 하는 코드도 정리를 해볼것입니다. 아까 나왔던 TL 이나 _typeId 등을 추가해줄건데 
	예시로 Player 클래스를 들겠습니다. 

	using TL = TypeList<class Player, class Mage, class Knight, class Archer>;

	class Player
	{
	public:
		Player()
		{
			_typeId = IndexOf<TL, Player>::value;
		}
		virtual ~Player() { }

		using TL = TL;

		int32 _typeId;
	};
	
	이런식으로 TL 과 _typeId를 만들것입니다. 전역으로 타입리스트를 관리하고 각 클래스는 사진의 타입으로 TL에서 몇번째 원소인지를 자신의 아이디로 기억합니다.
	
	그런데 이 뒤로 만드는 모든 클래스들을 하나하나 타이핑하기는 번거롭기 때문에 매크로를 추가해주겠습니다.
	 
	#define DECLARE_TL	using TL = TL; int32 _typeId;
	#define INIT_TL(Type)	_typeId = IndexOf<TL, Type>::value;
	
	class Player
	{
	public:
		Player()
		{
			INIT_TL(Player);
		}
		virtual ~Player() { }

		DECLARE_TL
	};

	이런식으로 DECLARE_TL에서는 각 클래스 내부에서 사용할 using TL 과 _typeId 를 정의 해주고 있고 
	INIT_TL 에서는 자신 타입을 템플릿으로 사용해서 TL 안에 몇번째 인덱스인지를 받아와 _typeId 를 초기화 해주고 있습니다. 


이제 테스트를 해보겠습니다. 
	{
		Player* player = new Player();

		bool canCast = CanCast<Knight*>(player);
		Knight* knight = TypeCast<Knight*>(player);

		delete player;
	}

이런 테스트 코드를 실행해보았는데 Player포인터에서 Knight포인터로 변환하려고 하는것입니다. 작은 타입에서 큰타입으로 변환하는것이다 보니 변환이 되지 않을것이고 
실제 canCast, knight 변수들의 값이 각각 false, nullptr 이었습니다. 

	{
		Player* player = new Knight();

		bool canCast = CanCast<Knight*>(player);
		Knight* knight = TypeCast<Knight*>(player);

		delete player;
	}
다음은 이렇게 player 객체를 만들때 Knight 로 생성을 해보았습니다. 그러면 Knight 객체는 먼저 상속받은 Player의 생성자에서 _typeId가 Player 의 아이디를 받지만 
이후 다시 Knight 생성자를 거치면서 Knight 의 아이디로 덮어 씌워집니다. 
그리고 나서 CanCast 함수와 TypeCast 를 실행하게 되면 player 객체의 아이디와 TL에서 변환하려고 하는 타입은 같은 타입이기 때문에 CanConvert 를 통과하게 될겁니다. 
실제로도 이 코드를 실행하게되면 true와 포인터 주소를 받을 수 있습니다. 


이렇게 해서 컴파일 타임에서 대부분 진행이 되는 코드로 dynamic_cast와 같은 효과를 내는 방법이 있습니다. 
이 방식, 개념을 처음 배우기에는 좀 더 어렵고 생소하겠지만 일단 만들고 나면 더 편하게 사용할 수 있는데 
앞으로는 어떤 객체를 캐스팅할때 일단 CanCast로 캐스팅을 한 후 그 결과 값이 nullptr인지를 체크하는것으로 위험한 캐스팅을 방지할수 있고 나아가 메모리 오염을 
막을 수 있는 겁니다. 

오늘 만든 코드는 생 포인터 타입으로 만들었지만 생성 소멸을 알아서 관리하기 위해서 shared_ptr을 적용할때는 어떻게 해야 할지 고민이 될 수 있습니다. 
해결법은 간단하게 shared_ptr 버전을 하나 더 만들면 되는겁니다. 

template<typename To, typename From>
shared_ptr<To> TypeCast(shared_ptr<From> ptr)
{
	if (ptr == nullptr)
		return nullptr;

	using TL = typename From::TL;

	if (TypeConversion<TL>::CanConvert(ptr->_typeId, IndexOf<TL, remove_pointer_t<To>>::value))
		return static_pointer_cast<To>(ptr);
	return nullptr;
}

template<typename To, typename From>
bool CanCast(shared_ptr<From> ptr)
{
	if (ptr == nullptr)
		return false;

	using TL = typename From::TL;

	return TypeConversion<TL>::CanConvert(ptr->_typeId, IndexOf<TL, remove_pointer_t<To>>::value);
}

이런 식으로 시그니처에서 받는 인자 타입과 반환 타입을 shared_ptr로 만들어 주면 컴파일러가 알아서 적절한 버전을 찾아 컴파일 해주게 될겁니다. 
반환할때 static_pointer_cast 를 사용해서 캐스팅 해야하는점을 주의해야합니다. 

다시 shared_ptr 버전의 TypeCast, CanCast 를 테스트 해보았습니다. 
{
	shared_ptr<Knight> knight = MakeShared<Knight>();

	shared_ptr<Player> player = TypeCast<Player>(knight);
	bool canCast = CanCast<Player>(knight);
}
shared_ptr 을 만들때 이전에 만들었던 커스텀 A_new, A_delete 를 사용하는 MakeShared 함수를 사용했습니다. 
Knight 에서 Player 로 캐스팅은 잘 되었고 shared_ptr 도 잘 동작하는걸 보았습니다. 

아니면 엉뚱하게 
{
	shared_ptr<Player> player = MakeShared<Knight>();

	shared_ptr<Archer> archer = TypeCast<Archer>(player);
	bool canCast = CanCast<Archer>(player);
}
Knight 로 생성해 Player 포인터로 들고 있는 player를 괜히 Archer 타입으로 캐스팅하려고 하면 캐스팅 실패를 하게될겁니다. 


-- 마무리 --
이렇게 해서 아주 오래전에 나온 그 대단한 책 Mordern C++ Design 에서 부터 나오는 내용인 TypeCast 를 알아보았습니다. 
클래스 끼리 캐스팅을 하면서 dynamic_cast를 하면 성능상 느리다는 것을 보완해 컴파일 타임에 다 계산이 끝나는 템플릿 을 활용한 TypeCast를 
알아보았습니다. 

생소하고 어려웠지만 그만큼 보람있는 테크닉이고 기왕 배운김에 이 방법을 사용해도 되고 아니면 그냥 기존의 방법대로 dynamic_cast나 static_cast를 사용해도 
될것입니다. 

일단 템플릿을 잘 이용하면 이런 재밌는 일을 할 수 있다는것을 알고 가면 좋겠습니다. 