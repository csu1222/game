


            Reader Writer Lock


이번시간에서 해볼 내용은 앞으로 배우고 실습할 서버 컨텐츠 및 서버 엔진에서 사용할 락을 직접한번 만들어 보겠습니다. 

/*
그전에 먼저 이전 시간에 배웠던 ThreadManager 부분에 대한 디테일을 조금 더 알아보고 시작하겠습니다. 
어떤 내용이었냐면 앞으로 쓰레드를 사용할 때 쓰레드들을 한번에 관리할 ThreadManager를 만들었고 또 이 매니저 들을 관리할 CoreGlobal
클래스 만들었고 그 안에서 나중에 생성 소멸 순서를 맞춰주려고 했었습니다. 
이 걸 구현할때 extern 으로 전역 변수로 생성해서 사용하고 그랬는데 
전역으로 사용하는게 맘에 안 들 수 있습니다. 따로 엔진을 만들었는데 굳이 다시 전역 변수를 사용해서 컨텐츠 단에서 전역 변수를 선언해서 
사용하는게 지저분 하다고 느낄 수도 있습니다. 

이런 경우를 위해 CoreGlobal.cpp 안에서 클래스의 정의를 전부 다 하고 객체까지 생성해버릴 수 있습니다. 

// CoreGlobal.cpp

#include "pch.h"
#include "CoreGlobal.h"
#include "ThreadManager.h"

ThreadManager* GThreadManager = nullptr;

class CoreGlobal
{
public:
	CoreGlobal()
	{
		GThreadManager = new ThreadManager();
	}

	~CoreGlobal()
	{
		delete GThreadManager;
	}

} GCoreGlobal;

이상태에서 바로 컨텐츠 단인 GameServer.cpp 에서 따로 CoreGlobal객체를 만들어 주지 않아도 GThreadManager 를 그냥 사용할 수 있습니다. 
*/


이어서 오늘 주제로 가겠습니다. 

Reader-Writer Lock 도 락이고 쓰레드와 관련된 클래스이다 보니 ServerCore 프로젝트의 Thread 필터 아래로 Lock 이란 이름의 클래스를 추가해보겠습니다. 

무작정 코드를 만들어보기 전에 Reader-Writer Lock 이 왜 필요한지에 대해 알아보고 시작하겠습니다. 
우선 처음부터 배웠던 표준 mutex 같은경우에 어떤 문제가 있는지 부터 보는게 좋을것 같습니다. mutex가 구리고 안좋고 이렇다는것은 아닙니다.

mutex의 문제점 
첫번째, 재귀적으로 락을 잡을 수 없다 어떤 함수에서 이미 락을 잡은 상태에서 또 다른 함수를 호출했을때 그 안에서 다시 락을 잡을 수 없다는 말이 되고 
사실 이런경우에는 recursive_mutex 라는걸 사용하면 되는데 더 심각한 문제는 
경우에 따라 정말 아주 가끔 상호배타적인 특성이 필요한 경우가 생깁니다. 

어떤 게임에서 일일 퀘스트를 하면 지정된 보상 아이템이 주어지는 기능이 있었고 보상 아이템은 항상 똑같은게 아니라 운영쪽에서 추가로 어떤 보상을 더 주려고 
세팅하면 더해서 보상이 주어지는 시스템이 있다고 치고 이걸 예시로 들어보겠습니다. 

이런 기능을 하는 함수가 있다고 해보겠습니다. 인자로 퀘스트의 아이디를 주면 해당 퀘스트에서 주어질 아이템의 아이디를 list로 받아 반환하는 함수입니다. 
이때 만약 퀘스트에 따라 주어지는 아이템이 처음 설정한 값에서 전혀 변하지 않고 그냥 그대로 반환된다면 사실 멀티쓰레드 환경에서도 딱히 락을 걸지 않아도 됩니다. 
멀티쓰레드 환경에서 락을 걸만큼 위험한건 여러 쓰레드가 동시에 수정을 하려고 할때가 위험한 것이기 때문인데 
그런데 정말 뜸하게 이 반환 아이템 리스트에 변경일 있을 수 있다고 했을 때 이때 에러가 날 확률이 매우 낮은데도 일부러 락을 거는것은 성능상 낭비처럼 느껴집니다. 

이런 경우에 사용할 수 있는게 Reader-Writer Lock 입니다. 
거의 대부분의 경우에서는 Read만 한다고 할때는 그냥 락을 걸지 않은것 처럼 쓰레드들이 메모리를 공유해서 사용한다고 하고 
희박한 확율로 Wirte를 하는 동안에는 이 순간만 상호배타적으로 동작하게끔 해주면 됩니다. 

이런 특성을 사용하는 락을 Reader-Wirte Lock (R-W Lock) 이라고 하는데 항상 이 락을 사용하지는 않는다고 해도 
특정한 상황에 사용하면 쓸데없는 경합을 반복하지 않아도 된다는 장점이 있습니다. 


그래서 이 RWLock 을 만들어볼 건데 물론 이것도 표준으로 사용할 수 있는 클래스가 있지만 직접 만드는 이유는 우리가 사용하고 싶은데로 최적화도 할 수 있을것이고 
정책도 골라줄 수 있을 것이고 뿐만 아니라 나중에 가면 이 락을 추적해서 데드락 상황을 미연에 방지할 수 있는 코드를 넣어줄 수도 있을것입니다. 

프로젝트 마다 지금 처럼 직접 락을 만들어 사용하는 경우도 있고 아니면 표준 클래스를 사용하는 경우도 있을겁니다. 
그 중 연습삼아 한번 만들어 사용해보는겁니다. 


- 코드 

->  Lock
    
    먼저 Lock.h 입니다. 

    이번에도 클래스를 한종류만 만드는것이 아니라 구간을 나눠서 여러 클래스를 만들어줄겁니다. 
	첫번째로 만들어줄 락은 Reader-Wirter Spin Lock 입니다. 
	락에는 고려해야 할 점이 많은데 상호배타적 락으로 할지 아니면 RW 방식으로 할지, 아니면 스핀락으로 할지 아니면 이벤트 방식으로 만들지를 고려해야합니다. 
	일반적으로 MMO에서는 서로 잠시만 데이터를 참조 했다가 놔주는 경우가 많기 때문에 스핀락을 사용하는게 조금더 효율적이라고 볼 수 있습니다. 

	오늘 만들 락을 표현해보겠습니다. 일단은 먼저 이 락은 32비트의 크기로 만들어 질것입니다. 

	[WWWWWWWW][WWWWWWWW] [RRRRRRRR][RRRRRRRR]

	W나 R 을 1비트라고 치고 [] 하나가 1바이트라고 볼 수 있습니다. 그리고 거기에 상위 16비트와 하위 16비트가 나눌 수 있는데 이 두 부분이 각각 의미가 달라집니다. 
	
	W : Write Flag (Exclusive Lock Owner ThreadId 이 락을 현재 획득하고 있는 쓰레드의 아이디)
	R : Read Flag (Shared Lock Count 공유 해서 사용하고 있는 리드 카운트)

	상위 16비트는 Write Flag 라고 해서 이 락을 현재 획득하고 있는 쓰레드의 아이디를 들고 있을겁니다. 
	하위 16비트는 Read Flag 라고 해서 락을 공유해 사용하고 있는 쓰레드들의 카운트를 넣어줄 겁니다. 

	두 플레그를 합쳐서 총 32 비트의 크기로 관리를 해주겠습니다. 

	앞으로 Lock 클래스 안에서 사용될 enum 들이 있습니다. 
	enum : uint32
	{
		ACQUIRE_TIMEOUT_TICK = 10000,		// 최대로 기다려줄 틱
		MAX_SPIN_COUNT = 5000,				// 최대로 회전할 수 
		WRITE_THREAD_MASK = 0xFFFF'0000,	// write flag 를 비트플레그로
		// 관리 할것 이기 때문에 정확하게 상위 16비트를 뽑아오기 위한 마스크
		READ_COUNT_MASK = 0x0000'FFFF,		// 반대로 READ COUNT를 위한 마스크
		EMPTY_FLAG = 0x0000'0000,
		/*
		비트 플레그가 익숙하지 않을 수 있는데 위에서 F로 되어 있는 부분은 
		2진법으로 보면 1로 되어 있고 그 부분을 OR 연산으로 긁어 오기 위한 
		마스크
		*/
	};

	그리고 클래스에서 사용할 멤버 변수들입니다. 
		
	private:
		Atomic<uint32> _lockFlag = EMPTY_FLAG;
		uint16 _writeCount = 0;
	
	사용할 함수들은 이렇습니다. 
	public:
	void WriteLock();
	void WriteUnlock();
	void ReadLock();
	void ReadUnlock();

	write 할때 락을 잠그고 풀어야 하고 read 할때 도 대칭적으로 해야할것입니다. 

	먼저 WirteLock 코드입니다. 
	이 함수에서 하고 싶은 일은 아무도 이 락을 소유 및 공유를 하고 있지 않을때 경합해서 소유권을 얻을것입니다. 
	쓰기를 하고 있을때는 상호 배타적으로 아무 쓰레드도 접근하지 못하게 하고 있을것이기 때문입니다. 

	그리고 아무도 소유 및 공유를 하고 있지 않는다는것은 _lockFlag 가 EMPTY_FLAG 인 상태입니다. 

	이것을 의사코드로 표현하자면
	1. 만약 _lockFlag 가 EMPTY_FLAG 라면 
	2. 현재 쓰레드의 LThreadId _lockFlag의 상위 16 비트에 저장한다 

	이렇습니다. 여기에 추가적인 작업이 더 있겟지만 핵심은 이렇습니다. 하지만 이걸 그냥 조건문으로 작성하면 멀티쓰레드 환경에서는 중간에 다른 쓰레드의 
	간섭이 있을 수 있기 때문에 CAS 로 이 작업을 해야합니다. 
		
	void Lock::WriteLock()
	{
		// 동일한 쓰레드가 소유하고 있다면 무조건 성공
		const uint32 lockThreadId = (_lockFlag.load() & WRITE_THREAD_MASK) >> 16;
		if (LThreadId == lockThreadId)
		{
			_writeCount++;
			return;
		}

		// 너무 오래 시도하고 있다면 
		const int64 beginTick = ::GetTickCount64();

		// 아무도 소유 및 공유 하고 있지 않을 때 , 경합해서 소유권을 얻는다. 
		const uint32 desired = ((LThreadId << 16) & WRITE_THREAD_MASK);
		while (true)
		{
			for (uint32 spinCount = 0; spinCount < MAX_SPIN_COUNT; spinCount++)
			{
				uint32 expected = EMPTY_FLAG;
				if (_lockFlag.compare_exchange_strong(OUT expected, desired))
				{
					_writeCount++;
					return;
				}
			}

			if (::GetTickCount64() - beginTick >= ACQUIRE_TIMEOUT_TICK)
				CRASH("LOCK_TIMEOUT");

			this_thread::yield();
		}
	}

	가장 먼저 하고 있는 일은 _lockFlag의 상위 16비트에 있는 아이디와 현재 LThreadId가 같은지를 체크해서 같다면 _writeCount++ 만하고 바로 리턴을 하고 있습니다.
	무슨 의미냐면 두 아이디가 같다는것은 현재 소유권을 가지고 있는 쓰레드안에서 다시 WriteLock 을 재귀적으로 호출하고 있다는 것입니다. 
	재귀적인 호출은 허용해줄것이기 때문에 카운트만 세고 허용하고 있는것입니다. 

	그리고 나서 beginTick 이라고 해서 경합을 시작할때의 틱 카운트를 세고 경합이 동 5000번(MAX_SPIN_COUNT 만큼) 시도 할 때 마다 틱이 얼마나 걸렸는지를 체크하는데
	이 틱이 ACQUIRE_TIMEOUT_TICK(10000) 이상이면 크래시를 내버립니다. 아니라면 yield로 잠깐 쉬고 다시 시도하게 될겁니다. 

	주요 내용인 경합 부분을 보면 먼저 desired 에는 지금 쓰레드의 LThreadId 를 좌로 16비트 이동을 해주고 WRITE_THREAD_MASK 와 & 연산으로 상위 16비트안으로 
	쓰레드 아이디를 만들었습니다. 
	무한 루프를 돌면서 경합을 할건데 expected 예상 값, 즉 EMPTY_FLAG를 만들고 _lockFlag를 CAS 로 경합을 시작합니다. 
	_lockFlag 가 EMPTY_FLAG 와 같다면 상위 16비트의 값을 LThreadId 로 바꾸고 _writeCount++ 을 한다음 리턴을 합니다. 
	같지 않다면 누군가 공유를 하고 있거나 누군가 소유해서 write를 하고 있다는 뜻이 되고 다시 for 루프를 돌기 시작하는데 5000번씩을 한 세트로 돕니다. 

	이제 WriteUnlock 입니다. 
	WriteUnlock 에서 주의할 점이 있습니다. 우리가 사용할 정책인데 
	이 락에서는 누군가 Write락을 한 상태에서 연속해서 Write 락을 잡을 수 있습니다. 그리고 Write 락을 잡은 상태에서 Read 락도 잡을 수 있습니다.
	하지만 Read 락을 잡은 상태에서 Write 락을 잡는것은 허용하지 않을것입니다. 
	Read락을 잡았다는것은 동시에 여러 쓰레드도 Read 락을 잡고 있을 수 있다는것인데 거기서 바로 Write락을 잡는다는것은 이상한 상태입니다. 
	애초에 Write를 하려면 처음부터 잡는게 맞으니까 그렇습니다. 

	그래서 WriteUnlock을 할 때 예외 적으로 체크해줘야하는것은 Read 락이 잡혀있는 상태에서는 WriteUnlock은 불가능 하다는것입니다. 
		
	void Lock::WriteUnlock()
	{
		// ReadLock 을 다 풀기 전에는 WriteUnlock은 불가능 
		if ((_lockFlag.load() & READ_COUNT_MASK) != 0)
			CRASH("INVALID_UNLOCK_ORDER");

		const int32 lockCount = --_writeCount;
		if (lockCount == 0)
			_lockFlag.store(EMPTY_FLAG);
	}

	_lockFlag 와 READ_COUNT_MASK 를 & 연산했을때 0이 아니라는것은 어디선가 Read 락을 잡고 있다는 뜻이고 그러면 크래시를 내줍니다. 

	Read 락을 아무도 잡고 있지 않다면 Write 락을 풀어 줄것인데 만약 WriteLock 을 재귀적으로 불러서 _writeCount 가 1 이상이라면 그냥 
	--_writeCount 를 해주고 최상위 까지 올라와서 _writeCount 가 0이 되었다면 락을 푼다는 의미에서 _lockFlag를 EMPTY_FLAG로 수정합니다. 


	다음은 ReadLock 함수입니다. 
	Read 락은 재귀적으로 락을 잡을때 Write 락 안에서는 잡을 수 있다는 정책이었습니다. 
		
	void Lock::ReadLock()
	{
		// 동일한 쓰레드가 소유하고 있다면 무조건 성공
		const uint32 lockThreadId = (_lockFlag.load() & WRITE_THREAD_MASK) >> 16;
		if (LThreadId == lockThreadId)
		{
			_lockFlag.fetch_add(1);
			return;
		}

		// 너무 오래 시도하고 있다면 
		const int64 beginTick = ::GetTickCount64();

		// 아무도 소유하고 있지 않을 때 경합해서 공유 카운트를 올린다.
		while (true)
		{
			for (uint32 spinCount = 0; spinCount < MAX_SPIN_COUNT; spinCount++)
			{
				uint32 expected = (_lockFlag.load() & READ_COUNT_MASK);
				if (_lockFlag.compare_exchange_strong(OUT expected, expected + 1))
					return;
			}

			if (::GetTickCount64() - beginTick >= ACQUIRE_TIMEOUT_TICK)
				CRASH("LOCK_TIMEOUT");

			this_thread::yield();
		}
	}

	먼저 동일한 쓰레드가 소유하고 있는지를 체크하는 코드는 WriteLock 에서도 다뤘습니다. 같은 쓰레드에서 호출한 락이라면 상호 배타적이라는것이 
	보장된 상태이니까 싱글쓰레드처럼 코드를 작성해도 됩니다. 
	_lockFlag의 fetch_add(1) 은 하위 16비트에 1을 더하는것 즉 Read Count를 1 늘리는것입니다.

	너무 오래시도하고 있을때의 코드도 WriteLock과 같습니다. 

	재귀적으로 락을 잡은게 아니고 아무도 소유하고 있지 않을 때 Read락을 잡았다면 예상값 expected 가 _lockFlag 의 하위 16비트 만 가져옵니다. 
	Read 공유 카운트는 상관없이 상위 16비트 가 비어 있을것을 예상하고 있습니다. 
	_lockFlag 와 expected 가 같다 즉 공유 카운트는 상관없이 소유 쓰레드가 없다면 expected + 1 값을 _lockFlag에 담습니다. 공유 카운트를 1 늘린거죠 
	카운트를 늘렸으면 Read 락을 잡은것으로 간주 하고 리턴합니다. 

	다음 ReadUnlock 은 간단합니다. 
		
	void Lock::ReadUnlock()
	{
		if ((_lockFlag.fetch_sub(1) & READ_COUNT_MASK) == 0)
			CRASH("MULTIPLE_UNLOCK");
	}

	_lockFlag 의 공유 카운트를 1 줄여주는 것인데 만약 Read Count 가 sub 하기 전에 0 이었다면 Read 락을 잡지도 않고 락을 풀고있다는 상황이므로 
	크래시를 내고 아니라면 그냥 카운트를 1 줄여줄겁니다. 


	이렇게 락을 잡고 푸는 부분은 다 만들었습니다. 중요한 것은 Write 락을 잡은 쓰레드 안에서 재귀적으로 다시 Write 락을 잡거나 Read 락을 잡는것은 가능하지만
	Read 락을 먼저 잡은 쓰레드에서 재귀적으로 Write 락을 잡는것은 막고 있다는 것입니다. 

	여기에 더해서 락을 잡고 푸는것을 매번 명시적으로 손수 해야하는것은 귀찮고 또 위험한 일입니다. 
	그래서 이 락을 알아서 관리해 줄 락 가드를 만들겠습니다. 

	/*---------------------------------------
			Lock Guard
	-----------------------------------------*/

	class ReadLockGuard
	{
	public:
		ReadLockGuard(Lock& lock) : _lock(lock) { _lock.ReadLock(); }
		~ReadLockGuard() { _lock.ReadUnlock(); }
	private:
		Lock& _lock;
	};

	class WriteLockGuard
	{
	public:
		WriteLockGuard(Lock& lock) : _lock(lock) { _lock.WriteLock(); }
		~WriteLockGuard() { _lock.WriteUnlock(); }
	private:
		Lock& _lock;
	};

	Read 락과 Write락의 락가드를 따로 만들었는데 각각 객체를 생성할때 락을 인자로 주면 락을 잡으면서 생성되고 락가드가 소멸될때 알아서 
	락을 풀면서 소멸할것입니다. 

	그리고 이 락가드들을 더 편하게 사용하기 위해서 CoreMacro.h 에서 매크로를 추가해보겠습니다. 
	-> 	CoreMacro
		/*===================
				Lock
		====================*/

		#define USE_MANY_LOCKS(count)	Lock _locks[count];
		#define USE_LOCK				USE_MANY_LOCKS(1)
		#define	READ_LOCK_IDX(idx)		ReadLockGuard readLockGuard_##idx(_locks[idx]);
		#define READ_LOCK				READ_LOCK_IDX(0)
		#define	WRITE_LOCK_IDX(idx)		WriteLockGuard writeLockGuard_##idx(_locks[idx]);
		#define WRITE_LOCK				WRITE_LOCK_IDX(0)

		매크로들의 의미를 알아보겠습니다. 
		USE_MANY_LOCKS 은 Lock 객체를 인자만큼의 갯수의 배열로 만들고 있습니다. 락을 하나만 만들여면 USE_LOCK 으로 하나만 만드는것입니다. 
		만든 락들은 _locks 라는 이름으로 관리되고 인덱스로 접근해 원하는 락을 잡는 버전이 Read, Write 둘다 있습니다. 
		특이한점은 락가드 객체의 이름뒤에 ##idx 라고 되어 있는데 이부분은 컴파일러에서 인자로 받은 값으로 치환을 해줍니다. 즉 락가드에 자동으로 번호를 붙여줍니다.
		0번 인덱스의 락을 잡는 버전도 있습니다. 

	
이제 우리가 만든 RW 스핀락을 테스트 해볼 시간입니다. 

테스트 코드는 이렇습니다. 

// GameServer.cpp

class TestLock
{
	USE_LOCK;
public:
	int32 TestRead()
	{
		READ_LOCK;

		if (_queue.empty())
			return -1;

		return _queue.front();
	}

	void TestPush()
	{
		WRITE_LOCK;

		_queue.push(rand() % 100);
	}

	void TestPop()
	{
		WRITE_LOCK;

		if (_queue.empty() == false)
			_queue.pop();
	}

private:
	queue<int32> _queue;
};

TestLock testLock;


void ThreadWrite()
{
	while (true)
	{
		testLock.TestPush();
		this_thread::sleep_for(1s);
		testLock.TestPop();
	}
}

void ThreadRead()
{
	while (true)
	{
		int32 value = testLock.TestRead();
		cout << value << endl;
		this_thread::sleep_for(1s);
	}
}

int main()
{
	for (int32 i = 0; i < 2; i++)
	{
		GThreadManager->Launch(ThreadWrite);
	}
	for (int32 i = 0; i < 5; i++)
	{
		GThreadManager->Launch(ThreadRead);
	}

	GThreadManager->Join();
}

락이 클래스에 기생해서 작동하도록 만들었습니다. 

Write 쓰레드는 2개 Read 쓰레드는 5개 만들어서 대부분 Read를 하는 중에 가끔 Write를 하는 상황을 가정했습니다.

대부분 Read 를 해서 거의 99퍼센트 확률로 Read 만 할 경우에는 서로 경합을 하지 않고 Read Count 만 오르락 내리락 하면서 동작을 할것이기 
때문에 효율적으로 동작하고 
정말 낮은 횟수로 Write 를 할 경우에만 상호배타적으로 다른 쓰레드들을 막아버리고 자기가 수정할것을 하고 나오는 코드가 되겠습니다. 

여기서 이것 저것 테스트 해볼 수 있는데 예를 들어 TestLock::TestPush 에서 WRITE_LOCK 매크로를 실행한 상태에서 TestRead를 실행해볼 수 있습니다. 
아까 말했듯이 Write 안에서 Read락을 잡는건 가능하지만 반대로 Read 락 안에서 Write를 잡는건 불가능 하다고 했습니다. 
어떤식으로 크래시가 나냐면 Lock::WriteLock 안에서 반복을 돌면서 CAS를 하는데 _lockFlag와 EMPTY_FLAG 가 같아야 리턴에 들어갈 수 있는데 
ReadLock을 먼저 걸면 _lockFlag의 하위 16 비트의 값이 올라가기 때문에 쭉 루프를 돌다가 LOCK_TIMEOUT 크래시가 납니다. 

아니면 어느 WRITE_LOCK에서 너무 오래 락을 잡고 있어서 타임 아웃이 되는 경우도 크래시가 나게 될겁니다. 
예를들어 TestPop 에서 중간에 텅빈 무한 루프를 만들어 두면 타임아웃이 됩니다. 

그래서 서버에서 크래시가 나는 경우들 중에 nullptr을 참조하는 문제와 더불어 락에서 타임아웃에 의한 크래시가 상위권에 있다고 합니다. 
그럴경우 일부러라도 크래시를 내서 해결을 해야지 그냥 마냥기다리면서 운에 맞겨 해결되기를 바라는것은 좋은 방법은 아닐겁니다. 

이번 시간에는 배울점이 많았습니다. 학습했었던 CAS나 락의 구현도 연습해볼 수 있었고 Reader-Writer Lock 형태의 락을 구현하기 위해 
32 비트중 상위 16비트, 하위 16비트를 나눠서 쓰레드의 아이디와 Read Count같이 별 상관 없어 보이던 데이터로 구현하는 방법등은 배울만 하였습니다. 