


        패킷자동화 (1)


*
강의 전 유의 사항 강의 자료로 프로젝트를 배포하고 있는데 이것을 압축해제후 빌드를 할때 프로젝트의 경로에 한국어가 들어가면 
에러가 뜰 수 있으니 유의 합니다.
*

이전시간에는 드디어 구글에서 배포한 Protobuf 를 우리 프로젝트에 적용하고 아주 간단한 사용 실습까지 해봤습니다. 
그런데 아직까지는 사용하는데 약간 귀찮고 반복적인 부분이 남아 있습니다. 

새 패킷 타입을 만들때 proto 파일을 만들어 직접 protoc의 배치파일(bat 확장자)를 실행해야하는 것, 그렇게 만든 pb.proto 파일들을 프로젝트로 직접 
추가해줘야하는 점, 패킷을 만들고 데이터를 넣을때 손수 하나하나 함수를 찾아서 넣어야 하는 부분, 패킷을 또 버퍼에 넣을때도 각 타입에 맞는 래핑함수를 직접만들고 
분류하는 switch case 문도 직접 수정해야 하는것 등이 조금 거슬리는 부분입니다. 

이런 작업을 그냥 두고 사용하는 경우도 있습니다. 그럴경우 패킷의 타입이 100개가 넘어가면서 관리하기 복잡해지고 실수 했을때 수정도 어려워집니다. 

자동화가 그냥 편리함 뿐만이 아니라 잘 설계하면 직접 타이핑하면서 생기는 오탈자에 의한 자잘한 버그들을 예방할 수 있습니다. 


이런 코드 리팩토링을 할때는 문제 인식을 잘 하는것이 중요합니다. 
어떤점이 불편하고 위험한지를 정확히 인식해야 리팩토링을 해야겠다는 생각이 들고 그 방법에 대해 기준이 설 것입니다. 
그런 의미에서 한번 패킷자동화를 하기전에 직접 수동으로 한번 그 과정을 격어보는것은 좋은 방법입니다. 

***
먼저 솔루션 디렉토리에서 구조정리를 해보겠습니다. 

이전 시간에 proto 파일을 컴파일링하는 protoc.exe 의 위치도 그냥 다운받은 폴더 그대로 우리 솔루션 아래에 가져다 놨습니다. 이것을 이제 구조에 맞춰 어디서 관리할지 
생각해보겠습니다. 

(SolutionDir)\Common\

솔루션 디렉토리 아래에 Common이라는 폴더를 새로 만들어서 이후로 추가될수 있는 공용으로 사용할만한 기능, 라이브러리들을 관리해주겠습니다. 
protoc 어쩌구 되어있던 폴더도 Common아래로 이동시키고 폴더이름도 Protobuf 라고 변경해주었습니다. 

Protobuf에서 지난시간에 추가했던 파일들도 정리해줘야 합니다. 

-- proto 파일들 

syntax = "proto3";
package Protocol;

message BuffData
{
    uint64 buffId = 1;
    float remainTime = 2;
    repeated uint64 victims = 3;
}

message S_TEST
{
    uint64 id = 1;
    uint32 hp = 2;
    uint32 attack = 3;
    repeated BuffData buffs =4;
}

이 것이 이전 시간에 만든 proto 파일입니다. 여기서 보면 S_TEST는 패킷의 설계를 하는 구조체 같은것이었지만 
BuffData 일반적인 class처럼 활용을 하고 있습니다. 
나중에 가면 enum값같은것도 관리하게될건데 이런 다양한 용도의 코드들을 한 파일에 몰아서 관리하는것은 좋지 않습니다. 

이후 proto 파일의 내용이 거대해지면 proto내용중 아주 일부분만 수정하더라도 같은 파일에 묶여있는 모든 코드들을 전부 다시 빌드해야 합니다. 
그래서 컨텐츠 별로 구분하는것도 괜찮습니다. 물론 아주 나중의 일이니 지금은 신경쓰지 않고 
Struct, Enum, Protocol 이렇게 세가지 용도로 나눠 보겠습니다. 

Struct, Enum, Protocol 이 세가지 proto 파일들을 이제 프로젝트에서 관리해줄것입니다. 서버, 클라이언트 프로젝트 아래 만들어 뒀던 Protocol 필터아래로 추가해줍니다.

Enum.ptoro를 예시들어보겠습니다. 

syntax = "proto3";
package Protocol;

enum PlayerType
{
	PLAYER_TYPE_NONE = 0;
	PLAYER_TYPE_KNIGHT = 1;
	PLAYER_TYPE_MAGE = 2;
	PLAYER_TYPE_ARCHER = 3;
}

이런식으로 플레이어의 직업을 관리할 수 있을 겁니다. 이때 NONE 타입을 0번으로 둔 이유는 protobuf에서 enum은 꼭 0부터 시작해야하는 규칙이 있다고 합니다. 

그리고 Struct.proto 에서는 뭘하는가 하면 

syntax = "proto3";
package Protocol;

import "Enum.proto"

message BuffData
{
    uint64 buffId = 1;
    float remainTime = 2;
    repeated uint64 victims = 3;
}
이렇게 전송하는 용도의 패킷이 아닌 일반적인 구조체 용도로 활용한 코드들을 이곳에 배치 시켜주겠습니다. 

패킷과 struct를 분리해 관리하다 보니 proto 파일들 사이에서도 서로 참조해 사용할 수 있습니다.
위에서는 Struct.proto에서 Enum.proto의 내용을 가져다 쓸 수 있으니 참조 하고 있습니다. 

마직막으로 실질적으로 패킷을 관리하는 Protoco.proto를 보겠습니다. 

syntax = "proto3";
package Protocol;

import "Enum.proto";
import "Struct.proto";

message S_TEST
{
    uint64 id = 1;
    uint32 hp = 2;
    uint32 attack = 3;
    repeated BuffData buffs =4;
}

이런 식으로 관리해보겠습니다. 


-- GenPacket.bat 배치 파일 

배치 파일도 편하게 관리할 수 있도록 VS에 추가합니다. 서버 클라양쪽의 Protocol 필터 아래로 가져다 놨습니다.      

protoc.exe -I=./ --cpp_out=./ ./Protocol.proto
protoc.exe -I=./ --cpp_out=./ ./Struct.proto
protoc.exe -I=./ --cpp_out=./ ./Enum.proto


IF ERRORLEVEL 1 PAUSE

이런식으로 이전에는 Protocol.proto만 컴파일 했었는데 기능에 따라 파일을 나눴으니 각각 컴파일 해줘야 합니다. 

그리고 이렇게 컴파일 한 후에는 pb.cc, pb.h 가 붙은 파일들이 각각 생길것입니다. 
이렇게 컴파일한 후의 파일들을 지금까지는 직접 경로로 가서 서버,클라 각각의 경로로 복사 붙여넣기 했었습니다. 

하지만 이작업을 패킷설계를 수정할때 마다 해줄 수는 없을겁니다.

그렇기 때문에 자동화해서 배치파일이 실행될때 마다 컴파일된 파일들을 다른 경로로 복사해주는 코드를 추가할겁니다. 배치파일의 문법은 필요할때 마다 한번씩 검색해 
사용해주면 충분합니다. 


XCOPY /Y Enum.pb.h "../../../GameServer"
XCOPY /Y Enum.pb.cc "../../../GameServer"
XCOPY /Y Struct.pb.h "../../../GameServer"
XCOPY /Y Struct.pb.cc "../../../GameServer"
XCOPY /Y Protocol.pb.h "../../../GameServer"
XCOPY /Y Protocol.pb.cc "../../../GameServer"


XCOPY /Y Enum.pb.h "../../../DummyClient"
XCOPY /Y Enum.pb.cc "../../../DummyClient"
XCOPY /Y Struct.pb.h "../../../DummyClient"
XCOPY /Y Struct.pb.cc "../../../DummyClient"
XCOPY /Y Protocol.pb.h "../../../DummyClient"
XCOPY /Y Protocol.pb.cc "../../../DummyClient"

이 코드를 붙여넣으면 원하던 알아서 복사하기가 실행됩니다. XCOPY는 파일을 복사하는데 만약 같은 이름의 파일이 있다면 덮어쓰기를 하겠다는 이야기입니다. 

나중에 가면 프로젝트가 모두 C++로 통일해서 진행한다는 보장이 없다 보니 상대방이 관리하는 프로젝트에 이 코드를 넘겨주는것이 속 편합니다. 

또한가지 유의할점은 위의 배치 파일 코드가 전부 상대 경로를 사용하다 보니, 다른 경로에서 원격으로 배치 파일을 실행하면 제대로 인지 하지 못할 수 있습니다. 
이것도 의도한대로 GenPacket.bat가 위치한 경로 기준으로 동작하는 코드를 추가하겠습니다. 

pushd %~dp0

이 코드를 파일 맨 위에 추가하면 됩니다. 

이제 GenPacket.bat 파일이 직접 실행 시키든 원격으로 실행시키든 DummyClient, GameServer 폴더로 컴파일된 파일들이 복사될겁니다. 

-- pb.cc 파일들 설정 

앞으로는 잘 복사가 되긴 할건데 이 상태로 빌드하면 에러가 날겁니다. 
pb.cc 파일들을 복사한뒤에는 속성에서 pch.h를 사용안한다고 해줘야 해결이 되었었습니다. 

여기서 또 아쉬운 점을 발견했습니다. 개발을 하다보니 Protocol, Struct, Enum proto 파일들을 수정할 일이 생길겁니다. 
그럴떄마다 GenPacket배치파일을 알아서 실행해줬으면 합니다. 

이럴때 할수 있는방법이 있는데 VS에서 빌드를 할때 이벤트를 걸어줄 수 있다고 합니다. 
GameServer 프로젝트의 속성을 보면 왼쪽 구성 속성중에 사용자 지정 빌드 이벤트 라는 항목이 있습니다. 

빌드 전, 링크 전, 빌드 후 시점에 따라 이벤트를 정해줄수 있습니다. 

지금은 빌드 전 시점에서 배치 파일을 실행하는 식으로 해보겠습니다. 
빌드 전 항목중 명령줄을 편집하기 해서 

CALL $(SolutionDir)\Common\Protobuf\bin\GenPacket.bat

이 명령어를 입력해줍니다.
이 작업을 DummyClient쪽에서도 똑같이 해줍니다. 
프로젝트들을 빌드해보면 로그에서 pb.cc, pb.h 파일들을 복사했다는 로그가 뜹니다. 

하지만 이 작업도 아쉬운점이 있습니다. 실질적으로 소스코드에서 아무런 변경이 없다고 하면 빌드 이벤트가 실행되지 않습니다. 
소스코드는 그대로인 상태로 proto 코드만 수정해서는 proto 파일들이 프로젝트에서 추적하고 있지 않기 때문에 새로 빌드하지 않습니다.

구글링을 해보면 재미있는 해결법이 나옵니다. 
솔루션 폴더를 열어두고 VS를 종료합니다. 

그리고 GameServer를 먼저 해결하자면 GameServer경로에서 GameServer.vcxproj 라는 파일이 있습니다. 이 파일을 우클릭해서 아무 텍스트 에디터로 실행합니다.  
아랫쪽을 보면 ItemGroup 태그중 proto 파일들이 묶여있는 그룹이 있습니다.  
파일탐색기에서 직접 드래그 드롭해서 추가했던 것들입니다. 

이 그룹을 바로 밑에 또 한번 복사해서 두 그룹으로 만듭니다. 
  <ItemGroup>
    <UpToDateCheckInput Include="..\Common\Protobuf\bin\Enum.proto" />
    <UpToDateCheckInput Include="..\Common\Protobuf\bin\Protocol.proto" />
    <UpToDateCheckInput Include="..\Common\Protobuf\bin\Struct.proto" />
  </ItemGroup>

이렇게 앞에 태그가 None이었던걸 UpToDateCheckInput로 바꿔 줍니다. 이러면 proto 파일들도 수정이 되면 인식이 되서 다시 이벤트를 실행해주게 될겁니다. 

마찬가지로 DummyClient에서도 똑같은 작업을 해줍니다. 

솔루션을 다시 실행해서 proto 파일을 아무렇게나 수정해서 다시 빌드해보면 소스코드처럼 그때그때 이벤트호출이 되는것을 볼수 있습니다. 

이렇게 해서 배치파일을 매번 직접 실행해야하는것과 proto 파일들만 수정해서는 이벤트가 호출되지 않는 문제를 해결했습니다. 


-- 패킷 타입 관리 

다음으로 수정할만한 것은 PacketHandler 들을 보면 초반에 S_TEST라는 패킷을 enum으로 관리하면서 패킷의 아이디로 사용하고 있습니다. 
이부분도 protobuf로 관리하면 좋을것 같습니다. 

Protocol.proto 에서 S_TEST를 관리하고 있는데 이 안에서 static uint16 PacketId = 1; 이런식으로 S_TEST의 아이디는 1이라고 외부에서도 알 수 있게 하고 싶지만 
이 static문법은 proro3 문법에는 없습니다. 

다른 방법으로는 S_TEST에 enum 멤버를 추가하고 그 안에서 PacketId를 관리하는것입니다. 

-- Protocol.proto

message S_TEST
{
    uint64 id = 1;
    uint32 hp = 2;
    uint32 attack = 3;
    repeated BuffData buffs =4;

    enum PacketId { NONE = 0; PACKET_ID = 1; }
}

proto문법에서 enum은 0부터 시작해야하니 NONE을 주었습니다. 

이렇게 관리하면 추가로 message가 하나 더 추가 된다 예를들얼 로그인 패킷이 추가된다면 

message S_LOGIN
{
    enum PacketId { NONE = 0; PACKET_ID = 2; }
}

각 message가 들고 있는 PacketId 라는 enum은 각자의 범위 안에서 유효한 이름이기 때문에 중복되도 괜찮고 하지만 PACKET_ID는 각자 1, 2번을 가지고 있을겁니다. 

그러면 이렇게 proto에서 enum으로 아이디를 관리한다면 프로젝트에서는 어떤 식으로 다루면 될지 보겠습니다. 

-- ServerPacketHandler 
이전에 패킷을 만들던 코드인 MakeSendBuffer 함수에서 버퍼에 데이터를 넣을때 패킷인 pkt와 이 패킷의 아이디인 S_TEST = 1; 을 같이 넣었습니다. 

이때 S_TEST부분을 

Protocol::S_TEST::PACKET_ID; 를 사용해서 꺼내 사용할 수 있게 되는것입니다. 
또 이것을 template로 사용할 수도 있기는 합니다. 


-- message에 enum으로 id를 관리할때의 문제점 
그런데 이렇게 하면 문제가 되는 부분은 message 마다 enum이 하나씩 붙어있는게 지저분 하기도 하고 
또 만약 id값이 곂치게된다면 어떻게 될까요 하드코딩으로 각각 PACKET_ID 값을 넣어주고 있다보니 곂치지는 않았는지 체크를 하지 못합니다. 
그러니까 지금처럼 enum으로 ID를 관리하는것은 억지로 PACKET_ID라는 값을 message에 넣어주고 있는겁니다. 

또 한가지 이렇게 고정된 값을 사용하면 안되는 이유가 해킹입니다. 자주 당하는 해킹이 패킷을 조작하는것입니다. 중간에 패킷의 값을 아무거나 수정해서 던져보는것입니다. 
고수 해커들은 패킷자체를 분석해서 패킷의 의미를 알고 조작할수도 있지만 보통은 이것저것 건드려 보면서 테스트를 하는것입니다. 

그래서 주기적으로 패킷값을 교체해 사용하는것이 좋습니다. 

그런 의미에서 패킷 값을 하드코딩해서 관리하는것은 아쉽습니다. 

결론은 자동화 툴이 필요합니다. 그리고 이 자동화 작업은 다음 시간에서 배워볼 일이고 이번시간은 다음시간에 무엇을 자동화 해야할지를 알아보는 시간입니다. 

-- ServerPacketHandler
이제 BufferReader, BufferWriter 헤더들은 필요가 없습니다. Include들을 지워줍니다. 

Protocol 파일에서 message들을 ServerPacketHandler쪽으로 가져오면 이 안에서 패킷 아이디를 자동적을 추가하는 형식이 될겁니다. 


// TODO : 자동화 
enum : uint16
{
	PKT_S_TEST = 1,
	PKT_S_LOGIN = 2,
};

class ServerPacketHandler
{
public:
	static void HandlePacket(BYTE* buffer, int32 len);

	// TODO : 자동화
	static SendBufferRef MakeSendBuffer(Protocol::S_TEST& pkt) { return MakeSendBuffer(pkt, PKT_S_TEST); }

private:
	template<typename T>
	static SendBufferRef MakeSendBuffer(T& pkt, uint16 pktId)
	{
		const uint16 dataSize = pkt.ByteSizeLong();
		const uint16 packetSize = dataSize + sizeof(PacketHeader);

		SendBufferRef sendBuffer = GSendBufferManager->Open(packetSize);

		PacketHeader* header = reinterpret_cast<PacketHeader*>(sendBuffer->Buffer());
		header->size = packetSize;
		header->id = pktId;

		ASSERT_CRASH(pkt.SerializeToArray(&header[1], dataSize));

		sendBuffer->Close(packetSize);
		return sendBuffer;
	}
};


이제는 MakeSendBuffer 함수를 private static으로 관리하도록 해주겠습니다. 
패킷종류가 늘수록 public 쪽에 있는 MakeSendBuffer 함수들이 쭉 늘어날겁니다. 
버퍼를 쓰는 쪽은 이렇고 

읽는쪽도 어떻게 수정해야 하나 생각해보겠습니다. 
이전까지는 HandlePacket 이라는 함수로 받은 패킷의 id를 switch case 문으로 확인하고 있었습니다. 이부분을 Map으로 key로 찾을 수 있도록 할 수도 있고 
아니면 그냥 배열을 크게 만들어 임의 접근으로 빠르게 찾을 수 있도록 해줄 수도 있을겁니다. 
아무튼 현재 HandlePacket으로 만들지는 않을것입니다. 

ServerPacketHandler.h 파일중 전역위치에 이런 코드를 추가합니다. 

using PacketHandlerFunc = std::function<bool(PacketSessionRef&, BYTE*, int32)>;
extern PacketHandlerFunc GPacketHandler[UINT16_MAX];

PacketHandlerFunc 라는 이름으로 패킷을 다루는 함수를 정의 하고 이 타입을 UINT16_MAX라는 크기의 전역 배열로 만들었습니다. 

ServerPacketHandler클래스의 private 영역쪽에 새로운 함수를추가합니다. 

	template<typename PacketType, typename ProcessFunc>
	static bool HandlePacket(ProcessFunc func, PacketSessionRef& session, BYTE* buffer, int32 len)
	{
		PacketType pkt;
		if (pkt.ParseFromArray(buffer + sizeof(PacketHeader), len - sizeof(PacketHeader)) == false)
			return false;

		return func(session, pkt);
	}

이런 함수가 추가 될것입니다. 템플릿으로 Protocol.proto 에서 어떤 타입인지를 PacketType으로 받고, 파싱한 패킷을 진행시킬 함수 ProcessFunc를 받습니다. 
ParseFromArray를 호출해준 다음 실패하면 false 반환 성공하면 func를 호출합니다. 

위에서 PacketSessionRef를 참조값으로 받아주고 있는이유는 그냥 PacketSessionRef를 받으면 참조카운트가 하나 늘었다 줄었다 하게 되는데 그 비용을 아끼기 위해서 
참조값으로 받습니다. 

HandlePacket은 기존의 코드 대신 어떻게 동작할것이냐면 인자를 하나 더 추가해 받아줄것입니다. 

	static void HandlePacket(PacketSessionRef& session, BYTE* buffer, int32 len);

왜 인자가 추가 되었냐면 지금까지 실습 코드에서야 버퍼를 그냥 BYTE* 와 Len 을 받아서 처리했지만 앞으로는 어떤 클라이언트에서 전송했는가가 중요해집니다. 
발신자를 알아야 다시 답을 되돌려 줄 수도 있을것입니다.  

	static bool HandlePacket(PacketSessionRef& session, BYTE* buffer, int32 len)
	{
		PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);
		// 헤더의 아이디를 인덱스로 바로 Handler 함수를 호출합니다. 
		return GPacketHandler[header->id](session, buffer, len);
	}

이런식으로 HandlePacket 함수에서 헤더에 적혀있는 아이디에 따라 GPacketHandler를 호출해주는것입니다. 


이제는 GPacketHandler라는 함수의 정체가 궁금해집니다. 정확한 내용은 다음시간 자동화 처리를 하면서 구현할것입니다. 
대략적으로는 패킷의 아이디에 따라 그에 맞는 함수 내용을 만들어주게 될겁니다. 

두루 뭉술하고 자세한 설명없이 그냥 코드만 따라 적고 있는 느낌이지만 이후 자동화를 다하고 큰 그림을 보면 이해가 갈것입니다. 

그래도 예를 들어보자면 GPacketHandler의 내용을 채워줄때 

// Custom Handler
bool Handle_INVALID(PacketSessionRef& session, BYTE* buffer, int32 len);

class ServerPacketHandler
{
public:
	// TODO : 자동화 
	static void Init()
	{
		GPacketHandler[0] = Handle_INVALID;
	}
}

어떤 함수 Handle_INVALID를 정의하고 ServerPacketHandler를 초기화 할때 id에 해당하는 인덱스에 정의했던 함수를 넣어주는겁니다.

여기서 Handle_INVALID함수는 등록되지 않은 패킷 아이디로 접근할때 사용하기 위해 만들었습니다. 즉 처음에는 GPacketHandler의 모든 내용을 Handle_INVALID로 채워주고 시작합니다. 

	static void Init()
	{
		for(int32 i = 0; i < UINT16_MAX; i++)
			GPacketHandler[i] = Handle_INVALID;
	}

추가로 또 예시를 들어서 S_TEST 에 대한 함수를 보자면 

bool Handle_S_TEST(PacketSessionRef& session, Protocol::S_TEST& pkt);

이런식으로 만들어 주면 될것입니다. Handle_INVALID와 다르게 BYTE* 형태의 버퍼와 길이인 len을 받는게 아지라 Protocol::S_TEST& pkt를 바로 받아주고 있습니다. 
이럴 수 있는 이유는 이 함수로 들어올 경우는 HandlePacket 함수로부터 패킷 헤더의 아이디가 S_TEST임을 확인하고 들어 왔을 때 이기 때문입니다. 
한번 체크하고 왔기 때문에 Handle_S_TEST 로 들어온 다음에는 따로 버퍼와 길이를 가지고 파싱을 할 필요가 없을겁니다. 

Handle_S_TEST를 GPacketHandler에 등록하는 코드는 이렇게 될겁니다.

	// TODO : 자동화 
	static void Init()
	{
		for(int32 i = 0; i < UINT16_MAX; i++)
			GPacketHandler[i] = Handle_INVALID;

		GPacketHandler[PKT_S_TEST] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_TEST>(Handle_S_TEST, session, buffer, len); };
	}

GPacketHandler의 원소는 PacketHandlerFunc 라는 시그니처의 함수이고 딱히 함수의 식별자는 중요하지 않기 때문에 람다식으로 함수를 만들어 넣습니다. 
필요한 인자들을 받고 반환으로 template를 사용하는 타입의 HandlePacket을 호출합니다. 
Init함수 자체가 처음에 초기화 할때 실행될 함수입니다. 그래서 PKT_S_TEST 타입에 해당하는 Handle 함수를 GPacketHandler에 담아두는것이고 
이 담아진 함수는 나중에 template없이 호출된 HandlePacket 에서 넘겨받은 버퍼와 길이를 알아서 파싱해 Handle_S_TEST를 호출해줄것입니다. 

이 복잡해 보이는 과정을 매번 만들어 줄 수는 없을 것이고 이 과정을 자동화로 처리하도록 처리해 줄것이란 말입니다. 

자동화하지 않을 부분도 있는데 Handle_INVALID, Handle_S_TEST 같은 함수입니다. 

컨텐츠에서 뭘할것인지는 툴에서는 알 수가 없기 때문입니다. 다만 식별자 컨벤션은 지켜주면서 만들것입니다. 

*** 
-- 마무리

마무리로 잘 되었는지 빌드를 해보니 에러가 뜹니다. 기존에 사용하던  ServerPacketHandler::HandlePacket 이 남아 있었습니다. 
GameSession 쪽에서 사용하고 있었는데 인자가 BYTE* 와 int32 두가지 뿐입니다. 이제는 어떤 세션에서 발신한건지 까지를 알아야 하니까 
PacketSessionRef 도 인자로 넘겨줘야합니다.

여기서 한번더 신경쓸만한 내용이 있는데 받은 패킷의 용도에 따라 게임플레이 로직을 처리하는 서버로 넘겨줄것인지, 아니면 데이터 베이스쪽 서버로 갈 패킷인지 등을 
구별해 각 서버의 HandlePacket으로 넘겨주는게 좋습니다. 그래서 바로 넘겨주지 않고 헤더를 살펴볼것입니다. 


void GameSession::OnRecvPacket(BYTE* buffer, int32 len)
{
	PacketSessionRef session = PacketSessionRef();
	PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);

	// TODO : PacketId 대역 체크 
	ServerPacketHandler::HandlePacket(session, buffer, len);
}
여기 OnRecvPacket에서 PacketSessionRef을 만들 때 새로 빈 세션을 만들어 인자로 넘겨주고 있습니다. 세션을 매개변수로 받는 이유인 누가 보냈는지 알기 위해서라는 목적을생각하면 
잘 이해되지 않습니다. 지금 서버 클라 구조가 1대1 밖에 안되기 때문에 임시로 만들고 있는것 같습니다.

이렇게 해서 이번 시간 내용이 끝났긴 했지만 일을 벌여놓기만 하고 수습을 하지 않았습니다. 결국 다음 시간의 내용과 함께봐야 이해가 가겠습니다. 
복잡한 자동화 작업은 처음 만들때는 힘들지만 한번 만들고 나서 부터는 컨텐츠 단의 코드만 만지면 알아서 잘 돌아가도록 하는 작업입니다. 

그리고 오늘 내용에서 나온 코드들은 결국은 자동화를 하면서 다 이동, 수정, 삭제될 코드들입니다. 자동화를 하는 흐름이 어떤지를 알기 위한 코드들입니다. 