


        JobQueue (2)


이전시간에 서버 프로그래밍을 하면서 락을 사용하게되면 경합상황이 발생하는 문제가 있고 그것을 해결하기위해서 Job과 JobQueue를 사용하는 원시적인 방법을 
우리 프로젝트에서 실습해봤습니다. 

이전시간의 JobQueue방식은 경합이 일어날만한 기능을 추가할때 마다 손수 클래스를 추가 해줘야 하는 문제점이 있었습니다. 
오늘은 그에 비해 2세대 같은 방법을 알아볼겁니다. 이번 시간역시 완벽한 방법은 아니고 아쉬운 점이 있습니다. 중간 단계를 거치는 이유는 어떤 원리와 장단점을 알아가는 
과정입니다. 


오늘 실습은 Job 파일쪽 코드를 수정 해볼것입니다. 
지금까지 Job을 어떤 식으로 사용했냐면 클래스기는 하지만 어떤 기능을 하는 함수처럼 사용하고 있었습니다. 그리고 그건 그냥 함수자(Functor)의 사용법입니다. 

목표를 하나 잡겠습니다. 

// 오늘의 목표 밑의 기능을 job으로 만들기
static void HealByValue(int64 target, int32 value)
{
	cout << target << "한테 힐 " << value << "만큼 줌" << endl;
}

실제 기능이라기 보다는 그냥 로그로 찍어서 힐했다 치는 것입니다. 이 기능을 job으로 만들어 보겠습니다. 
함수자에게 위의 함수의 기능을 하게 하기 위해서는 필요한게 몇가지 있는데 일단 HealByValue 함수 자체도 들고 있어야 하고 함수가 실행할때 필요한 인자들도 함수자가 들고 있어야 합니다. 

// 함수자 (Functor)
template<typename Ret>
class Job
{
public:
	void operator() ()
	{

	}

private:

};

함수자는 이런 () 오퍼레이터를 오버로딩 했다고 하면 사용할때는 

Job<void> job;

job();

이런식으로 사용하는게 함수자 였습니다. 이 형태는 반환 타입을 템플릿문법으로 받고 있는 상태입니다. 

여기에 만약 HealByValue 함수를 적용한다고 해서 인자 두개를 받겠다고 한다면 


// 함수자 (Functor)
template<typename Ret, typename T1, typename T2>
class Job
{
public:
	Ret operator() (T1 t1, T2 t2)
	{

	}

private:

};


{
        Job<void, uint64, uint32> job;

        job(100, 10);
}

이런식으로 사용할 수 있을것입니다. 
그리고 사실 이 operator() 라는것이 IJob의 Execute와 똑같은 의미입니다. 

	Ret operator() (T1 t1, T2 t2)
	{

	}

	Ret Execute(T1 t1, T2 t2)
	{

	}

이 두개가 똑같이 사용할 수 있다는것입니다. 여기에 추가 하자면 앞으로 인자가 몇개가 될지 알 수 없습니다. 
그래서 직접 템플릿 인자를 하나씩 늘리는 방식으로 하다보면 결국 각 인자 갯수 만큼을 다 만들어야 할것 같습니다. 하지만 템플릿 문법자체에서 
같은 이름을 가진 클래스를 여러번 템플릿 문법을 추가해 만들 수 없습니다. 

모던 C++에서는 이것을 잘 해결해주는 문법이 있었습니다. 

// 함수자 (Functor)
template<typename Ret, typename... Args>
class Job
{
public:
	Ret operator() (Args... args)
	{

	}

	Ret Execute(Args... args)
	{

	}
private:

};

가변 템플릿 Variadic Template 입니다. 함수들의 인자를 가변적으로 받아줄 수 있게되어 아까 테스트한 Job을 다시 보면 

{
        Job<void, uint64, uint32> job;

        job(100, 10);
}

아까와 똑같이 사용할 수 있고 또 여기서 인자를 하나 늘려서 사용한다고 해도 아무런 문제가 없습니다.

그래서 일단 Job의 형태는 가변 템플릿을 사용해 유동적으로 대응 하도록 만들어 주면 되겠다고 할수 있겠습니다. 

Job의 껍데기는 만들었는데 아직 갈길은 멉니다.

다음으로 하고 싶은것은 이 Job 껍데기에 HealByValue 의 코드를 직접 넣어주고 싶은게 아니라 알아서 어떤 함수를 연결시켜주고 싶은겁니다. Job안에서 어떤 조건이 되면 
HealByValue 함수를 호출해주도록

여러 방법이 존재하겠지만 가장 쉬운 방법중 하나는 함수 포인터를 이용하는것입니다. 하는김에 먼저 위의 Job이라는 클래스 명을 FuncJob으로 수정하였습니다. 

연결할 함수의 타입을 쉽게 사용하기 위한 using이 필요합니다. 

	using FuncType = Ret(*)(Args...);

FuncType이 Ret 타입을 반환할것이고 Args... 라는 가변 템플릿을 인자로 받는 함수의 타입이라는 뜻입니다. 이 FuncType을 멤버 변수로도 가지고 있을거고 이 멤버 변수를 채워주는 
생성자도 만들었습니다. 

template<typename Ret, typename... Args>
class FuncJob
{
	using FuncType = Ret(*)(Args...);
public:
	FuncJob(FuncType func) : _func(func)
	{

	}

	Ret operator() (Args... args)
	{
		_func(args...);
	}

	Ret Execute(Args... args)
	{
		_func(args...);
	}
private:
	FuncType _func;
};

들고 있는 _func를 () 오퍼레이터와 Execute 에서 호출해주면 해당 함수로 연결이 되는것입니다. 


	{
		FuncJob<void, int64, int32> funcJob(HealByValue);

		funcJob(100, 10);
	}

사용은 이렇게 되겠습니다. 

경우에 따라서 컴파일러가 FuncJob의 템플릿 부분을 알아서 잡아주는 경우도 있긴하다고 합니다. 

시험삼아 위의 코드까지만 실행해보면 제대로 HealByValue의 내용인 로그가 뜹니다. 

이렇게 해서 Functor를 사용해서 지정한 함수를 들고 있게 만들었습니다. 
아직 부족한점은 우리가 Job을 만들어 줄때 주는 인자들도 같이 기억하고 있게끔 해줘야 합니다. Job이라는게 일단 일감을 밀어두듯이 사용할 것이다 보니 
나중에 Execute할때 되면 인자를 잊어버릴수가 있습니다. 
이전 시간의 GRoom의 IJob 방식에서는 클래스 내에 인자들을 다 기억하고 있었습니다. 각각 개별 클래스로 만들었기 때문에 가능했습니다. 

가변 템플릿의 갯수대로 자동으로 각 인자를 기억할 수 있는 방법이 없을까 싶습니다. 직접 인자를 Args... _args; 이렇게 들고 있을 수 있는 방법은 없습니다. 
다만 우회해서 처리할 방법이 있는데 C++11 기준으로 std::tuple<Args...> _tuple; 이라고 들고 있을 수 있습니다.
이 tuple 을 초기화 하기위해서 생성자에서 인자로 받아 채워줘야합니다. 
그리고 () 오퍼레이터나 Execute에서는 이제 따로 Args... arg 라고 인자를 받아주는게 아닌 _tuple 이라는 멤버 변수에서 인자를 호출해주면 됩니다. 

template<typename Ret, typename... Args>
class FuncJob
{
	using FuncType = Ret(*)(Args...);

public:
	FuncJob(FuncType func, Args... args) : _func(func), _tuple(args...)
	{

	}

	Ret operator() ()
	{
		std::apply(_func, _tuple);
	}

	Ret Execute()
	{
		std::apply(_func, _tuple);
	}
private:
	FuncType _func;
	std::tuple<Args...> _tuple;
};

그런데 () 오퍼레이터와 Execute 함수를 호출할때 인자를 넘겨주는 방법이 애매한데 C++17 기준으로는 std::apply라는 기본 메소드에 꽂아 주면 됩니다. 
이때 자신이 사용하는 VS 에서 C++17 버전을 지원하고 있지 않다면 컴파일러에서 빌드 에러가 날것입니다. 

VS에서 GameServer 속성 -> C/C++ -> 언어 -> C++ 언어 표준의 옵션을 17버전 까지 올려주면 됩니다. 

이렇게 되면 이제 테스트는 어떻게 바뀌게 되냐면 

	{
		FuncJob<void, int64, int32> funcJob(HealByValue, 100, 10);

		funcJob();
                funcJob.Execute();
	}

FuncJob을 생성하면서 생성자에 먼저 인자들을 주게 되고 () 실행이나 Execute를 할때는 아무인자 없이 호출하면됩니다.
(앞으로는 () 오퍼레이터 말고 Execute 함수를 사용하는 것으로 하겠습니다. 햇갈릴 수 있기 때문)

그런데 그러면 이런 의문이 듭니다. C++17 이전에는 어떤방식으로 이 것을 구현했을까요? 아직도 C++11 을 기준으로 만든 프로젝트들이 많다고 합니다. 
템플릿 문법을 이리저리 잘 사용하면 된다고 합니다. 


-- C++11 시절 가변 인자를 템플릿문법으로 구현하는방법 
굳이 어려운 방법을 사용하는것 같지만 그래도 이후로 템플릿문법을 잘 사용하는 감각에 도움이 될것이기 때문에 한번 시작해보겠습니다. 


// C++11 apply

template<int... Remains>
struct seq
{};

template<int N, int... Remains>
struct gen_seq : gen_seq<N - 1, N - 1, Remains...>
{};

template<int... Remains>
struct gen_seq<0, Remains...> : seq<Remains...>
{};

template<typename Ret, typename... Args>
void xapply(Ret(*func)(Args...), std::tuple<Args...>& tup)
{
	return xapply_helper(func, gen_seq<sizeof...(Args)>(), tup);
}

template<typename F, typename... Args, int... ls>
void xapply_helper(F func, seq<ls...>, std::tuple<Args...>& tup)
{
	(func)(std::get<ls>(tup)...);
}


이런 전혀 이해가 안가는 흑마법으로 만든 xapply를 FuncJob::Execute에서 호출해보면 잘 동작한다는걸 알수 있습니다. 

동작하기는 하지만 도대체 왜 동작하는건지를 이해하려고 시도해보겠습니다. 

차근차근 분석해보겠습니다. 

먼저 tuple 이라는 컨테이너가 뭔지를 알아보겠습니다. 

	auto tup = std::tuple<int32, int32>(1, 2);

어떤 데이터를 모아 두는 것인데 템플릿으로 넣어준 타입 순서대로 데이터를 가지고 있을겁니다. 

안의 내용물을 꺼내고 싶을때는 std::get을 사용합니다. 

	auto val0 = std::get<0>(tup);
	auto val1 = std::get<1>(tup);

get을 사용할때는 템플릿부분에 꺼내고 싶은 원소의 인덱스 번호, ()안에는 꺼낼 컨테이너를 주면 됩니다. 
이것이 tuple의 기초적인 사용법입니다. 

그래서 xapply_helper 의 내용을 보면 func라는 인자는 실해해줄 함수를 뜻라고 실행할때 get으로 tup에 담긴 ls번 인덱스의 값들을 ... 이라는 문법으로 전부 꺼내주고 있습니다.

	(func)(std::get<ls>(tup)...);
이 코드가 
	std::get<0>(tup); std::get<1>(tup); std::get<2>(tup); ... 
이렇게 담겨있는 만큼 하나씩 꺼내 func의 인자로 넘겨주고 있습니다.

그러면 get을 사용할때의 ls는 또 템플릿에서 seq<ls...> 이렇게 되어있습니다. 이것은 또 어떤 의미인지를 알아보겠습니다. 

예를 들어서 gen_seq을 템플릿에 3이라는 값을 주고 만들어 보겠습니다. 

	auto s = gen_seq<3>();

커서를 가져다 대면 이것은 구조체라고 설명이 나옵니다. 
그런데 gen_seq라는 두가지 struct를 잘 보아야합니다. 

template<int N, int... Remains>
struct gen_seq : gen_seq<N - 1, N - 1, Remains...>
{};

이 버전의 gen_seq는 다시한번 N-1, N-1, Remains을 받는 gen_seq를 상속받고 있습니다.
이것의 위의 gen_seq<3>() 을 풀어서 보겠습니다.

gen_seq<3>() 을 호출하면 템플릿 N이 3인 상태입니다. 그리고 나머지 Remains라는 가변 템플릿은 없을수도 있고 있을수도 있는데 지금은 3 하나만 받고 있기 때문에 
Remains은 아무것도 없는걸로 칩니다. 

그러면 상속받는 gen_seq를 보면 gen_seq<2, 2> 를 상속받고 있다고 할 수 있습니다. 
이제 다시한번 gen_seq<2, 2> 에 대해 알아봐야하는데 이것은 또다시 N이 2가 되고 Remains도 2가 오게됩니다. 

다음 상속은 gen_seq<1, 1, 2> 가 되고 한번더 확장하면 gen_seq<0, 0, 1, 2> 이렇게 될겁니다. 
이제부터는 N이 0으로 시작하게 될텐데 이때 부터는 

template<int... Remains>
struct gen_seq<0, Remains...> : seq<Remains...>
{};

이 버전의 gen_seq가 가장 가깝기 때문에 이 버전으로 인지하게 될겁니다. 이것은 gen_seq가 0으로 시작하면 seq의 Remains 개 만큼을 받는다고 되어있습니다. 
gen_seq가 아닌 seq로 들어왔기 때문에 더 이상 계산이 멈추게 됩니다.

그래서 사실상 xapply 에서 xapply_helper를 호출하면서 gen_seq<sizeof...(Args)>() 를하면서 seq를 만들어 준겁니다. 
이때 sizeof...(Args) 는 가변템플릿 문법인데 FuncJob을 만들때 받은 Args의 사이즈 만큼을 의미합니다. 

다시 정리하자면 먼저 인자의 갯수만큼 인덱스를 가지고 있는 seq를 만들어주는 gen_seq가 있고, xapply에서는 gen_seq를 사용해서 xapply_helper에게 
func, seq, tuple을 넘겨주게 됩니다. 이때 seq의 인덱스들은 가변 템플릿으로 되어있고 또 xapply_helper에서 가변템플릿 문법으로 
각각 ls값마다 get을 호출해주게됩니다. 그렇게 get으로 호출된 값들이 func의 인자로 들어가게 됩니다. 

정말 이런 이해하기도 햇갈리는 방법을 처음 떠올린 사람이 대단합니다. 

아무튼 이렇게 해서 FuncJob 이라는 클래스에서 생성자에 넘겨주는 함수와 인자들을 가지고 tuple과 FuncType에 저장해 두었다가 필요한때에 호출해 실행해줄 수 있게 
만들었습니다. 

아직 문제 한가지가 더 남았는데 FuncJob에서 FuncType을 받아주는 게 Ret을 뱉어주고 Args를 인자로 받아주는 형태의 함수를 받아줍니다. 
이게 모든 종류의 함수를 받아주지 못합니다. 함수에는 여러 가지 함수가 있는데 

class Knight
{
public:
	void HealMe(int32 value)
	{
		cout << "Heal Me!" << value << endl;
	}
private:

};

이런식으로 클래스의 멤버 함수같은 경우는 전역으로 사용할 수 없고 클래스에 종속되어서 사용됩니다. 앞에 static이 붙었다면 사실상 전역함수처럼 호출이 가능하지만 
그냥 멤버 함수와 전역 함수는 함수 호출 규약이 다르다고 합니다. 

이 경우를 두번째 테스트를 해볼겁니다. 
Knight 객체를 대상으로 job을 만들어 주고 싶습니다. 하지만 위에서 만든 FuncJob 을 사용해서는 시그니처가 다르다 보니 통과가 되지 않을겁니다. 
그래서 어떻게 해야하는가 하면 FuncJob을 하나 더 복사해 조금 수정하여 사용할것입니다.

template<typename T, typename Ret, typename... Args>
class MemberJob
{
	using FuncType = Ret(T::*)(Args...);

public:
	MemberJob(T* obj, FuncType func, Args... args) : _obj(obj), _func(func), _tuple(args...)
	{

	}

	Ret Execute()
	{
		// std::apply(_func, _tuple);
		xapply(_obj, _func, _tuple);
	}

private:
	T*					_obj;
	FuncType			_func;
	std::tuple<Args...> _tuple;
};

T라는 템플릿을 늘렸는데 클래스타입을 뜻할것입니다. FuncType 도 T에 종속된 함수임을 T::로 추가해줘야합니다. 그리고 T타입의 객체도 포인터로 들고 있을겁니다(_obj)
들고 있을것이 하나더 늘었으므로 생성자에서도 T* obj 를 받아 초기화 해줄것입니다. 지금은 생 포인터를 사용하고 있지만 나중에 스마트 포인터로 바꿔도 됩니다. 

Execute 함수에서 사용하는 xapply같은 경우도 똑같이 멤버 함수 버전을 하나 더 늘려줄것입니다.

template<typename T, typename Ret, typename... Args>
void xapply(T* obj, Ret(T::*func)(Args...), std::tuple<Args...>& tup)
{
	return xapply_helper(obj, func, gen_seq<sizeof...(Args)>(), tup);
}

typename T 를 더 받아주고 또 인자도 T* 타입 오브젝트도 받아줍니다. 실행할 함수인 func도 T에 종속되었음을 표시해줍니다. 
그리고선 xapply_helper에도 오브젝트를 인자로 전달해줍니다. 

template<typename T, typename F, typename... Args, int... ls>
void xapply_helper(T* obj, F func, seq<ls...>, std::tuple<Args...>& tup)
{
	(obj->*func)(std::get<ls>(tup)...);
}

오브젝트를 전달 받았으니 typename T를 추가하고 인자목록에도 오브젝트를 추가합니다.

이제는 멤버 함수에 대해서도 함수자를 활용하는 job을 사용할 수 있게 됩니다. 


***

그러면 이제 함수자를 활용하는 방법에 대해 배웠는데 이것을 이전 시간에 만든 IJob에 적용해보겠습니다. 

class IJob
{
public:
	virtual void Execute() { }
};

Execute를 상속하는 기능을 가진 이 IJob 클래스를 오늘 만든 FuncJob, MemberJob에 상속시켜줍니다. 

이제 Ret Execute 가 아닌 virtual Execute () override 를 사용하게 됩니다. 
굳이 Ret를 반환하도록 해줄 필요가 없는것이 잡이라고하는 일감은 사실 어떤 반환값을 받기위해 사용하는게 아니라 어떤 일감을 나중에 시간날때 처리해달라고 
사용하는것입니다.

FuncJob, MemberJob 은 어떻게 사용하는가 하면 이제 Room 클래스로 가야합니다. 
이전에 각 기능마다 새로 job 클래스를 만들어 주었었습니다. 전부 날려주겠습니다. 

// IJob을 도입하면서 락을 잡지 않고 싱글 스레드환경인것 처럼 코딩합니다.
class Room
{
public:
	void Enter(PlayerRef player);
	void Leave(PlayerRef player);
	void Broadcast(SendBufferRef sendBuffer);

public:
	// 멀티 스레드 환경에서는 일감으로 접근 
	void PushJob(JobRef job) { _jobs.Push(job); }
	void FlushJob();

private:
	map<uint64, PlayerRef> _players;

	JobQueue _jobs;
};

extern Room GRoom;

이렇게 시작할건데 어디에 오늘 만든 잡을 적용해야 하는가 하면 PushJob을 할때 Job을 만들어 밀어 넣을겁니다. 이때 Enter, Leave, Broadcast 중 어떤 함수를 호출할지를 지정해주면 되는데 
그걸 도와줄 헬퍼 함수를 만들어 주겠습니다. 

	template<typename T, typename Ret, typename... Args>
	void PushJob(Ret(T::*memFunc), Args... args)
	{
		auto job = MakeShared<MemberJob<T, Ret, Args...>>(static_cast<T*>(this), memFunc, args...);
		_jobs.Push(job;)
	}

이런 함수를 멤버 함수로 추가해줬습니다. 내용에서는 job을 만들어 주는데 MemberJob 을 MakeShared로 만듭니다. 그 중 클래스를 뜻하는 T는 this를 T*으로 캐스팅해 넘겨주고 있습니다. 

빌드를 한번하면 변경된 코드에 따라 에러를 수정해줍니다. 

ClientPacketHandler 쪽에 문제가 몇가지 있습니다. 
PushJob을 하는 방법이 달라져서 입니다. 

	GRoom.PushJob(MakeShared<EnterJob>(GRoom, player));

이전에는 위와 같이 PushJob을 할때 객체를 만들어 넘겨주고 있었는데 이 방식이 아닙니다. 
따로 Job을 만들고 JobQueue에 넣는게 아니 인자로 어떤 잡을 만들지를 넘겨주는것입니다. 

	GRoom.PushJob(&Room::Enter, player);
