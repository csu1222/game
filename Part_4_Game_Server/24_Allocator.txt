

        Allocator


메모리 할당에 대한 내용을 배워볼겁니다. C++ 은 장점이자 단점일수 있지만 세부적이 커스터 마이징이 가능합니다. 

객체를 동적할당을 하기 위해서는 new delete 명령어 쌍을 사용해서 동적할당을 하였습니다. 스마트 포인터를 사용해도 알아서 관리해준다 
뿐이지 내부적으로는 다르지 않았습니다. 

그런데 2000년대 초반 서버쪽에서는 생으로 new delete를 사용해서 동적할당을 하지 않고 메모리를 직접 관리를 해서 사용하는 경우가 많았습니다.
소위 메모리 풀링, 오브젝트 단위 풀링이라고 한답니다.
왜 new delete 를 하지 않고 굳이 직접 메모리를 관리하려고 하냐는 의문이 생깁니다. 

크게 두가지 이유로 볼 수 있습니다. 

1 - 메모리를 사용하기 위해서 new 를 한다고 했을때 우리가 사용할 용량이 부족하다고 하면 new delete 명령어가 유저 레벨에서만 동작하는 명령어는 
    아닐겁니다. 메모리라는 하드웨어를 다루기 위해서는 당연히 커널 레벨까지 요청을 해야할겁니다. 그래서 new로 메모리를 요청하게 되면 
    컨택스위칭을 통해 커널영역에 메모리 영역을 만들고 다시 유저영역으로 건내주게 될 겁니다. 
    항상 100%확률로 컨택스위칭이 일어난다는 것은 아닙니다. new delete도 내부적으로 잘 처리하는 기법이 있기는한데 불가피할 상황일때는 
    컨택스위칭을 할 확률이 있다는 것 자체가 문제입니다. 
    그럴바에 아예 아주 넉넉하게 메모리를 한번에 요청한 다음 그 메모리 안에서 필요한 만큼씩 나눠서 사용하면 커널에 따로 요청할 필요없이 
    사용할 수 있을겁니다. 

2 - 메모리가 아주 큰 단위로 할당을 요청하면 괜찮은데 작은 단위로 할당을 요청하는 경우가 있습니다. 예를 들어서 vector 가 그런데 
    vector의 원소가 capacity를 넘어가게되면 1.5배 혹은 2배사이즈로 늘려가면서 할당을 요청하는데 
    새로 요청할때 마다 새로운 메모리 주소에 할당을 받을겁니다. 그런데 이렇게 여러번 옮겨다니다 아쉬운 부분은 이전에 vector가 사용하던 
    자잘한 메모리는 free되어서 반납이 되기는 했지만 이곳 저곳에 흩어져 있기 때문에 이 자잘한 메모리 보다 조금 더 큰 용량이 필요한 
    데이터가 생기면 약간 용량이 모자라서 아예 다른 곳에 저장해야하는 점이 있습니다. free는 되어있지만 실질적으로 사용을 못하면 
    소용이 없습니다. 

이런 이유들 때문에 메모리를 직접 크게 할당해서 효율적으로 사용하려는 의도로 메모리를 직접 할당을 받았다고 합니다. 

하지만 요즘은 어떻게 개선이 되었는지 그냥 new delete를 해도 성능이 잘나온다고 하고 그래서 최근 프로젝트에서는 그냥 사용한다고 합니다. 

그래도 메모리 할당의 기술에 대해 알아는 보고 넘어가는게 좋을것입니다. 알고 안하는것과 몰라서 못하는것은 차이가 있을것입니다. 


오늘의 주제로 들어가겠습니다. 
먼저 new delete 에 대해 좀 더 알아볼것인데 신기하게도 new, delete 도 오버로딩의 대상이 될 수 있습니다. 

// new operator overloading (Global)
void* operator new(size_t size)
{
	cout << "new! " << size << endl;
	void* ptr = ::malloc(size);
	return ptr;
}

void operator delete(void* ptr)
{
	cout << "delete!" << endl;
	::free(ptr);
}

void* operator new[](size_t size)
{
	cout << "new! " << size << endl;
	void* ptr = ::malloc(size);
	return ptr;
}

void operator delete[](void* ptr)
{
	cout << "delete!" << endl;
	::free(ptr);
}

이렇게 중간에 문자열을 콘솔에 출력하는 코드를 넣고 실험해보면 동작합니다. 그러니 그때 필요에 따라 추가적인 동작을 넣어 줄 수 있다는 얘기입니다. 

new delete를 커스터마이징해서 사용하는것 자체는 매우 좋은데 글로벌로 모든 new delete에 수정이 되는것은 문제가 될수 있습니다. 
외부 라이브러리 라던가 아니면 직접 만든 클래스라도 어떤건 기본 명령어를 쓰고 싶을 수도 있는데 말입니다. 

class Knight 
{
public:

	Knight() 
	{
		cout << "Knight()" << endl;
	}

	~Knight()
	{
		cout << "~Knight()" << endl;
	}

	void* operator new(size_t size)
	{
		cout << "Knight new! " << size << endl;
		void* ptr = ::malloc(size);
		return ptr;
	}

	void operator delete(void* ptr)
	{
		cout << "Knight delete!" << endl;
		::free(ptr);
	}


	int32 _hp = 100;
	int32 _mp = 10;
};

그럴땐 이런식으로 클래스안에 넣어서 사용하면되는데 이러면 Knight 클래스에서 new delete를 할때만 저 문자열이 출력됩니다. 
이때 new delete의 연산자 오버로딩은 앞에 static이 붙은것처럼 인식합니다. 


그럼 이제 new delete 의 오버로딩이 잘 동작하는걸 확인했으니 그럼 애당초 이 new를 할때 무슨 일이 일어나는지를 살펴보겠습니다. 
디스어셈블리로 살펴보면 new Knight() 를 하는순간에 Knight 클래스의 멤버변수들의 크기 만큼 크기를 구해서 
Knight::operator new 를 호출합니다. 여기서는 콘솔 출력과 ::malloc으로 메모리 확보를 하였었습니다. 그리고 다음으로 Knight의 생성자를 호출하고 있는데 
C++코드에서는 한줄로 되어 있지만 어셈블리에서는 여러줄로 되어있었습니다.

그러나 지금 배운 클래스 마다 연산자 오버로딩을 추가하는 방식은 반복작업이 너무 많습니다. 코드를 매크로로 대체할 수 도 있지만 그것마저 번거로울수 있으니 
다음과 같은 방법을 사용하는게 좋을것입니다. 


->  Allocator 클래스

    ServerCore 프로젝트 Memory 필터 아래에 Allocator 라는 클래스파일들을 추가합니다.
    // Allocator.h 
    class BaseAllocator
    {
    public:
        static void*	Alloc(int32 size);
        static void		Release(void* ptr);
    };

    // Allocator.cpp
    void* BaseAllocator::Alloc(int32 size)
    {
        return ::malloc(size);
    }

    void BaseAllocator::Release(void* ptr)
    {
        ::free(ptr);
    }

    Allocator 파일에는 정책에 따라 여러 얼로케이터를 만들것인데 일단 첫시간이고 하니 기본인 BaseAllocator를 만들었습니다. 
    받은 인자 그대로 malloc, free를 해주는 코드입니다. 
    여기에 나중에 필요한 기능들을 추가해줄 수 있습니다. 예를들어 나중에 로그를 찍을 수 있고 카운팅을 해서 할당한 객체 수를 알아 볼 수 있고 
    Alloc과 Release를 짝을 맞춰서 얼마나 메모리 릭이 일어났는지를 체크 할 수 도 있을겁니다.

    
->  Memory 클래스 

    또 새로 추가할 클래스파일은 Allocator 클래스와 같은 위치에 추가해줍니다. 
    이 클래스에서는 Allocator에 만든 BaseAllocator의 내용을 추가로 원하는대로 정책을 추가해줄 겁니다. 

    #pragma once
    #include "Allocator.h"

    template<typename Type, typename... Args>
    Type* A_new(Args&... args)
    {
        Type* memory = static_cast<Type>(BaseAllocator::Alloc(sizeof(Type)));
        
        // placement new	할당된 메모리에 생성자를 호출해주는 문법 
        // new(객체를 만들어줄 공간) 객체의 템플릿(std::forward<Args>(인자들)...);
        new(memory) Type(std::forward<Args>(args)...);

        return memory;
    }

    먼저 A_new 라고 이름붙인 new 연산자 입니다. 템플릿 문법이 매번사용하던 것과 조금 다른데 첫번째 템플릿 인자는 그냥 평소 쓰던 그대로고
    두번째 인자가 typename 뒤에 ... 이 붙어있습니다. 이름은 Args라고 붙혔는데 이건 Args 에 오는 인자가 없거나 하나이거나 하나이상이라도 
    대응가능하도록 하는 C++ 11 이상에서의 모던 C++ 문법입니다. 
    모던 C++ 이전에서는 올 수 있는 인자 갯수마다 손으로 하나하나 오버라이딩 해줬어야 됐다고 합니다. 

    내용은 A_new의 <> 안에는 객체를 만들 Type이 들어오고 인자() 안에는 Type의 생성자가 받아주는 인자들이 들어올겁니다. 
    Type* 타입의 memory는 BaseAllocator::Allocator로 메모리를 할당한 다음 그 주소를 리턴하는데 void* 타입으로 리턴하기 때문에 memory에 
    받아주기 위해 Type* 으로 static_cast를 해주고 있습니다.

    다음 코드는 placement new 라는 문법인데 여지껏 사용하던 new는 아까 알아 봤듯이 새로 new 연산자를 호출해 malloc으로 메모리를 할당하고 
    생성자를 불렀는데 
    지금 배우는 placement new 에서는 어디에 할당 할것인지를 지정해 줄수 있고 생성자의 인자도 어떤걸 넣을지를 알려 줄 수 있습니다. 
    new 뒤의 괄호에는 객체를 생성할 공간이 있는 주소를 주고 생성할 클래스의 Type의 생성자와 괄호 안에는 생성자의 인자를 넘겨줄건데 
    forward로 감싸져있습니다. 인자로 받을 데이터가 rvalue일수도 있고 lvalue일수도 있어서 그렇습니다.그리고 인자의 개수가 가변적일 수 있으니 
    뒤에 ... 도 붙어 있습니다. 
    이제부터는 객체 동적할당할때 인자갯수가 필요한 만큼 넘겨주면 적합한 생성자를 호출해줄 수 있습니다. 
    호출 형식은 아래와 같습니다. 
    Knight* knight = A_new<Knight>(100);
    이러면 Knight 객체 크기의 메모리를 malloc으로 확보한 다음 그 주소에 Knight 생성자로 객체를 생성해주는데 인자를 주면 인자가 있는 생성자 버전으로
    아니면 기본 생성자로 생성합니다. 

    프로젝트를 지금 바로 A_new로 실행해보면 에러가 뜰것인데 왜냐면 Knight 클래스 내부에 만들어 놨던 연산자 오버로딩이 아직 유효하기 때문입니다. 
    사실 new 연산자는 여러 버전이 있는데 Knight 안의 new 와 A_new가 충돌해서 에러가 뜹니다. 앞으로 A_new 버전을 사용할것이니까 Knight안의 new는 
    주석처리 하였습니다. 

    template<typename Type>
    void A_delete(Type* obj)
    {
	    odj->~Type();
        BaseAllocator::Release(obj);
    }

    다음으로 delete 역할을 할 함수를 만들어 줘야 하는데 소멸자의 경우는 더 간단합니다. 순서가 객체의 소멸자를 호출해주고 객체가 있던 메모리를 반환 해주면
    되는데 반환은 BaseAllocator에서 만들었던걸 사용하면 되고 소멸자를 명시적으로 호출하는 방법이 위와 같은데 
    보통 그냥 다른 멤버 함수를 부르듯이 -> 를 이용해서 호출하면됩니다. 평소에는 따로 이렇게 부를 일이 없었기 때문에 처음 보는 문법입니다. 

    이렇게 해서 할당자의 기본이라고 볼 수 있습니다. 이제 이 코드에 원하는 기능을 커스터마이징해서 사용할수 있게 되었습니다. 


지금은 BaseAllocator만 사용하고 있지만 나중에는 필요한 정책의 Allocator를 만들고 또 매크로로도 묶어서 간편하게 사용할 수 있을겁니다. 
예시로 오늘 만든 코드를 매크로로 만들어 보자면 

->  CoreMacro

    /*===================
            Memory
    =====================*/

    #ifdef _DEBUG
    #define A_alloc(size)			BaseAllocator::Alloc(size)
    #define A_release(ptr)			BaseAllocator::Release(ptr)
    #else
    #define A_alloc(size)			BaseAllocator::Alloc(size)
    #define A_release(ptr)			BaseAllocator::Release(ptr)
    #endif

    이렇게 매크로를 만들어 두면 Memory에서 할당, 해제를 할때 앞에 BaseAllocator같은 클래스를 타이핑하지 않아도 됩니다. 



오늘 내용으로 알수 있는것은 new 와 delete가 오버로딩을 할 수 있는 대상이었고 필요한 경우에만 커스터마이징한 할당자를 만들어 호출할수 있고 
이 만든 할당자에서는 입맛에 맞게 정책들을 정해줄 수 있게 기본 공사를 하였습니다. 