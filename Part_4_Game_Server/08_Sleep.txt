

        Sleep


이번에는 락을 구현할때 대기를 하는 두번째 방법인 Sleep 에 대해 알아보겠습니다. 

저번시간에 대부분의 기능을 구현했기때문에 오늘 실습 자체는 슬립 함수만 추가해주면 됩니다. 

먼저 Lock 구현 기초 시간에 비유를 통해 알아 봤던 랜덤 메타 Sleep 의 내용을 좀 더 자세히 알아보겠습니다. 

/*
일단 자리로, 나중에 다시 (랜덤 메타)

비유를 다시 보면 화장실을 갔는데 이미 누가 사용하고 있을때 문 앞에서 기다리는게 아니라 일단 자리로 돌아가서 할일 하다가 
나중에 랜덤한 시간이 지나고 다시 화장실로 가보는 방법입니다.
정말로 운에 모든걸 맡기고 있는겁니다. 

여기서 좀 더 깊게 알아 볼 수 있는 내용이 있는데 
식당의 비유를 다시 떠올려 보면 몇가지 식당(프로그램)이 있고 각 식당마다 직원(쓰레드)이 있습니다. 이 직원들을 움직이려면 
식당관리자(커널레벨)에 있는 영혼(CPU코어)를 직원에 할당해야 직원이 움직입니다. 식당관리자에서도 영혼을 보내고 받아주는 
직원이 하나 있었습니다. 

식당들이 있는 곳을 유저레벨이라고 부르고 식당관리자가 있는 곳을 커널레벨이라고 부릅니다.
커널영역이라함은 운영체제를 동작시키기위한 기본 프로그램들이 있는 영역입니다. 윈도우즈를 실행하기 위해서 커널영역으로 
돌아와야 한다는 말입니다. 

결국은 어떤 코드가 실행이 된다는것은 코드를 실행하는 주체가 CPU가 될겁니다. CPU가 해당 코드를 실행해서 동작해야 하는데 
커널영역의 코드도 마찬가지로 커널영역의 쓰레드에 CPU코어가 할당되어서 코드 실행이 되어야합니다. 

이 내용을 왜 강조하냐면 오늘 배우는 Sleep을 구현한다는게 어떤 의미인지 설명하기 위해서인데
커널이 하고 있는 기능들은 모두 중요하지만 그중 하나의 기능인 스케쥴링이라는게 있습니다.

스케쥴링은 현재 컴퓨터에서 실행되고 있는 프로그램이 여러개 있을겁니다. 다음으로 CPU 코어를 어디에 할당할건지 
골라주는 기능인데 물론 다음 실행할 프로그램을 고르는 기준은 운영체제마다 그리고 정책 마다 다를겁니다. 
프로그램의 중요도에 따라 어떤 특정프로그램에 우선순위를 줄 수도 있을것이고 그리고 이전 실행이 언제 되었는지도 
추적하면서 어느정도 공평하게 CPU 를 배분해줄 필요도 있을겁니다. 

그리고 만약 어떤 직원에게 코어를 할당해서 움직이고 있으면 그 순간에는 커널레벨이 움직이지 않고 있을겁니다. (싱글코어기준)
그렇다는것은 다음으로 실행할 프로그램을 골라주는 행동은 일단 코어를 커널영역의 쓰레드가 돌려받고 나서야 
골라줄 수 있습니다. 

결론적으로는 스케쥴러가 코어를 할당을 할때는 할당한 쓰레드가 무한적으로 코어를 사용해도 된다는 허락을 해주는게 아니라 
타임슬라이스 라고 해서 니가 몇초동안 실행될 수 있다고 실행권 같은걸 준다고 볼 수 있습니다. 코어를 할당받은 쓰레드는 
허락받은 시간내에서는 코어를 사용할 수 있는겁니다. 시간을 다 쓰고 나면 다시 커널레벨로 코어를 돌려주고 커널영역에서는 
다음 코어를 할당할 프로그램을 고르고 타임슬라이스도 정해서 코어를 건내주게 됩니다. 

반면 코어를 할당받은 프로그램 입장에서 받은 타임슬라이스를 항상 모두 소진해야 하는것도 아닙니다.
특정상황에 따라 할당받은 시간을 다 쓸 필요가 없다고 하면 스스로 반환을 하는경우도 있고,
온갖 시스템 콜을 요청하면 자발적으로 반환하는 경우도 있을겁니다. 

지금 시스템 콜이라는 용어가 또 새로 등장했는데 쓰레드에서 코드를 실행하다가 cout 같은 명령어를 실행하게되면 
유저레벨에서는 하드웨어를 조작할 수 없는데 cout 같은 콘솔 하드웨어에 요청하는 시스템 콜을 요청하게 되면 
커널영역으로 코어를 반환하고 cout 이 요청한 동작을 실행한다음 다시 유저레벨로 코어를 돌려보내면서 동작하게 됩니다.

이런식으로 특정 API를 사용할때 자발적으로 코어 사용권을 반납하거나 딱히 시간을 모두 사용할 필요가 없어서 반납하거나 
합니다. 아니면 명시적으로 Sleep 과 같은 명령을 실행하게되면 코어 실행권을 반납합니다.

락이 잠겨 있어서 지금 내가 뭔가 할 수 있는게 없다고 판단이 되면 스핀락을 돌면서 근성있게 시도하는 방법도 있고 
아니면 깔끔하게 포기하는 방법도 있을겁니다. 
이 포기하는 방법에서 자기가 할당받은 타임슬라이스를 포기하고 커널레벨로 CPU코어를 반납하고 있는겁니다.
*/

오늘 실습은 간단하게 Sleep계열 함수 하나만 추가하는 것이지만 그 안에서 일어나는 과정은 위와 같이 복잡한 
부분들이 개입을 하고 있는겁니다. 

서버 프로그래머는 운영체제나 컴퓨터 공학의 다른 분야와 접목되는 경우가 많습니다. 

이제 실습으로 가보겠습니다. 
실습으로 가기전에 Sleep 함수는 자신의 CPU 코어 실행 소유권을 포기하는 개념이라는것을 기억하고 넘어가면 좋겠습니다.

- 실습 

이번시간에 코드를 수정할 부분은 이전 시간에 구현했던 부분중에 SpinLock::lock() 함수 안에서 

        while (_locked.compare_exchange_strong(expected, desired) == false)
        {
                expected = false;
        }

이 부분입니다. _locked의 compare_exchange_strong를 체크해서 실패 false 라면 expected를 false로 다시 설정하면서 
무한 루프를 돌고 있는겁니다. 
이 스핀락은 쓰레드가 할당받은 타임슬라이스를 끝까지 사용하면서 가능한 한 기다리는겁니다.

그러면 오늘 추가할 코드가 있는데 이 코드도 마찬가지로 운영체제마다 각각의 함수가 있었는데 
thread 라는 공용 라이브러리가 추가되면서 통합되었는데

        while (_locked.compare_exchange_strong(expected, desired) == false)
        {
                expected = false;

                this_thread::sleep_for(std::chrono::milliseconds(100));
        }

이런 코드가 추가됩니다. this_thread의 메소드 중에 sleep_for와 yield 두가지를 사용한다고 하는데 그 중 sleep_for
에서는 인자로 얼마나 sleep 할건지 시간을 넣어줍니다. 
std::chrono::milliseconds 라는 공용함수로 100 밀리 세컨드라는 시간을 sleep_for 에게 준겁니다.

        this_thread::sleep_for(100ms);

이렇게 100ms 라고 해도 똑같이 100 밀리 세컨드라고 인식합니다.
100ms 부분을 따라 들어가보면 ms 가 오퍼레이터로 사용되어서 사실 std::chrono::milliseconds(100) 를 말하는것입니다.
sleep_for 는 실행되면 일단 코어 실행권을 반납하고 인자로 받은 시간이 지난후에 다시 스케쥴링에 등록해서 다음 실행권을
받는걸 기다리는 함수입니다. 

yield 를 사용하는것도 있다고 했는데 this_thread::yield(); 를 실행하면 yield 의 의미인 양보한다 라는 말처럼 
자기가 받은 타임슬라이스를 양보를 한다음 스케쥴링하라고 떠넘기는 함수입니다.
그러니까 사실상 yield 를 호출한다는것은 sleep_for(0ms) 라는것과 개념적으로 똑같습니다.

그리고 허무하게도 이게 코드수정 끝입니다. 

이 sleep_for 나 yield가 추가되면 사실상 SpinLock이 아니게 됩니다. compare_exchange_strong 를 실패하게되면 
타임슬라이스동안 계속 대기하는게 아니라 실행권을 반납 하게됩니다.

오늘 수정한 SpinLock 클래스도 그냥 sleep 정책을 적용만하는게 아니라 이전에 말했듯이 
필요에따라 한 while을 5000 번 반복한다음 이 이상 기다리는건 손해구나 싶으면 그때 sleep을 하는 방법을 채택할 수도 
있습니다.

여기까지 하고 프로그램을 실행해보면 0이라는 결과가 나옵니다. 실행결과는 같지만 
내부적으로 어떤 변화가 있는지를 알수 있었습니다. 

오늘 실습자체가 대단히 중요한것은 아니지만 일부러 실습해본것은 sleep 을 배우면서 자발적으로 실행권을 반납하므로 인해 
컨텍스트 스위칭을 유발하는걸 배우고 실행권을 반납을 유발하는 경우를 알게되면 
컨탠츠를 만들면서 로그를 찍는다면서 cout 같은 시스템 콜을 남발하면 프로그램이 느려질 수도 있다는 걸 알수 있는 시간이었습니다.
앞으로 빠른 반응을 원한다면 시스템 콜을 최대한 자제해야한다는 교훈을 얻었습니다.