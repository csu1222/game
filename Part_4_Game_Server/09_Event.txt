


            Event


이번시간은 멀티쓰레드 환경에서 사용하는 Lock 의 동기화 방법중 이벤트라는 방법에 대해 알아보겠습니다.

사실 이벤트라는 것 자체가 꼭 락에서만 이용한다는 개념은 아니고 사용하는 범위가 넓습니다. 

먼저 이전에 배웠던 스핀락과 슬립을 배우고 세번째로 나온 방법인 이벤트인데 왜 이벤트가 필요했는지를 떠올려보면 
화장실의 비유에서 화장실문이 잠겨 있으니 직원에게 화장실 문이 열리면 알려달라고 하고 자리로 돌아가는 방법이었습니다.

그런데 이 직원이 그냥 지나가는 직원을 붙잡고 부탁하는게 아니라 식당 관리자, 커널을 말하는겁니다.

이벤트를 사용하고 만들때 C# 에서는 AUTO RESET EVENT, MANUAL RESET EVENT 로 클래스가 나뉘어 지는데 
우리가 사용하는 C++ windows API 에서는 이벤트를 만들때 인자를 어떻게 주느냐에 따라 AUTO, MANUAL 을 나뉘게 됩니다

이벤트는 쉽게 생각하자면 불리언 타입이라고 생각할 수 있습니다. true, false 두가지 상태처럼 문이 열리고 닫히는 
두가지 상태에 따라서 진행을 할 수 있는지 없는지를 판별할 수 있을겁니다. 

화장실의 비유로 돌아와서 기다리는 사람이 락이 풀리면 알려달라고 부탁을 하면서 이벤트를 생성하게 됩니다. 이벤트에는
두가지의 상태가 있습니다. 
처음에 기다리던 사람이 이벤트를 만들고 시작하는데 처음의 상태는 이벤트의 시그널이 꺼져있는 상태 입니다.
기다리는 사람은 이 시그널을 참고하면서 시그널이 켜지면 깨워달라면서 잠들게 됩니다.
직원은 시그널이 켜지면 기다리던 사람을 깨우면됩니다. 

그렇다면 시그널은 누가 켜주는 걸까요 
바로 화장실 안에 있던 사람입니다. 화장실을 빠져나오면서 자물쇠를 풀고 아까 만들었던 이벤트에 접근해서 시그널 상태를 바꿔주게 됩니다.
시그널이 켜지면 기다리던 사람을 깨워서 화장실을 사용하도록 할 수 있다는 말입니다.

이전까지 컨텍스트 스위칭 얘기를 하면서 쓰레드를 직원이나 사람에 비유했고 각 사람들은 CPU 코어에 해당하는 영혼이 할당되어야 움직일 수 
있다고 했습니다.
이벤트의 시그널이 꺼져있는 상태에서는 기다리는 계속 잠든상태 블록킹상태로 되어있는거고 나중에 시그널이 켜지면 잠들어있던 쓰레드를 
다시 움직이는 상황이 되는겁니다. 

이 방법의 장점을 생각해보면 기다리는 사람이 문앞에서 계속 대기를 타면서 쓸모없는 에너지를 낭비하지 않고 제 3자에게 요청해서 정말 
필요한 상황에서 자기를 깨워달라고 하면 자신 입장에서는 낭비 없이 움직일 수 있을겁니다.
하지만 단점이라고 한다면 부탁을 받은 직원 커널영역에서 추가적인 리소스가 들어가기 때문에 항상 남발할 수 는 없을것이고 
어느정도 대기 시간이 있다고 예상되는 상황에서 사용하면 유용하다고 볼 수 있겠습니다. 

이 내용을 이제 코드로 만져보면서 실습해보겠습니다.


-- 코드 
이번 실습은 이전 시간에 만들던 락을 가지고 실습하지 않고 일반적인 상황에서 실습을 하려고 합니다. 
위에서 이벤트는 락에서만 사용하는게 아니라고 했었습니다. 이벤트를 활용하고 연습하는것도 중요하지만 
이벤트가 스핀락처럼 무한 트라이를 하는 방법에 비해 어떤 장점이 있는지를 확실히 알고 가는게 중요하다고 생각합니다.

이벤트를 사용하기 위해서는 일단 windows.h 를 추가해야합니다. 

오늘 실습하는 상황은 일단 mutex 를 만들고 int32 를 담는 queue 를 하나만들어서 이 queue는 공용데이터로 사용할겁니다. 

그리고 함수로는 데이터를 막 생성해서 밀어넣는 Producer 라는 함수와 밀어넣어진 데이터를 소비하는 Consumer 라는 함수가 있을겁니다. 
왜 이 두 함수를 상황으로 사용하냐면 게임 프로그래밍에서 클라이언트에서 수신 받은 데이터들을 밀어넣고 밀어넣은 패킷들을 추출해서 처리를하는 
상황이 빈번하기 때문입니다. 

 
mutex  m;
queue<int32> q;

void Producer()
{
	while (true)
	{
		{
			unique_lock<mutex> lock(m);
			q.push(100);
		}

		this_thread::sleep_for(100ms);
	}
}

void Consumer()
{
	while (true)
	{
		unique_lock<mutex> lock(m);

		if (q.empty() == false)
		{
			int32 data = q.front();
			q.pop();
			cout << data << endl;
		}
	}
}

int main()
{
	thread t1(Producer);
	thread t2(Consumer);

	t1.join();
	t2.join();
}

이렇게 처음의 상황을 만들어 봤습니다. Producer에서는 무한 루프를 돌면서 unique_lock으로 락을 걸고 100이라는 값을 q에 push합니다.
그리고 sleep_for로 100ms 만큼씩을 쉬어가면서 반복합니다. 

Consumer에서도 마찬가지로 무한 루프를 도는데 q가 비어있지 않다면 그 front값을 꺼내서 cout을 하고 있습니다. 물론 무한루프를 돌면서 
cout 을 사용하는건 좋은 습관은 아니지만 간편하게 하기위해서 그냥 사용했습니다. 

두 쓰레드를 생성하고 join을 해서 실행해보면 0.1초마다 100 이 콘솔에 출력되는걸 볼 수 있습니다. 

이 코드에서는 한가지 아쉬운 점이 있습니다.
데이터를 밀어넣는 Producer가 0.1 초마다 데이터가 추가되고 있지만 이게 아니라 데이터가 더욱 가끔 추가된다고 해보겠습니다.
0.1초가 아니라 3시간에 한번씩 데이터가 밀어 넣어진다고 한다면 Producer는 sleep 되어 있는 시간동안은 잠들어 있다가 시간이 되면 
실행되겠지만
Consumer에서는 3시간에 한번씩 데이터가 추가되는걸 모르고 데이터가 들어올때 까지 계속 루프를 돌면서 q를 체크하고 있을겁니다.
게다가 심지어 q도 공용 데이터이기 때문에 lock을 잡으면서 루프를 실행하는것도 아쉽습니다.

그러니까 Producer에서 데이터를 밀어 넣어주지 않으면 Consumer는 아무것도 하지않고 뺑뺑이만 돌고있는 작업이됩니다. 

다시 Producer에서 데이터를 밀어넣는 시간을 10초로 늘려서 디버깅 실행해보면 코드가 버그나는것은 아니지만 진단 도구의 CPU 점유율이
꽤 먹고 있는걸 볼 수 있습니다.

Consumer함수가 하염없이 데이터가 들어오기를 기다리는 것보다는 데이터가 들어올때 까지 쉬다가 데이터가 들어왔다는 시그널이 켜지면 
그때 일을 시작하는게 더 효율이 좋을 수 있는겁니다. 

이걸 실습하기 위해 이벤트를 활용해볼겁니다. 

::CreateEvent 라는 windows API 입니다. 이 함수는 인자를 4개 받는데 두번째, 세번째 인자가 중요하고 그 중 두번째 인자가 특히 중요합니다. 
먼저 첫번째 인자의 경우에는 보안 속성과 관련있는데 아직 배우지 않아서 신경쓰지 않을것이기 때문에 NULL로 넣어주고 
두번째 인자는 수동으로 리셋을 시켜줄것이냐 자동으로 리셋을 시킬것이냐를 골라주는겁니다. True를 주면 Manual reset 수동으로 리셋 시키겠다는 말이고 
False를 주면 Auto Reset 자동으로 리셋시켜달라는 말입니다.
세번째 인자는 bool 타입으로 초기 상태를 정하는 인자입니다. True를 주면 시그널을 킨 상태가 기본으로 설정하는것이고 False를 주면 시그널을 
끈 상태가 초기 상태인걸로 하는것입니다. 
네번째 인자는 이 이벤트의 이름을 지어 줄 수 있습니다. 

우리 실습에서는 이벤트를 아래와 같이 만들었습니다. 

	::CreateEvent(NULL/*보안속성*/, FALSE/*bManualReset*/, FALSE/*bIntialState*/, NULL/*Name*/);

이렇게 크리에이트 이벤트를 하면 이건 어디까지나 유저레벨 클라이언트 단에서 마음대로 조작할 수 있는건 아니고 
이벤트라는것 자체가 커널쪽에 만들어지고 커널쪽에서 처리할 수 있기때문에 이벤트를 커널 오브젝트라고도 부릅니다. 
그리고 이 CreateEvent는 반환으로 HANDLE 이라는 타입을 반환하는데 
이 핸들은 우리가 사용하던 int 타입처럼 어떤 숫자를 뜻하는데 
이 숫자가 아무 의미없는 숫자는 아니고 일종의 번호표라고 생각하면 되겠습니다. 
만약 CreateEvent 의 반환된 핸들의 값이 10번이라면 나중에 커널단에 이벤트를 사용하고 싶다고 할때 10번에 해당하는 이벤트에 대해 
무언가를 해주세요 라고 요청할 수 있는겁니다. 이벤트가 꼭 하나만 있을거라는 보장은 없으니까 여러 이벤트중에 이용하고자 하는 이벤트가 
무언지 특정하기 위한게 핸들입니다.

실습에서는 핸들을 mutex나 queue 같이 전역 변수로 만들어서 Producer나 Consumer에서도 접근할 수 있게 해주겠습니다.

그리고 핸들은 객체의 new, delelte 처럼 마지막에 CloseHandle(handle); 처럼 닫아줘야합니다.

다음 설명할것은 아까 이벤트가 커널 오브젝트라고 했는데 이 커널 오브젝트의 의미는 커널에서 사용하는 오브젝트 말그대로입니다. 
그래서 이벤트 뿐만 아니라 다양한 커널에서 관리하는 객체를 만들어 줄때 이 객체 데이터들을 관리하는 데이터 블록이 커널 오브젝트입니다. 
기본적으로 커널 오브젝트가 가지고 있는 공통적인 속성이 있는데 
Usage Count	라고 해서 이 오브젝트를 몇명이 사용하고 있는지를 관리하는 것이 있고 
Signal / Non-Signal  는 위에서 설명했듯이 bool 타입처럼 사용되고 켜지고 꺼지는 두가지 상태를 가질 수 있는겁니다. 
이 두가지 는 커널오브젝트가 가지고 있는 공통 속성이고 

이번에 배우는 Event에서는 추가로 
Auto / Manual 자동 수동을 고르는 bool 타입으로 된 속성이 있습니다. 
커널 오브젝트 중에 Event는 가벼운 편에 속하기 때문에 부담없이 사용할 수 있습니다. 가볍다는건 상대적으로 가볍다는 말입니다. 

이 속성들을 이용해서 유저레벨의 Producer 함수와 Consumer 함수에서 커널 오브젝트인 Event를 참조하고 있다가 Event의 속성중에 
Signal인지 Non-Signal인지를 확인하고 실행할지를 관리해주는겁니다. 

이제 Producer 쪽에서 데이터를 밀어넣어 줄 때 아무것도 안하고 그냥 밀어넣었지만 이제는 한가지 과정을 더합니다. 

void Producer()
{
	while (true)
	{
		{
			unique_lock<mutex> lock(m);
			q.push(100);
		}

		::SetEvent(handle);

		this_thread::sleep_for(100ms);
	}
}

::SetEvent(handle); 이 코드가 추가 되었는데 이 코드가 무슨 일을 하는것이냐면 Main 에서 생성한 Event의 Signal을 켜서 파란불로 바꿔 주세요 
라고 하는겁니다. 일종의 불리언이라고 했던 Signal을 false 에서 true 로 바꿔 주는겁니다. 

Consumer 쪽에서는 지금까지 q에 데이터가 들어올때 까지 의미없이 루프를돌고 있었는데 이제는 추가되는 코드가 생깁니다. 


void Consumer()
{
	while (true)
	{
		::WaitForSingleObject(handle, INFINITE);

		unique_lock<mutex> lock(m);

		if (q.empty() == false)
		{
			int32 data = q.front();
			q.pop();
			cout << data << endl;
		}
	}
}

::WaitForSingleObject(handle, INFINITE);
이 코드가 추가 되었는데 인자로는 EVENT를 만들었던 핸들과 INFINITE라는 걸 주었습니다. 두번째 인자에는 얼마나 기다릴지 시간을 넣어주는데 
INFINITE는 커서를 가져다 대 보면 사실 -1 을 뜻합니다. 
Main에서 전역변수 handle 에 생성한 Event를 Consumer의 WaitForSingleObject가 인자로 받고 그 Event의 State 상태가 Signal이면 진행을 하고 
만약 Non-Signal 상태이면 해당 쓰레드가 진행되지 않고 수면상태로 들어가게 될겁니다. 
그렇게 while을 무한 뺑뺑이 도는게 아니라 일시정지를 합니다.  

이렇게 전역변수 handle 과 Main에서 CreateEvent, Producer에서는 SetEvent, Consumer에서는 WaitForSingleObject
네줄의 코드가 추가 되었을 뿐인데 이전과 동작 방식이 완전히 달라집니다. 

그리고 CreateEvent의 두번째 인자인 bManualReset 부분을 False로 만들어서 Auto 인 상태인데 이게 어떻게 동작하냐면 
기본상태인 Non-Signal 에서 Producer에서 데이터를 밀어넣으면서 SetEvent 로 Signal로 설정하면 Consumer의 
WaitForSingleObject에서 Signal이 켜졌음을 감지하고 이 쓰레드를 깨워서 동작 시킨다음 바로 Non-Signal로 자동으로 세팅합니다. 

만약 bManualReset 을 True로 설정해서 Manual Reset 으로 설정하면 Consumer의 WaitForSingleObject 를 통과한 다음 
자동으로 Non-Signal이 되지 않기때문에 직접 ::ResetEvent(handle); 이라는 명령어로 직접 꺼줘야 합니다. 

우리 실습에서는 Auto Reset 상태로 진행할겁니다. 

이제 Event를 적용한 프로그램을 실행해보면 이전과 비슷하게 실행되는것 같지만 CPU점유율은 거의 없다시피하는정도로 줄어든걸 확인할 수 있습니다. 

다시 집어보면 Producer에서 데이터를 하나 밀어주고 SetEvent 로 생성한 Event의 Signal 을 켜주고 sleep_for 로 1000ms 동안 잠들면 
Signal 이 켜진 순간 t2 쓰레드가 Consumer의 WaitForSingleObject를 통과해서 데이터를 처리하는 것이었습니다. 그리고 나서 다음 Signal이 켜질때까지
t2 쓰레드도 잠들어서 CPU의 점유를 풉니다.


그리고 이제 이 Event 자체도 종종 사용하기는 하지만 다른 형태로 변주되어서도 자주 사용된다고 합니다. 다른 변주 버전은 이 후에 배우게 될겁니다.


- 정리 
이번 시간 중요했던 내용은 Event를 사용하면 계속 무한 루프를 돌면서 CPU를 점유하고 있는게 아니라 신호가 켜졌을때 만 쓰레드가 동작하고 
신호가 꺼지면 CPU 점유를 반납하고 대기 상태로 돌아가는겁니다.

겸사 겸사 커널 오브젝트라는 개념도 조금 알아봤습니다. 
이런 Event나 다른 커널 객체를 이용하게 되면 어떤 장점이 있냐면 지금은 하나의 프로그램 내에서만 동기화 작업을 하고 있는데
그게 아니라 다른 프로그램 사이의 동기화를 할때도 커널 객체를 사용합니다.

기존에 만들었던 스핀락 동기화 방법은 유저 레벨에서만 이뤄지는 동기화 방법이었다면 이번 Event 로 하는 동기화 방법은 
커널 레벨까지 확장된 동기화 방법이었습니다. 
그만큼 활용성이 높아지기는 하지만 단점이라고 하면 유저레벨안에서 처리하는 방법이 아닌 제 3자 커널 영역까지 끌여들여서 추가 비용을 들이는 점이 
단점입니다. 
이 동기화 방법이 사용되는 케이스가 너무 자주 일어나는 케이스라면 커널영역을 거치는 이 방법이 오히려 악수가 될 수 있습니다.

상황에 따라 적절한 방법을 사용하는게 중요하겠습니다. 