

    TCP 서버 실습


네트워크 프로그래밍에서 두번째 내용인 TCP 서버 실습입니다. 이전 시간에서는 아주 간단한 소켓 프로그래밍 코드를 작성하고 실행 시켜봤습니다. 
큰 틀에서 이런 흐름으로 진행된다는것을 배울 수 있었습니다. 

이제 이어서 간단하게 클라이언트와 서버간에 데이터를 송수신하는 실습을 해보겠습니다. 

이전 실습했던 코드를 보면 클라이언트 측에서는 먼저 WSAStartup 함수로 WinSock 을 시작하고 클라이언트측 소켓을 만들었습니다. 
소켓을 만들때는 
SOCKET clientSocket = ::socket(AF_INET, SOCK_STREAM, 0); 이렇게 만들었는데 각 인자가 뜻하는것은 IPv4, IPv6 같은 IP주소 체계를 골라주는 부분,
SOCK_STREAM 은 TCP SOCK_DGRAM 은 UDP 라는 소켓 유형을 정하는 부분이고 세번째는 사용할 특정 프로토콜을 지정하는 정수인데 보통 첫번째 두번째 인자를 넣었으면 
0으로 둔다고 합니다. 
그리고 socket 함수의 반환값은 SOCKET 이라는 typedef 인데 실제로는 UINT_PTR, unsigned __int64 입니다. 그러니까 어떤 정수를 반환받는건데 이 정수에따라
만든 소켓이 몇번소켓인지 운영체제에게 알려주는 역할을 한다고 합니다. 이후 이 소켓이 오류 없이 생성이 되었는지 체크하는 코드도 사용했습니다. 

클라이언트 소켓을 만들었으면 연결을 시도할 서버의 주소를 설정합니다. 우리 실습에서는 IPv4 체계를 사용할것이기 때문에 
서버쪽도 같은 체계의 주소 구조체를 만들어 줍니다. 
SOCKADDR_IN serverAddr;     이 SOCKADDR_IN 이라는 구조체가 IPv4 용 주소를 담는 구조체입니다. 
serverAddr이 혹시 다른 데이터가 들어있을 수 있으니 memset 을 사용해 0으로 밀어주고 SOCKADDR_IN의 데이터들을 담아줄겁니다. 
SOCKADDR_IN 의 내용물에는 sin_family, sin_addr, sin_port 가 있습니다. sin_family와 sin_port 는 unsigned short 이고 sin_addr은 unsigned long 입니다. 
즉 다 어떤 정수를 담고 있는데 sin_family는 AF(Address Family)를 어떤걸 사용하는지를 뜻하고 sin_addr 은 연결할 서버의 ip주소를 담습니다. 
sin_port 는 서버의 주소에서도 세부적으로 접근할 포트 번호를 정합니다. 
주소와 포트의 관계는 어느 건물의 몇호실 같이 큰 범주의 주소가 ip주소, 해당 ip 주소에서도 세부적인 주소가 포트입니다. 

연결하려고 하는 서버의 주소도 만들었으니 연결(connect)를 할 차례입니다. 
인자로는 클라이언트의 소켓, SOCKADDR* 로 캐스팅한 serverAddr, serverAddr의 크기를 넣어주면 됩니다. 
connect 함수는 실패했을때 SOCKET_ERROR 라는 -1 정수를 반환하는데 그걸로 에러 체크를하면되고 

여기까지 모든 에러 상황을 피했다면 이제 서버와 연결이 되었다는 뜻이고 하려고 하는 일을 하면됩니다. 이 부분에서 오늘 강의내용이 들어갑니다. 

    char sendBuffer[100] = "Hello World!";
    int32 resultCode = ::send(clientSocket, sendBuffer, sizeof(sendBuffer), 0);
    if (resultCode == SOCKET_ERROR)
    {
        int32 errCode = ::WSAGetLastError();
        cout << "Send ErrorCode : " << errCode << endl;
        return 0;
    }

    cout << "Send Data! Len : " << sizeof(sendBuffer) << endl;

이게 데이터를 보낼때 사용하는 코드인데 중요한것은 send 라는 함수입니다. 이 함수를 통해 연결된 서버로 데이터를 전송하는것인데 

반환 타입은 어떤 정수를 반환하는데 이 정수는 데이터가 잘 전송되었는지 실패했는지의 코드입니다. 잘 전송되었으면 보낸 데이터의 바이트 수를 반환하고 
실패하면 -1 을 반환한다고 합니다. 
시그니처를 보면 
::send(SOCKET s, const char* buf, int len, int flag); 
라고합니다. 이제는 조금 보면 어떤 내용인지 대충 알 수 있는데 

첫번째 인자인 SOCKET 은 딱 봐도 데이터를 보내는 측의 소켓입니다. 지금 클라이언트 테스트 코드에는 소켓이 하나뿐이기도 한데 clientSocket을 줍니다. 
두번째 세번째 인자는 아마 보낼 데이터에 관한 인자들입니다. 위에서는 char 타입 100개짜리 배열을 넘겨주고 있습니다. 배열 자체가 포인터를 이용한 
컨테이너기 때문에 그대로 넘겨줘도 됩니다. 그리고 세번째 인자는 보낼 데이터의 사이즈를 주면되는데 
위에서 sendBuffer 자체는 100 바이트 짜리 크기이지만 넣어준 내용물은 Hello World! 라는 문자열 뿐입니다. 그러면 사이즈가 100 이라고 해야하는지 
13 (널 종료 문자까지 포함)을 줘야 할지 햇갈리는데 지금은 그냥 sendBuffer 자체의 크기 100을 주었습니다. 
마지막 인자로 flag 라고 하는데 전송에 대한 플레그입니다. MSG_DONTROUTE, MSG_OOB 같은 플레그를 줄 수 있는데 그냥 0으로 두고 사용해도 된다고 합니다. 

결국 이코드에서는 서버로 "Hello World!" 라는 문자열을 전송하고 있습니다. 
클라이언트는 일단 이정도로 해두고 서버쪽을 보겠습니다. 

서버에서는 이전시간에 배웠던 내용을 복습해보자면 클라이언트와 비슷하지만 좀 더 복잡한 과정을 거칩니다. 

WinSock 활성화하는 것, 서버쪽 소켓인 listenSocket을 만드는 부분까지는 비슷합니다. 그 다음 다른 부분이 서버 자신의 주소를 SOCKADDR_IN 으로 
담아 놓는것입니다. 
그리고 나서 listenSocket에 자신의 주소인 serverAddr 을 bind 해줍니다. 바인드 까지 했으면 listen 함수를 통해 들어올 연결 요청을 기다립니다. 
요청이 들어 왔으면 accept 함수로 실제 연결을 함과 동시에 클라이언트의 소켓과 주소를 받아서 직접 서로 데이터을 전송합니다. 

이부분에서 오늘 내용이 들어갑니다. 

    // TODO
    while (true)
    {
        char recvBuffer[1000];
        int32 recvLen = ::recv(clientSocket, recvBuffer, sizeof(recvBuffer), 0);
        if (recvLen <= 0)
        {
            int32 errCode = ::WSAGetLastError();
            cout << "Recive ErrorCode : " << errCode << endl;
            return 0;
        }

        cout << "Recv Data! Data = " << recvBuffer << endl;
        cout << "Recv Data! Len = " << recvLen << endl;
    }

send 한 데이터를 받는 쪽 함수는 recv (Recive) 입니다. 받는 인자의 타입이나 반환 타입이나 send와 아주 비슷합니다. 그렇지만 용법은 조금 주의해야하는데 
먼저 send에서는 데이터를 보내는 입장이다 보니 보낼 버퍼에 데이터를 채워서 보냈지만 받는 입장에서는 텅빈 버퍼로 받아줘야합니다. 
여기서는 넉넉하게 1000 바이트 크기의 버퍼로 받아주고 있습니다. 
그리고 첫번째 인자인 소켓에는 어떤 소켓을 넣어줘야 하는지도 햇갈릴 수 있습니다. 서버쪽에서는 맨처음 listenSocket 과 이후 accept 로 생성한 clientSocket 
두가지가 있기 때문인데 
네트워크를 비유한 예시에서 맨처음 전화를 받는 대리인이 listenSocket 이고 이후 용무를 처리하는 쪽의 대리인을 clientSocket 라고 합니다. 
그렇게 생각하면 listenSocket 은 한번 clientSocket에 인계를 했으면 이후로는 고객은 접촉할 일이 없어집니다. 
마찬가지로 코드에서 accept 이후로는 clientSocket 으로만 통신을 하면 되는겁니다. 

이렇게 recv 함수가 실행되면 빈환값으로 받은 데이터의 크기가 정수로 반환됩니다. 만약 제대로 실행되지 않았다면 -1 이 반환될겁니다. 
지금이야 그냥 Hello World! 라는 문자열을 주고 받고 있는데 이 데이터를 ASCII 문자열을 주고 받지만 
나중에는 그냥 정수일 수도 있고 어떤 타입이 왔는지 알 수 없는겁니다. 이 부분은 나중에 패킷에 대해 배울때 더 자세히 알아보겠습니다. 

이렇게 클라이언트에서 서버로 데이터를 보내는 코드를 작성 해 봤는데 다음으로 클라이언트에서 송신한 데이터를 서버가 그대로 바로 되돌려 송신하는 
방식을 만들어 보겠습니다. 
이 방식을 '에코 서버(Echo Server)'라고 합니다. 

    int32 resultCode = ::send(clientSocket, recvBuffer, recvLen, 0);
    if (resultCode == SOCKET_ERROR)
    {
        int32 errCode = ::WSAGetLastError();
        cout << "Send ErrorCode : " << errCode << endl;
        return 0;
    }

간단하게 만들 수 있는데 클라이언트에서 데이터를 보내는 코드 그대로 사용하면 됩니다. 대신 보내는 데이터인 버퍼는 아까 수신한 데이터인
recvBuffer 로 그 크기도 받은대로인 recvLen 으로 두었습니다. 

이렇게 하면 클라에서 서버로 서버에서는 받은 데이터를 추출하고 프린트후 다시 클라로 되돌려 보냅니다. 

또 다시 클라에서도 서버에서 되돌아온 데이터를 받는 코드를 작성하면 무한히 반복하는 코드가 될것 같습니다.

이제 한번 실행해보면 this_therad::sleep_for(1s); 로 인해 1초에 한번씩 서로 데이터를 주고 받으면서 커맨드 프롬프트에서 출력되고 있습니다.

생각보다 간단하게 서버 클라 간 통신이 이뤄지는건가? 생각이 들지만 아직 전부 배운것은 아닙니다. 
좀 더 고찰할 부분들이 남아있습니다. 

먼저 send 와 recv 가 동작하는 방식에 대해 몇가지 테스트를 해볼겁니다. 우리 같은경우는 나중에 온라인게임을 만들려고 할때 send, recv 를 통해 만들 수 있을까를 
고민해봐야합니다. 그냥 함수 그대로가 아니라 내가 구현하려는 분야에 어떻게 사용 응용할건지를 생각해야합니다.

현재는 1.클라에서 데이터 send, 2.서버에서 데이터 recv, 3.서버에서 클라로 다시 send, 4.클라에서 recv 
라는 4가지 단계로 동작하고 있는거 같습니다. 

이때 만약 서버쪽에서 recv, send 하는 코드들을 모두 주석처리 해보면 어떻게 동작할까요?

그냥 생각하기로는 클라에서 데이터를 send 했지만 서버에서 recv 해주는 코드가 없기 때문에 send 가 실패해서 에러코드가 출력되던가 
아니면 recv 해줄때까지 코드가 멈춰있던가 할것 같습니다. 
하지만 실행해보면 클라의 send가 성공해서 100바이트의 데이터를 전송했다는 로그가 나옵니다. 서버쪽에서는 accept 까지 된 후 
클라와 접속이 되고 아이피 까지 출력하는 곳 까지만 진행됩니다. 디버깅중 아예 종료가 아니라 일시정지를 하면 어느 부분을 실행하고 있는지를 알 수 있는데 
서버코드 중 이전에 recv, send 코드를 작성했던 while 문에서 돌고 있습니다.

send, recv 함수들은 블로킹함수(Blocking Function)입니다. 블로킹 함수란 실행을 완료할때 까지 다음코드로 진행하지 않는 함수입니다. 약간 멀티쓰레드에서의 락과 비슷한
느낌입니다. 
그러면 블로킹함수인 send가 왜 서버쪽엔 recv 로 받지도 않았는다 그냥 지나가 버렸을까요?
그 이유를 알기 위해서 잠시 설명을 해보겠습니다.

        소켓 입출럭 버퍼는
    가장 기본적인 네트워크 통신을 하면서 send 와 recv 를 건드려보고 있었는데 어떻게 동작하길레 서버에서 받지도 않았는데 send가 블로킹되지않고 그냥 넘어갔을지
    궁금합니다. 
    
    원리를 알기 위해서는 소켓 입출력 버퍼에 대한 내용을 어느정도 이해하고 있어야합니다. 그리고 이 내용이 앞으로 두고두고 등장할 내용입니다.

    일단 클라이언트와 서버가 있고 서로 소켓생성들이 되고 커넥션 까지 진행 되었다고 하겠습니다. 
    (즉, 클라에서는 소켓 생성 후 커넥트, 서버에서는 소켓생성 자신주소와 바인드 리슨 어셉트 까지 마친 상태)
    그러면 소켓이 만들어 졌을때 일반적인 유저 레벨이 아닌 운영체제에서 관리하는 커널영역에 송수신과 관련된 버퍼들이 생성됩니다. 
    RecvBuffer와 SendBuffer 가 만들어 지는데 클라에 한쌍 서버쪽에 한쌍씩 만들어집니다. 

    아까 클라에서 서버로 Hello World! 라는 '패킷'을 만들어서 send로 보내줬습니다. 
    이 동작이 그냥 함수를 사용한 막 바로 클라에서 서버로 전송이 되는것 처럼 느꼈지만 사실은 유저레벨에서 호출한 함수들은 다 기기를 직접 건드릴 
    권한이 없기때문에 모두 운영체제에 이런 일을 해달라고 요청을 합니다. 

    그래서 아까 Hello World! 라는 문자열을 send 했을때 실제로 일어난 일이 무엇이냐면 클라이언트에서 클라이언트 측 SendBuffer 에 Hello World! 문자열을 복사하려고 시도합니다.
    이 작업을 send 함수가 하는 일이고 send는 클라측 커널영역 SendBuffer에 데이터를 넘겨줬으니 자신은 할 일이 끝났다고 인식합니다. 
    아까 실질적으로 서버에서는 데이터를 받지 않았습에도 불구하고 블로킹함수인 send가 혼자서 성공적으로 완료되었다고 나온 이유가 이것입니다. 

    소위 블로킹함수임에도 실제 코드상에서 딱 그 위치에 블로킹되지 않을 수 있다는말입니다. 의도와 다르더라도 블로킹함수의 실제 동작이 이루어졌다면 그대로 진행이 되는겁니다.

    이제 우리의 임무인 send 함수 호출하기는 여기서 마무리 되는거고 기기 내부적으로 운영체제끼리 작업을 해서 상대방 컴퓨터(서버)쪽 RecvBuffer에 어떻게든 
    데이터를 보내주게 됩니다. 이 동작은 유저레벨에서는 신경쓸 필요가 없습니다. 여기까지 아직 서버에서 recv 함수를 호출하지 않은상태입니다. 

    서버에서 recv 함수를 호출하게 되면 커널레벨에서 알아서 RecvBuffer로 받은 데이터를 꺼내게 될겁니다. 이때 이미 Hello World! 문자열이 도착해 있다면 
    recv 함수는 성공적으로 버퍼 변수에 데이터를 복사해주고 호출성공으로 처리하게 될겁니다. 

    이렇게 유저레벨에서만 동작하는게 아니라 커널 레벨에서 어떻게 동작하는지를 알게되니 send후 recv를 해주지 않아도 왜 그냥 성공했다고 나오는지 이해가 갑니다. 

    이제 조금 상황을 바꿔서 생각해보겠습니다. 
    다시 처음부터 클라이언트에서 send 를 호출할때로 돌아가는데 이때 클라쪽 SendBuffer가 이미 꽉 차있는 상태에서 send 함수를 호출했다고 하면 어떤일이 발생할까요?
    send 함수는 보낼 데이터를 클라 자신쪽 SendBuffer로 넘기는 동작을 하던 함수인데 그 메모리가 꽉차있다면 send는 자신의 동작을 완수하지 못하고 
    블로킹(정지) 되어 있게됩니다. 이때 물론 기다린다고 해서 계속 무한루프를 도느라 cpu 소모를 많이 해가면서 기다리는건아니고 이 프로세스가 잠들게 되고 
    send가 동작할때까지 잠들게 됩니다. 
    그러면 다음으로 이어 동작하려면 어떻게 해야하느냐 하면 커널영역 운영체제에서 알아서 상대방 서버쪽 RecvBuffer로 데이터를 전송이 되어야지만 공간이 확보되고 
    이때 다시 send 함수가 데이터를 밀어넣고 완료를 할 수 있게 됩니다. 

    다음 케이스는 이번에 서버에서 recv 함수를 호출하는데 이때 만약 서버쪽 RecvBuffer 에 아무런 데이터가 없을때는 어떻게 동작할까요?
    어느정도 대칭성이 있는데 recv 함수는 RecvBuffer에 있는 데이터를꺼내는 동작을 하는데 텅텅비었다면 recv의 프로세스는 잠이 들어서 블로킹을 하게 됩니다. 
    마찬가지로 언젠가 클라로부터 데이터가 들어올때까지 기다렸다가 다시 동작하게 될겁니다. 

    결국 서버와 클라이언트 간에 서로 데이터를 보냈으면 그만큼 받아줘야 서로 커널쪽 버퍼에 쌓이지않고 잘 처리가 될겁니다. 

    극단적으로 클라측에서 send를 호출하는데 클라 SendBuffer와 서버 RecvBuffer까지 꽉차있는 상태라면 운영체제도 더이상 동작하지 못하고 더 더욱 심한 
    정체에 빠집니다. 
    해결은 서버쪽 유저레벨에서 recv 함수로 데이터를 하나씩 처리해 RecvBuffer에 공간을 만들어야 합니다.

    즉 send가 블로킹이 되는 조건은 send를 하는쪽 커널영영의 SendBuffer가 꽉 차있을때 블로킹이되고,
    반대로 recv가 블로킹 되는 조건은 recv를 하는쪽 커널영역의 RecvBuffer에 아무 데이터가 없을때 블로킹이됩니다. 

    그래서 우리 테스트 케이스에서 서버쪽에서 데이터를 받아주는 코드가 없는데도 클라의 send는 성공적으로 동작하는 이유를 알 수 있었습니다. 
    게다가 클라 recv 에서 더이상 진행이 되지 않은 것도 상대방이 보내준 데이터가 없다 보니 블로킹이 걸렸던 것이었습니다. 

    이렇게 send, recv 라는 블로킹 함수를 사용한 가장 기본적인 통신에 대해 배워 보았고 이걸 또 우리의 목적인 게임에 적용한다면 어떨까 생각을 해보았습니다. 
    매우 골치아픈 문제가 생길것 같은데 클라이언트에서 데이터를 send를 한다고 해도 서버에서 당장 recv를 해주지 않는다고하면 클라는 send 코드에서 멈춰버릴것이고 
    반대로 상대방에서 데이터가 넘어오지 않아도 블로킹이 될겁니다. 

    멀티쓰레드 쪽 내용에서 알아봤던 것처럼 블로킹할때 계속 무한루프를 돌면서 cpu를 점거하지는 않지만 sleep_for 이나 조건변수같이 한번막히면 
    자기 프로세스의 cpu 사용권을 내려놓으면서 동작할것입니다. 

    온라인 게임의 클라이언트가 블로킹이 걸렸을때 서버쪽에 어떤 문제가 생겨서 처리가 늦는다고 하면 클라쪽에서는 네트워크에 막혀서 다른 그래픽스 작업같은 
    무거운 작업까지 멈춘다는것은 말이 안되는 상황입니다. 
    그러면 쓰레드를 하나더 만들어 거기에 네트워킹작업을 시키면 되지 않을까 생각도 드는데 이 방법은 클라이언트 측에서는 할 수 있는 방법일겁니다. 
    하지만 서버는 다릅니다. 서버로 접속하는 클라이언트의 수가 수천 수만이 될 수도 있는데 각 클라이언트갯수마다 쓰레드를 만들어 처리하는것은 무리가 있습니다. 
    그러면 어떻게 하느냐 나중에 블로킹 함수가 아닌 다른 방식의 함수를 알아보겠습니다. 


    다음으로 또 해볼 실습이 있는데 서버쪽에 주석 처리 했던 코드들 중에 recv 하는 코드들만 다시 살려 보겠습니다. 그리고 recv 코드가 실행되기 전에 
    this_therad::sleep_for(1s); 로 1초씩 멈춰주었습니다. 
    반대쪽 클라이언트에서는 send 함수를 반복문을 사용해 10반복해 보내도록 하고 recv 코드는 주석 처리 해두었습니다. 

    알아보고싶은것은 데이터를 보내는 측에서 100바이트 씩 10개의 데이터를 연속해서 보내고 데이터를 받는 측에서는 1초에 한번씩 동작하는 recv 함수가 
    두번째 문제입니다. 아까 send 함수의 동작원리를 알아볼때 유저레벨에서 보낸 데이터를 SendBuffer에 차곡차곡 쌓이는것 처럼 말했지만 사실 데이터끼리 
    구분되어있는게 아니라 뭉텅이로 담깁니다. 이것이 TCP 의 특징이라고합니다. 
    이후 TCP, UDP 에 대해 자세히 알아볼것이긴한데 이번시간에 간단하게 조금 알아보겠습니다. 

    일단 두번째 문제를 실행해보면 클라쪽에서는 100바이트를 보냈다고 출력되고 서버에서는 1000바이트를 받았다고 출력이 됩니다. 
    코드 자체가 100바이트 짜리 배열에 Hello World! 라는 문자열을 담은 걸 10개 보냈어서 100바이트 보냈다고 출력이 되지만 
    서버쪽에서는 한번에 쌓인 100 x 10 크기의 데이터를 받아버림으로써 1000바이트 크기의 데이터를 받았다고 출력합니다. 다만 받은 데이터를 출력하는 부분에서는 
    Hello World! 열개가 아니라 한개만 출력하고 있는데 1000바이트 크기의 데이터라도 문자열은 시작 주소로부터 null 중단 지점까지의 데이터만 문자열로 인식하기 때문에
    가장 앞의 문자열만 출력하는것입니다.

    따라서 클라이언트에서 데이터 10개를 한번에 send 하면 데이터 하나씩 전송이 되서 recv도 10번에 나눠 실행되는것이 아니라 
    10개의 데이터가 한번에 뭉쳐서 전송되게 되는겁니다. recv도 전송받은 모든 데이터를 한번에 뭉쳐서 받아줍니다. 
    그러면 발생하는 문제는 분명 100 바이트 짜리 데이터를 10개 를 보냈는데 서버 에서 받은 데이터는 이 데이터 뭉치가 몇바이트 단위로 나눠서 해석해야하는지를 전혀 
    알 수 없습니다.

    그렇다는것은 실제로는 100바이트 짜리 데이터 10개 라는걸 어떻게 서버에 알려주느냐 하면 현재로는 따로 알려줄 수 없고 나중에는 
    결국 데이터 자체에 이 데이터는 어느정도의 크기로 되어있다고 기입을 해주어야 합니다. 
    이 내용은 이번시간에는 직접 다루지는 않을것이고 일단 TCP에서는 전송하는 데이터에 바운더리가 없다 라는 특징을 알고 가는것에 의미를 두겠습니다. 

    TCP에서는 데이터의 바운더리가 없다보니 만약 상대쪽 RecvBuffer에 여유공간이 50바이트 뿐이 남지 안았다면 sendBuffer 에서 보내는 데이터도 50 바이트가 가게됩니다. 
    그러면 원래 의도한바와 전혀 다른 정보가 될 수도 있습니다. 그렇기 때문에 이 것을 반드시 처리해줘야 하겠습니다.