


        XML Parser



우리가 지난시간까지 데이터 베이스 연동을 편리하게 하기위한 준비 작업을 해봤습니다. 
그냥 개인 프로젝트를 준비한다고 하면 여기까지만 해도 충분하고 넘친다고 할 수 있습니다. 

그래도 한발짝 더 나아가서 큰 프로그램을 출시한다거나 아니면 라이블까지 병행한다고 한다면 여기에 추가적으로 생각할게 좀 더 생깁니다. 

특히나 버전 관리를 어떻게 할것인지가 문제가 됩니다. 

버전관리에 대해 딱히 언급을 한적이 없을겁니다. 이 부분은 따로 찾아보면 많은 자료가 나오기 때문에 따로 다루지는 않은겁니다. 

보통은 git 을 말하는데 코드를 작업하고 커밋을 할때 마다 세이브 포인트를 만드는것과 비슷합니다. 
이게 왜 라이브에서 중요하냐면 라이브서비스에서는 항상 최신버전을 배포하는것이 아닙니다. 어느정도 다듬고 최대한 버그를 수정했다고 하면 그때서야 배포를하고 
작업은 다음 컨텐츠를 작업할것입니다. 

특히나 많은 사람들이 같이 작업하는 환경에서 더 중요한데 개인 프로젝트야 다른 사람이 건드리지 않고 나 혼자만 작업한다는 보장이 있지만
공동 프로젝트에서는 남이 건드린 코드에서 내 소스가 깨진다는 일이 비일비재 하다고 합니다. 그래서 가장 먼저 summit 하는 사람이 우선권을 가지는 일종의 선빵필승이 있다고 합니다. 

하여튼 소스코드는 이렇게 버전 관리 프로그램이 많습니다. 


하지만 데이터 베이스의 경우는 좀 달라지는데 우리가 연동한 데이터 베이스가 VisualStudio에서는 열어보고 확인할수 있지만 그렇다고 해서 이 데이터 베이스 자체를 버전관리 범위에 넣어주지는 
않았습니다. 
거기에 매번 서버를 띄울때 마다 매번 테이블들을 드랍한 수 다시 띄우는것은 간단하게 테스트 하니까 가능하지 사실 말이 안되는 얘기입니다. 
왜냐하면 만든 테이블에는 굉장히 중요한 정보가 들어 있을수 있습니다. 예를 들어 유저의 캐릭터 정보도 있을 수 있고 유저들의 골드와 캐쉬재화, 비싼 아이템 들이 있을텐데 

매 버전마다 전부 싹 드랍 해버리고 다시 테이블을 생성하는건 말이 안됩니다. 
결국은 어떤 식으로건 간에 지금 작업하고 있는 소스코드와 DB의 버전을 맞춰줄 필요가 있다는건데 이것에 ORM 기술을 사용하면 다 알아서 해줍니다. 

ORM기술이 어떤 느낌이냐면 소스코드의 버전이 올라가고 내려갈때 각각 데이터 베이스에 테이블을 어떻게 만들고 없애야 하는지를 관리하고있습니다. 
예를들어서 어떤 소스코드에서 한단계 아래버전으로 갈때 account라는 데이터가 없어진다고 하면 알아서 데이터베이스에  account라는 테이블을 드랍해주는 것입니다. 
이런건 마이그레이션 (Migration) 이라고 합니다. 

우리는 마이그레이션이 소스코드 상에서 관리하고 있고 또 소스 코드는 버전 관리 프로그램으로 관리하기 때문에 소스코드 버전 관리만하면 알아서 데이터베이스까지 버전을 쉽게 맞춰줄 수 있다는 말입니다. 

그런데 지금 우리가 테스트하고 있듯이 ODBC로 데이터 베이스 테이블을 쿼리로 직접 관리할때는 어떻게 해야 하는지를 생각해봐야 겠습니다. 
만약에 DB버전과 소스 코드의 버전이 맞지 않는다면 쿼리에서 테이블에는 id와 gold만 있을때 소스코드에서는 name과 creaetDate 까지 밀어 넣으려고할것입니다. 


이런문제를 해결하기 위해 고민을 해봐야 하는데 일단 두가지 스타일이 있을 수 있습니다 .

먼저 아까 알아본 마이그레이션 해주는 클래스를 직접 만들어 관리하는것입니다. 
따로 spl 파일을 만들어 쿼리를 관리해줄겁니다. 
예를들어서 DB_01.spl 이라는 파일을 만들고 

CREATE TABLE [dbo].[Version]
(
	[version] FLOAT NOT NULL
)

CREATE TABLE [dbo].[Gold]					
(											
	[id] INT NOT NULL PRIMARY KEY IDENTITY, 
	[gold] INT NULL,						
	[name] NVARCHAR(50) NULL,				
	[createDate] DATETIME NULL				
)

이런 쿼리를 저장해 두면서 버전이 늘때 DB_02.spl 을 만들어 거기에 맞는 쿼리를 또 저장하는 식으로 관리해주는 겁니다.

서버쪽 소스코드에서도 일종의 config 파일을 항상 들고 있을겁니다. 
DB 커넥션 스트링 뿐만아니라 서버 포트, 아이피 등 온갖 정보를 따로 config 파일로 빼서 관리를하는데 거기에 현재 서버가 연동해야할 DB 버전도 같이 기록을 하는겁니다.

이렇게 DB 버전을 관리하는 방법이 하나 있습니다.
이 방법의 문제점이라고 하면 아까 처럼 버전을 이동할때마다 UP이 있고 Down이 있는데 각 각 하나의 파일씩 스크립트를 만들어줄게 많다 보니 전문적으로 담당하는 인원이 있는경우는 상관이 없겠지만
어떤경우는 그냥 서버 프로그래머가 한번에 일을 맡는 경우도 있습니다. 


그래서 오늘 알아볼 것은 일종의 아주 간단한 ORM을 직접 만드는 방법입니다. 
DB 원본설계는 XML 파일로 관리를 하고 그걸 자동화 툴로 만들어 주는 방식입니다. 

그러면 바인드 계열의 함수도 자동 생성될 뿐만 아니라 DB 업데이트에 대한 스크립트도 자동 생성이 되게끔 하는겁니다. 


*** 

아까 임시로 만들었던 DB_01.spl 파일은 삭제해주고 새로 파일을 만들어 줍니다. GameDB.xml 이라는 이름으로 만들었습니다. 
<?xml version="1.0" encoding="utf-8"?>
<GameDB>
	<Table name="Gold">
		<Column name="id" type="int" notnull="true" />
		<Column name="gold" type="int" notnull="false" />
		<Column name="name" type="nvarchar(50)" notnull="false" />
		<Column name="createDate" type="datetime" notnull="false" />
		<Index type="clustered">
			<PrimaryKey/>
			<Column name="id"/>
		</Index>
	</Table>
</GameDB>

계속 사용하던 테이블을 xml로 묘사한겁니다. 

최상위로 GmaDB 라고 루트노드를 만들고 내부적으로 설계를 할겁니다 먼저 테이블이 하나 있습니다. 테이블 이름은 Gold로 지었었고 테이블 내부에서는 컬럼이 4개가 있었습니다. 
컬럼은 각각 id, gold, name, creaetDate 이었습니다. 
추가로 인덱스가 하나 있었는데 id에 할당되는 PrimaryKey였습니다. 따로 Index의 노드를 만들어 id를 대상으로 인덱스가 걸려있다고 표현했습니다. 

이제 이 xml 파일을 잘 파싱해서 이대로 테이블이 만들어 지도록 해주면 되겠습니다.

이어서 더 작업해보겠습니다.
	<Procedure name="spInsertGold">
		<Param name="@gold" type="int"/>
		<Param name="@name" type="nvarchar(50)"/>
		<Param name="@createDate" type="datetime"/>
		<Body>
			<![CDATA[
			INSERT INTO [dbo].[Gold]([gold], [name], [createDate]) VALUES(@gold, @name, @createDate)
			]]>
		</Body>
	</Procedure>

	<Procedure name="spGetGold">
		<Param name="@gold" type="int"/>
		<Body>
			<![CDATA[
			SELECT id, gold, name, createDate FROM [dbo].[Gold] WHERE gold = (@gold)
			]]>
		</Body>
	</Procedure>

Procedure 태그를 두개 만들었습니다. Procedure란 데이터 베이스에서 사용하느 함수 같은것입니다. 지금까지 직접 INSERT 문 SELECT 문을 사용하던걸 함수화 한겁니다. 
Param 이라고 이름 붙힌 태그는 함수에서 인자에 해당하는 것들이고 Body 라는 태크는 {} 구현부 라고 보면 되겠습니다. 
구현부 안에서 <![CDATA[]]> 라는 태그는 기본 자동완성에 있던 태그인데 이 태그의 사용법은 []안의 코드는 xml 코드로 인식하지 않고 그 통채로 C++ 코드로 인식해주는 용도입니다. 
C++ 코드인데도 해당 xml내에서 곂치는 키워드가 있으면 혼동이 생길수 있는거 방지해주는 공식 지원 태그입니다. 
그래서 구현부에는 INSERT 문 SELECT 문을 적었습니다. 

Param 의 이름에 @ 를 붙여 이름 지은 이유가 Body에 인자를 대입하기 위해서 입니다. 

일단 여기까지 설계는 완료가 되었는데 이제부터 우리만의 ORM 시스템을 만들어야 합니다.
이전시간까지 데이터 베이스를 다루던 코드들은 모두 날려주겠습니다. 대신 방금 만든 xml을 긁어와 사용할것입니다. 

하지만 C++에서는 표준으로는 xml을 긁어오는 기능을 지원하지 않습니다. 
rapidxml 이라는 라이브러리를 검색해 다운 받았습니다.
이 라이브러리는 따로 CMAKE 같은걸로 빌드해서 파일을 가져올 필요없이 그냥 소스코드 그대로 가져오면 되는 간편한 라이브러리입니다. 

여기에 추가로 Utils 필터 아래에 FileUtils 라는 클래스 파일을 추가해주겠습니다. 말그대로 파일을 읽고 어쩌고 하는 기능들을 여기서 관리해줄것입니다.

하나더 추가로 XML파일을 읽는걸 도와주는 헬퍼 클래스도 추가할건데 이건 XML 필터아래에서 관리하겠습니다. 

-- FileUtils

먼저 FileUtils로 표준 입출력함수를 추가하겠습니다. C++17에 추가된 filesystem이라는 라이브러리를 사용하는 방법인데 놀랍게도 C++은 이 파일시스템이 17버전이전에는 지원하지 않았다고 합니다. 
그냥 윈도우의 의존적인 함수를 이용하거나 리눅스에 의존하는 함수를 사용하곤 했엇는데 이젠 어느정도 표준에 들어 왔기 때문에 지원합니다. 

그래서 ServerCore의 C++ 버전은 다시 17버전으로 올려줘야 합니다.

#include <vector>
#include "Types.h"


/*---------------------
	FileUtils
----------------------*/
class FileUtils
{
public:
	static Vector<BYTE>			ReadFile(const WCHAR* path);
	static String				Convert(string str);
};


namespace fs = std::filesystem;

Vector<BYTE> FileUtils::ReadFile(const WCHAR* path)
{
	Vector<BYTE> ret;

	fs::path filePath{ path };

	const uint32 fileSize = static_cast<uint32>(fs::file_size(filePath));
	ret.resize(fileSize);

	basic_ifstream<BYTE> inputStream{ filePath };
	inputStream.read(&ret[0], fileSize);

	return ret;
}

String FileUtils::Convert(string str)
{
	const int32 srcLen = static_cast<int32>(str.size());

	String ret;
	if (srcLen == 0)
		return ret;

	const int32 retLen = ::MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<char*>(&str[0]), srcLen, NULL, 0);
	ret.resize(retLen);
	::MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<char*>(&str[0]), srcLen, &ret[0], retLen);

	return ret;
}

그냥 ReadFile, Convert 두개의 함수만 만들었습니다. 무슨 역할을 하냐면 fs 라는 키워드로 filesystem을 불러오고
파일경로 path를 인자로 받아서 그 경로의 파일을 긁어와 ret에 복사해 뱉어주고 있습니다. 
그리고 이 ReadFile은 utf-8 인코딩을 기준으로 동작합니다. 아까 만든 GameDB.xml도 utf-8로 인코딩되는데 이건 고정된것이 아니라 다른 인코딩으로 변경할
수는 있긴합니다. 하지만 많은 서비스들에서 utf-8을 많이 사용하고 있기도 하고 대부분 영문으로 코드가 작성될것이기 때문에 여기서도 그냥 utf-8 그대로 사용하겠습니다. 

다음은 Convert 함수입니다. 반환 타입이 String 이라는 타입인데 이것은 우리가 이전에 Container.h 에 정의해준 타입입니다. 
String, WString 두가지 버전이 있었는데 우리는 앞으로 WCHAR 기준으로 사용할것이기 때문에 기존의 String

using String = basic_string<char, char_traits<char>, StlAllocator<char>>;

이 using을 날려주고 

using String = basic_string<wchar_t, char_traits<wchar_t>, StlAllocator<wchar_t>>;

이 WString 이었던 using의 이름을 String으로 바꿔서 사용하겠습니다. 즉, Convert 의 반환타입은 사실 WString인겁니다. 
대문자로 시작하는 String은 wstring, 소문자로 시작하는 string은 말 그대로 string인겁니다. 
그래서 Convert 함수의 인자는 string을 받고 MultiByteToWideChar라는 윈도우즈 함수를 통해 String으로 변환을 해줍니다. 

FileUtils는 여기까지 하고 다은은 XMLParser로 넘어가겠습니다. 

-- XmlParser

이름 그대로 xml 파일을 파싱하는 클래스가 될겁니다. 아까 다운 받은 rapidxml 라이브러리를 사용하기 쉽게 래핑해주는 역할을 할겁니다. 
먼저 사용할 타입들을 using으로 선언 했습니다. 

using XmlNodeType = xml_node<WCHAR>;
using XmlDocumentType = xml_document<WCHAR>;
using XmlAttributeType = xml_attribute<WCHAR>;

그리고 XmlNode 라는 클래스와 XmlParser 라는 클래스 두개를 만듭니다. 실제로 사용할때는 XmlParser 객체를 생성하고 그 멤버 변수인 
ParseFromFile을 실행해주면 경로와 아웃풋으로 받을 XmlNode를 인자로 주면 경로에 있는 xml 파일을 FileUtils::ReadFile로 읽어온 다음 
FileUtils::Convert로 wstring으로 변환해 멤버 변수 _data에 담아줍니다.
그 후 _document를 생성해주고 있는데 이 _document는 rapidxml에서 지원하는 xml_document의 WCHAR 타입 입니다. 
그리고 마찬가지로 rapidxml에서 지원하는 parse라는 멤버 함수에 _data의 0번 인덱스의 주소를 넘겨주면 거기서 부터 파싱을 해주게 됩니다. 
마무리로 아웃풋으로 받을 root 라는 인자를 _document의 first_node를 생성자의 인자로 넘겨줍니다. 여기서 first_node는 
아까 GameDB.xml에서 <GameDB> 노드를 말하는데 이제 XmlNode 객체 root는 <GameDB>를 가리키고 있는 상태입니다.  
class XmlParser
{
public:
	bool ParseFromFile(const WCHAR* path, OUT XmlNode& root);

private:
	shared_ptr<XmlDocumentType>		_document = nullptr;
	String							_data;
};
/*---------------
	XmlParser
----------------*/

bool XmlParser::ParseFromFile(const WCHAR* path, OUT XmlNode& root)
{
	Vector<BYTE> bytes = FileUtils::ReadFile(path);
	_data = FileUtils::Convert(string(bytes.begin(), bytes.end()));

	if (_data.empty())
		return false;

	_document = MakeShared<XmlDocumentType>();
	_document->parse<0>(reinterpret_cast<WCHAR*>(&_data[0]));
	root = XmlNode(_document->first_node());
	return true;
}

그러면 XmlNode 클래스는 어떤 역할이냐면 루트노드로 부터 마치 트리구조처럼 되어 있는 xml 코드를 파싱하는걸 도와줍니다. 

class XmlNode
{
public:
	XmlNode(XmlNodeType* node = nullptr) : _node(node) { }

	bool				IsValid() { return _node != nullptr; }

	bool				GetBoolAttr(const WCHAR* key, bool defaultValue = false);
	int8				GetInt8Attr(const WCHAR* key, int8 defaultValue = 0);
	int16				GetInt16Attr(const WCHAR* key, int16 defaultValue = 0);
	int32				GetInt32Attr(const WCHAR* key, int32 defaultValue = 0);
	int64				GetInt64Attr(const WCHAR* key, int64 defaultValue = 0);
	float				GetFloatAttr(const WCHAR* key, float defaultValue = 0.0f);
	double				GetDoubleAttr(const WCHAR* key, double defaultValue = 0.0);
	const WCHAR* GetStringAttr(const WCHAR* key, const WCHAR* defaultValue = L"");

	bool				GetBoolValue(bool defaultValue = false);
	int8				GetInt8Value(int8 defaultValue = 0);
	int16				GetInt16Value(int16 defaultValue = 0);
	int32				GetInt32Value(int32 defaultValue = 0);
	int64				GetInt64Value(int64 defaultValue = 0);
	float				GetFloatValue(float defaultValue = 0.0f);
	double				GetDoubleValue(double defaultValue = 0.0);
	const WCHAR* GetStringValue(const WCHAR* defaultValue = L"");

	XmlNode				FindChild(const WCHAR* key);
	Vector<XmlNode>		FindChildren(const WCHAR* key);

private:
	XmlNodeType* _node = nullptr;
};

각각 타입에 따라 함수를 만들다 보니 길어졌습니다. 정의부 전체를 보기 보다는 일부를 예로 들어 보겟습니다. 

이해하기 쉬운 int32 를 보면 

int32 XmlNode::GetInt32Attr(const WCHAR* key, int32 defaultValue)
{
	XmlAttributeType* attr = _node->first_attribute(key);
	if (attr)
		return ::_wtoi(attr->value());

	return defaultValue;
}

_node는 루트 노드이고 여기부터 key에 해당하는 어트리뷰트가 있는지를 찾아 attr에 저장하고 attr 이 null 아니라면 attr은 string 형태일테니까
_wtoi라는 변환 함수를 이용해 string을 정수로 반환 해줍니다. 

그래서 래핑 함수를 만들어 주지 않으면 _wtoi 같은 함수를 직접 호출해줘야 합니다. 


최종적으로 만들어준 기능을 가지고 간단하게 파싱하는 실습을 해보겠습니다. 
테스트 코드는 이렇습니다. 

	//
	XmlNode root;
	XmlParser parser;
	if (parser.ParseFromFile(L"GameDB.xml", OUT root) == false)
		return 0;

	Vector<XmlNode> tables = root.FindChildren(L"Table");
	for (XmlNode& table : tables)
	{
		String name = table.GetStringAttr(L"name");
		String desc = table.GetStringAttr(L"desc");

		Vector<XmlNode> columns = table.FindChildren(L"Column");
		for (XmlNode& column : columns)
		{
			String colName = column.GetStringAttr(L"name");
			String colType = column.GetStringAttr(L"type");
			bool nullable = !column.GetBoolAttr(L"notnull", false);
			String identity = column.GetStringAttr(L"identity");
			String colDefault = column.GetStringAttr(L"default");
			// Etc...
		}

		Vector<XmlNode> indices = table.FindChildren(L"Index");
		for (XmlNode& index : indices)
		{
			String indexType = index.GetStringAttr(L"type");
			bool primaryKey = index.FindChild(L"PrimaryKey").IsValid();
			bool uniqueConstraint = index.FindChild(L"UniqueKey").IsValid();

			Vector<XmlNode> columns = index.FindChildren(L"Column");
			for (XmlNode& column : columns)
			{
				String colName = column.GetStringAttr(L"name");
			}
		}
	}

	Vector<XmlNode> procedures = root.FindChildren(L"Procedure");
	for (XmlNode& procedure : procedures)
	{
		String name = procedure.GetStringAttr(L"name");
		String body = procedure.FindChild(L"Body").GetStringValue();

		Vector<XmlNode> params = procedure.FindChildren(L"Param");
		for (XmlNode& param : params)
		{
			String paramName = param.GetStringAttr(L"name");
			String paramType = param.GetStringAttr(L"type");
			// TODO..
		}
	}
	//

하나씩 분석해보겠습니다. 

제일 처음에 XmlNode객체 root 와 XmlParser 객체 parser 를 생성하였고 parser의 ParserFromFile 함수로 GameDB.xml을 파싱해서 그 루트 노드를 root에 담아줍니다. 
이걸 == false로 체크해 실패하면 바로 리턴으로 빠져나오고 있습니다. 

그리고 나서 root 노드로부터 FindChildren 함수로 루트 노드 밑으로 모든 Table을 찾아서 Vector<XmlNode> tables 에 담아줄겁니다. 
근데 지금 만든 테이블이 Gold 테이블 밖에 없으니 하나만 들어 갈겁니다. 

tables를 순회하는 for문에서 처음 해주는 것은 GetStringAttr로 name 을 가져오고 있는데 
<Table name="Gold"> 여기서 name이 가리키는 Gold를 가져오는것입니다. 
다음은 역시 테이블에서 여러 컬럼들을 가지고 있을것이니까 Table에서 FindChildren(L"Column");으롤 컬럽들을 또 긁어와 하나씩 순회 할수 있습니다. 
긁어온 컬럼들을 순회하면서 컬럼이름, 컬럼 타입, 널 허용여부, 아이디, 디폴트 값을 가져옵니다. 

컬럼들을 체크한 후는 역시 FindChildren으로 인덱스를 긁어오고 있습니다. 

마찬가지로 Procedure도 파싱을 해줍니다. 

적당히 중단점을 잡고 한줄씩 실행하면서 의도한대로 각 변수에 값들이 들어오는걸 확인하였습니다.

여기까지 xml 파일을 만들고 그 데이터를 추출하는 작업을 해봤습니다. 아직은 추출까지만 했지만 이어서 다음 시간에는 추출한 데이터를 다시 데이터 베이스에 복원하는 작업을 해보겠습니다. 