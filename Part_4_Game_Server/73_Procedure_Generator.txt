


    Procedure Generator



진짜 서버 파트 마지막입니다. 

이전 시간에 말이 나온 김에 Procedure를 자동화 하는 부분 까지 만들어 보겠습니다. 

툴을 만들때는 이왕이면 언어를 통일하는게 관리하기 편하니까 패킷 자동화 툴과 마찬가지로 파이썬으로 작업해보겠습니다. 

선수 작업으로 이전 PacketGenerator를 만들었던 Tools 폴더 아래에 새 프로젝트 추가 -> Python 어플리케이션 추가 를 합니다. 
이름은 ProcedureGenerator 라고 하겠습니다. 이 프로젝트 아래에 다시 추가로 XmlDBParser.py 라는 항목을 추가
새 폴더 만들기 Template 추가 Template 밑으로 GenProcedures.h, Procedure.h 추가 까지 해줍니다.

자동화 툴은 이전과 마찬가지로 jinja2 를 가지고 만들것이기 때문에 구조가 비슷합니다. 

코드를 분석해보겠습니다. 
jinja2를 사용하는것이다 보니 시작은 똑같습니다. 

-- ProcedureGenerator.py

import argparse
import jinja2
import XmlDBParser 

세가지 를 import 해줍니다. 

def main():
    arg_parser = argparse.ArgumentParser(description = 'StoredProcedure Generator')
    arg_parser.add_argument('--path', type=str, default='C:/Users/seonguk/Documents/myProject/c++_gameprograming/Part_4_Game_Server/Server/GameServer/GameDB.xml', help='Xml Path')
    arg_parser.add_argument('--output', type=str, default='GenProcedures.h', help='Output File')
    args = arg_parser.parse_args()

먼저 아규먼트 파서를 만듭니다. 이 arg_parser의 설명은 StoredProcedure Generator아고 하고 경로를 설정해줄건데 타입은 string, 기본 경로는 저의 프로젝트 위치로 했습니다.
그리고 툴을 사용한 결과물을 어디에 둘건지도 설정합니다. GenProcedures.h 가 아웃풋 파일이 됩니다. 
다 설정 했으면 arg_parser.parse_args() 를 호출해 파싱한 결과물을 args에 저장합니다.

    if args.path == None or args.output == None:
        print('[Error] --path --output required')
        return

그리고 args에서 정상적으로 인자를 받았는지를 확인합니다. 제대로 받았다면 위의 조건문으로 들어오지 않을겁니다. 

    parser = XmlDBParser.XmlDBParser()
    parser.parse_xml(args.path)

XmlDBParser 객체를 생성해 parser 라는 변수에 담고 parse_xml을 합니다. 


-- XmlDBParser

XmlDBParser 의 parse_xml(path) 를 통해 경로에있는 파일을 파싱해주고 있습니다.
먼저 XmlParser클래스 부터 보겠습니다. 

import xml.etree.ElementTree as ET

class XmlDBParser:
    def __init__(self):
        self.tables = {}
        self.procedures = []
이 부분이 생성자에 해당하는것이었습니다. 멤버변수로 tables 라는 딕셔너리와 procedures라는 리스트를 들고 있을겁니다. 

    def parse_xml(self, path):
        tree = ET.parse(path)
        root = tree.getroot()
        for child in root:
            if child.tag == 'Table':
                 self.tables[child.attrib['name']] = Table(child)
        for child in root:
            if child.tag == 'Procedure':
                self.procedures.append(Procedure(child, self.tables))
이 함수가 경로의 파일을 파싱하는 함수입니다. 

tree는 ET라는 객체의 parse(path) 를 호출하고 있습니다.그리고 그 root 를 얻어 오고 있는데 대충 파싱과 루트 노드를 얻어오는거 같습니다. 
그 후 root 를 for 순회를 하면서 child의 tag 가 Table 이면 Table(child) 로 Table 객체를 self.tables[child.attrib['name']] 에 담습니다. 

class Table:
    def __init__(self, node):
        self.name = node.attrib['name']
        self.columns = {}
        for child in node:
            if child.tag == 'Column':
                self.columns[child.attrib['name']] = ReplaceType(child.attrib['type'])

Table 클래스 입니다. 테이블 노드를 인자로 받는데 이 노드의 name을 자신의 name으로 들고 있고 Table이 가지고 있을 Column을 또 node 부터 순회하면서 가져옵니다. 

다시 루트노드에서 순회를 도는중 해당 노드의 태그가 Procedure라면 self.procedures.append(Procedure(child, self.tables)) 를 하고 있습니다.

Procedure 클래스를 보겠습니다. 

class Procedure:
    def __init__(self, node, tables):
        name = node.attrib['name']
        if name.startswith('sp'):
            self.name = name[2:]
        else:
            self.name = name
        self.params = []
        for child in node:
            if child.tag == 'Param':
                self.params.append(Param(child))
            elif child.tag == 'Body':
                self.columns = ParseColumns(child, tables)
                self.questions = MakeQuestions(self.params)

node 와 tables 를 받고 있습니다. node는 Procedure가 있는 노드이고 그 노드의 name 값을 name라는 임시 변수에 저장합니다. 그리고 첫글자가 sp로 시작하면 두글자 뒤에부터를 self.name으로 
저장하고 아니라면 그대로 다 저장합니다. 
self.params 라는 변수에는 파라미터들을 담아줍니다. 순회를 돌면서 Param끼리 모아주고 정의부에 해당하는 Body부분을 각각 스캔을 해줍니다. 
Body 를 스캔하면서 ParseColumns 과 MakeQuestion이라는 함수를 호출합니다. 

def ParseColumns(node, tables):
    columns = []
    query = node.text
    select_idx = max(query.rfind('SELECT'), query.rfind('select'))
    from_idx = max(query.rfind('FROM'), query.rfind('from'))
    if select_idx > 0 and from_idx > 0 and from_idx > select_idx:
        table_name = query[from_idx+len('FROM') : -1].strip().split()[0]
        table_name = table_name.replace('[', '').replace(']', '').replace('dbo.', '')
        table = tables.get(table_name)
        words = query[select_idx+len('SELECT') : from_idx].strip().split(",")
        for word in words:
            column_name = word.strip().split()[0]
            columns.append(Column(column_name, table.columns[column_name]))
    elif select_idx > 0:
        word = query[select_idx+len('SELECT') : -1].strip().split()[0]
        if word.startswith('@@ROWCOUNT') or word.startswith('@@rowcount'):
            columns.append(Column('RowCount', 'int64'))
        elif word.startswith('@@IDENTITY') or word.startswith('@@identity'):
            columns.append(Column('Identity', 'int64'))
    return columns

여기서는 이전에 xml 파일에서 쿼리문을 사용하던것에서 어떤 컬럼들이 있는지 갯수등을 알아야 지만 그것을 컬럼 값으로 빼서 관리해 줄 수 있을겁니다. 

	<Procedure name="spGetGold">
		<Param name="@gold" type="int"/>
		<Body>
			<![CDATA[
			SELECT id, gold, name, createDate FROM [dbo].[Gold] WHERE gold = (@gold)
			]]>
		</Body>
	</Procedure>

여기서 Param 태그와 Body 태그의 내용을 잘 추출하기 위해 노력하고 있는겁니다. rfind 라는 함수를 통해 문자열에서 원하는 단어를 찾는 작업을 하고 있습니다.
SELECT 와 FROM 을 찾아주고있는데 왜 그러냐면 SELECT를 찾아주면 쿼리의 첫번째 인덱스가 걸릴것이고 FROM을 찾아주면 인자들이 들어온 다음 인덱스가 걸릴것이기 때문에 
이 두 인덱스 사이의 문자열을 잘 해석해서 인자들을 하나씩 긁어오기 위해서 입니다. 

그래서 위에 select_idx 와 from_idx 를 가져온뒤 if 문으로 select_idx, from_idx가 유효한지를 체크하고 이런저런 문자열을 다루는 함수로 'Gold' 라는 테이블의 이름을 가져옵니다. 
이런식으로 이런저런 데이터를 긁어오게 됩니다. 

그 다음으로 MakeQuestions 부분입니다.

def MakeQuestions(params):
    questions = ''
    if len(params) != 0:
        questions = '('
        for idx, item in enumerate(params):
            questions += '?'
            if idx != (len(params)-1):
                questions += ','
        questions += ')'
    return questions

결국 쿼리에서 파라미터가 들어가야할 부분은 (?,?,?) 이런식으로 파라미터 갯수만큼 물음표를 붙여줘야하는데 이것을 해주는게 MakeQuestions입니다. 

이런 과정을 거쳐서 ProcedureGenerator의 

    parser = XmlDBParser.XmlDBParser()
    parser.parse_xml(args.path)

부분이 실행되는겁니다. 

-- Procedure.h
이렇게 xml 파일을 쫙 긁어 파싱을 한 다음에는 그 내용을 가지고 jinja2를 활용하면 되겠습니다. 
jinja2를 적용하는 파일이 Procedure.h 입니다. 

{%- macro lower_first(text) %}{{text[0]|lower}}{{text[1:]}}{% endmacro -%}

{%- for proc in procs %}
class {{proc.name}} : public DBBind<{{proc.params|length}},{{proc.columns|length}}>
{
public:
	{{proc.name}}(DBConnection& conn) : DBBind(conn, L"{CALL dbo.sp{{ proc.name }}{{ proc.questions }}}") { }

{%- for param in proc.params %}
  {%- if param.type == 'nvarchar' %}
	template<int32 N> void In_{{param.name}}(WCHAR(&v)[N]) { BindParam({{loop.index - 1}}, v); };
	template<int32 N> void In_{{param.name}}(const WCHAR(&v)[N]) { BindParam({{loop.index - 1}}, v); };
	void In_{{param.name}}(WCHAR* v, int32 count) { BindParam({{loop.index - 1}}, v, count); };
	void In_{{param.name}}(const WCHAR* v, int32 count) { BindParam({{loop.index - 1}}, v, count); };
  {%- elif param.type == 'varbinary' %}
	template<typename T, int32 N> void In_{{param.name}}(T(&v)[N]) { BindParam({{loop.index - 1}}, v); };
	template<typename T> void In_{{param.name}}(T* v, int32 count) { BindParam({{loop.index - 1}}, v, count); };
  {%- else %}
	void In_{{param.name}}({{param.type}}& v) { BindParam({{loop.index - 1}}, v); };
	void In_{{param.name}}({{param.type}}&& v) { _{{lower_first(param.name)}} = std::move(v); BindParam({{loop.index - 1}}, _{{lower_first(param.name)}}); };
  {%- endif %}
{%- endfor %}

{%- for column in proc.columns %}
  {%- if column.type == 'nvarchar' %}
	template<int32 N> void Out_{{column.name}}(OUT WCHAR(&v)[N]) { BindCol({{loop.index - 1}}, v); };
  {%- elif column.type == 'varbinary' %}
	template<typename T, int32 N> void Out_{{column.name}}(OUT T(&v)[N]) { BindCol({{loop.index - 1}}, v); }
  {%- else %}
	void Out_{{column.name}}(OUT {{column.type}}& v) { BindCol({{loop.index - 1}}, v); };
  {%- endif %}
{%- endfor %}

private:
{%- for param in proc.params %}
  {%- if param.type == 'int32' or param.type == 'TIMESTAMP_STRUCT' %}
	{{param.type}} _{{lower_first(param.name)}} = {};
  {%- endif %}
{%- endfor %}
};
{% endfor %}

이것이 어디서 쓰일것이냐면 이전시간에 DBSynchronizer.cpp에서 namespace sp 안에 있던 GetDBTables 같은 클래스를 만들어주는겁니다. 
다른 부분은 이미 PacketGenerator에서 해봤던 내용과 비슷한데 맨위의 

{%- macro lower_first(text) %}{{text[0]|lower}}{{text[1:]}}{% endmacro -%}

이건 파이썬으로 하는 매크로인데 lower_first(text) 에서 text에 들어가는 문자열의 첫번째 문자을 소문자로 바꿔주는 매크로입니다. 
종종 이 lower_first 매크로가 등장하는것 말고는 기존 jinja2 문법과 같습니다. 

처음보는 문법도 있는데 DBBind를 상속하면서 템플릿으로 파라미터의 갯수와 컬럼의 갯수를 넣어주었던 부분이

 public DBBind<{{proc.params|length}},{{proc.columns|length}}>

이런식으로 되어있는데 이건 jinja2 의 문법으로 파라미터 뒤의 | 을 한 뒤 length를 하면 곧바로 파라미터의 갯수를 뱉어줍니다. 

이런 문법에 또 {%- for proc in procs %} 처럼 for 문을 돌 수도 있고 loop.index - 1 같은 문법도 있는데 loop.index는 현재 돌고 있는 루프의 인덱스를 가져오는 것입니다. 

그러면 GenProcedures.h 라는 파일은 어떤 일을 하느냐 하면 
#pragma once
#include "Types.h"
#include <windows.h>
#include "DBBind.h"

{%- macro gen_procedures() -%} {% include 'Procedure.h' %} {% endmacro %}

namespace SP
{
	{{gen_procedures() | indent}}
};

gen_procedures라는 매크로를 만들고 있는데 그 내용은 gen_procedures() 를 호출한 곳에 아까 Procedure.h 의 내용 전체를 붙여넣는 일입니다. 
그러니깐 보기 좋게 코드를 감춰둔 것입니다. 그냥 한 파일로 만들어도 되지만 일단 깔끔하게 이렇게 만들었습니다. 

***

그러면 이제 이 코드들을 실행하면 어떻게 될지를 생각해보겠습니다.

이전 PacketGenerator 때를 생각해보면 아마 pyinstaller 로 exe 파일을 만들어 줄수 있는데 MakeExe.bat을 만들어 이런저런 옵션들을 함께 실행할수 있습니다. 
그런의미에서 MakeExe.bat 을 ProcedureGenerator 폴더에도 만들어줍니다. 

pushd %~dp0
pyinstaller --onefile ProcedureGenerator.py
MOVE .\dist\ProcedureGenerator.exe .\GenProcs.exe
@RD /S /Q .\build
@RD /S /Q .\dist
DEL /S /F /Q .\ProcedureGenerator.spec
PAUSE

이코드를 실행하면 GenProcs.exe 파일 하나로 만들어줍니다. 

만든 exe 파일은 별도에 경로에 옮겨서 관리하면 됩니다. PacketGenerator때도 프로젝트 경로에서 Common이라는 폴더아래로 옮겼습니다. 

(SolutionDir)/Common/Procedures/.   경로로 옮겨주겠습니다. 옮길 파일들은 Template 폴더와 GenProcs.exe 입니다. 
다 옮겼으면 이걸 더 쉽게 실행하기위한 배치 파일을 하나 더 만들어줍니다. 

pushd %~dp0

GenProcs.exe --path=../../GameServer/GameDB.xml --output=GenProcedures.h

IF ERRORLEVEL 1 PAUSE

XCOPY /Y GenProcedures.h "../../GameServer"

DEL /Q /F *.h

PAUSE

이 배치파일을 실행하면 (SolutionDir)/GameServer 아래로 GenProcedures.h 가 생성이 될겁니다. 

그렇게 자동으로 완성된 GenProcedures.h 를 보면 이제는 데이터 베이스에 컬럼을 추가하는 쿼리를 그냥 CALL dbo.spInsertGold(?,?,?) 이렇게 처리합니다. 
그외에도 gold 컬럼에 데이터를 추가할때 인자가 오른값이면 오른값참조를 해서 값을 멤버 변수 _gold에 복사해 두었다가 추가하는 등 추가기능도 넣었습니다. 
이렇게 필요한 기능이 있으면 여기서 하나씩 추가하면 되겠습니다. 

***

여기서 끝이 아니라 GameDB.xml 이 변경되었는지 관찰하다가 변경된 사항이 있으면 자동으로 업데이트 해주는 작업도 했었습니다. 

GameServer 프로젝트의 속성중 빌드 이벤트 란에서 빌드 전 이벤트에 이전에 GenPacket.bat 를 실행해주도록 했었습니다. 
이것과 유사하게 GetProcs.bat 도 실행하도록 해줍니다. 이 작업으로 GameServer를 실행하거나 빌드할때 마다 GenProcs.bat도 같이 실행해주게 됩니다. 

한가지더 추가로 GameServer의 경로에서 GameServer.vcxproj 파일을 메모장으로 열어보면 여러 코드들이 들어있습니다. 이중 거의 아랫부분에서 PacketGenerator 때 
UpToDateCheckInput 이라는 명령어를 사용했습니다. 이 명령어가 가리키는 파일이 변경되었으면 빌드 이벤트를 실행해달라는 뜻입니다. 

여기까지 했으면 빌드하는것까지 자동화가 끝났습니다.

이제 정상적으로 툴이 작동하는지를 테스트 해보겠습니다. 

이전시간에 DBSynchronizer로 버전을 맞춘 다음 순서부터입니다. 
#include "GetProcedures.h"
	{
		WCHAR name[] = L"csu1222";
		SP::InsertGold insertGold(*dbConn);
		insertGold.In_Gold(100);
		insertGold.In_Name(name);
		insertGold.In_CreateDate(TIMESTAMP_STRUCT{ 2023, 8, 24 });
		insertGold.Execute();
	}
    여기서 insert를 하고 

	{
		SP::GetGold getGold(*dbConn);
		getGold.In_Gold(100);

		int32 id = 0;
		int32 gold = 0;
		WCHAR name[100];
		TIMESTAMP_STRUCT date;

		getGold.Out_Id(OUT id);
		getGold.Out_Gold(OUT gold);
		getGold.Out_Name(OUT name);
		getGold.Out_CreateDate(OUT date);

		getGold.Execute();

		while (getGold.Fetch())
		{
			GConsoleLogger->WriteStdOut(Color::BLUE,
				L"ID[%d] Gold[%d] Name[%s]\n", id, gold, name);
		}
	}
    여기서 select로 긁어와서 출력합니다.

***

여기까지 파트 4 서버 프로그램 강의가 끝났습니다. 

전반적인 복습을 간략하게 해보겠습니다. 

지금까지의 결과물을 실행해보면 아직 언리얼 엔진에 연결해 그래픽적인 결과를 볼 수 있는게 아니고 우리가 설정한 수 만큼의 클라이언트가 서버에 접속해 Hello Wolrd만 보내고 있는것이다 보니 
단순한 채팅프로그램 처럼 보였습니다.
 
하지만 그 안에서 클라를 먼저 끄더라도 서버가 크래시가 나지않고 연결 종료 로그가 출력되는등의 작업도 볼 수 있습니다. 

가장 먼저는 서버 프로그래밍에서 중요한 스레드에 대한 내용을 알아봤습니다. 스레드 생성은 어떻게 하는지 아토믹 타입은 무엇인지, 락은 무엇인지, 락의 종류는 어떻게 있는지, 데드락 현상은 왜 일어나는지
그리고 직접 락을 구현해보는 연습도 했습니다. 
스핀락을 이용해 보고 슬립, 그리고 이벤트 방식으로 여러방식을 이용해 본 다음 표준에서 등장하는 condition variable,future 같은 것들도 알아봤습니다. 

다음은 TLS 라는 스레드 각자의 로컬 저장소를 알아보고 스택을 만들때 락을 기반으로 만드는 스택큐 같은 걸 만드는 실습도 했었고 락 프리 구조로 스택과 큐를 만드는 실습도 했습니다. 
그리고 스레드 관리에 대한 내용을 배웠고 DeadLockProfiler 라는 클래스를 만들어서 빨리 데드락 상황을 디버그 상황에서 빠르게 탐지 할 수 있고 문제 해결을위한 여러 방안들을 마련해봤습니다. 
스레드에 관련된 내용은 이렇게 다뤘었고 

다음은 메모리에 관한 내용이었습니다. 
기본적인 new delete를 사용해 할당하는 방법이 아닌 우리만의 할당자들을 만들어서 사용하는 방법에 대해 알아 봤었고 각종 할당자를 만들었는데 예를들어 stomp allocator를 사용해 
메모리 오염을 한번에 잡는 실습도 해봤습니다. 이어서 메모리 풀링적용해 메모리 풀링용 할당자를 만들어 알아서 풀링할수 있겠끔 실습도 해봤습니다. 
그리고 다이나믹 캐스트 대신 타입 캐스트에 대한 개념도 알아봤습니다 

다음은 네트워크에 대한 내용으로 소켓이 무엇인지 통신이 무엇인지를 알아 봤고 tcp udp의 개념과 차이를 알아보고 블로킹 소켓 논블로킹 소켓 그리고 동기화 비동기화 에 대해서도 알아 봤습니다.
본격적으로 네트워크 라이브러리를 iocp 로 만들기 시작했고 몇백의 유저가 들어와도 문제 없이 처리하는것도 확인 할 수 있습니다. 
그리고 패킷 직렬화가 무엇인지, 어떤 기법들이 있는지를 실습해보고 그다음 구글에서 만든 프로토 버프를 적용해 실습해봤습니다. 거기에 jinja2, pyinstaller 를 활용해 자동화 툴로 
패킷코드들을 자동화 처리하고 있습니다. 
또 락방식으로 패킷을 처리하는게 아닌 잡 방식을 사용하는이유 그리고 잡을 사용하는데 어떤 방식들이 있는지를 알아봤습니다. 

최종적으로 DB를 서버에 적용하는 것에 대해 알아봤습니다. ODBC 를 사용해 C++ 코드에서 DB 쿼리를 전송하는 방법을 알아봤습니다. 
그리고 DB의 버전관리를 위해 우리만의 ORM을 만들고 또 이것을 자동화 툴로 만들어 xml 파일에 수정이 있으면 업데이트가 되도록 하였습니다. 