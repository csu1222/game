


            패킷직렬화 (2)



지난 시간까지 패킷에 데이터를 밀어 넣을때 가변 크기 데이터를 섞어서 넣는게 아닌 각 가변 길이 데이터의 헤더를 고정 크기로 만들어 
고정 크기 데이터를 먼저 밀어 넣은다음 그 뒤로 가변길이 데이터들을 넣는 방식으로 수정을 해봤습니다. 

그리고 이 방법의 장점은 이후로 가변길이 데이터가 여러가지 등장한다고 해도 앞에 고정길이 데이터로 두었던 가변길이 데이터의 헤더로 
빠르게 패킷이 오염되지 않았는지를 체크할 수 있었습니다. 

이것만해도 신기한 아이디어 였는데 오늘은 여기서 더 신기한 발상의 전환을 하게 될겁니다. 

패킷 직렬화에는 크게 두가지 부류가 있습니다. 이것이 구글에서 유명한 ProtoBuf 와 PlatBuffer의 차이이기도 합니다.

이전 까지 방식에서 데이터를 읽을때 받은 패킷의 데이터를 꺼내기 위해 임시 변수들을 만든 다음 그곳에 데이터를 꺼내 사용하고 있습니다. 
이것은 너무 당연하게 생각할 수 있습니다. 버퍼의 내용을 꺼내서 쓰려면 변수에 담아 다뤄야 할것입니다. 

마찬가지로 데이터를 만드는 부분도 SendBuffer에 데이터를 밀어넣기 위해서 임시 객체들을 만들고 있습니다.
매개변수로 받은 

vector<BuffData> buff, wstring name 

등이 그렇습니다. 엄밀히 말해서 컨텐츠 단에서 당장 필요하지 않았을 수 있지만 버퍼에 데이터를 넣기 위해서 객체를 먼저 만들고 그걸 Make_S_TEST에 넘겨주고 
그 데이터를 토대로 버퍼를 체우고 있습니다. 
이것이 딱히 문제가 되지는 않습니다. 이렇게 하면 확실히 코드 가독성이 좋아지고 관리하기가 좋아진다는 장점이 있습니다 

그럼에도 불구 하고 중간에 vector 같은 객체를 만든다는 복사비용이 들것입니다. 

그래서 이번 시간에 새로 알아볼 방법은 데이터를 만들고 읽을때 임시객체를 만드는과정을 생략하고 바로 버퍼에 꽂아주고 또 바로 꺼내 쓰는 방법에 대해 알아볼것입니다. 
이 방법이 복잡하기 때문에 먼저 Read 하는 부분만 먼저 작업해볼겁니다. 


***

-- ClientPacketHandler

가장 먼저 생각의 전환을 해야 할 아이디어는 먼저 Handle_S_TEST() 라는 이름의 패킷을 읽는 함수에서 고정 데이터들을 꺼낼때 

	PKT_S_TEST pkt;
	br >> pkt;

이렇게 꼭 임시 변수에다가 꺼내야 하는가? 라는 것입니다. 

사실은 우리가 버퍼에 데이터를 밀어 넣을때 

    [PKT_S_TEST(고정길이 데이터 + 헤더들)][가변 길이 데이터들... ][가변 길이 데이터들... ]

이런 형태로 들어가 있습니다. 

이것을 굳이 따로 꺼낼 복사할 필요 없이 인자를 직접 포인터로 가르켜 데이터를 사용하면 될것입니다. 


#pragma pack(1)
struct PKT_S_TEST
{
	struct BuffsListItem
	{
		uint64 buffId;
		float remainTime;
	};

	uint16 packetSize;
	uint16 packetId;
	uint64 id;
	uint32 hp;
	uint16 attack;
	// 가변길이 데이터를 묘사하는 데이터 
	uint16 buffOffset; // 가변길이 데이터가 시작하는 인덱스
	uint16 buffCount;
	
	// 패킷의 내용이 정상적으로 처리되고 있는지를 확인하는 함수 
	bool Validate()
	{
		uint32 size = 0;
		size += sizeof(PKT_S_TEST);
		// 이 체크는 적어도 고정데이터들은 들어와 있는지를 확인
		if (packetSize < size)
			return false;
		
		size += buffCount * sizeof(BuffsListItem);

		if (size != packetSize)
			return false;

		if (buffOffset + buffCount * sizeof(BuffsListItem) > packetSize)
			return false;

		return true;
	}

	// BuffsList를 BuffsListItem을 타입으로 는 PacketList 라고 정의 합니다. 
	using BuffsList = PacketList<PKT_S_TEST::BuffsListItem>;

	// BuffsList를 꺼내는 함수
	BuffsList GetBuffsList()
	{
		// PKT_S_TEST의 시작주소에 buffOffset 만큼을 더하면 가변데이터의 시작 주소입니다. 
		// BYTE* 가 1바이트짜리니까 uint16인 buffOffset을 더하면 주소가 나옵니다.
		BYTE* data = reinterpret_cast<BYTE*>(this);
		data += buffOffset;

		// 반환할때는 다시 PKT_S_TEST::BuffsListItem*로 캐스팅해서 PakcetList의 생성자에 넘겨줍니다.
		return BuffsList(reinterpret_cast<PKT_S_TEST::BuffsListItem*>(data), buffCount);
	}
};
#pragma pack()


void ClientPacketHandler::Handle_S_TEST(BYTE* buffer, int32 len)
{
	BufferReader br(buffer, len);

	// 버퍼의 데이터를 굳이 임시 객체에 복사하지 않아도 되지 않을까?

	// BYTE 배열인 buffer를 바로 캐스팅해서 PKT_S_TEST로 해석을 합니다.
	PKT_S_TEST* pkt = reinterpret_cast<PKT_S_TEST*>(buffer);

	// PacketSession::OnRecv를 지나오면서 일단 PacketHeader 만큼은 들어 있다고 보장할 수 있습니다. 
	// 그 헤더에 적힌 사이즈와 버퍼크기를 비교하기는 했는데 그게 오염되어 있는지는 확인해봐야합니다. 

	// Validate 에서 순서대로 고정데이터까지는 들어왔는지 들어왔다면 그 내용들을 가지고 가변데이터들 까지 제대로 들어왔는지를 
	// 확인합니다. 
	if (pkt->Validate() == false)
		return;

	// 여기까지 왔다면 일단 pkt 라는 포인터가 buffer에 있는 데이터들을 PKT_S_TEST로 해석합니다.

	// 그렇다면 이전처럼 가변데이터들도 굳이 새로 객체를 만들어 받아줄 필요없이 
	// 데이터들의 주소를 알수 있기때문에 곧바로 접근 할 수 있을겁니다. 
	// 데이터에 접근하기 편하게 헬퍼 클래스를 만들었습니다.

	// 가변데이터를 PacketList로 관리해 줍니다. 

	PKT_S_TEST::BuffsList buffs = pkt->GetBuffsList();

	// buffs는 buffer의 데이터를 복사한게 아닌 그냥 포인터로 가리키고 있는것입니다. 

	// 따로 꺼내 저장하는게 아닌 PacketList에 만들어둔 [] 연산자로 직접 접근할수 있게 됩니다. 
	cout << "BuffCount : " << buffs.Count() << endl;
	for (int32 i = 0; i < buffs.Count(); i++)
	{
		cout << "Buff Info : " << buffs[i].buffId << " " << buffs[i].remainTime << endl;
	}
}


template<typename T>
class PacketList
{
public:
	PacketList() : _data(nullptr), _count(0) { }
	PacketList(T* data, uint16 count) : _data(data), _count(count) { }

	T& operator[] (uint16 index)
	{
		ASSERT_CRASH(index < _count);
		return _data[index];
	}

	uint16 Count() { return _count; }

private:
	// 데이터 타입(T)과 시작주소(_data), 그리고 갯수(_count)를 알면 
	// 그냥 배열처럼 접근 할 수 있을것입니다. 
	T*				_data;
	uint16			_count;
};

이렇게 수정이 되었는데 ClientPacketHandler.h 에 가변데이터들을 관리하기 위한 헬퍼클래스인 PacketList를 만들었습니다. 
PacketList는 템플릿으로 다룰 데이터 타입을 받고 그 데이터의 시작주소를 _data로 가리킵니다. 그리고 그 데이터들이 몇개나 있는지를 _count로 들고 있는데 
이 두 변수 _data, _count는 생성자에서 받아올수 있습니다. 
이러면 시작주소에서 데이터 타입만큼씩을 움직이는 배열처럼 사용할 수 있습니다. 사용하기 편하게 []오퍼레이터를 오버로딩해 사용할것인데 
접근할 index가 데이터의 최대 크기인 _count가 넘어가면 안되도록 예외처리를 합니다. 

그리고 이 PacketList가 우리 실습에서 사용할 수 있도록 PKT_S_TEST구조체 내에 새로 정의와 바로 꺼내 사용할 수 있도록 함수를 만들었습니다. 
BuffsList 라는 이름에 PakcetList<PKT_S_TEST::BuffsListItem>을 정의 해두었습니다. 타이핑하기 기니깐 짧게 만들어 둔겁니다. 
또 가변데이터에 접근할때 GetBuffsList 함수로 바로 꺼낼수 있게 해두었습니다. 

이제 버퍼를 읽는 함수인 Handle_S_TEST를 보면 인자인 buffer를 굳이 다시 임시 객체에 복사하는게 아닌 
BYTE의 포인터였던 buffer를 바로 reinterpret_cast<PKT_S_TEST*> 로 캐스팅해 해석하면 그대로 데이터를 가져다 사용할 수 있게 되는것입니다. 
이때 buffer는 PacketSession::OnRecv를 통과한 버퍼이기 때문에 PacketHeader 만큼은 분명 들어 있고, 헤더에 적힌 패킷 사이즈 만큼도 넘어 왔을것입니다. 
하지만 이때 패킷 헤더의 사이즈는 오염되있을 수도 있기 때문에 PKT_S_TEST::Validate에서 다시 체크를 합니다. 
Validate를 통과했다면 고정데이터인 PKT_S_TEST 크기만큼 들어있는지를 한번, 또 PKT_S_TEST에 기록된 가변데이터의 크기가 다 들어 왔는지도 또 한번 체크합니다. 
이후 가변데이터에 접근할때는 위에서 만든 PKT_S_TEST::GetBuffsList()를 사용해 일종의 배열로 사용하도록 하고 또 배열처럼 사용할 수 있다보니 불필요한 복사를 하지 않고 
바로 []로 인덱스 접근을 할 수 있게 됩니다.


***

여기까지가 PlatBuffer의 읽기에 대한 내용이라고 합니다. 

구글에서 만든 대표 두가지 방법중 하나인 ProtoBuf는 그래도 임시객체를 사용한다고는 합니다. 장단점이 있기 때문인데 
개발하는 과정에서는 임시객체를 만들어 사용하는게 편하다고 합니다.

읽기말고 쓰기를 할때도 데이터를 버퍼에 바로 꽂아넣는 방법에 대해 다음시간에 알아볼것입니다. 이것은 읽기 보다 좀 더 복잡하고 고려할게 많다고는 합니다.
이것은 일단 다음 시간 이야기이고 읽기에 대해 좀 더 알아보겠습니다. 

***

데이터를 꺼낼때 PacketList를 사용해 []로 접근하는것은 알겠습니다. 
그런데 vector 임시 객체로 복사해 사용했을때는 좀 더 다양한 사용법이 있었습니다. 

예를 들어 이터레이터를 사용한다던가 하는 방법입니다. 

for (auto it = buffs.begin(); it != buffs.end(); ++it)
{
		cout << "Buff Info : " << it->buffId << " " << it->remainTime << endl;
}

이런식으로도 활용할 수 있었고 

또 range for 문법을 사용하기도 했었습니다. 

for (auto& buff : buffs)
{
    cout << buff.buffId << " " << buff.remainTime << endl;
}

이런식으로도 사용할 수 있었습니다.


하지만 직접 만든 유사 배열인 PakcetList는 아직 지원하기 않고 있습니다. 이것은 이전에 C++ 문법 파트에서 직접 vector 나 list를 구현하면서 이터레이터를 만들어 주던 방법으로 
추가해주면 되는것입니다. 
다시 복습할 겸 추가해보겠습니다. 먼저 이터레이터라는 개념을 추가해야 합니다. 

template<typename T, typename C>
class PacketIterator
{
public:
	PacketIterator(C& container, uint16 index) : _container(container), _index(index) { }

	bool				operator!=(const PacketIterator& other) const { return _index != other._index; }
	const T&			operator*() const { return _container[_index]; }
	T&					operator*() { return _container[_index]; }
	T*					operator->() { return &_container[_index]; }
	PacketIterator&		operator++ () { _index++; return *this; } // 전위++
	PacketIterator		operator++(int32) { PacketIterator ret = *this; ++_index; return ret; }
private:
	C&					_container;
	uint16				_index;
};

템플릿으로 데이터 타입과 컨테이너를 받습니다. 멤버 변수를 보면 이터레이터가 가리킬 컨테이너와 인덱스가 있습니다. 
그리고 생성자에서는 각각의 값을 채워주고 있는데 사실 이게 이터레이터의 구조입니다. 
여기에 필요한 기능들을 연산자 오버로딩으로 채워주면됩니다. 

이제 이 이터레이터를 PacketList에 적용합니다.

template<typename T>
class PacketList
{
public:
	PacketList() : _data(nullptr), _count(0) { }
	PacketList(T* data, uint16 count) : _data(data), _count(count) { }

	T& operator[] (uint16 index)
	{
		ASSERT_CRASH(index < _count);
		return _data[index];
	}

	uint16 Count() { return _count; }

	// ranged-based for 지원
	PacketIterator<T, PacketList<T>> begin() { return PacketIterator<T, PacketList<T>>(*this, 0); }
	PacketIterator<T, PacketList<T>> end() { return PacketIterator<T, PacketList<T>>(*this, _count); }
private:
	// 데이터 타입(T)과 시작주소(_data), 그리고 갯수(_count)를 알면 
	// 그냥 배열처럼 접근 할 수 있을것입니다. 
	T*				_data;
	uint16			_count;
};

begin()과 end()라는 이터레이터를 반환하는 함수들을 추가 했습니다. 

신기하게도 코드를 이렇게만 추가하면 위에서 예시를 들었던 이터레이터활용과 ranged-based for 까지 동작하게 됩니다. 


*** 
결론은 패킷을 역 직렬화 할때 꼭 임시 객체를 만들고 복사해 사용해야 하는것이 아닌 곧바로 버퍼에 접근해서 원하는 타입으로 해석해 사용할 수 있다는것,
장점은 불필요한 복사 비용을 줄일 수 있다는 것이었습니다. 