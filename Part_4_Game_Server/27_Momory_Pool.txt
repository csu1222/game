


        Memory Pool

지금까지 메모리 관리에 대해 여러가지를 배웠었습니다. 
서버 프로그래밍 그 중에서도 멀티 쓰레드 환경에서 포인터를 사용할때 주의해야 할 점과 그 해결법으로의 스마트 포인터,
그리고 객체를 생성하면서 메모리를 할당하는 할당자를 오버로딩 할 수 있고 오버로딩해서 커스텀으로 필요한 할당자를 만들 수 있었고 
또 할당자를 C++ 에서 사용하는 new delete는 사실 엄밀히 동작하는게 아니었고 windows에 직접 요청하는 
::VirtualAlloc, ::VirthalFree를 통해 메모리 오염을 감지할 수 있는 할당자도 만들었습니다. 
그리고 이 커스텀 할당자를 STL 컨테이너에서도 사용할 수 있었고 그것 까지 따로 Container.h 라고 새로 헤더 파일로 빼줬습니다. 

다음으로 이어서 메모리 풀링을 배워볼겁니다. 
풀링이라는 용어가 언리얼이나 유니티나 서버를 만들거나 자주 등장합니다. 

풀이란 연못 같은거라고 생각하면되는데 지금까지는 메모리를 할당한 다음 다 사용하면 해제를 해줬는데 
이제는 메모리를 쓰자 마자 해제를 해주는게 아니라 어느 공간에 잠시 두었다가 나중에 사용할 수 도 있을겁니다. 
C++ 의 new delete 중 delete 는 키워드를 사용하면 그 즉시 메모리를 해제하는게 아니었고 잠시 어딘가에 저장해두는 듯한 동작을 하였습니다. 

이렇게 메모리 풀은 이해하기 어려운 개념은 아니었습니다. 
하지만 실제로 구현하려고 하면 생각해야 할 부분이 좀 있습니다.

가장먼저 생각해 볼 수 있는 풀링 방식은 오브젝트 풀링이라고 예를 들어 Knight 라는 객체를 만들었다가 삭제를 시도할때 
혹시 나중에 또 새로운 Knight 객체를 만들 수도 있을것 같아서 Knight 클래스를 만들 메모리 들만 모아 두는 방식이 있습니다. 
그런데 여기서 또 생각해 볼 점이 C++ 에서는 동적 할당을 하기 위해 메모리 할당을 받는게 객체 뿐만이 아닙니다. 
예시로 vector 라는 동적 배열도 배열의 크기가 늘어나서 capacity 를 넘어가면 새로운 메모리 구역을 할당받는 구조였습니다. 
마찬가지로 map 이라는 컨테이너도 내부적으로 노드 구조체들로 이루어져 원소가 추가 될때마다 메모리 이곳 저곳에 위치하게 될텐데 
그래서 메모리를 객체 단위로 풀링하는 오브젝트 풀링 보다는 여러 상황에 사용할 수 있는 풀링 방식을 고민해 봐야 할겁니다. 
즉, 메모리 풀링에 크기를 고정하지 않아야 한다.

그런데 왜 꼭 메모리 풀링을 사용해야 할지 필요성도 알면 좋을것 같습니다. 
먼저 메모리를 할당받고, 다 사용한 메모리를 해제하고 하는것을 반복하다보면 유저 레벨과 커널 레벨을 왕복하는 컨택스트 스위칭이 자주 일어나게 되고 
그것은 성능적인 문제를 일으킵니다. 
또 메모리 할당, 해제를 반복하다 보면 메모리의 파편화라는 문제도 생깁니다. 자잘한 메모리 할당 해제를 반복하면서 중간에 다른 데이터가 메모리를 할당받고 하면
자잘 자잘한 빈 메모리만 남게 되는데 이 작은 메모리를 재사용할 수 없게 되는 상황도 생길 수 있는 데 
(물론 요즘 할당기는 알아서 메모리 파편화를 잡아주기 때문에 꼭 신경써야 하는지는 의문입니다. 최근 업계에서는 메모리 풀링을 적용하는것은 하는지 안하는지 
선택의 영역이라고 합니다. 그래도 공부할때는 어떤 것이든 일단 배우고 나서 필요에 따라 사용할지 안 할지를 결정하는 것이 좋을겁니다.)


실습에 들어가기 위해 ServerCore 프로젝트 -> Memory 필터 -> MemoryPool 클래스 파일 추가 
를 해줍니다. 

->      Memory Pool.h
        
        메모리 풀을 만들때 정책을 정해줄건데 먼저 위에서 말했던 같은 크기의 데이터 만을 담는 메모리 풀을 만들던가 아니면 한번에 큰 메모리를 할당 받은 다음 그 안에서 
        필요한 만큼의 메모리를 유동적으로 나눠 사용하는 방법이 있습니다. 

        메모리 풀을 만들기 전에 필요한 struct가 있습니다. 
        // 데이터 앞에 붙일 메모리 헤더 데이터의 크기는 얼마인지, 힙에 할당된 다음 메모리
        // 주소는 어디인지 등의 정보를 담는 헤더
        struct MemoryHeader
        {
                // [MemoryHeader][Data]
                MemoryHeader(int32 size) : allocSize(size) { }

                static void* AttachHeader(MemoryHeader* header, int32 size)
                {
                        new(header) MemoryHeader(size);	// placement new
                        return reinterpret_cast<void*>(++header);
                }

                static MemoryHeader* DetachHeader(void* ptr)
                {
                        MemoryHeader* header = reinterpret_cast<MemoryHeader*>(ptr) - 1;
                        return header;
                }

                int32 allocSize;

                // TODO : 필요한 정보 추가 
        };

        MemoryHeader 가 무엇이냐면 실제 할당된 메모리에 데이터를 저장할텐데 그 데이터 앞에 이 MemoryHeader를 동적할당한 포인터를 붙여 뒤의 데이터의 정보를 
        기록할겁니다. 
        왜 이런게 필요한지를 알아야 하겠죠 표준에서 delete 를 할때 뒤에 그냥 포인터만 주었었습니다. 그런데 그러면 해제할 메모리의 크기나 이 메모리 다음에 
        위치한 메모리의 주소 같은 정보들을 따로 알기 어렵기 때문에 원래 처음 할당을 할때 데이터 앞의 정보들을 담은 헤더가 붙는다고 합니다. 

        내용을 하나 씩 설명 해보면 일단 들고 있을 변수는 할당 받을 사이즈를 int32 타입으로 들고 있습니다. 이 사이즈는 생성자에서 받아 초기화해줍니다. 

        함수는 AttachHeader, DetachHeader 둘이 있는데 차례대로 보면 
        AttachHeader는 static 함수이고 void* 를 반환합니다. 인자로는 MemoryHeader* 와 사이즈를 받습니다. 
        코드는 이전에 배운 placement new 문법으로 메모리를 할당할 주소를 인자 header 의 위치로 지정하고 할당받을 메모리의 크기인 allocSize 에 담아 주면서 생성을 합니다. 
        그리고 반환은 header를 void*로 캐스팅해서 반환하고 있는데 이때 ++header의 연산을 하고 있습니다. 포인터에 1을 더한다는것은 실제로 주소값에 1을 더하는게 아니라 
        포인터한개 크기 만큼을 이동하는 것이었습니다. 즉 header라는 포인터 바로 다음 위치의 주소를 void* 로 캐스팅해 반환하고 있습니다. 

        그리고 DetachHeader 에서는 반대로 void* ptr 을 받아서 MemoryHeader* 를 반환하고 있습니다. 그러니까 데이터의 주소를 받으면 데이터 앞에 위치해 있을 MemoryHeader* 의 
        주소를 반환하는겁니다. 방법도 마찬가지로 ptr을 MemoryHeader* 로 캐스팅한 다음 1 만큼 빼주면 되겠습니다. 

        일단 MemoryHeader는 이정도로 만들고 나중에 추가할 데이터가 있다면 추가하면 됩니다.

        MemoryPool 클래스를 보겠습니다. 
        
        /*----------------
                Memoty Pool
        ------------------*/
        class MemoryPool
        {
        public:
                MemoryPool(int32 allocSize);
                ~MemoryPool();

                void			Push(MemoryHeader* ptr);
                MemoryHeader*	Pop();
        private:
                int32 _allocSize = 0;
                atomic<int32> _allocCount = 0;

                USE_LOCK;
                queue<MemoryHeader*> _queue;
        };

        메모리를 하나씩 할당할 크기인 _allocSize와 몇개의 메모리나 풀에 가지고 있는지를 세는 _allocCount를 아토믹 객체로 만들었습니다. 
        그리고 메모리들의 주소를 모아서 들고 있을 _queue 도 만들었는데 일단 Lock도 사용할겁니다. 

        생성자와 소멸자 그리고 Push 함수와 Pop 함수가 있을겁니다. 여기서 Push, Pop이 뭘 뜻하냐면 메모리 풀에서 Pop을 한다는것은 메모리를 가져다가 데이터를 사용하기위해 
        꺼내는 것이고 Push는 다 사용한 메모리를 다시 메모리 풀에 가져오는걸 말합니다. 

->      MemoryPool.cpp
                
        MemoryPool::MemoryPool(int32 allocSize) : _allocSize(allocSize)
        {
        }
        생성자는 그냥 인자로 받은 int32 를 변수에 담아줍니다.
        
        MemoryPool::~MemoryPool()
        {
                while (_queue.empty() == false)
                {
                        MemoryHeader* header = _queue.front();
                        _queue.pop();
                        ::free(header);
                }
        }
        소멸자에서는 메모리 풀이 소멸하기 전에 _queue에 내용물이 있는지를 체크해서 만약 있다면 전부 pop 해주고나서 소멸합니다. 

        MemoryHeader* MemoryPool::Pop()
        {
                MemoryHeader* header = nullptr;
                {
                        WRITE_LOCK;
                        // Pool에 여분이 있는지?
                        if (_queue.empty() == false)
                        {
                                // 있으면 하나 꺼내온다 
                                header = _queue.front();
                                _queue.pop();
                        }
                }

                // 없으면 새로 만든다 
                if (header == nullptr)
                {
                        header = reinterpret_cast<MemoryHeader*>(::malloc(_allocSize));
                }
                else
                {
                        ASSERT_CRASH(header->allocSize == 0);
                }

                _allocCount.fetch_add(1);

                return header;
        }
        Pop 함수를 먼저 살펴보겠습니다. 이걸 먼저 살펴보는게 더 이해하기 쉬울겁니다. 
        대강 어떻게 진행되냐면 header라는 MemoryHeader* 를 nullptr로 함수내 변수로 생성하고 _queue의 내용물이 있다면 header에 담아주고 
        _queue가 비어 있다면 새로 MemoryHeader객체를 동적할당해서 만들어 줍니다. 
        _queue가 비어서 새로 객체를 만들어 줄때 header의 allocSize가 0이면 크래시를 내주는 예외체크를 해주고 있는데 이 메모리 풀을 처음 만들때 
        무슨이유에서인지 메모리 한 덩어리가 0크기라고 설정되었다면 뭔가 이상한 상태이기때문에 크래시를 내주고 있습니다.
        마무리로 _allocCount를 1 증가 시켜주고 header를 반환하고 끝냅니다. 

        void MemoryPool::Push(MemoryHeader* ptr)
        {
                WRITE_LOCK;
                ptr->allocSize = 0;

                // Pool에 메모리 반납
                _queue.push(ptr);

                _allocCount.fetch_sub(1);
        }
        Push는 코드가 더 간략합니다. 먼저 락을 걸고 시작합니다. Push에서 하는일은 인자로 받은 ptr의 메모리는 이제 사용하지 않을것이라 메모리 풀에 
        반납하는 메모리 주소입니다. 반납하기 전에 이제 이 위치에 데이터가 없으니 allocSize를 0으로 밀어주고 
        메모리에 반납하는 의미로 _queue 에 푸시해주고 사용중인 메모리가 하나 줄었다는 의미에서 _allocCount를 1 줄여줍니다. 

다음으로 이번에는 지금 만든 MemoryPool 클래스를 활용하는 방식인데 Memory클래스 파일을 만들어서 거기에 커스텀 할당자를 정의 했었습니다. 
거기에서 작업을 이어가보겠습니다. 

->      Memory.h

        class MemoryPool;

        /*-------------
                Momory
        --------------*/
        class Memory
        {
                enum
                {
                        // ~1024 까지는 32단위, ~2048Rkwl 128단위, ~4096까지 256단위
                        POOL_COUNT = (1024 / 32) + (1024 / 128) + (2048 / 256),
                        MAX_ALLOC_SIZE = 4096,
                };

        public:
                Memory();
                ~Memory();

                void* Allocate(int32 size);
                void Release(void* ptr);

        private:
                vector<MemoryPool*>	_pools;
                
                // 메모리 크기 <-> 메모리 풀
                // O(1) 빠르게 찾기 위한 테이블
                MemoryPool* _poolTable[MAX_ALLOC_SIZE + 1];

        };

        먼저 전방선언으로 MemoryPool을 일단 사용가능하도록 풀어줍니다. 그리고 Memory 클래스에서 enum을 먼저 선언하고 있는데 
        무슨 의미나면 보통 메모리 풀을 사용할때 작은 사이즈의 메모리가 더 많이 사용되고 사용하는 사이즈가 커질수록 사용되는 갯수가 줄어든다고 합니다. 
        그걸 효율적으로 사용하기 위한 정책입니다. 
        가장큰 메모리 풀의 사이즈가 4096이고 32비트의 사이즈부터 32씩 커지며 1024 사이즈의 메모리 풀까지 만들었다면 다음은 128씩 커지는 메모리 풀들, 
        또 256씩 커지도록 메모리 풀들을 만들어줍니다. 
        이 메모리 풀에서 나뉜 메모리의 갯수를 POOL_COUNT로 계산해 들고 있습니다. 

        함수로는 생성자, 소멸자가 있고 사이즈를 인자로 받는 Allocate함수와 어떤 메모리를 해제할지 포인터를 받는 Release함수가 있습니다. 
        변수는 MemoryPool의 포인터를 들고 있는 vector _pools가 있습니다. 
        그리고 _poolTable이란 배열도 있습니다. 사이즈가 MAX_ALLOC_SIZE + 1 입니다. 무슨 용도이냐면 어떤 데이터를 사용하기 위해서 그 데이터의 사이즈가 있을겁니다. 
        그 사이즈를 인덱스에 넣으면 그 위치에 있는 메모리 풀 주소로 가서 적절한 메모리 풀을 찾을수 있는 테이블입니다. 인덱스로 임의접근을 하면 
        O(1) 의 시간복잡도를 사용하게 됩니다. 

->      Memory.cpp

        사실 메모리 매니저인 Memory 클래스의 생성자에서는 처음에 _pools에 들어갈 메모리 풀들을 전부 만들어 줍니다. 
        Memory::Memory()
        {
                // 여기서 사용할 메모리 풀들을 만들어줄겁니다.
                int32 size = 0;
                int32 tableIndex = 0;

                for (size = 32; size <= 1024; size += 32)
                {
                        MemoryPool* pool = new MemoryPool(size);
                        _pools.push_back(pool);

                        while (tableIndex <= size)
                        {
                                _poolTable[tableIndex] = pool;
                                tableIndex++;
                        }
                }

                for (size = 1024; size <= 2048; size += 128)
                {
                        MemoryPool* pool = new MemoryPool(size);
                        _pools.push_back(pool);

                        while (tableIndex <= size)
                        {
                                _poolTable[tableIndex] = pool;
                                tableIndex++;
                        }
                }

                for (size = 2048; size <= 4096; size += 256)
                {
                        MemoryPool* pool = new MemoryPool(size);
                        _pools.push_back(pool);

                        while (tableIndex <= size)
                        {
                                _poolTable[tableIndex] = pool;
                                tableIndex++;
                        }
                }
        }
        아까 정한 정책대로 각 크기의 메모리 풀을 만들어 _pools에 push_back하고 _poolTable에도 적절한 주소를 넣어주고 있습니다. 
                        
        Memory::~Memory()
        {
                for (MemoryPool* pool : _pools)
                        delete pool;

                _pools.clear();
        }
        소멸자입니다. 사실 이 메모리 풀이 소멸할때는 프로그램이 종료할때 일것이라 딱히 신경안써도 되지만 일단 혹시 모르니 직접 전부 밀어주고 소멸하도록
        하였습니다.        

        void* Memory::Allocate(int32 size)
        {
                MemoryHeader* header = nullptr;

                const int32 allocSize = size + sizeof(MemoryHeader);

                if (allocSize > MAX_ALLOC_SIZE)
                {
                        // 할당할 데이터의 사이즈 + 메모리 헤더의 크기가 메모리 풀링 최대 크기를 넘어가면 일반 할당
                        header = reinterpret_cast<MemoryHeader*>(::malloc(allocSize));
                }
                else
                {
                        // 메모리 풀에서 꺼내온다
                        header = _poolTable[allocSize]->Pop();
                }

                return MemoryHeader::AttachHeader(header, allocSize);
        }
        Allocate 함수입니다. 인자로 받는 size는 실제 사용하려는 데이터의 크기를 받습니다. 그 데이터에다가 MemoryHeader를 붙혀주는 동작을 하고 있습니다. 
        allocSize라고 실제 데이터 크기에 MemoryHeader 크기 만큼을 더해서 할당을 받을겁니다. 
        그런데 그 allocSize가 메모리풀의 최대 크기인 MAX_ALLOC_SIZE를 넘었다면 사실 이 데이터는 메모리 풀링을 사용하지 않아도 되는 데이터입니다. 그래서 따로
        그냥 메모리 할당을 받아서 그 맨앞 주소를 header에 받습니다. 
        else 라면 메모리 풀안에 들어갈 사이즈인데 해당 사이즈에 알맞는 메모리풀을 _poolTable에서 받아 MemoryPool::Pop() 을 통해 꺼내옵니다. 
        이 Pop에서는 맨처음 꺼내는거라면 새로 만들어 반환하고 이전에 만들었고 또 다시 회수한 메모리라면 그걸 반환해줬었습니다. 

        그리고 반환할때는 MemoryHeader의 크기 까지 할당받은 header를 그대로 반환하는게 아니고 MemoryHeader::AttachHeader로 실제 데이터가 시작되는 주소로 
        변환해서 반환합니다. 

        void Memory::Release(void* ptr)
        {
                MemoryHeader* header = MemoryHeader::DetachHeader(ptr);

                const int32 allocSize = header->allocSize;
                ASSERT_CRASH(allocSize > 0);

                if (allocSize > MAX_ALLOC_SIZE)
                {
                        // 메모리 풀링 최대 크기를 벗어 났으니 일반해제
                        ::free(header);
                }
                else
                {
                        // 메모리 풀에 반납한다
                        _poolTable[allocSize]->Push(header);
                }
        }
        마지막으로 Release 함수입니다. 먼저 실제 사용하던 데이터의 시작주소를 인자로 받을건데 해제할때는 그 앞에 붙어있을 MemoryHeader 까지 같이 해제해야 하기 때문에
        MemoryHeader::DetachHeader(ptr); 로 MemoryHeader 부터 시작하는 주소를 header에 받아옵니다. 
        Memory::Allocate 에서 AttachHeader를 할때 header에 입력한 allocSize가 있을겁니다. 그게 메모리 헤더까지 포함한 이 데이터의 크기입니다. 
        그걸 allocSize로 받아주고 만약 이값이 0이라면 뭔가 이상한 상태이니 크래시를 내줍니다. 
        다음 조건문으로 allocSize가 MAX_ALLOC_SIZE보다 크다면 메모리 풀에서 사용한 메모리가 아니니 일반 해제를 해주고 
        아니라면 메모리 풀안에서 가져다 사용한 메모리 일것이므로 반납을 해줍니다. 

        지금 Allocate와 Release에서 따로 락을 걸지 않고 그냥 만들었는데 그 이유는 멀티쓰레드 환경에서 락을 거는 이유는 동시에 여러 락이 한 데이터를 수정할때 
        위험하기 때문인데 이 두 함수에서 다루는 메모리는 각 쓰레드에서 독립적으로 사용할것이기 때문에 굳이 락을 걸지 않고 있습니다. 
        각각 메모리를 공용으로 사용하는 메모리 풀에 넣거나 빼는 MeomoryPool::Pop(), Push() 는 내부적으로 락을 걸어주고 있기도 합니다. 

이제 이 Memory의 Allocate와 Release를 하게 되면 그 데이터가 메모리 풀링을 할 대상인지 그냥 할달을 할 대상인지 알아서 동작하게 될겁니다. 
여기서 또 메모리 할당과 해제에 C++ 표준인 ::malloc, ::free를 사용했는데 왜 커스텀으로 만든 A_alloc, A_release를 사용하지 않았냐면 
일단 현재는 디버그 모드에서 실행되기 때문에 StompAllocator가 호출이 될건데 이 StompAllocator와 메모리 풀과의 궁합이 잘 안맞습니다. 

StompAllocator가 하는일은 C++ 표준이 아니라 Windows 표준의 ::VirtualAlloc, ::VirtualFree 를 사용해서 매 번 새로 메모리를 할당하고 사용이 끝나면 
곧바로 해제를 하는 방식으로 동작했었습니다. 이게 메모리 오염을 잡기는 좋기는 했습니다. 
하지만 메모리 풀링을 하는 이유는 메모리를 사용하고 해제를 할때 바로 메모리 해제를 하지 않고 나중에 혹시 같은 사이즈의 메모리가 필요해질때를 위해 남겨두기 위해서 였습니다. 
이 두 개념이 거의 정반대의 개념이기 때문에 둘 중하나를 선택해서 사용해야 할것입니다. 

이제 이렇게 만든 메모리 풀을 실제로 사용하기 위한 작업을 해보겠습니다.

먼저 Memory 객체는 서버에서 공용으로 사용되는 객체입니다. 그리고 공용 객체는 CoreGlobal 이라는 클래스에서 관리하고 있었습니다. 

->      CoreGlobal.h

        extern class ThreadManager*		GThreadManager;
        extern class Memory*			GMemory;

        extern class DeadLockProfiler*	GDeadLockProfiler;
        이 헤더에서는 일단 전방선언을 하고 있엇습니다. 

->      CoreGlobal.cpp

        #include "pch.h"
        #include "CoreGlobal.h"
        #include "ThreadManager.h"
        #include "Memory.h"
        #include "DeadLockProfiler.h"

        ThreadManager*		GThreadManager = nullptr;
        Memory*				GMemory = nullptr;
        DeadLockProfiler*	GDeadLockProfiler = nullptr;

        class CoreGlobal
        {
        public:
                CoreGlobal()
                {
                        GThreadManager = new ThreadManager();
                        GMemory = new Memory();
                        GDeadLockProfiler = new DeadLockProfiler();
                }

                ~CoreGlobal()
                {
                        delete GThreadManager;
                        delete GMemory;
                        delete GDeadLockProfiler;
                }

        } GCoreGlobal;
        생성과 소멸을 해주고 있습니다. 

        이제는 서버내에서 전역적으로 GMemory 객체를 사용할 수 있습니다. 


다음으로는 Allocator 클래스에서 BaseAllocator, StompAllocator, StlAllocator 를 사용하듯이 메모리 풀을 사용하는 얼로케이터 
PoolAllocator를 만들어 주겠습니다. 

->      Allocator.h

        /*----------------
                Pool Allocator
        ------------------*/

        class PoolAllocator
        {
        public:
                static void*	        Alloc(int32 size);
                static void		Release(void* ptr);
        };

->      Allocator.cpp
        
        /*----------------
                Pool Allocator
        ------------------*/

        void* PoolAllocator::Alloc(int32 size)
        {
                return GMemory->Allocate(size);
        }

        void PoolAllocator::Release(void* ptr)
        {
                GMemory->Release(ptr);
        }
        이 때 GMemory에 에러가 날 수 있는데 그건 Memory.h 가 include되지 않아서 입니다. 


그리고 사용할 얼로케이터를 CoreMacro 에서 매크로 화 해서 사용했었습니다. 일단 지금 실습을 위해 디버그 모드일때 StompAllocator를 사용하던걸
PoolAllocator를 사용하도록 바꿔 주었습니다.
->      CoreMacro.h
        
        /*===================
                Memory
        =====================*/

        #ifdef _DEBUG
        #define A_alloc(size)			PoolAllocator::Alloc(size)
        #define A_release(ptr)			PoolAllocator::Release(ptr)
        #else
        #define A_alloc(size)			BaseAllocator::Alloc(size)
        #define A_release(ptr)			BaseAllocator::Release(ptr)
        #endif

그러면 이제 디버그 모드에서 A_new, A_delete 를 사용하면 PoolAllocator::Alloc, PoolAllocator::Release 를사용하는 A_alloc, A_release가 불려질겁니다.
그안에서 또 전역 객체인 GMemory의 Allocate, Release를 호출하게 되고 이안에서는 또 실제 데이터 크기에 MemoryHeader 의 크기 까지 포함한 크기로 
할당을 하는데 그 크기가 메모리 풀의 범위 안에 들어가면 적당한 메모리 풀에 Pop이나 Push를 하게 됩니다. Pop을 할때 AttachHeader를 하면서 헤더까지 포함한 
사이즈가 헤더에 저장됩니다. 

이런 과정을 통해 메모리 풀을 사용하도록 하였습니다. 

눈여겨 봐야할것은 어떤 범위안의 사이즈인 데이터를 묶어서 관리한다는겁니다. 같은 클래스만 같은 풀에서 관리하는게 아니라 다른 클래스라고 하더라도 그 크기가 
비슷하면 같은 메모리 풀에서 관리하게 됩니다.

GMemory를 사용할때는 메모리 할당까지만 하고 실제 객체를 new 해주지 않습니다. new는 따로 커스텀 할당자에서 placement new를 통해 생성해주었었습니다. 


-- 실습 

실습을 해보겠습니다. 메모리 풀을 실습하기 위해서 멀티쓰레드 환경으로 실습을 해봐야 할겁니다. 
GameServer.cpp 에서 GThreadManager->Launch를 5번 하였습니다. 각 쓰레드에서 실행할 코드는 
Vector<Knight> v(10); 으로 Kngiht 객체 10개를 가진 벡터와 Map<int32, Knight> m; 에 m[100] = Kngiht(); 로 도 Knight 객체를 만들었습니다. 
이것을 무한 루프를 도는 쓰레드가 5개 입니다. 각 쓰레드가 객체를 생성하고 소멸하는걸 계속 반복하게 됩니다. 

마지막으로 GThreadManager->Join() 도 해주고 실행해보았습니다. 

제대로 실행되는걸 확인할 수 있을겁니다. 

중단점을 잡고 디버깅을해보면 StlAllocator로 들어가게 되고 거기서 또 A_alloc을 따라 들어가면 GMemory의 Alloc으로 들어갑니다. 
Knight 객체가 _hp와 _mp를 들고 있기 때문에 크기가 16바이트인데 거기에 메모리 헤더에서 allocSize 4바이트 까지 합쳐 20바이트의 메모리를 할당받으려고 합니다. 

이렇식으로 비교적 간단하게 메모리 풀을 만들어 보았고 다음시간에는 이 메모리 풀을 보안하는 방법을 배워보겠습니다. 