


        UniCode



이전 시간에 패킷을 만들고 읽는 기능을 PacketHandler 라는 이름으로 만들어 봤습니다. 
패킷에 가변데이터를 담는 방법도 알아봤습니다. 그중 문자열을 어떻게 보낼까 가 이번시간의 주제입니다. 

알고 있는 문자열 데이터 타입은 

string name;
wstring name;

이렇게 두가지가 있습니다.
그런데 가변길이의 문자열을 보내야 하기 때문에  

vector<char> 이런것 처럼 문자열의 길이를 먼저 패킷에 넣어주고 각 문자를 차례대로 넣어주면 되지 않을까 생각이 듭니다. 
그리고 이게 사실 일반적으로 간단하게 구현할 수 있는 가변 길이 문자열을 패킷에 넣는방법입니다. 

그러면 왜 따로 강의를 만들어 문자열을 다루느냐 Unicode나 인코딩에 대해 정식으로 다룬적이 없기때문에 기회에 다뤄보는것입니다. 
지금까지는 문자열을 그냥 그러려니 했었는데 이젠 조각조각 내서 다룰것이기 때문에 
문자열에 대해 자세히 알아볼 시간이 필요합니다.

char sendData[1000] = "가";
char sendData2[1000] = u8"가";
WCHAR sendData3[1000] = L"가";
TCHAR sendData4[1000] = _T("가");

문자열도 위와같이 여러가지 버전이 있습니다. 
각각의 버전이 어떤 차이가 있는지 궁금합니다. 

한번 위 코드 뒤에 중단점을 잡고 실행해 각 변수에 커서를 가져다 대보니 sendData2 빼고는 다 "가" 라는 문자열로 인식하고 있습니다. 

디버그에서 변수의 값들을 16진수로 표시하게끔 바꿔주고 각 배열의 값들을 살펴보니 
char 타입의 sendData는 b0, a1 이라는 값을 가지고 있고 이게 "가"를 뜻하고 있는걸 알 수 있습니다.
u8 을 앞에 붙힌 sendData2는 ea, b0, 80 이라고 값이 세개 입니다. u8이 사실 utf-8 을 뜻한다고 합니다. 
WCHAR 타입의 sendData3은 ac00 이라는 2바이트짜리가 몰려서 "가"를 뜻하고 있습니다. 
마지막 TCHAR 타입의 sendData4는 일단 WCHAR와 똑같이 ac00 라는 값을 가지고 있습니다. 

문자열에 대한 여러가지 타입마다 같은 글자를 표시하는 다양한 방식이 있다는걸 알 수 있었는데 지난시간까지 하던 패킷 전송에서 적용하려면 
이 다양한 방법을 잘 알아야 제대로 주고 받을때 분석을 할 수 있을겁니다.

이런 이유로 인코딩과 유니코드에 대해 알아보는 시간을 가져보겠습니다. 


*** 

생각보다 이해하기 어렵지 않은 내용이라고 합니다. 

몇가지 주제를 쪼개어 알아볼것입니다. 

- 문자(Character)
- 문자 집합 (Character Set) vs 인코딩(Encoding)
- CP949 vs UTF-8 vs UTF-16
- MBCS(Multi Byte Character Set) vs WBCS(Wide Byte Charater Set)


차근차근 하나씩 살펴보겠습니다.
 
먼저 '문자'

-- 문자 (Charater)
컴퓨터는 사실 0과 1로이루어진 bit 신호밖에 알아듣지 못합니다. 그중 어떻게 비트를 나열하면 이것을 "A" 라고 하자 이런식으로 약속해놓은게 문자입니다. 

만야 0100 0001 이라는 비트가 있다고 했을때 이것은 16진수로는 0x41, 10진수로는 65라고 할 수 있지만 이것들도 이 비트를 각각 16진수로 해석하겠다,
10진수로 해석하겠다 했을때의 값입니다. 즉, 어떻게 해석할건지에 따라 의미가 달라집니다. 

처음에 컴퓨터언어, 프로그래밍을 만들때 2진수, 16진수, 10진수, 부동소수점등도 필요했을테지만 결국 사람끼리 데이터를 주고 받을때는 알파벳도 굉장히 중요했을겁니다.

그리고 프로그래밍에서 문자는 ABC 같은 그래픽적인 문자를 이야기 하는것입니다. 어떤 비트는 어떤 형태의 픽셀들의 색을 바꾸어 화면에 나타내자고 정하는것이고 
그중 가장 처음 만들어진 규약이 'ASCII'코드 라는 규약입니다. 북미쪽 라틴계열에서 사용하는 알파벳들을 어떤 숫자들과 매핑을 했습니다. 

위에서 예시를 들었던 0100 0001 , 0x41, 65 를 뜻하는 비트는 ASCII 에서 "A" 를 뜻합니다. 

char test = 'A';

이 변수도 디버깅중 들어 있는 값을 16진수로 확인해보면 0x41 이라는 수가 들어있습니다. 
즉 어떤 숫자가 어떤 문자이다 라고 대입해놓은 것들의 모음을 '문자 집합' 이라고 합니다.

-- 문자 집합 (Character Set)
ASCII 코드도 마찬가지로 어떤수가 어떤문자라고 약속해놓은것이기 때문에 문자 집합이라고 할 수 있습니다. 

또 당연하겠지만 문자집합은 딱 한가지만 있는것이 아닙니다. 초창기 프로그래밍에서는 127번까지만 있는 ASCII 코드만으로도 충분했을테지만 
점점 프로그래밍을 전 세계에서 하게 되면서 같은 서양권, 유럽만 해도 각 나라마다의 알파벳이 있고 또 중국에서는 한자들의 종류만해도 엄청나게 많아 집니다. 
마찬가지로 일본어, 한국어도 그렇습니다. 

그래서 ASCII 코드로 전세계의 문자에 대응하는것은 불가능 했습니다. 그래서 초창기에서는 각 나라마다 자기 나라에 맞는 문자 집합, 규약을 만들어 사용했습니다. 
우리나라도 "KS X 1001" 이라는 문자 집합이 있는데 한국 산업 문자 집합 규격을 만들었다고 합니다. 
전형적으로 한국어를 표현하기 위해 만들어 진것이기 때문에 한국어 위주로 표현을 하고 
이런식으로 각 나라마다 자기 편한대로 문자 집합을 사용했던 적이 있습니다. 

이제 문제가 되는것은 나라간에 코드를 교환할때가 문제가 되었습니다. 한국아 KS X 1001 을 사용했을때는 여기에 맞는 규격대로 문자들을 기록했을텐데 
이 코드가 다른 나라로 갔고 사용한 문자 집합이 KS X 1001이라는걸 알려주기 전까지는 완전히 다른식으로 읽히게 됩니다. 

이런 난잡한 상황은 안되겠다 해서 전세계에서 사용하기 위해 약속한 문자 집합이 바로 "UNICODE" 입니다. 
문자들을 비트에 대입해 저장 한다고 했는데 그러면 1Byte 에서 표현할 수 있는 수는 255 까지 인데 이 갯수로는 당연히 세상 모든 문자를 표현할 수 없으니 
2byte를 사용해 봤습니다. 그렇다고 딱 2바이트 전체를 채웠다는 것은 아니고 대략적으로 그렇다는 것입니다. 

당연히 유니코드를 처음만들때 용량을 너무 많이 먹지않고 왠만큼 중요한 문자들을 모두 사용할 수 있도록 만들려고 했을겁니다.
그렇지만 한자나 한국어만 봐도 조합수가 다양합니다. 

그렇다 보니 2바이트를 넘어 문자를 기록하기도 합니다. 거의 사용하지 않는 문자들이긴 합니다.

이제 그러면 어떤 상황이던지 간에 2바이트 정도 되는 유니코드를 사용하면 되는가 하면 그것도 아닙니다. 
만약 어떤 서비스는 정말 북미 내에서만 사용할 것이라고 한다면 ASCII 코드정도 범위만 사용해도 될겁니다. 게다가 유니코드의 가장앞에는 ASCII 코드와 완전히 호환되도록 
Basic Latin 문자들이 모여 있습니다. 

돌고 돌아서 북미에서 서비스 하기 까지 127개의 문자만 필요한데 유니코드형식을 지키기 위해서 2바이트나 되는 용량을 항상사용해야 하냐면 그것은 아닐것입니다. 

프로그래머용 계산기에서 1바이트를 비트로 표현하면 0000 0000 까지 이고 가장 앞의 수 빼고 모든 비트를 키면 0111 1111 , 10진수로는 127 입니다. 
즉, 문자열을 1바이트크기로 해석하고 최상위 비트가0인상태라고 하면 ASCII 코드로 인지하겠다 라고 할 수 있고 
그게 아니고 다른 언어도 표현하겠다 라고 해서 127 이상의 비트를 세팅하는 순간 다른 언어로 받아들이겠다 라고 우리만의 규약을 만들면 
대부분의 경우에는 1바이트로 표현하되 특수한 경우에만 바이트 수를 늘려 사용하겠다고 할 수 있을겁니다. 

-- 인코딩 (Encoding)
여기서 인코딩에 대해 알아볼 차례입니다. 문자 집합과 인코딩을 구별할 수 있어야 하는데 
인코딩은 똑같은 데이터를 다른 형식으로 변환해서 관리하는것을 말합니다.

예를 들어서 'hello.txt' 라는 텍스트 파일이 있다고 하고 이 파일을 압축할때 압축 방식도 여러가지 있습니다. 윈도우에서 많이 사용하는 ZIP 파일 방식도 있고 
리눅스에서 사용한다고 하는 tar.gz 방식도 있다고 합니다. 
이렇게 다양한 방식으로 압축을 하지만 결국 표현하고 있는 데이터는 동일 할것입니다. 

인코딩도 결국에는 표현할 데이터는 똑같지만 다른 숫자로 변환해 들고 있을 일종의 압축 알고리즘이라고 볼 수 있습니다. 

어떤 압축 규칙을 지정해서 압축후 바이트의 첫비트가 0으로 시작한다면 이 문자는 ASCII 코드를 이용해서 영문으로 인지하겠다 라는 규칙을 만들고 
그게 아니고 첫 비트가 1로 켜져 있다고 하면 나머지 부분들을 사용하겠다, 예를 들어 시작이 110x xxxx 로 시작하면 128 ~ 2047 까지의 수를 말한다고 인식할것이고 
1110 xxxx 으로 시작하면 2048 ~ 65535 사이의 데이터로 판별할것이다라고 규약을 만드는 것입니다. 

이렇게 하면 만약에 운이 나쁘게 용량이 큰 1110 으로 시작하는 문자라면 용량을 많이 차지 하겠지만 대부분이 0으로 시작하는 문자라면 그만큼 용량에 이득을 본다고 할 수 있습니다. 
 
그래서 유니코드는 대부분 2바이트로 표현할 수 있지만 알파벳은 1바이트 한글을 3바이트 사용하도록 압축할 수 있습니다. 

문자 집합과 인코딩은 이렇게 의미가 다르지만 의미를 혼용해서 사용하는 경우가 많습니다. 그렇기 때문에 너무 엄밀하게 따지지 말고 대충 이해하면서 사용하면 되겠습니다. 

추가로 여러가지 압축 방법이 있지만 대표적인 압축 방식이 'UTF-8' 입니다. 
UTF-8은 기본적으로 유니코드 문자집합을 사용하긴 하지만 인코딩 방식을 특이하게 해서 영문은 1바이트, 한글을 3바이트로 표시하는 위에서 예시를 든 방식을 사용합니다. 

UTF-8 이라는 이름중 8이라는 숫자가 의미하는것은 8비트를 최소 단위로 사용한다는 뜻입니다. 
UTF-16 이라는 인코딩 방식이 있는데 이것은 단순한데 유니코드의 2바이트 까지를 그대로 사용한다는 의미입니다. 
유니코드는 정말 자주 사용하지 않는 문자들을 2바이트 이상에 매핑해두었다고 했었는데 그래서 자주 사용하는 문자들을 그냥 유니코드 그대로 해석하고 
그래서 영문도 한글도 2바이트로 표현한다는 특징이 있습니다. 

그렇기 때문에 영어를 위주로 사용하는 환경이라면 UTF-8이 이득이고 한글이나 중국어 일본어를 주로 사용하는 환경이면 UTF-16이 이득이 됩니다. 

서로 장단점이 있기 때문에 필요에 따라 선택해 사용하면 될것입니다. 


또 추가로 마이크로소프트에서 도입한 인코딩 방식 중 'CP949' 라는 것이 있습니다. 코드페이지 949 라는의미인데 
우리가 어떤 인코딩 방식을 사용한다고 해서 하나의 문자 집합을 사용해야 한다는 것은 아닙니다. 
CP949는 신기하게도 문자 집합 두가지를 같이 사용하고 있습니다. 영문권에서는 KS-X-1003 이라는 문자집합을 사용하고 한글같은 경우에는 KS-X-1001 문자집합을 사용한다는게
CP949 인코딩 방식입니다.

요즘은 유니코드를 사용하는것이 대세이기 때문에 일부러 사용할 필요는 없겠지만 

비주얼 스튜디오에서 char 타입으로 한글을 작성하면 CP949형태로 사용이 됩니다.  

-- MBCS vs WBCS
마지막으로 이 두가지에 대해 알아보겠습니다. 

나중에 비주얼 스튜디오에서 설정할 수 있는 부분이긴합니다. 

MBCS (Multi Byte Character Set)
- char 타입을 사용하면 사실상 MBCS를 사용한다는 의미입니다.
- 개별 문자를 다수의 바이트로 표현한 문자 집합 입니다.

WBCS (Wide Byte Character Set)
- wchar 타입이 WBCS를 사용한다는 뜻입니다.
- 유니코드 기반의 문자 집합을 사용(Windows 기준으로는 UTF-16 으로 받아주려고 합니다.)

그래서 우리가 코드에서 char를 사용하느냐 wchar를 사용하는냐에 따라 갈리는데 

우리가 UTF-16 을 사용해 코드를 주고 받을 예정이라고 하면 모든 문자열을 wchar 로 만들어 관리해야 한다는 것이고 
필요에 따라 CP949를 사용한다고 하면 char로 관리해야 한다는 뜻입니다.


문자열에 대한 이런 내용들을 고려해 생각해보면 우리가 UTF-16을 기준으로 문자들을 다루고 있었는데 다른 곳에서 UTF-8 기준으로 코드를 만든다면 
두 코드는 서로 데이터를 분석하지 못할것입니다. 


***

-- 결론 

문자 vs 문자 집합 vs 인코딩 
이 세가지 개념에 대해 구별할 수 있게 되었고 

또 인코딩 방식중 자주 사용하는 
CP949 vs UTF-8 vs UTF-16
에 대해서도 알아 봤습니다. 

또 char 타입과 wchar 타입이 뜻하는 MBCS vs WBCS 도 알아 봤습니다. 


*** 

-- 실습 

알아본 내용을 실습을 통해 좀더 이해해보겠습니다. 

이번 시간 처음에 확인했던 코드를 다시 보면 


	// 여러가지 버전의 문자열
	char sendData[1000] = "가";			// CP949 = KS-X-1001(한글문자 2바이트) + KS-X-1003(로마문자 1바이트)
	char sendData2[1000] = u8"가";		// UTF-8 = Unicode를 사용하되 한글 3바이트 로마 1바이트로 변환함
	WCHAR sendData3[1000] = L"가";		// UTF-16 = Unicode를 사용하되 한글/로마 둘다 2바이트 로 거의 Unicode 그대로 사용
	TCHAR sendData4[1000] = _T("가");


이렇게 정리가 되는걸 알 수 있습니다. 
다시 디버깅에서 주소에 담겨있는 데이터를 보면 CP949를 사용하는 sendData는 1바이트 두개를 사용해 한글 2바이트로 표현하는걸 확인할 수 있고 
UTF-8을 사용하느 sendData2는 1바이트 3개를 사용해 표현하고 
UTF-16을 사용하는 sendData3은 2바이트 하나를 사용해 표현하고 있다는걸 알 수 있습니다. 

위에서 알아봤던 내용 그대로 입니다. 

그러면 마지막인 TCHAR는 무엇인가 하면 데이터만 보면 WCHAR와 똑같은 형태를 하고 있습니다. 
TCHAR를 사용하는 경우는 어떤 라이브러리를 만들때 이 라이브러리가 어떤 환경에서 사용될지를 특정할 수 없다고 하겠습니다. 
그럴 경우 특정 인코딩방식을 사용하면 범용적으로 사용하기 어려울 수 있으니 애매하게 사용하는 쪽에서 골라달라고 할때 사용하는게 TCHAR입니다.

지금 우리환경에서는 GameServer 우클릭 -> 속성 -> 고급 -> 문자 집합  을 살펴보면 유니코드 문자 집합 사용이라고 되어있습니다. 
그렇기 때문에 TCHAR는 WCHAR로 변환이 되어 사용되지만 설정에서 멀티바이트 문자집합으로 옵션을 바꿔 버리면 char 로 변환되어 사용이 될겁니다. 

환경에따라 알아서 골라주게 할 수 있는 조커픽이 TCHAR 라고 할 수 있습니다. 

-- ServerPacketHandler

SendBufferRef ServerPacketHandler::Make_S_TEST(uint64 id, uint32 hp, uint16 attack, vector<BuffData> buffs, wstring name)
{
	SendBufferRef sendBuffer = GSendBufferManager->Open(4096);

	BufferWriter bw(sendBuffer->Buffer(), sendBuffer->AllocSize());
	PacketHeader* header = bw.Reserve<PacketHeader>();
	// 인자로 데이터를 밀어넣습니다.
	bw << id << hp << attack;

	// 가변 데이터 
	// 먼저 가변데이터의 사이즈를 밀어 넣습니다. 메모리가 아까우니 uint16으로 캐스팅합니다.
	bw << (uint16)buffs.size();

	// 이제 가변 데이터의 내용물들을 하나씩 넣어줍니다. 
	for (BuffData& buff : buffs)
	{
		bw << buff.buffId << buff.remainTime;
	}

	// 가변 데이터 2탄 wstring 문자열 
	// 위쪽 가변데이터와 똑같은 방식을 사용합니다.
	// 먼저 문자열의 크기를 밀어 넣습니다. 
	// UTF-16 기준으로 size()를 사용하면 마지막에 null종단문자는 사이즈에 포함되지 않습니다. 
	// 어짜피 UTF-16을 사용한다고 알고 있으면 받는쪽에서 처리해줘도 됩니다. 
	bw << (uint16)name.size();

	// BufferWrite.Write 함수는 void* 타입으로 src를 받아주고 있엇습니다. 
	// 사이즈는 문자열의 갯수에 문자 한개당 크기(sizeof(WCHAR))를 곱해주었습니다. 
	bw.Write((void*)name.data(), name.size() * sizeof(WCHAR));

	header->size = bw.WriteSize();
	header->id = S_TEST;

	sendBuffer->Close(bw.WriteSize());

	return sendBuffer;
}

-- GameServer
	while (true)
	{
		// 가변데이터를 만듭니다.
		vector<BuffData> buffs{ BuffData{100, 1.5f}, BuffData{200, 2.3f} , BuffData{300, 0.7f} };

		// 패킷 핸들러에서 패킷을 만들어주는 기능을 추가 했습니다. 
		SendBufferRef sendBuffer = ServerPacketHandler::Make_S_TEST(1001, 100, 10, buffs, L"안녕하세요");

		GSessionManager.Broadcast(sendBuffer);

		this_thread::sleep_for(250ms);
	}

-- ClientPacketHandler

void ClientPacketHandler::Handle_S_TEST(BYTE* buffer, int32 len)
{
	// 패킷을 처리만 하는 함수이긴하지만 header 까지 꺼내줘야 순서가 맞습니다. 
	BufferReader br(buffer, len);

	PacketHeader header;
	br >> header;

	uint64 id;
	uint32 hp;
	uint16 attack;

	br >> id >> hp >> attack;

	cout << "ID :" << id << " HP :" << hp << " ATT:" << attack << endl;


	// 가변데이터 파싱
	// 추출할 그릇
	vector<BuffData> buffs; 

	uint16 buffCount;

	// 패킷에 담았던 순서 그대로 꺼냅니다.
	br >> buffCount;

	buffs.resize(buffCount);
	for (int32 i = 0; i < buffCount; i++)
	{
		br >> buffs[i].buffId >> buffs[i].remainTime;
	}

	cout << "BuffCount : " << buffCount << endl;
	for (int32 i = 0; i < buffCount; i++)
	{
		cout << "Buff Info : " << buffs[i].buffId << " " << buffs[i].remainTime << endl;
	}

	// 문자열을 받아줄 그릇
	// Make_S_Test에서와 똑같은 순서로 데이터를 꺼냈습니다. 
	wstring name;
	uint16 nameLen;
	br >> nameLen;
	name.resize(nameLen);

	br.Read((void*)name.data(), nameLen * sizeof(WCHAR));
	
	// wstring 을 사용하면서 wcout 을 사용해야 한다거나 추가 설정을 해야하는것이 있습니다
	wcout.imbue(std::locale("kor"));
	wcout << name << endl;
}


이렇게 해서 가변길이 데이터를 보내는 방법중 문자열에 대한 것도 실습을 해봤습니다. 

가변길이 데이터의 갯수를 먼저 패킷에 밀어넣고 그 뒤로 데이터들 자체도 차례대로 밀어넣는다는 방법을 문자열에 똑같이 적용할 수 있었습니다. 

이 방법이 가장 효과적인 방법은 아니지만 가장 단순하고 직관적인 방법입니다. 