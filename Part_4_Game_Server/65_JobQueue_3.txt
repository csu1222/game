


    JobQueue 3 



이전시간까지 굉장히 난해한 템플릿문법을 알아보았습니다. 이전 시간에 만든 Job이 최종적으로 사용할 방법은 아니지만 
C++의 이해도를 높히는데에는 도움이 되었을것입니다.  

오늘 최종적으로 사용할 버전은 아니기 때문에 이전 코드들은 다 날릴 것입니다. 
이제부터는 Job을 ServerCore쪽에서 관리할것입니다. ServerCore 밑으로 Job 필터를 하나 만들고 거기에 작업을 하겠습니다. 
Job, JobQueue 클래스 파일들을 추가해주고 이전 코드들중에 JobQueue 부분은 그대로 사용할것이기 때문에 새로 만든 JobQueue파일로 복사해줍니다. 
복사할때 JobRef 라는 using은 Types.h 에 옮겨줍니다. 

using JobRef = shared_ptr<IJob>; 이코드를 Types로 옮기는에 이제는 IJob이란 클래스가 아니라 오늘 만들 Job 클래스 자체를 전방선언과함께 추가합니다.

using JobRef				= std::shared_ptr<class Job>;

이제는 ServerCore에서 어떻게 Job클래스를 만들지를 고민해야하는데 그전에 이전 테스트하던 GameServer의 Job 파일들을 삭제해줍니다. 

지금처럼 사용하던 코드들을 그냥 지워버리면 테스트하기 어렵기 때문에 일단 에러나는 부분들을 주석처리해 빌드는 되도록 만들어줍니다. 
주석처리한 부분은 GameServer의 테스트 코드, Room의 FlushJob과 JobQueue, ClientPacketHandler 쪽에서 GRoom::PushJob 대충 이런 부분들을 주석처리해주었습니다.  

***

이제 이번시간에 만들 최종적인 Job에 대해 알아보겠습니다. 

사실은 C++11으로 넘어오면서 굉장히 강력한 기능을 얻었는데 깊게 생각하지 않는 경우가 많다고 합니다. 
바로 람다식입니다. 그리고 functional.h 와 조합을 하는것입니다. 

어떤 느낌이냐면 


#include <functional>

std::function<void(void)>;

function이라는것을 사용할 수 있는데 위의 형태라면 반환타입 void 인자도 void 형태의 함수를 다 받아줄 수 있습니다. 
그리고 이걸 람다식으로 표현할수도 있습니다. 

	PlayerRef player = MakeShared<Player>();

	std::function<void(void)> func = [=]()
	{
		GRoom.Enter(player);
	};

	func();

어떤 플레이어가 Room에 들어간다고 했을때 func라는 function 객체에 람다식으로 Enter 를 하겠다고 담아두면 나중에 필요할때 func를 호출하면 그때 동작할 수 있습니다. 
아주 간단해 보이는 방법입니다. 

이전시간에 배웠던 functor를 잘 알게 되면 람다에 대한 이해가 더 쉬워집니다.

람다식을 처음 배울때는 그냥 익명함수라고 배울것입니다. 
처음 배웠던 함수는 반환타입, 함수 식별자, 인자, 구현부 까지 해서 
void HelloWorld()
{
    cout << "Hello World" << endl;
}
이렇게 만드는 함수를 
std::function func = [=]()
{
    cout << "Hello World" << endl;
}
이런식으로 구현부만 빼서 만들 수 있다고 배울겁니다. 

그런데 람다식에는 [] 안에 들은 람다 캡쳐라는 개념도 있습니다. 캡쳐라는것이 이전시간에 만들었던 functor와 느낌이 비슷합니다.

만약 인자를 받는 함수가 있다고 해보겠습니다.

void HelloWorld(int32 a, int32 b)
{
    cout << "Hello World" << endl;
}

이 함수를 호출할때 인자를 아래와 같이 줄 수 있을텐데

HelloWorld(1, 2); 

이것을 함수 포인터로 만들면 인자들을 저장할수 없어서 그래서 함수자 functor를 만들때 std::tuple에 인자들을 저장하고 호출할때 복원하는 작업을 이전시간에 했던겁니다.

그런데 람다에서는 그냥 

PlayerRef player = MakeShared<Player>();
std::function func = [=]()
{
		HelloWorld(1, 2);
		GRoom.Enter(player);
}

이런 코드가 실행됩니다. 아예 모를때는 그냥 되는가보다 했지만 
functor를 배우고 나면 이것이 신기해 보입니다. 

지난시간에 배웠던 난해한 코드를 람다식에서는 간단하게 지원한다는것입니다. 그리고 이런 것들을 프로그래밍에서 클로져라고 합니다.  
람다식에서 인자가 있는 함수를 사용하면 컴파일러가 내부적으로 그 인자들을 들고 있는 클래스를 만듭니다. 

힘들게 만들었던 부분을 컴파일러가 알아서 처리해주기때문에 우리는 std::function이 Job 이라고 생각할 수 있다면 나머지 문제들은 다 해결이 된다고 할 수 있습니다.

하지만 람다식에 장점만 있는것은 아닙니다. 
C++과 람다식 간의 궁합이 안맞는것이라고 할 수 있는데 

std::function func = [=]() { }

이런 람다식에서 [] 이 부분을 캡쳐라고 합니다. 캡쳐에 아무것도 주지 않으면 외부에서 가져온 변수를 사용하면 에러가 나게 되고 [=]으로 복사 모드로 사용하면 
외부인자를 복사 형식으로 가져올것이고 [&]으로 참조 모드로 사용하면 외부인자를 참조형식으로 사용할것입니다. 

그러니까 만약 Player를 인자로 받는 함수를 람다식으로 호출한다면 컴파일러가 인자를 클래스로 자동생성해서 저장해두게 될건데
class Test
{
public:

private:
	PlayerRef _player1;	
	PlayerRef& _player2;
}

[=]은 _player1 처럼 복사 방식, [&]은 _player2 처럼 참조 방식으로 만들어줄것이라는 이야기 입니다. 

그리고 전체를 대상으로 모드를 지정하는것 뿐만 아니라 각각에 대해서 지정해 줄 수 있습니다. 

	PlayerRef player = MakeShared<Player>();
	std::function<void(void)> func = [player]()
	{
		HelloWorld(1, 2);
		GRoom.Enter(player);
	};
	
	PlayerRef player = MakeShared<Player>();
	std::function<void(void)> func = [&player]()
	{
		HelloWorld(1, 2);
		GRoom.Enter(player);
	};

위쪽은 player를 복사 방식으로 가져오겠다. 아래쪽은 player를 참조 방식으로 가져오겠다고 개별 지정한것입니다.


그러면 이런 람다의 캡쳐가 C++와 왜 안어울리는지를 알아보자면 
람다식으로 만든 함수를 바로 사용하면 모르겠는데 우리가 사용하고 싶은 방식은 Job으로 사용하기위해 JobQueue에 넣어 놨다가 적절한 때에 꺼내 처리하고 싶은겁니다. 
그러기 위해서 캡쳐해서 넣어준 값들이 JobQueue에서 처리 될 때 까지 유지 되어야 된다는겁니다. 

위의 코드를 예로 들어서 func 안에서 GRoom의 Enter 인자로 player를 받고 있는데 캡쳐가 참조 방식이라고 해보겠스빈다. 
그러면 PlayerRef& 라는 타입일겁니다 PlayerRef는 또 shared_ptr<Player> 인데 이걸 또 참조값으로 받고 있는겁니다. 이 MakeShared로 생성된 Player 객체, 이 객체를 가리키는
스마트 포인터인 PlayerRef를 참조하게 되면 Player 객체의 참조 카운트가 더 늘지는 않게 됩니다. 따로 shared_ptr이 하나 더 생기는게 아니라 가리키던걸 다시 참조하는 형태 이기 때문입니다. 

그러다 보니 player의 참조 카운트가 0이 되어서 삭제가 된다고 하면 player가 유효하지 않게 됩니다. 그래서 캡쳐를 하고 그게 객체인 경우에는 그 객체의 생명주기가 사용이 끝날때 까지 
살아있도록 보장을 해줘야합니다. 이것은 이전에 네트워크 라이브러리를 만들면서 Send, Recv 같은 일감을 걸어줄때 반드시 그 세션이 정상적으로 살아있어야지만 말이됬던것과 마찬가지로
람다에서도 사용하는 객체가 유지 되어야 합니다. 
마찬가지로 전역으로 만들어 뒀던 GRoom 도 마찬가지로 생명주기가 보장 되어야합니다. 

또 람다를 사용할때 참조카운트와 생명주기에 대한 문제 말고도 다른 문제가 있는데 


class Knight
{
public:
	void HealMe(int32 value)
	{
		_hp += value;
		cout << "HealMe!" << endl;
	}

	void Test()
	{
		auto job = [=]()
		{
			HealMe(_hp);
		};
	}

private:
	int32 _hp = 100;
};

이런 클래스가 있다고 해보겠습니다. 
멤버 변수로 _hp가 있고 힐을 달라고 하는 멤버 함수가 하나 있습니다. 그리고 Test라는 함수에서는 이 HealMe의 기능을 하는 잡을 만들어 줄겁니다. 이때 
HealMe의 인자로 자기 자신의 멤버 변수인_hp를 복사 방식으로 넘겨주고 있습니다.  이 상황이 문제 없어 보일수 있습니다. 그리고 이 job을 외부로 반환해준다거나 해줄 수도 있습니다. 

그런데 사실은 벌써 치명적인 버그가 숨겨져 있습니다. 람다 캡쳐를할때 모든 것을 복사하겠다는 [=]은 위험합니다. 
		
	auto job = [=]()
	{
		HealMe(_hp);
	};

이 식에서는 실제로는 _hp만 복사하고 있는게 아니라 this->_hp 를 복사하고 있는걸 생략하고 있는것이었습니다.즉 자신의 주소를 복사해 들고 있는겁니다. 
이때 자신의 주소라는것은 Knight 라는 객체가 유효해야 가능한건데 애당초 이걸 반환했다가 자신 객체가 유효하지 않게되면 이미 반환되어 있는 Job은 유효하지 않은 메모리를 
들고 있게 되는것이기 때문에 아주 위험해집니다. 

그래서 람다를 사용할때는 어지간해서는 어떻게 캡쳐를 할건지 명시해 주는게 좋습니다. 
	
	auto job = [this]()
	{
		HealMe(this->_hp);
	};

이렇게 명시를 해놓는다면 아직 위험한것은 마찬가지이지만 적어도 나중에 버그를 찾을때 여기가 이상하다는걸 쉽게 알 수 있을겁니다. 
거기다 Knight 객체를 shared_ptr로 들고 있었다면 this를 사용하는것 자체가 안됩니다. 
만약 shared_ptr를 사용하기로 했다면 enable_shared_from_this를 상속하고 자신의 포인터를가리킬때는 sharred_from_this() 를 사용해 자신을 가리킵니다. 

class Knight : public enable_shared_from_this<Knight>
{
public:
	void HealMe(int32 value)
	{
		_hp += value;
		cout << "HealMe!" << endl;
	}

	void Test()
	{
		auto job = [self = shared_from_this()]()
		{
			self->HealMe(self->_hp);
		};
	}

private:
	int32 _hp = 100;
};

self 라는 이름으로 저장해 사용하고 있습니다.
이 shared_from_this를 사용하게 되면 자신을 가리키는 포인터도 참조 카운트를 증가시키기 때문에 사용중에는 유효하다는걸 보장할 수 있습니다.

그리고 인터넷에 떠돌고 있는 말중에 람다 식과 shared_ptr을 같이 사용하면 메모리 릭이 일어난다는 말이 있다고 합니다. 
이런 코드인데 

class my_class
{
	// ...
public:
	typedef std::function<void()> callback;
	void on_complete(callback cb) { complete_callback = cb; }
private:
	callback complete_callback;
	// ...
}

// ... 
std::shared_ptr<my_class> obj = make_shared<my_class>();
obj->on_complete([obj]()
	{
		obj->clean_someting-up();
	});

이런 코드를 실행하면 참조카운트가 0이 되지않고 메모리 누수가 일어 난다는 것입니다.

이 주장은 사실상 my_class 안에 shared_ptr<my_class> obj가 생긴것과 같습니다. 이것은 람다 식과 관계없이 클래스 내부에서 사이클이 생긴문제입니다.
그러니까 람다에서 shared_ptr를 같이 사용하는건 가능한 일이고 조심해야 할것은 참조 사이클이 생기지 않도록 관리하는것이겠습니다. 


우리 테스트 프로젝트에서 Room을 간단하게 사용하기 위해 그냥 extern 전역 객체로 만들었었는데 이것을 extern 이긴한데 shared_ptr 로 만들어 테스트 해보겠습니다. 

class Room : public enable_shared_from_this<Room>
{
public:
	void Enter(PlayerRef player);
	void Leave(PlayerRef player);
	void Broadcast(SendBufferRef sendBuffer);

public:
	void FlushJob();

private:
	map<uint64, PlayerRef> _players;

};

extern shared_ptr<Room> GRoom;

이렇게 shared_ptr 을 사용하도록 수정하고 람다 테스트 하던 코드에서는 


	PlayerRef player = MakeShared<Player>();
	std::function<void(void)> func = [self = GRoom, &player]()
	{
		HelloWorld(1, 2);
		self->Enter(player);
	};

이런 식으로 사용 할 수 있을겁니다. 

이렇게 사용해도 스마트 포인터 관련 문제가 일어 날 수도 있지 않은가 할 수 있는데 이런 걱정을 해결하기 위해 ServerCore쪽 Job 파일들 코드를 작업해보겠습니다. 


/*----------
	Job
-----------*/

// 람다식에서는 따로 인자를 받기보다는 캡쳐를 해 사용하기때문에 
// 반환 void, 매개변수 void 형으로 만들었습니다.
using CallbackType = std::function<void()>;

class Job
{
public:
	Job(CallbackType&& callback) : _callback(std::move(callback))
	{
	}

	// shared_ptr을 관리해주는 버전
	template<typename T, typename Ret, typename... Args>
	Job(shared_ptr<T> owner, Ret(T::* memFunc)(Args...), Args&&... args)
	{
		_callbackt = [owner, memFunc, args...]()
		{
			(owner.get()->*memFunc)(args...);
		};
	}

	void Execute()
	{
		_callback();
	}

private:
	CallbackType _callback;
};

반환 void, 인자 void 형의 함수를 CallbackType 이라고 정의 하겠습니다. Job에서는 이 CallbackType을 멤버 변수로 들고 있을것이고 이후 
일감을 처리할때 Execute로 호출해줄건데 멤버 변수 _callback을 어떻게 초기화 해줄것인지를 역시 생성자에서 받아올겁니다. 
두가지 생성자를 만들었습니다. 첫번째 생성자는 그냥 곧바로 콜백 함수를 받는 버전입니다. 
그리고 두번째 생성자는 shared_ptr을 받는 버전입니다. 어떻게 사용할 수 있는가 하면 Job을 만들때 인자로 owner, memFunc, args... 를 넘겨주면 
알아서 참조 카운트를 증가시켜주는 식으로 동작한다고 합니다. 

코드로만 보면 잘 와닿지 않을 수 있기 때문에 예제를 같이 보겠습니다. 
먼저 Job을 편하게 사용할 수 있도록 JobSerializer 라는걸 만들어 보겠습니다. 
이게 왜 필요하냐면 이전에 Room에서 Push랑 Flush를 각각 함수를 만들어 사용하고 있었습니다.
이것을 매번 만들어주기는 귀찮으니 JobQueue를 사용하는 애들은 JobSerializer를 상속받게 해줄겁니다. 

#include "Job.h"
#include "JobQueue.h"


class JobSerializer : public enable_shared_from_this<JobSerializer>
{
public:
	void PushJob(CallbackType&& callback)
	{
		auto job = ObjectPool<Job>::MakeShared(std::move(callback));
		_jobQueue.Push(job);
	}

	template<typename T, typename Ret, typename... Args>
	void PushJob(Ret(T::*memFunc)(Args...), Args... args)
	{
		shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
		auto job = ObjectPool<Job>::MakeShared(owner, memFunc, std::forward<Args>(args)...);
		_jobQueue.Push(job);
	}

	virtual void FlushJob() abstract;

protected:
	JobQueue _jobQueue;
};

JobSerializer는 JobQueue를 들고 있으면서 인자로 받을 Job을 JobQueue에 넣거나 실행하는 클래스입니다. Push 할때는 두가지 버전을 만들어 주었는데 
하나는 이번시간에 배운 람다식을 바로 넘겨주는 방법이고 다른 한가지 방법은 이전시간처럼 따로 클래스를 만들고 그 멤버 함수를 Job으로 만들어 JobQueue에 넣는 버전입니다. 

앞으로 JobQueue.h는 이곳저곳에 써먹을 것 같으니 공용 헤더인 CorePch쪽에 추가 해주었습니다.

다음할작업은 Room 코드를 수정해줄것인데  

#include "JobSerializer.h"

class Room : public JobSerializer
{
public:
	void Enter(PlayerRef player);
	void Leave(PlayerRef player);
	void Broadcast(SendBufferRef sendBuffer);

public:
	virtual void FlushJob() override;

private:
	map<uint64, PlayerRef> _players;
};

extern shared_ptr<Room> GRoom;

void Room::FlushJob()
{
	while (true)
	{
		JobRef job = _jobQueue.Pop();
		if (job == nullptr)
			break;
		job->Execute();
	}
}

방금 만든 JobSerializer를 상속시켜주면서 이전에 만든 구조를 그대로 사용할 수 있도록 해주었습니다. 

남은 코드는 테스트하는 부분인데 GameServer 쪽 테스트 코드를 수정해보겠습니다. 
바뀔 부분은 GRoom.FlushJob을 호출할때 GRoom이 shared_ptr로 가리키도록 했기 때문에 GRoom->FlushJob() 으로만 바꿔주면 됩니다. 

PushJob을 하는부분은 ClientPacketHandler 쪽 코드들이었습니다. 
그 중 Handle_C_ENTER_GAME, Handle_C_CHAT 이었습니다. 
이번 강의 시작할때 잠시 주석 처리 했던 부분들을 복원 할건데 

방에 입장할때는 
	
	GRoom->PushJob(&Room::Enter, player);

채팅을 Broadcast할때는 

	GRoom->PushJob(&Room::Broadcast, sendBuffer);

이런식으로 사용할 수 있을겁니다. 

이제 프로젝트를 클라와 서버 둘다 실행해서 확인해보면 이전에 했던대로 로그들이 쫙 뜰겁니다.

결과물은 많이 달라지지 않았지만 내부적으로 경합상황을 많이 줄이기 위한 JobQueue를 도입했고 그 중에서도 좀더 편하고 안전한 방법을 찾아서 
직접 클래스를 하나하나 만들어 Job으로 사용하는 방법, 함수자와 함수 포인터를 가지고 Job을 만드는 방법, 람다식을 사용해 Job을 만드는 방법등을 알아 봤습니다. 

아직 끝난게 아닙니다. 
다음으로 생각해 봐야 할 것은 Push, Pop을 어떻게 할것인가 입니다. 지금은 일감을 넣어주는애 따로 일감을 꺼내주는애가 따로 있습니다. 
그 중 일감을 꺼내는 부분은 FlushJob() 을 호출하는 부분인데 이것을 지금은 메인스레드에서 처리해주도록 하고 있고 그냥 while루프를 돌면서 계속 호출하고 있습니다. 

지금이야 간단하게 테스트 하기 위해 Room을 하나만 만들어서 테스트 하고 있지만 나중에 가면 Room이 어마어마하게 많아 질 수 있고 또 정책에 따라서 
JobQueue를 Room마다 배치하는게 아닌 객체 마다 배치하는 경우도 있습니다. 특히 심리스 MMO를 만들때는 객체마다 JobQueue를 배치하는경우가 많다고 합니다.

즉, Knight, Monster, Missile 등 움직이는 모든 객체 마다 각자의 JobQueue를 가지고 있게 될건데 그럴때는 무한루프를 돌면서 FlushJob를 호출하는게 
애매해 집니다. 나중에 가서 객체가 많아지면 지금처럼 메인스레드 하나만 처리하는게 아닌 여러 스레드가 GRoom에만 접근하는것은 무리가 갑니다. 