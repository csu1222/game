


        OverLapped 모델 (+ 단어 정리)


오늘 주제인 OverLapped 모델은 앞으로 중요하게 사용하게될 모델입니다. 이전 Select, WSAEventSelect 모델들은 클라이언트에서나 
사용할 모델이지만 
OverLapped 모델은 서버에서도 중요하게 사용된다고합니다.
그래도 OverLapped 모델을 어떻게 사용하는지는 좀 있다 실습을 하면서알아볼것이고 
그전에 먼저 단어 정리부터 하고 시작하겠습니다. 

지금까지 여러 용어들이 나왔습니다. 
블로킹 (Blocking) , 논블로킹 (NonBlocking), 동기 (Synchronous), 비동기 (Asynchronous) 이런 용어들이 여럿 나왔는데 확실이 이게 무엇이다 딱 
집고 넘어가는 시간을 가져보겠습니다. 

뉘앙스로 보면 블로킹과 동기, 논블로킹과 비동기가 서로 비슷한 개념처럼 보일수도 있는데 이런 애매한 용어의 경계를 알아보겠습니다. 

동기, 비동기 와 블로킹, 논블로킹이 각각 2 X 2 로 총 4개의 경우의 수가 나올수 있는데  

동기-블로킹, 비동기-블로킹, 동기-논블로킹, 비동기-논블로킹 

위의 네가지중 블로킹인지 논블로킹인지를 기준으로 먼저 이야기 해보겠습니다. 
어떤 기준이냐면 함수를 호출하면 대기를 하는지? 아니면 바로 완료가 되는지? 를 기준으로 보면됩니다. 
소켓프로그램을 시작할때 배웠던 내용에서는 기본적으로 모두 블로킹 방식의 소켓이었습니다. connect, accept, recv, send 같은 소켓 함수들은
블로킹 방식일때는 각 함수 호출 성공 조건이 맞지 않으면 대기하다가 조건이 맞으면 동작하기 시작했었습니다. 
이것이 블로킹 방식에서의 소켓 함수들이었고 
ioctlsocket 함수로 소켓을 논블로킹 방식으로 바꿔서 실습했을때는 소켓함수들을 호출했을때 호출하자마자 결과가 있건없건 거의 바로 반환을 해주고
이것을 루프를 돌면서 성공값을 리턴할때 까지 반복 호출해주는게 논블로킹 방식의 소켓이었습니다. 

이런식으로 블로킹, 논블로킹을 구별하는건 소켓 함수를 호출했을때 성공할때 까지 대기를 하느냐 아니면 호출의 결과값이 없더라도 바로 반환을 하느냐 의 차이입니다. 

위의 내용들을 보았을때 블로킹 소켓이건 논블로킹 소켓이건 소켓함수들은 동기 방식으로 동작합니다. 
여기서 말하는 동기, 비동기를 쉽게 보자면 
동기(Synchronous)는 '동시에 일어나는' 걸 뜻한다고 할 수 있고 반대로 비동기(Asynchronous)는 '동시에 일어나지 않는'것을 뜻한다고 할 수 있습니다.
그러면 뭐가 동시에 일어나고 아닌지를 알아야 합니다. 
바로 호출-연산-반환이 동시에, 연속적으로 일어나야 하는지 아니면 꼭 그렇지 않아도 되는지 입니다. 
동시에 일어나야한다는건 어떤 함수를 호출하고 연산, 반환 까지 중간에 다른 작업은 하지않고 이 함수만 코드 한줄씩 처리하는것인데 
비동기 방식은 꼭 동시에 일어나지 않아도 된다는 표현은 비동기 방식이라도 동시에 일어날 수도 있지만 각 동작이 떨어져서 처리되어도 가능하다는 것입니다. 
그래서 비동기 방식에서 함수를 호출 하고 나서 다른 코드가 먼저 실행된후 먼저 실행했던 함수의 연산이 일어나도 된다는것입니다. 

read, write 같은 함수를 비동기 방식으로 호출했다고 하면 사실상 이 read,write라는 작업을 해달라고 예약 요청을 해둔셈입니다. 
당장실행하지 않아도 되고 여유가 될때 실행해도 된다고 여유를 주는겁니다. 
그런데 이 비동기 방식을 잘못 이해하면 read,write를 다른 쓰레드를 만들어 처리하도록 맡기는 걸로 생각할 수 있는데 
멀티쓰레드와 비동기는 다른 개념입니다. 
비동기는 한 쓰레드 안에서 코드의 실행을 순서대로 하지 않는 방식입니다. 반면 멀티쓰레드는 쓰레드를 여러개로 나누어서 동시에 여러 일을 진행하지만 
각각의 쓰레드 안에서는 코드가 순서대로 진행 됩니다. 
둘다 코드가 유연하게 동작하도록 하는 기법이지만 비동기 방식이 좀 더 반응성이 좋은 대신 더욱 복잡해 디버깅이 불리하고 
멀티쓰레드는 비동기 방식에 비해 반응성이 낮지만 디버깅이 유리하다고 합니다. 
두 방식을 함깨 사용해 멀티쓰레드 환경에서 비동기 방식을 사용할 수도 있다고 합니다. 

일상적인 예시를 들어보겠습니다. 
내가 은행에 전화를 걸어서 대출에 대한 대답을 듣고 싶다고 해보겠습니다. 이때 전화를 걸어 대출에 대한 질문을 했다면 은행에서는 그에 대한 답을 줄겁니다.  
이것은 동기 방식입니다. 전화를 걸고 바로 답을 달라고 기다리고 또 답을 들었습니다. 
이번에는 같은 질문을 이메일로 보냈습니다. 그리고 은행에서도 나중에 메일을 확인해 답장을 주었습니다. 
이것은 비동기 방식입니다. 나도 이메일을 보내고 나서 잠시 잊고 내 볼일을 보고 은행에서도 이메일을 받고도 볼일 보다가 나중에 확인해 답을 주었습니다. 

이번시간에 굳이 용어정리를 한 이유는 지금까지 블로킹이든 논블로킹이든 동기방식을 기준으로 배워왔습니다. 
이후로는 좀 특별한 비동기 방식의 소켓함수들을 배우게 될것이기 때문입니다. 

지금까지는 recv, send 를 하기전에 Select나 WSAEventSelect함수를 사용해서 원하는 상황이 준비되었는지를 확인한 다음 동기 방식의 소켓 함수들을 호출했다면 
오늘 내용에서는 전체적인 방법론이 달라져서 recv나 send를 예약하듯이 진행을 해줄겁니다. 비동기 방식이기 때문에 먼저 실행한다고 해서 멈추는게아니고 
나중에 여건이 될때 알아서 함수들이 실행이 될것입니다.

비동기 방식의 시점이 다르다는 것은 함수를 호출한 뒤에 어떤식으로건 언젠가 다시 일감이 실행완료되었는지 판별할 수 있어야합니다. 
크게 두가지 방법이 있습니다. 

한가지는 '콜백(CallBack)' 방식으로 처음 일감을 요청할때 애당초 나중이 일감이 다 끝나면 연락을 달라는 함수를 같이 건내줘서 
일이 끝났음을 알려주는 방법입니다.

두번째로는 그냥 이벤트를 사용해서 일감이 끝나면 시그널을 켜줌으로 일감이 다 끝났음을 알리는 방법이 있습니다. 

이렇게 두가지 방법을 다 알아보고 실습을 해볼겁니다. 

+ 추가 
정리하는 사람마다 다르게 해석하기도 합니다. 예를 들어 Select 모델을 Async-NonBlocking 으로 보는 사람도 있고 Async-Blocking 으로 보는 사람도 있습니다. 
또 네가지 조합이 있다고 해서 네조합 모두 똑같은 빈도로 사용하는것은 아닙니다. 
Async-Blocking은 특히나 잘 어울리지 않습니다. Blocking 이라는것은 함수가 끝날때까지 대기를 하는 방식인데 Async 는 함수를 호출해도 꼭 곧바로 반환이 되지 않아도 되는 
것이니 만큼 잘 어울리지 않습니다. 
주로 많이 사용하는 조합은 Sync-Blocking, Async-NonBlocking 두가지가 주로 잘 사용되는 조합이라고 합니다. 


오늘 실습을 해볼것은 Async-NonBlocking 방식일겁니다. 
흐름이 어떻게 될것이냐면 Asynchronous 버전의 read를 호출해주게 되고 그러면 사살상 커널에 read를 해달라고 요청을 하긴 했는데 당장을 하지 않아도 되고 언젠가 답을 달라고 
한것입니다. 코드는 따로 진행되는 중에 커널쪽에서 아까 호출한 Async read 가 완료가 되었다면 유저쪽에 완료되었다고 시그널로 알려줄 수도 있고 콜백으로 알려줄 수도 있는것입니다. 

그리고 이런 방식을 OverLapped 모델이라고 부릅니다. 
OverLapped 모델에서는 recv,send 같은 소켓함수들이 Async 방식의 함수들로 바꿔서 호출이 될것이고 어떤 흐름으로 구현이 될지 실습을 해보겠습니다. 


// 실습 

실습을 시작할 환경은 
윈속 시작 -> listenSocket 생성 -> ioctlsocket 함수로 논블로킹 소켓으로 변경 -> serverAddr 을 만들고 bind, listen 호출 

여기 까지는 똑같이 진행된 후 부터 실습 시작하겠습니다. 

Overlapped IO (비동기 + 논블로킹)
- Overlapped 함수를 건다 (WSARecv, WSASend)
- Overlapped 함수가 성공했는지 확인 후 
-> 성공했으면 결과 얻어서 처리
-> 실패했으면 사유를 확인 사유가 Pending(보류)이라면 나중에 완료되면 알려달라고 두가지 방법중 하나를 선택

Overlapped 함수들 
WSASend
WSARecv
AcceptEx		- AcceptEx와 ConnectEx는 나중에 네트워크 라이브러리제작때 자세히 알아볼것
ConnectEx

WSASend, WSARecv 두 함수가 받는 인자들은 거의 비슷합니다. 어떤 인자를 받는지 알아보겠습니다.
1) 비동기 입출력 소켓
2) 입출력 버퍼를 WSABUF 라는 구조체로 받아줌배열의 시작 주소
3) WSABUF의 크기,개수
4) 보내고/ 받은 바이트 수
5) 상세 옵션인데 일단 0으로 넣으면 됩니다.
6) WSAOVERLAPPED의 구조체의 주소값 
7) 입출력이 완료되면 OS가 호출할 콜백함수 (오늘 실습에서는 사용하지 않을것)


WSABUF 에는 buf와 len데이터가 있지만 인자로 따로 배열 시작 주소와 개수를 넣어주는 이유는
밑과 같이 여러버퍼를 한번에 넣어 줄 수 있기때문 
char sendBuffer[100];
WSABUF wsaBuf[2];
wsaBuf[0].buf = sendBuffer;
wsaBuf[0].len = 100;

char sendBuffer2[100];
wsaBuf[1].buf = sendBuffer2;
wsaBuf[1].len = 100;

위의 방법을 통해 나중에 알아볼 우아한 기법으로 
Scatter-Gether 기법 이라고 합니다. 
나중에 데이터 패킷을 보낼때 패킷들이 서로 흩어져 있을건데 그 패킷들을 위처럼 한 버퍼에 
모으고 연결해서 보내고 있습니다. 일단 이내용은 나중에 다시 다룰 내용입니다. 

WSAOVERLAPPED 가 어떻게 되어있는지를 따라 들어가보면 OVERLAPPED라는 구조체이고 
내부적으로는 여러 값들이 복잡하게 있는데 대부분은 운영체제에서 알아서 사용하는 값들이고 
우리가 신경써야하는 데이터는 
HANDLE hEvent 라는 핸들을 보면 됩니다. 이 변수에 우리가 이벤트 핸들을 넣어주는 것입니다. 
이 OVERLAPPED.hEvent 라는 곳에 생성한 이벤트를 통해 비동기적으로 동작 완료된 것을 통보받을수 있습니다.

이런 인자들을 받고 있고 

또 처음 OVERLAPPED 함수를 사용할때 잘못 사용할 경우도 있습니다.
WSASend, WSARecv는 비동기 함수이기 때문에 호출할 시점과 완료가 된 시점이 같지 않을 수 있다고 했습니다. 그래서 
두번째 인자 WSABUF와 WSAOVERLAPPED에 대한 정보를 넘겨준 다음 확실히 동작이 완료될때 까지 건드리지 않고 가만히 놔둬야합니다. 
괜히 동기 함수처럼 코드 줄이 지나갔다고 동작이 완료되었겠꺼니 하고 건드렸다가는 나중에 커널이 미뤄둔 OVERLAPPED함수를 실행할때 우리가 의도한 데이터가 아니라 
엉뚱한 데이터가 송신/수신 될 수 있다는 말입니다. 

다시한번 쭉 정리해보갰습니다. 

        OverLapped 모델 (이벤트 기반)
        1) 비동기 입출력 지원하는 소켓을 생성 + 통지를 받기 위한 이벤트 객체를 생성
        2) 비동기 입출력 함수 호출 (1에서 만든 이벤트 객체를 같이 넘겨줌, 인자중 WSAOVERLAPPED 구조체 안에 hEvent 변수에 넘겨줌) 
        3) 비동기 작업이 바로 완료 되지 않으념, WSA_IO_PENDING 오류 코드가 뜰것 
        -운영체제는 이벤트 객체를 signaled 상태로 만들어 완료상태를 알려줄것
        4) WSAWaitForMultipleEvents 함수를 호출해서 이벤트 객체의 signaled 상태를 판별 
        5) WSAGetOverlappedResult 함수를 호출해서 비동기 입출력 결과 확인 및 데이터 처리

위의 흐름중에 WSAWaitForMultipleEvents 함수는 이전 시간 WSAEventSelect 모델에서 다뤄 봤으니 넘어가고
비동기 함수의 결과를 확인하는 WSAGetOverlappedResult 함수에 대해 알아보겠습니다. 

WSAGetOverlappedResult 함수의 인자
1) 비동기 소켓
2) 넘겨준 OVERLAPPED 의 포인터 
3) WSARecv나 WSASend의 결과물의 바이트 수
4) fWait 라고 모든 작업이 완료될때 까지 대기할것인지 하나라도 완료되면 반환할것인지를 고르는 플래그
5) 상세한 옵션을 지정해 줄수 있는데 지금은 왠만해선 건들지 않을것


이 내용들을 텍스트로 보면 복잡해 보이지만 실제 코드로 구현해보면 그정도로 복잡하지는 않는다고 합니다. 

오늘 실습은 어떻게 진행할것이냐면 아까 listen 까지 호출한 상태라고 했습니다. 
이후 accept 를 할때 이 함수도 비동기 방식의 함수로 호출할수 있지만 아직 이번 시간에는 그냥 accept를 호출하고 
send, recv 만 비동기 방식 함수로 실습을 해보겠습니다. 


// 이번 시간에는 WSAOVERLAPPED 구조체를 들고 있을것이고 에코 서버가 아니라 데이터를 받기만 할것
// 이기에 sendBytes 를 지웠습니다. 
struct Session
{
	SOCKET socket = INVALID_SOCKET;
	char recvBuffer[BUFSIZE] = {};
	int32 recvBytes = 0;
	WSAOVERLAPPED overlapped = {};
};

Session 구조체의 내용을 조금 변경했습니다. 

이번 시간에는 일단 accept 하는 부분은 그냥 Sync-NonBlocking 방식으로 진행했습니다. accept도 Async 함수가 있지만 나중에 
네트워크 라이브러리를 배울때 더 자세히 배울것입니다.

// 세션에 소켓과 이벤트 객체를 담았습니다. 
Session session = Session{ clientSocket };
WSAEVENT wsaEvent = ::WSACreateEvent();
session.overlapped.hEvent = wsaEvent;

while (true)
        {
		{
			// OVERLAPPED 함수가 필요한 인자들을 다 만들어 주었습니다. 
			WSABUF wsaBuf;
			wsaBuf.buf = session.recvBuffer;
			wsaBuf.len = BUFSIZE;

			DWORD recvLen = 0;
			DWORD flags = 0;

			// 이렇게 호출한 WSARecv는 바로 값을 반환 할 수도 있고 아니면 나중에 반환할 수도 있습니다. 
			// 아마 수신 버퍼에 이미 데이터가 있다면 수신 성공을 하면서 빠져나올것이고 ,
			// 수신 버퍼에 데이터가 없어도 빠져나오기는 할겁니다. 
			if (::WSARecv(clientSocket, &wsaBuf, 1, &recvLen, &flags, &session.overlapped, nullptr)
				== SOCKET_ERROR)
			{
				// 연결 실패일 수도 있고 수신버퍼에 데이터가 없을 수도 있습니다.
				
				if (::WSAGetLastError() == WSA_IO_PENDING)
				{
					// Pending
					cout << "Pending" << endl;
					::WSAWaitForMultipleEvents(1, &wsaEvent, TRUE, WSA_INFINITE, false);
					::WSAGetOverlappedResult(session.socket, &session.overlapped, &recvLen, FALSE, &flags);
				}
				else
				{
					// TODO : 문제 있는 상황
					break;
				}
			}

			// 수신 성공
			cout << "Data Recv Len = " << recvLen << endl;
		}

		::closesocket(session.socket);
		::WSACloseEvent(session.overlapped.hEvent);
	}

코드들은 아까 정리했던 흐름 그대로 만들면 되었습니다. 

그리고 이번 시간에는 클라이언트도 조금 수정해줄건데 지금까지 미러 서버로 실습하고 있었는데 이번엔 클라에서는 데이터를 보내고 서버에서는 데이터를 받기만 하는 
서버로 실습할겁니다. 
즉, 클라이언트에서는 WSASend 함수를 사용해 보았습니다. 

	char sendBuffer[100] = "Hello World!";
	// 이벤트 객체도 만듭니다. 
	WSAEVENT wsaEvent = ::WSACreateEvent();
	WSAOVERLAPPED overlapped = {};
	overlapped.hEvent = wsaEvent;
	while (true)
	{
		// 이번엔 클라이언트에서도 대칭적으로 WSASend를 사용해보겠습니다. 
		WSABUF wsaBuf;
		wsaBuf.buf = sendBuffer;
		wsaBuf.len = 100;

		DWORD sendLen = 0;
		DWORD flags = 0;

		if (::WSASend(clientSocket, &wsaBuf, 1, &sendLen, flags, &overlapped, nullptr)
			== SOCKET_ERROR)
		{
			if (::WSAGetLastError() == WSA_IO_PENDING)
			{
				// Pending
				cout << "Pending" << endl;
				::WSAWaitForMultipleEvents(1, &wsaEvent, TRUE, WSA_INFINITE, FALSE);
				::WSAGetOverlappedResult(clientSocket, &overlapped, &sendLen, FALSE, &flags);
			}
			else
			{
				// TODO : 문제 있는 상황
				break;
			}
		}

		cout << "Send Data Len = " << sendLen << endl;
		this_thread::sleep_for(1s);
	}

코드는 별것 없이 그냥 대칭적으로 만들면 되었습니다. 

오늘 실습 내용은 사실 효용성은 별로 없습니다. 뭐때문이냐면 WSASend, WSARecv 를 호출한 다음 바로 완료가 되면 다행이지만 만약 Pending 상태가 되었다면
이번 코드에서는 결국 WSAWaitForMultipleEvents 함수에서 해당 소켓이 준비될때 까지 대기를 해야합니다. 
이전 주제인 WSAEventSelect 모델처럼 이벤트 객체들을 한곳에 모아서 WSAWaitForMultipleEvents 를 했으면 한번에 여러 이벤트를 관찰할 수도 있겠습니다. 
좀 더 나을 수는 있지만 이벤트 방식으로 관찰하는것 자체가 최선의 방법은 아닌것 같다는걸 느낄수 있습니다. 