


        소켓 옵션


네트워킹 프로그래밍을 하면서 기본적으로 윈속을 시작한다음 클라는 클라에서 사용할 소켓, 서버에서는 서버에서 사용할 소켓을 만들게 되는데 
이 소켓을 만들면서 내부적으로 같이 커널영역에 recv버퍼, send버퍼가 따로 생긴다고 했었습니다. 거기에 더해서 다양한 옵션을 커스터마이징할 수 있습니다. 

오늘내용은 비교적 쉬운 내용이라고 합니다. 

::setsockopt(SOCKET s, int level, int optname, const char* optval, int optlen);
::getsockopt(SOCKET s, int level, int optname, const char* optval, int optlen); 

이런 두가지 함수가 있는데 setsockopt 함수로 소켓 옵션을 설정하고 getsockopt 함수로는 소켓옵션을 가져올 수 있습니다. 

이 두 함수도 여러인자들을 받아주고 있습니다. 각인자가 어떤 의미인지를 살펴보겠습니다. 
첫번째 인자인 s는 설정하고 가져올 소켓의 식별자입니다. 어떤 소켓을 대상으로 실행할지를 골라주는 것입니다.
두번째 인자인 level은 옵션을 넣어줄때 그 옵션을 해석하고 처리할 주체를 넣어주는겁니다. 만약 소켓이 처리하는 옵션이다 하면 SOL_SOCKET
아니면 IP가 처리하거나 통신 프로토콜이 처리하는 옵션이다 하면 해당하는 옵션을 넣어주면 됩니다. 

	// 소켓 코드 -> SOL_SOCKET
	// IPv4 -> IPPROTO_IP
	// TCP 프로토콜 -> IPPROTO_TCP

이렇게 레벨을 정해주고 나면 그 안에서 또 어떤 옵션에 접근할건지 정해줘야합니다. 
각 레벨에서 사용하는 대표적인 옵션들이 마이크로 소프트 공식문서에 나와있습니다. 모든 옵션을 외워야 할 필요는 없지만 그 중에 그나마 알고 있으면 좋은 
몇가지를 꼽아보겠습니다. 

SO_KEEPALIVE	= 주기적으로 연결 상태를 확인 할지에 대한 여부 (연결이라 함은 TCP에서만 동작함) (옵션값=bool) 
				필요한 이유는 연결중에 상대방이 소리소문없이 연결을 끊는 경우도 있기 때문 주기적으로 TCP 프로토콜 연결상태 확인 -> 연결 끊어짐 감지

SO_LINGER(지연하다)	= 연결을 하던 중 더이상 연결을 하지 않아도 된다면 소켓 연결을 끊을 수 있습니다.(closesocket 함수)  
				closesocket() 함수는 소켓의 리소스를 반환하는 기능 이외에도 여러 동작을 같이 하는데 소켓간의 연결을 끊는 동작도 합니다. 이때 커널 버퍼에 남아있는
				데이터를 어떻게 처리할지를 정해주는게 SO_LINGER 입니다. 
				옵션 값으로는 LINGER 라는 구조체를 받아주고 있는데 LINGER 구조체는 u_short 타입의 변수 on/off, linger 두개를 가지고 있습니다. 
				on/off 가 0이라면 closesocket() 실행시 바로 소켓연결을 끊어버리고 0이 아니라면 linger 만큼의 시간만큼 연결끊는걸 지연시킵니다. 
				디폴트 값은 0이라서 바로 연결이 끊어지지만 필요한 경우에 사용하는 것입니다. 
	// ::shutdown
	그리고 SO_LINGER 가 나와서 하는말인데 closesocket 을 할때 그냥 아무말 없이 소켓을 닫아버리는건 그다지 좋지 않습니다. 
	서로 무전기로 통신중에 할 말을 하고 바로 무전을 끊어 버리면 할말을 다 해서 끊은건지 아니면 전파나 상대 상황이 좋지 않아서 끊긴건지를 알 수 없기때문에 
	할말 한 후 오버라는 말을 붙여줍니다. 
	이것과 비슷하게 closesocket을 하기전에 send나 recv를 더이상 사용하지 않을것이라는 신호를 상대에게 전해준 다음 소켓을 닫아주면 좋습니다. 
	::shutdown(SOCKET s , int how); 	이런 인자를 받는데 소켓을 그냥 사용하던 소켓을 넣어주면 되고 how에는 세가지 선택을 할수 있습니다. 
	SD_SEND = send를 막는다. SD_RECIVE = recv를 막는다. SD_BOTH = send, recv 둘 다 막는다. 
	필요에 따라 선택해주고 이론적으로는 shutdown 후에 closesocket을 호출하는게 좋다고 합니다. 
	하지만, 이건 권고 사항이고 우리의 목적인 온라인 게임에서는 온갖 상황이 일어날 수 있습니다. 정상적으로 프로그램이 종료된다면야 잘 동작하겠지만 라이브 서비스하는 
	온라인게임이다 보니 클라이언트에서 그냥 컴퓨터의 전원을 뽑아 버릴수도 있고 정전이 날 수도 있고 아니면 서버쪽에서도 어떤 문제로 강제종료가 될 수도 있습니다. 

SO_SNDBUF = 송신 버퍼 크기
SO_RCVBUF = 수신 버퍼 크기
	위의 두 옵션은 묶어서 설명할 수 있는데 수신, 송신 버퍼의 크기에 대한 옵션입니다. 그만큼 중요한 내요이겠죠 옵션 값이 무슨 타입인지 찾아보면 int 타입을 받고 있습니다. 
	크기를 설정하기 전에 기본 버퍼 크기가 얼마인지 알아보았습니다. getsockopt을 사용했는데 각각 버퍼가 65536, 64KB 임을 알 수 있었습니다. 
	이 값을 필요에 따라 설정해 줄 수가 있다는 말인데 그 값을 터무니 없이 큰 값을 설정할 수는 없다고 합니다. 그렇게 되면 그냥 이 코드를 무시해버릴 수도 있다고 합니다. 

SO_REUSEADDR = 소켓이 이미 사용중인 주소에 바인딩 될 수 있는지를 bool 타입으로 설정
	이 옵션은 TCP에서 IP와 port 를 재사용할 수 있게 해주는 건데 어떤 상황에 사용되길레 알아 둬야 하는 옵션인가 하면 서버를 띄울때 소켓을 만들고 자신의 주소를 바인딩하고 
	접속 요청을 받은 클라쪽을 listen 하다가 accept를 한 다음 통신을 시작한다고 했는데 실제 상황에서 서버를 다루다 보면 자신의 주소를 다른 프로그램에서 사용하고 있을 수도 
	있고 아니면 이전에 서버를 강제종료후 다시 서버를 띄우는데 이전 시도의 찌꺼기가 남아있어 처리되기까지 기다려야 하는 경우가 있습니다. 
	그럴때 이 옵션을 켜주면 바로바로 다음 서버를 띄울 수 있게 되는겁니다. 

추가적으로 한가지 더 알아주면 좋은게 IPPROTO_TCP 레벨에서 TCP_NODELAY 옵션입니다. 
이 TCP_NODELAY 옵션에서는 커널쪽 버퍼에 데이터가 충분히 크면 보내고, 그렇지 않으면 데이터가 쌓일 때 까지 대기를 하는 옵션인데 (Nagle 알고리즘)
장점은 작은 패킷을 불필요하게 보내는 걸 방지할 수 있고 단점은 한번에 모아 보내기 때문에 반응 시간이 손해를 봅니다. 
그런데 우리가 하려고 하는건 온라인 게임이다 보니까 반응속도가 빠를게 중요하기 때문에 이 옵션을 꺼줘야 합니다. 
옵션 이름이 NODELAY 니까 값을 true로 줘야 딜레이를 없앨 수 있습니다. 

이정도만 알면 일단 큰 무리는 없다고 할 수 있습니다. 

setsockopt 에서 이제 소켓, 레벨, 옵션네임까지 정해준다음은 실질적 옵션 값을 줘야하는데 고를수 있는 옵션이 많고 각각 값의 길이가 다르다 보니 
따로 만들어 넘겨줘야합니다. 

예를 들어서 SOL_SOCKET레벨에 SO_KEEPALIVE 옵션을 설정하려면 공식문서를 보면 각옵션네임 마다의 값의 타입이 어떤지 나와 있습니다. SO_KEEPALIVE의 경우에는 bool 타입을 
받고 이 값에 따라 주기적 연결 상태 체크여부를 설정합니다. 

	bool enable = true;
	::setsockopt(serverSocket, SOL_SOCKET, SO_KEEPALIVE, (char*)&enable, sizeof(enable));

이런식으로 각 옵션마다 값으로 줄 타입이 다를 수는 있겠지만 적절한 값을 주면 되는걸 알 수 있습니다. 

기억해두면 좋을 옵션을 몇가지 알아 보았는데 모든 내용은 공식문서에서 찾아 볼 수 있으니 필요한 옵션이 생기면 그때 알아보는 것도 좋겠습니다. 