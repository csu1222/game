

        STL Allocator 

    
이전 시간에 Stomp Allocator 를 배웠습니다. ::VirualAlloc , ::VirtualFree 를 활용한 얼로 케이터로 
성능은 무겁지만 개발 단계에서 메모리 오염 버그가 있는지를 알아 볼 수 있는 방법이었습니다. 

이어서 오늘 알아볼 것은 Base Allocator 와 Stomp Allocator를 사용해서 A_new, A_delete 라는 우리만의 연산자 오버로딩을 해서 사용했습니다. 
객체를 이렇게 하나 하나 만드는 방법도 있겠지만 

실제 게임을 만들때 사용하는 모든 객체를 하나 하나 직접 만들지는 않을겁니다. 
예를 들면 vector를 사용해서 관리도 할것이고 map을 사용해서 key, value 로 관리해주기도 할겁니다. 
이 방식으로 객체를 만들게 되면 표준의 new delete 를 여전히 사용하고 있을겁니다. 그래서 이것도 고쳐줘야 할텐데 

어떻게 하느냐 면 사실 서버 프로그래밍이라던가 메모리 풀링을 해본적이 없다면 당연히 모르겠지만 vector나 map을 드래그 한다음 F12 를 누르면 
코드까지 따라 들어갈 수 있다는걸 알고 있을겁니다. 

따라 들어가보면 템플릿에 첫번째가 평소 사용하던대로 원소들의 타입을 정하는 것이고 두번째 템플릿이 _Alloc이라고 해가지고 사용할 얼로케이터를 
지정할 수 있습니다. 지정해주지 않고 기본으로 만들면 표준 얼로케이터를 사용하도록 되어 있는데 이부분을 가지고 우리가 원하는 얼로케이터를 지정해주면 
될겁니다. 

그러면 이것만 해주면 끝인가? 

    vector<int32, BaseAllocator> numbers;

이러면 끝인가 싶을 수 있는데 그렇지는 않고 요구하는 사양이 있을겁니다. 
일단 확인겸 이대로 한번 빌드를 해봐서 통과하는지를 보면 당연하게도 빌드 실패가 됩니다. 

표준 할당자에서 기본적으로 이런저런 타입이나 다른 것들을 정의 해주고 있는데 커스텀 할당자들에는 그런걸 설정해준 적이 없다 보니 그렇습니다. 

그래서 오늘 작업할 것은 STL 에서 만들어놓은 표준 할당 연산자들과 우리가 만든 커스텀 할당자가 호환 되도록 보완 해주는 작업을 할것입니다. 

->  Allocator.h 파일

    이전 시간에 만들었던 Stomp Allocator 밑에 새로 클래스를 파주겠습니다. 
    /*----------------
        STL Allocator
    ------------------*/

    template<typename T>
    class StlAllocator
    {
    public:
        using value_type = T;

        StlAllocator() { }

        template<typename Other>
        StlAllocator(const StlAllocator<Other>&) { }

        T* allocate(size_t count)
        {
            const int32 size = static_cast<int32>(count * sizeof(T));
            return static_cast<T*>(A_alloc(size));
        }

        void deallocate(T* ptr, size_t count)
        {
            A_release(ptr);
        }
    };

    템플릿 문법을 사용해서 여러 타입에 대응 가능하게 해줄겁니다. 그리고 STL 표준에 부합 하도록 사양을 맞춰줄때 필요한것이 
    value_type, 다른 타입을 받는 템플릿 생성자, 소문자로 만든 allocate, deallocate 함수들이 필요합니다. 

    자세히 왜 필요하고 어떻게 사용되는지는 따로 연구해보면 되고 일단 이렇게 갖추면 호환이 되서 사용이 가능합니다. 

    특이한 점은 allocate 의 인자로 받는 size_t 타입 인자 count 는 이전에 BaseAllocator나 StompAllocator 처럼 할당할 메모리 사이즈 
    자체를 받는게 아니라 T 타입 객체를 몇개 나 만들건지를 받습니다. 
    그 부분이 const int32 size 에 T 의 사이즈와 count 를 곱해줍니다. 

이렇게 만든 StlAllocator를 테스트 해보겠습니다. 

->  GameServer.cpp

    아직 CoreMacro 같은데에 적어 놓지 않았으니 Allocator.h 를 include부터 합니다. 
    
    #include "Allocator.h"


    int main()
    {
        
        vector<Knight, StlAllocator<Knight>> v(100);

    }

    중단점을 걸면서 디버깅을 해보면 제대로 100개의 Knight 객체를 생성하고 소멸한다는걸 알 수 있습니다. 

이렇게 해서 간단하게 표준 STL에서 동작하도록 커스텀 얼로케이터를 수정해봤습니다. 

근데 vector 뿐만 아니라 map 이라던가 queue 라던가 하는 컨테이너들에게 각자 요구하는 사양이 있을겁니다. 

여러 컨테이너를 관리하기 위해서 새로 헤더 파일을 만들어 줄겁니다.
ServerCore 프로젝트-> Memory 필터 아래에 Container.h 파일을 만들어 주었습니다. 그리고 이전에 만들었던 헤더중 CorePch.h 를 보겠습니다. 

->  CorePch.h

    이 헤더에 이전에 추가해 뒀던 내용중에 여러 컨테이너를 include 하는 코드들이 있습니다. 전부를 Container.h 로 옮겨주고 CorePch.h 에는 
    Container.h 를 include 해주는걸로 정리 해줍니다. 

->  Container.h

    CorePch.h 에서 옮겨온 컨테이너 헤더들 이외에 Type.h 와 Allocator.h 도 include 해주었고 
    혹시 모르니 using namespace std; 도 추가 해주었습니다. 

    그건 그렇고 이 파일에서 뭘하려는 거냐면 아까 테스트할때 

    vector<Knight, StlAllocator<Knight>> v(100);

    이런 형태로 코드를 작성했는데 매번 이렇게 길게 작성하려면 번거로울것이기 때문에 앞으로 좀 더 간편히 사용하도록 할겁니다.

    template<typename Type>
    using Vector = vector<Type, StlAllocator<Type>>;
    이런식으로 정의 해 놓으면 다음 테스트할때는 

    Vector<Knight> v(100);
    이렇게 사용해도 StlAllocator를 사용한 커스텀 할당자가 사용됩니다. 

    비슷하게 vector, list, map, set, deque, queue, stack, priority_queue, basic_string, unordered_map, unordered_set 등을 정의 해주면 됩니다. 

    일단 list는 비슷합니다. 
        
    template<typename Type>
    using List = list<Type, StlAllocator<Type>>;    

    map은 조금 어려워 지는데 key와 value 그리고 어떻게 원소들을 비교해 가지고 있을지 Pred 라는 옵션이 있고 그 다음이 allocator 를 골라주는 부분입니다. 

    template<typename Key, typename Type, typename Pred = less<Key>>
    using Map = map<Key, Type, Pred, StlAllocator<pair<const Key, Type>>>;
    
    StlAllocator를 넣어줄 때도 타입을 map에 맞게 pair 타입을 주고 있습니다. 

    다음은 set 입니다. map과 거의 비슷한데 key , value로 나뉘어 지지 않고 key가 value도 겸하고 있는 형태입니다. 
        
    template<typename Key, typename Pred = less<Key>>
    using Set = set<Key, Pred, StlAllocator<Key>>;

    그리고 큐와 스택도 자주 사용하는데 이 컨테이너의 설명을 보면 특이하게 첫번째 템플릿으로 원소 타입을 정하고 두번째 템플릿으로 기본 컨테이너를 정하는데 
    deque로 되어 있습니다. deque가 뭐였는지 다시 복습해보면 deque는 컨테이너의 전방과 후방 양쪽에서 데이터를 삽입 삭제를 할 수 있는 컨테이너이고 
    이 성질중 필요한것을 가져와 사용하는게 큐와 스택입니다. 

    template<typename Type>
    using Deque = deque<Type, StlAllocator<Type>>;

    template<typename Type, typename Container = Deque<Type>>
    using Queue = queue<Type, Container>;

    template<typename Type, typename Container = Deque<Type>>
    using Stack = stack<Type, Container>;

    그래서 이렇게 공통된 deque 가 사용할 할당자만 수정한 다음 큐와 스택에 적용해주면 되겠습니다.

    다음은 우선순위 큐입니다. 우선순위 큐는 선입선출의 원리를 가지고 있고 거기에 어떤 기준으로 안에 있는 원소들을 정렬해놓은게 우선순위 큐였습니다. 
    우선순위 큐는 길찾기 알고리즘을 배울때 등장했었습니다. 균형 이진 트리나 레드 블랙 트리를 활용했었습니다. 
    또 이진 트리를 표현할때 노드를 사용할 수 도 있지만 벡터로 표현하는 방법도 있었습니다. 벡터의 인덱스를 일정 규칙에 따라 원소들을 배열하면 되었습니다. 
    그래서 필요한 템플릿은 원소자체의 타입, 그리고 기본 컨테이너를 골라 줄건데 방금 언급 했다 시피 벡터, 그중에서도 위에서 정의한 Vector를 사용하면 
    할당자도 커스텀한 할당자가 적용 될것입니다. 또 우선순위를 정할 기준인 Pred 도 정해줍니다. 

    template<typename Type, typename Container = Vector<Type>, typename Pred = less<typename Container::value_type>>
    using PriorityQueue = priority_queue<Type, Container, Pred>;

    추가로 몇개를 더 해볼건데 문자열을 뜻하는 String, WString 도 있을겁니다. 이 두 가지가 어떻게 만들어져 있는지를 따라 들어가보면 
    basic_string 이라는 컨테이너로 되어있다는걸 알수 있습니다.
    using String = basic_string<char, char_traits<char>, StlAllocator<char>>;

    using WString = basic_string<wchar_t, char_traits<wchar_t>, StlAllocator<wchar_t>>;

    여기서 추가로 경우에 따라 unordered_map, unordered_set을 사용하는 경우도 있을겁니다. unordered_map 은 시간 복잡도가 O(1) 인 컨테이너로 
    메모리를 많이 사용하는 대신 속도가 아주 빠른 편에 속하였습니다. 
    사용하는 템플릿은 map은 key와 value, Hasher 라는 hash 함수, KeyEq이라는 값과 그리고 할당자입니다. set은 value가 빠집니다. 

    template<typename Key, typename Type, typename Hasher = hash<Key>, typename KeyEq = equal_to<Key>>
    using HashMap = unordered_map<Key, Type, Hasher, KeyEq, StlAllocator<pair<const Key, Type>>>;

    template<typename Key, typename Hasher = hash<Key>, typename KeyEq = equal_to<Key>>
    using HashSet = unordered_set<Key, Hasher, KeyEq, StlAllocator<Key>>;

    이후에 혹시 더 필요한 STL 컨테이너들이 생긴다면 이곳에 추가해주면 될겁니다. 


이번에 신기하게도 STL 컨테이너에 할당자를 지정해줄 수 있다는걸 알수 있었습니다. 

앞으로는 컨테이너를 사용할때 지금 정의한 이름으로 생성하면 되겠습니다. 