


        Job Timer


지난 시간 까지 job에 대한 내용을 쭉 한바퀴 돌아 봤습니다. 
반복적인 내용도 많고 Job이 무었인지 확실히 와닿지도 않는데 이렇게 강조할 일인가 할 수도 있지만
이것이 정말 중요한 내요입니다. 물론 네트워크도 중요합니다. 서버이다 보니 클라이언트와 패킷을 주고받는 네트워크도 매우 중요하지만 
그 외에 로직들 예를들면 월드에서 몬스터의 이동이나 투사체의 움직임 같은 로직을 처리하는 Job도 또한 매우 중요한것입니다.


이번시간에 이어서 Job에 관련된 내용 한가지를 더 알아볼건데 
잠시 그 이야기를 하기 전에 지난시간에 만들었던 코드중에 조금 수정해보겠습니다. 

우리 코드에서 이것 저것을 다 shared_ptr을 활용해 Ref 라는 글자를 붙혀 사용하고 있었습니다. 
그리고 shared_ptr를 활용하게 되면 스마트 포인터 특성상 참조 카운트를 사용하기 때문에 오염된 메모리를 건드린다거나 댕글링 포인터(Dangling Pointer)
를 줄일 수 있지만 반대로 메모리 릭이 일어날 확률이 늘어납니다. 주고 받는거죠 어떻게 보면 메모리 릭이 나는게 아예 크래시가 나버리는것보다는 낫다고 볼 수 있지만
어떨때에는 오히려 메모리릭을 잡기가 더 어려울 수 있습니다. 
그래서 어느 프로젝트에서는 서버를 돌릴수록 조금씩 메모리 릭이 일어나고 몇주 이후에는 강제로 서버를 다시 실행해야 하는 상황도 있다고 합니다.
그런만큼 마냥 무시할 만한 문제는 아니라는 겁니다. 

연습삼아 하나만 고쳐보자면 지난시간에 만들고 있던 코드중 GameSession 파일중 GameSession의 소멸자 코드를 보면 GameSession이 소멸할때 자신이 소멸한다고 
로그를 찍어주고 있었지만 어느 순간부터 이 로그를 보지 못했습니다. 즉, 슬슬 메모리 릭이 일어나고 있다는것입니다. 
아직은 코드량 자체가 많은 편은 아니다 보니 코드만 봐도 어디서 문제가 있는지 알 수 있습니다. 


class GameSession : public PacketSession
{
public:
	~GameSession()
	{
		cout << "~GameSession" << endl;
	}

	virtual void OnConnected() override;
	virtual void OnDisconnected() override;
	// OnRecv는 sealed로 잠궜고 대신 OnRecvPacket을 재정의해 사용합니다. 
	virtual void OnRecvPacket(BYTE* buffer, int32 len) override;
	virtual void OnSend(int32 len) override;

public:
	Vector<PlayerRef> _players;
};

PlayerRef들을 물고 있는 Vector _players가 있습니다. 이 Player 를 따라 들어가보면 


class Player
{
public:
	uint64 playerId = 0;
	string name; 
	Protocol::PlayerType type = Protocol::PLAYER_TYPE_NONE;
	GameSessionRef ownerSession; // Cycle 문제 해결해야함
};

자기 자신의 오너 세션자체를 스마트 포인터로 들고 있다보니 벌써 사이클이 생긴것입니다. 

그러다 보니 GameSession::OnDisconnected를 호출하면서 GSessionManager.Remove 하는 것까지는 좋았지만 들고 있는 _players를 해제해주지 않아서 
제대로 삭제 되지 않고 있는겁니다.  또 Player는 Room에서도 물고 있었습니다. 

class Room : public JobQueue
{
public:
	void Enter(PlayerRef player);
	void Leave(PlayerRef player);
	void Broadcast(SendBufferRef sendBuffer);

private:
	map<uint64, PlayerRef> _players;
};

extern shared_ptr<Room> GRoom;

이런 여러곳에서 Player가 물려 있다보니 메모리 해제되지않고 Player가 물고있는 GameSession도 덩달아 메모리 해제가 되지 않는것입니다. 

그래서 이런 부분의 처리에 대한 실습을 먼저 해보겠습니다. 

먼저 GameSession 코드 부터 보겠습니다. 
GameSession과 Player가 연결되는 부분은 ClientPacketHandler::Handle_C_LOGIN() 에서 클라이언트로 부터 로그인 요청이 왔을때 그것을 처리해주면서 
클라이언트가 가지고 있는 Player 캐릭터들을 DB로 부터 불러와 다시 넘겨주면서 GameSession에서도 Player들을 들고 있도록 했습니다. 

서버가 보낸 S_LOGIN 패킷을 받은 클라이언트는 거기서 다시 어느 Player로 접속할건지 그 인덱스를 패킷에 담아 보낼겁니다. 그것이 Handle_C_ENTER_GAME 입니다.
여기서 받은 C_ENTER_GAME의 데이터중 몇번인덱스의 플레이어를 Room에 입장할건지를 처리해 주고 있는데 
이때 클라이언트가 어떤 Player로 접속하려고 하는지, 또 그 Player가 어떤 Room에 접속했는지를 GameSession에서 알고 있도록 해줄것입니다. 

GameSession의 멤버 변수에 두가지를 추가할겁니다. 

	PlayerRef _currentPlayer;
	weak_ptr<class Room> _room;

현재 클라이언트에서 선택한 플레이어가 누구인지 그리고 또 어느 Room에 접속하였는지를 들고 있을겁니다. 
그러면 이것을 채워주는 곳은 ClientPacketHandler::Handle_C_ENTER_GAME 입니다. 

bool Handle_C_ENTER_GAME(PacketSessionRef& session, Protocol::C_ENTER_GAME& pkt)
{
	GameSessionRef gameSession = static_pointer_cast<GameSession>(session);

	uint64 index = pkt.playerindex();
	// TODO : Validate

    // 여기서 PlayerRef 변수를 새로 만들던것을 gameSession에서 들고 있는 _currentPlayer에 연결하였습니다. 
	gameSession->_currentPlayer = gameSession->_players[index];	
    // 룸도 GameSession에서 들고 있는 변수에 연결합니다. 
	gameSession->_room = GRoom;
	
	GRoom->DoAsync(&Room::Enter, gameSession->_currentPlayer);

	Protocol::S_ENTER_GAME enterGamePkt;
	enterGamePkt.set_success(true);
	auto sendBuffer = ClientPacketHandler::MakeSendBuffer(enterGamePkt);
	gameSession->_currentPlayer->ownerSession->Send(sendBuffer);

	return true;
}

이제는 게임세션에서 _currentPlayer, _room 이라는 포인터를 통해 지금 어떤 플레이어로 어떤 방에 접속했는지를 알수 있게 됩니다.
그러면 어떤 플레이어, 룸으로 접속했는지를 알게 되었으니 GameSession::OnDisconnected에서 해제시켜 줄 수 있습니다.    


void GameSession::OnDisconnected()
{
	GSessionManager.Remove(static_pointer_cast<GameSession>(shared_from_this()));

	if (_currentPlayer)
	{
		// _room.lock()을 통해 shared_ptr로 변환 
		if (auto room = _room.lock())
			room->DoAsync(&Room::Leave, _currentPlayer);
	}

	_currentPlayer = nullptr;
	_players.clear();
}

_currentPlayer가 nullptr이 아니고 또 _room.lock() 을 한결과가 nullptr이 아니라면 이 GameSession은 접속한 플레이어도 있고 Room도 있는 상태입니다. 
그럴경우 먼저 플레이어를 Room에서 Leave 해준 다음 조건문을 빠져나옵니다. 이후는 _currentPlayer가 원레 nullptr 이었거나 Room에서 Leave 한 상태입니다. 
그러면 _currentPlayer를 nullptr로 밀어주고 다른 플레이어들이 있는 _players도 clear로 밀어주고 끝냅니다. 
이렇게 GameSession과 Player 객체 사이의 사이클을 끊어주는 코드를 추가한겁니다. 

이런식으로 다른 곳도 참조 카운트가 사이클 없이 잘 해제되는지를 알아보면 될것입니다. 

현재 채팅 프로그램은 시작할때 연결한 다음 프로그램 종료할때 까지 쭉 메세지만 보내고 있었습니다. 
이것을 중간 중간에 클라가 연결을 끊었다 연결했다 하느 식으로 바꾸면 그 때 바다 메모리 릭이 일어나는지를 확인 할 수 있을겁니다.

*** 

그건 그렇고 이번시간 본 내용인 JobTimer 에 대해 알아보겠습니다. 

지난 시간까지 JobQueue에 DoAsync라는 함수를 사용해 일감을 밀어넣는 작업까지 되었습니다. DoAsync는 이 잡큐에 넣을 일감을 람다식으로 받던지 아니면 functor로 받아 
저장하고 있었습니다.

그런데 막상 실제로 게임을 만들때 이 DoAsync만 가지고 만들려고 하면 아쉬워지는 부분이 있는데 
보통 스킬이건 AI건 어떤것이라도 무한대로 틱을 돌면서 실행하는 것은 거의 없습니다. 클라이언트같은 경우는 렌더링을 해야 하니 각 픽셀을 매 프레임마다 계산해야 하는 상황이긴 하지만 
서버쪽에서는 그래픽스 같이 1초에 몇백번 갱신을 할만한 오브젝트는 없습니다. 보통은 AI도 1초단위 아니면 2초단위로 갱신이 되는게 일반적일겁니다. 

결국은 서버는 클라에 비해 빠르게 연산할 필요가 없다는 것입니다.

만약 클라이언트에서 쿨타임을 계산한다고 해서 1초가 언제 지났는지를 알기 위해 무한 루프를 돌면서 체크하듯이 할 수 있을겁니다. 

서버의 경우는 객체가 몇십만 몇백만개가 되는데 1초가 지난걸 알기위해서 몇백만의 객체마다 무한루프를 돌면서 체크하는것은 확실히 불합리합니다. 
그래서 예약 시스템이 필요합니다. 1초후에 라는걸 걸어주면 정말 1초후에 실행되는 무언가가 필요하다는것입니다. 

그리고 사실 이건 왠만한 게임 엔진에서 지원하는 기능입니다. 그런 예약 시스템을 우리 프로젝트에 도입하는게 이번시간 목표입니다.
예약을 만들려다 보니 햇갈리는게 지금까지는 일감이 있으면 곧바로 실행해주거나 아니면 JobQueue에 넣어 주는 것을 하고 있었습니다.

JobQueue의 Push도 보면 내가 첫번째로 들어 왔다면 큐에 Push도 하고 실행까지 하는것이고 아니라면 일감만 밀어 넣고 빠져나오도록 만들었습니다.

이제 만약 예약을 걸어서 일감을 밀어 넣어줘야 한다면 지금 방식으로는 무한 루프를 돌면서 예약시간동안 묶여 있어야 되기 때문에 그러지 않도록 하려면 예약 방식이 달라져야 하겠습니다.


예약 시스템도 당연하겠지만 다양한 방법이 있습니다. 오늘 배울 것은 그 중에서도 중앙 통제를 사용한 방법입니다.
지금 사용하는 LockQueue 방식이나 아니면 우선순위 큐를 사용해 일감을 들고 있다고 하고 이 일감이 언제 실행되어야 할지를 각각 알아야 하는데 그게 어렵습니다.
그래서 큐에서 일감을 각각 들고 있기 보다 중앙 시스템을 둬서 중앙에서 일감을 들고 있다가 그 일감을 빠르게 체크해 뿌려주는 방식으로 만들어 볼겁니다. 

말로 설명하면 이해하기 어려우니 역시 작업을 하면서 이해해보겠습니다. 


-- JobTimer.h

먼저 JobData 라는 구조체를 만들겁니다. 이 구조체에서는 JobQueue를 weak_ptr로 들고 있고 JobRef job 도 들고 있을겁니다. 
왜 JobQueue를 weak_ptr로 들고 있을거냐면 나중에 잡을 실행하려고 만드는데 이걸 shared_ptr로 만들면 기다리는 시간동안 참조 카운터가 계속 0이 되지 않을 것이기 때문에 
그런 부분을 방지하기 위해 weak_ptr로 들고 있을겁니다. 

struct JobData
{
	JobData(weak_ptr<JobQueue> owner, JobRef job) : owner(owner), job(job)
	{
	}
	weak_ptr<JobQueue>		owner;
	JobRef					job;
};

그리고 TimerItem이라고 해서 우선순위 큐에 들어갈 원소 구조체도 만들겁니다. 들고 있을 멤버 변수는 먼저 uint64 executeTick = 0; 이라고 실행되어야 할 틱을 들고 있을것이고
그리고 위에서 만들어준 JobData를 들고 있을겁니다. 또 비교하기 쉽도록 < 연산자도 만들어 줬습니다.

struct TimerItem
{
	bool operator<(const TimerItem& other) const
	{
		return executeTick < other.executeTick;
	}

	uint64 executeTick = 0;
	JobData* jobData = nullptr;
};

다음은 JobTimer 클래스입니다. 
public 을 열고 첫번째로 Reserve라는 멤버 함수를 만들어줄건데 받아줄 매개변수는 uint64 tickAfter, weak_ptr<JobQueue> owner, JobRef job 을 받아줄겁니다.
이게 첫번째 함수 잡 타이머에 예약을 한다 라는 부분입니다. 

멤버 변수는 private로 들고 있을건데 먼저 이 JobTimer는 락을 사용할겁니다. 그래서 USE_LOCK을 추가합니다. 
그리고 위에서 말했든 우선순위 큐를 TimerItem 을 원소로 해서 들고 있을거이고 또 아토믹 불리언 변수도 들고 있을건데 이름은 _distributing 이라고 해서 이리저리 실행을 하고 있는지
그러니까 한번에 한명만 일감 배분을 맡겠다라는 정책을 만들겁니다. 

추가로 멤버 함수 Distribute, Clear 를 만들어 줍니다.
/*-------------------
	JobTimer
-------------------*/
class JobTimer
{
public:
	void Reserve(uint64 tickAfter, weak_ptr<JobQueue> owner, JobRef job);
	void Distribute(uint64 now);
	void Clear();

private:
	USE_LOCK;
	PriorityQueue<TimerItem>	_items;
	Atomic<bool>				_distributing = false;
};


-- JobTimer.cpp

먼저 말하자면 JobTimer는 전역으로 사용할겁니다. 

void JobTimer::Reserve(uint64 tickAfter, weak_ptr<JobQueue> owner, JobRef job)
{
	const uint64 executeTick = ::GetTickCount64() + tickAfter;
	JobData* jobData = ObjectPool<JobData>::Pop(owner, job);

	WRITE_LOCK;
	_items.push(TimerItem{executeTick, jobData});
}

Reserve에서 실행할 시간인 executeTick을 계산하고 jobData오 오브젝트 풀에서 만들어 꺼내옵니다. 여기까지는 서로 공용 메모리를 건드리지 않기 때문에 락을 안걸어도 되지만 
이후 _items에 데이터를 밀어 넣을때는 JobTimer를 전역으로 사용할것이기 때문에 락을 걸고 동작합니다. 

다음은 먼저 Clear를 보겠습니다.

void JobTimer::Clear()
{
	WRITE_LOCK;
	
	while (_items.empty() == false)
	{
		const TimerItem& timerItem = _items.top();
		ObjectPool<JobData>::Push(timerItem.jobData);
		_items.pop();
	}
}
마찬가지로 락을 걸고 시작합니다. 자주 보던 패턴으로 우선순위 큐인 _items가 빌때 까지 하나씩 top() 으로 꺼내 오브젝트 풀에 돌려 놓고 pop으로 _items를 하나씩 꺼냅니다. 

다음 Distribute 입니다. 

void JobTimer::Distribute(uint64 now)
{
	// 한번에 한 스레드만 통과 
	if (_distributing.exchange(true) == true)
		return;

	Vector<TimerItem> items;
	{
		WRITE_LOCK;

		while (_items.empty() == false)
		{
			const TimerItem& timerItem = _items.top();
			if (now < timerItem.executeTick)
				break;

			items.push_back(timerItem);
			_items.pop();
		}
	}

	for (TimerItem& item : items)
	{
		if (JobQueueRef owner = item.jobData->owner.lock())
			owner->Push(item.jobData->job);

		ObjectPool<JobData>::Push(item.jobData);
	}

	// 끝났으면 풀어준다 
	_distributing.store(false);
}
인자인 now 는 아마 Distribute를 호출할때의 ::GetTickCount64() 값일겁니다. 
순서대로 보면 _distributing.exchange(true) 의 반환값이 true 인지를 보고 있는데 이건 아토믹함수로 이전에도 자주 봤던 패턴입니다. _distributing의 값을 exchange의 인자로 바꿔주면서 
원래 _distributing가 가지고 있던 값을 반환하는것입니다. 즉 이 코드는 이미 누군가 JobTimer::Distribute를 실행하고 있는지를 보는것입니다. 

그리고 Vector<TimerItem> items; 를 만들고 중괄호로 범위를 집고 있는데 이것은 최대한 락을 잡는 범위를 작게 잡으려고 하는것입니다. 
그래서 중괄호 들어오자 마자 락을 잡고 _items의 원소들을 하나씩 꺼내 실행될 시간이 된것들을 items에 밀어 넣고 있습니다. 현재 시간인 now와 어느정도 기다릴지 tickAfter만큼을 더한 executeTick을 비교해 
실행할 때가 된 아이템을 구별합니다. 

이렇게 꺼낸 items는 이제 이 스레드 로컬 메모리에 있기 때문에 따로 락을 잡지 않아도 됩니다. 
이상태로 items의 원소를 하나씩 꺼내 owner에 job을 넣어주고 다 사용한 JobData는 오브젝트 풀에 반납합니다. 

여기까지 왔다면 잡고있던 _distributing을 풀어주고 끝냅니다. 

( 위의 수정을 하면 owner->Push(item.jobData->job); 에서 에러 메세지가 날겁니다. JoqQueue::Push를 보면 인자를 &&으로 오른값으로 받고 있습니다. 이렇게 까지 할 필요는없고 
그냥 &&을 지워서 인자를 받아주는걸로 수정하였습니다.
그리고 JobQueue::Push 라는 함수자체가 private상태인데 public 상태로 바꿔야 외부에서 접근이 가능합니다. )


그리고 JobQueue::Push를 보면 내가 처음으로 들어왔으면 바로 실행하는 식으로 동작하고 있었는데 JobTimer는 처음으로 들어 왔어도 그냥 일을 밀어 넣고 나가기 위해 인자로 옵션을 하나더 만들겠습니다. 


void				Push(JobRef job, bool pushOnly = false);

void JobQueue::Push(JobRef job, bool pushOnly)
{
	const int32 prevCount = _jobCount.fetch_add(1);
	_jobs.Push(job); // WRITE_LOCK

	// 첫번째 Job을 넣은 스레드가 실행까지 담당
	if (prevCount == 0)
	{
		// 이미 실행중인 JobQueue가 없으면 실행
		if (LCurrentJobQueue == nullptr && pushOnly == false)
		{
			Execute();
		}
		else
		{
			// 여유 있는 다른 스레드가 실행하도록 GlobalQueue에 넘긴다
			GGlobalQueue->Push(shared_from_this());
		}
	}
}

그러면 이제 Distribute에서 JobQueue::Push를 호출해주던 부분에 두번째 인자를 true로 주면 됩니다. 그러면 Distribute에서 호출된 Push는 아주 빠르게 실행됩니다. 

이제 이 JobTimer 라는걸 어떻게 사용할까 생각해보자면 아까 위에서 JobTimer는 전역 객체로 사용할것이라고 했으니 CoreGlobal에 추가해주면 될것 같습니다. 
추가하는것은 이전과 똑같이 CoreGlobal.h 에 extern class 로 선언하고 cpp 쪽에 JobTimer.h 를 include 후 다시 cpp에서 nullptr로 초기화 해줍니다. 
또 CoreGlobal 생성자안에서 GJobTimer 생성 소멸자에서는 delete 해주는 것으로 전역 객체로 사용할 준비가 됩니다.

실질적으로 예약이 필요할때 JobQueue에서 어떻게 사용하냐면 이전에 만들었던 DoAsync 함수와 비슷하지만 JobTimer를 사용하는 함수들을 만들어 줄겁니다. 


	void DoTimer(uint64 tickAfter, CallbackType&& callback)
	{
		JobRef job = ObjectPool<Job>::MakeShared(std::move(callback));
		GJobTimer->Reserve(tickAfter, shared_from_this(), job);
	}

	template<typename T, typename Ret, typename... Args>
	void DoTimer(uint64 tickAfter, Ret(T::* memFunc)(Args...), Args... args)
	{
		shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
		JobRef job = ObjectPool<Job>::MakeShared(owner, memFunc, std::forward<Args>(args)...);
		GJobTimer->Reserve(tickAfter, shared_from_this(), job);
	}

인자로 uint64 tickAfter 가 추가 되었고  이전에는 오브젝트 풀에서 Job을 꺼내온 다음 바로 Push해줬었는데 잠시 변수에 저장해두고 다시 GJobTimer->Reserve를 호출해주는 것이 다릅니다. 

***

테스트를 위해 GameServer코드로 가보겠습니다. 이전시간까지 어느 스레드에 각 일감을 배분할지를 생각해보고 있었습니다. 
이제는 누군가가 일감을 꺼내 배분 시켜줘야합니다. 

모두가 만능형 직원이 되서 평등하게 일감을 맡는게 우리 정책이었습니다. 

-- ThreadManager 코드
스레드 매니저에 새로 함수를 만들어 줄겁니다 .

void ThreadManager::DistributeReservedJobs()
{
	const uint64 now = ::GetTickCount64();

	GJobTimer->Distribute(now);
}

이렇게 간단한 함수를 하나 추가해서 ThreadManager로 관리하는 스레드들에게 Distribute를 시킬수 있게 해줬습니다.

그리고 GameServer 코드로 돌아와 DoWorkerJob 함수내에서 ThreadManager::DoGlobalQueueWork() 를 호출해주기 전에 배분을 해주겠습니다.

void DoWorkerJob(ServerServiceRef& service)
{
	while (true)
	{
		LEndTickCount = ::GetTickCount64() + WORKER_TICK;

		// 네트워크 입출력 처리 -> 인게임 로직까지 (패킷 핸들러에 의해)
		service->GetIocpCore()->Dispatch(10);

		// 예약된 일감 
		ThreadManager::DistributeReservedJobs();

		// 글로벌 큐
		ThreadManager::DoGlobalQueueWork();
	}
}

실질적으로는 어떻게 사용할수 있을것이냐면 

GRoom->DoTimer(1000, [](){ cout << "Hello 1000" << endl; }); 

이런식으로 1000ms 후 즉 1초후에 Hello 1000 이라는 문자열을 출력해달라고 예약할 수 있게 됩니다.

테스트코드로 2개 더 추개해서 2초 3초에 실행되도록 해보겠습니다.

	GRoom->DoTimer(1000, []() { cout << "Hello 1000" << endl; });
	GRoom->DoTimer(2000, []() { cout << "Hello 2000" << endl; });
	GRoom->DoTimer(3000, []() { cout << "Hello 3000" << endl; });

그런데 테스트를 해보면 3000, 2000, 1000 순으로 뒤집혀서 출력됩니다.

왜 그런것이냐면 JobTimer 에서 우선순위 큐로 executeTick 을 비교 정렬한 큐를 사용하고 있었는데 비교 연산자를 < 말고 > 로 수정해야합니다. 
우선순위큐의 기본 정렬기준을 less로 해뒀는데 큰거에서 작은것 순으로 정렬 되어서 그렇습니다. 
우리는 작은것에서 큰순서로 정렬 되기를 원하니까 

struct TimerItem
{
	bool operator<(const TimerItem& other) const
	{
		return executeTick > other.executeTick;
	}

	uint64 executeTick = 0;
	JobData* jobData = nullptr;
};

이렇게 수정합니다.

이제 다시 빌드 후 시작해 보면 의도한 대로 1, 2 ,3 초에 각각 메세지가 출력되는걸 확인 할 수 있습니다. 

또 한가지 집고 넘어가자면 JobTimer::Distribute 함수에서는 왜 _distributing 이라는 bool을 사용해 딱 하나의 스레드만 통과하도록 만들었을까요
정말 간발의 차로 일감이 두개 있다고 해보겠습니다. 그러면 정말 운이 나쁘게 락을 잡지 않은 범위에서 owner에 밀어 넣는 순서가 꼬일 수 있기 때문입니다. 
극악의 확률로 일어나는 버그라서 잘 재현이 되지는 않지만 일단 버그가 발생하면 재현이 되지않는것이 더욱 문제가 될겁니다. 미리 예방을 하는 의미입니다. 