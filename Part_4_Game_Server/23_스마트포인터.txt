


        스마트 포인터 


이전 시간까지 참조 카운트의 기초에 대해 알아보았고 이번시간에는 스마트 포인터에 대해 알아볼겁니다. 

프로젝트마다 표준 스마트 포인터를 사용하는 경우도 있고 아니면 직접 만들어 사용하는 경우도 있다고 했었습니다. 
이전 시간에는 이렇게만 말하고 넘어갔는데 각기 사용하는데 장점,단점도 알아야 어떤경우에 어떤 방식을 사용하는게 좋을지 판단할 수 있을겁니다. 

먼저 이전 시간처럼 shared_ptr을 만들어 사용할때 입니다.

1 - 이미 만들어진 클래스를 대상으로 사용 불가 
    무슨 말이냐면 우리가 만든 TSharedPtr 은 RefCountable 이라는 아토믹하게 레퍼런스 카운트를 하는 상위 클래스를 상속받은 클래스에 사용할 수 
    있는 스마트 포인터 였습니다. 모든 코드를 전부 직접 만든다면 원하는 클래스에 원하는대로 상속 시킬수 있겠지만 
    모든 코드를 직접만드는 경우는 정말 드물것이고 보통 오픈 소스인 외부 라이브러리중 필요한 기능을 가져다 사용할겁니다. 
    이때 외부 라이브러리 코드는 마음대로 상속을 시키는게 불가능하기 때문에 TSharedPtr가 무용지물이 됩니다. 
    하지만 이 단점은 스마트 포인터가 필요한 부분만 만든다는 방법으로 해결 가능하기 때문에 아주 큰 단점은 아닐겁니다. 

2 - 순환(Cycle) 문제
    두번째 단점인 순환 문제는 직접 만들건 표준을 사용하건 공통된 문제인데 이 순환 문제는 고민할 것이 조금 많습니다. 

    순환 문제의 예시를 들어보겠습니다. 와우와 비슷한 온라인게임을 만들려고 하고 그 안에 투기장이라는 PVP컨텐츠를 만들것입니다. 
    Knight 라는 직업이 있고 클래스로 들고 있을 데이터를 만들어 두었습니다. Knight클래스에는 많은 데이터들이 있겠지만 그 중 타겟이라는 
    공격이나 대화 등의 상호작용을 할 상대를 포인터로 들고 있을 것입니다. 여기서 이전 시간에 배운 TSharedPtr를 사용해서 타겟을 스마트 포인터로 
    들고 있을것입니다. 그런데 투기장이라는것은 상대방도 있을건데 두 플레이어가 서로를 타겟으로 지정하고 PVP를 한 결과 두 캐릭터가 동시에 
    사망했다고 하면 그 캐릭터 객체들이 사라져야 하는데 객체 본인이 사라지려고 Release를 해도 타겟으로 지정된 이상 참조 카운트가 0이 되지 않고 
    그게 양 캐릭터를 참조 카운트 1인채로 아무것도 못하게 만들어 버립니다. 

    이게 순환 문제라는것입니다. 

    shared_ptr를 사용하는것 자체는 나쁜것이 아니지만 순환문제를 해결해줘야 합니다. 위의 예시에서는 두 캐릭터가 사망하기 전에 명시적으로 
    각각 자신의 타겟을 nullptr 로 밀어주면서 레퍼런스 카운트를 1로 줄여놓은 다음 삭제코드에 들어가면 되겠습니다. 

    이 버그가 일어나는 경우는 사실 컨텐츠 단에서 두 객체가 서로를 바라보면서 생기는 버그는 생각보다 많이 없고 게임 엔진의
    컴포넌트 패턴에서 어떤 클래스가 다른 클래스를 포함하고 있는 쪽에서 자주 일어납니다. 

    다시 위의 예시를 가지고 설명해보자면 기사 객체에 더불어 이번에는 Inventory 라는 클래스를 만들어서 플레이어가 인벤토리를 하나씩 가지고 있을것이고
    이 기능을 각 플레이어 클래스안에 넣는게 아니라 따로 빼서 컴포넌트 식으로 관리합니다. Knight 클래스 내부에서도 인벤토리 포인터를 들고 있어야 할테고 
    인벤토리 입장에서도 자신의 주인이 되는 캐릭터를 포인터로 들고 있는 형태로 만들어 보겠습니다. 

    이때 인벤토리 클래스에서 기사를 참조 타입으로 들고 있으면 별다른 문제없이 돌아갈 테지만 기사를 shared_ptr로 들고 있으면 또 순환 문제가 일어나게됩니다. 

    순환문제가 일어나면 어떤 결과물이되냐면 RPG게임에서 몬스터에 이런 버그가 일어나고 있다면 메모리가 해제되지 않아서 렘 사용량이 쭉 늘어나게 됩니다.

    또 직접만든 스마트 포인터에서만 이런 문제가 발생하는게 아니라 표준 스마트 포인터에서도 이런 문제가 일어납니다. 

    표준 shared_ptr는 어떻게 되어있는지를 알아보면 
    
    표준 shared_ptr 버전 
	shared_ptr의 코드를 따라 들어가보면 _Ptr_base 라는 클래스를 상속받고 있고 
	이 _Ptr_base 클래스는 shared_ptr 과 weak_ptr 을 위한 베이스 클래스라고 주석이 적혀있다
	_Ptr_base의 멤버 변수는 element_type* 타입 하나와 _Ptr_count_base* 타입의 변수가 있다
	또 shared_ptr을 만들때는 생성자를 사용하는 것보다 make_shared를 사용하는 편이 좋다고 하는데
	그 이유는 make_shared 코드를 살펴보면 Knight로 넘겨준 것이 템플릿으로 new _Ref_count_obj2
	하고 있습니다. 또 이 클래스 코드를 따라 가보면 절묘하게도 아까 살펴본 _Ref_count_base를 
	상속하고 있습니다. 
	이것은 우리가 만든 RefCountable 클래스를 상속받는것처럼 된다는 겁니다. 
	[Knight | RefCountingBlock] 
	make_shared로 만들게 되면 위의 [] 와 같이 Knight 객체와 더해서 레퍼런스 카운팅을 하는 객체를 
	한번에 공간을 할당해 만들어 줍니다. 
	그러면 이번에는 RefCountingBlock에 해당하는 객체는 어떤 데이터를 가지고 있을까요
	직접 만들었던 RefCountable 을 생각해보면 레퍼런스 카운트를하는 정수를 가지고 있을것 같은데 
	또 타고 들어가면 Uses 와 Weaks 라는 두가지 아토믹 카운터가 있습니다. 


그리하여 오늘 알아볼 내용은 모두 표준 라이브러리의 스마트 포인터 3종에 대해 알아볼겁니다. 

shared_ptr, unique_ptr, weak_ptr 이라고 총 3가지 종류가 있는데 


이중에 unique_ptr 이 하는 역할은 사실 스마트 포인터라고 하기도 미안합니다. 

unique_ptr<Knight> k2 = make_unique<Knight>();

이런 코드로 만들수 있고, 이것은 사실상 생포인터와 거의 같은데 부하도 거의 없고 다만 내부적으로 들여다보면 복사 생성자와 복사 연산자를 막아 두었습니다. 
말 그대로 유니크 포인터 입니다. 한 생명주기 안에서는 똑같은 객체를 가리키는 포인터는 하나뿐일것이고 정 다른 변수에 이 객체를 넘겨주려면 
std::move(k2) 이렇게 원래 k2의 권한을 포기하고 이동을 시켜주어야 합니다. 
복사가 되지 않고 변수의 생명주기가 끝나면 알아서 객체를 delete 해주는 것 이 이 유니크 포인터의 전부입니다. 


다음으로 weak_ptr입니다. 사실 이번 강의의 주요 내용이 shared_ptr과 weak_ptr의 내용입니다. 

weak_ptr를 사용하면 순환 문제를 해결할 수 있습니다. 그렇다고 꼭 weak_ptr만을 사용해야하는것도 아닙니다. shared_ptr만을 사용하더라도 알아서 순환 문제를 
일으키지 않는 구조로 만들거나 순환이 되더라도 명시적으로 순환을 풀면서 메모리 릭이 발생하지 않게 하면 되었습니다.


그럼 weak_ptr이 어떤 내용이길레 순환문제를 해결하면서 shared_ptr을 대체할 수 있는지를 알아보겠습니다. 
weak_ptr은 make_shared로 생성할수 있고 아니면 있던 shared_ptr을 그대로 받을 수도 있습니다. 

shared_ptr<Knight> spr = make_shared<Knight>();

weak_ptr<Knight> wpr = make_shared<Knight>();
weak_ptr<Knight> wpr2 = spr;

그리고 weak_ptr을 사용하려면 그냥 곧바로 사용할 수 없고 포인터가 가리키고 있는 객체가 아직 존재하는지를 체크한 다음 사용할 수 있습니다. 
방법은 이렇습니다. 

bool expired = wpr.expried();

매번 이렇게 사용하는게 번거롭다면 lock() 을 이용해 shared_ptr로 캐스팅을 한 후 사용할수 있습니다. 

shared_ptr<Knight> spr2 = wpr2.lock();

이 두가지 사용법을 시도하는중에 어떠한 이유로 객체가 없어졌다고 했을때 아예 expired는 아예 통과가 안되고 shared_ptr로 캐스팅을 한경우는 nullptr이 반환되며
사용할 수 없습니다. 


여기서 위에서 알아 봤던 shared_ptr, weak_ptr 둘 공통의 부모 클래스인 _Ptr_base가 있고 이 클래스가 들고 있는 멤버 변수들이 사용할 클래스 포인터 하나와 
Uses, Weaks 카운트가 같이 있는 _Ptr_count_base 객체 입니다. 

아까 설명하지 못했던 Uses, Weaks 가 무슨의미이냐면 Uses 카운트는 그냥 shared_ptr로 가리키고 있는 참초 횟수이고 Weaks는 마찬가지로 weak_ptr로 가리키고 있는 
참조 횟수입니다. 

이번 강의 처음에 만들어 봤던 shared_ptr은 참조 카운트를 봐서 0이 되면 delete 를 해주는 방식이었습니다. 그 역할을 지금 _Ptr_count_base 가 대신하고 있는것입니다. 
표준에서 Uses 카운트 즉 shared_ptr의 참조 카운트가 0이 되면 사용하던 객체, Knight 객체 같은것은 그때 정책에 따라 날려주던지 안날리던지 하지만 
이때 Weaks 카운트가 0이 아니라면 RefCountingBlock 은 날리지 않습니다. 

이런 구조이다 보니 weak_ptr을 사용할때는 객체 자체는 날라 갔을 수도 있기때문에 체크를 하고 사용합니다. 

weak_ptr 과 shared_ptr 은 서로 보완적인데 weak_ptr은 RefCountingBlock을 참조해서 객체가 사라졌는지 아닌지를 알 수 있지만 
객체 자체의 수명에는 관여하지 못하는 스마트 포인터입니다. 

이런 성질을 이용해서 shared_ptr만 사용할때의 순환 Cycle 문제를 해결할 수 있는데 

예를들어 위에서 Knight와 Inventory가 서로를 shared_ptr로 들고 있을때 서로가 참조 카운트를 1올려주고 있기 때문에 객체의 삭제가 일어 나지 않는 문제에서 
Inventory가 들고있는 _knight 포인터를 weak_ptr로 들고 있게되면 Inventory에서는 Knight 객체의 생명에는 관여하지 못하기 때문에 Knight 객체를 삭제하면 그대로 
delete 까지 됩니다. 

Inventory객체 에서는 _knight를 weak_ptr 로 들고 있다보니 expired나 캐스팅을 해서 Knight객체가 아직 존재하면 그 데이터를 읽거나 할 수 있는데 
어쩌가 Knight가 삭제 되었다고 하더라도 _knight.expired() 가 false 가 되거나 _knight.lock()으로 캐스팅한 shared_ptr가 nullptr 이 될 뿐입니다. 

즉, shared_ptr만 사용하더라도 조심해서 순환 문제가 일어나지 않게 하던가 아니면 shared_ptr와 weak_ptr를 같이 사용하면서 weak_ptr를 사용할때 체크를 해가면서 
사용하던지의 선택의 문제입니다. 

마지막으로 _Ptr_base의 코드를 보면 멤버 변수중에 _Incref, _Decref, _Incwref, _Decwref 이라는 이름의 함수들이 있습니다. 이름만 봐도 각 Uses 카운트와 Weaks카운트를
증감 하는 함수같습니다. _Incref 함수는 그냥 카운트를 증가시키는 동작을 하고 _Decref에서 카운트 감소를 한 다음 카운트가 0인지를 봐서 Destroy와 
_Decwref를 호출하는 동작을 하고 있습니다 Uses 카운트가 0이라는 이야기는 객체를 삭제한다는 말이고 그러면 현재 이 shared_ptr이 사라지면서 Weaks 카운트도 하나 준다는 
말입니다. 이후 _Decwref에서도 Weaks의 갯수를 체크할것입니다. 