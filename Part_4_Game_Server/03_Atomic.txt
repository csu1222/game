


        Atomic



지난시간은 표준 쓰레드 라이브러리로 생성하는 방법을 알아 봤고 

이번시간은 멀티 쓰레드 환경에서 공유 데이터를 사용할때 일어나는 문제점들에 대해 하나씩 알아보는 시간입니다. 

공유 데이터를 사용하는 환경을 간단히 만들어 보면 

int32 sum = 0;

void Add()
{
	for (int i = 0; i < 100'0000; < i++)
	{
		sum++;
	}
}

void Sub()
{
	for (int i = 0; i < 100'0000; < i++)
	{
		sum--;
	}
}

sum 이라는 전역 변수를 하나 만들었고 Add 함수에서는 100만번 sum을 1씩 더하고 있고 Sub 함수는 100만번 1씩 빼주고 있습니다. 

이런 상황에서 멀티쓰레드를 사용하지 않고 그냥 메인 쓰레드 하나만 사용해서 Add, Sub를 호출하면 마지막으로 최종값이 0으로 떨어질겁니다 
당연한 얘기입니다. 

그런데 우리가 궁금한건 멀티쓰레드 환경에서 구동했을때 어떻게 되는지가 궁금합니다. 

	std::thread t1(Add);
	std::thread t2(Sub);
	t1.join();
	t2.join();

	cout << sum << endl;

t1 과 t2 라는 각각의 쓰레드를 만들어서 하나는 Add, 나머지는 Sub 함수를 실행하도록 만들고 join으로 기다려서 동기화 한다음 sum을 출력 해봤습니다. 

결과는 놀랍게도 전혀 엉뚱한 값이 나옵니다. 심지어 실행할때 마다 값이 바뀝니다. 

왜이런 일이 일어날까요?
당연히 백만번 더하고 백만번 빼면 0이 되어야하는데 멀티쓰레드에서는 그렇지 않은가 궁금합니다. 

이것이 공유데이터를 사용하는데 생기는 문제입니다. 이 문제는 멀티 쓰레드를 사용하면서 두고두고 골치가 아픕니다.

이때 개념을 확실히 알고 가야하는게 스택과 공유 메모리를 구분 할 줄 아는것인데 
예를들어 전역 변수와 함수내 변수는 저장되는 메모리 위치가 다릅니다. 전역변수 같은경우는 데이터 영역에 저장되고 ,
함수내 변수는 스택 메모리에 저장됩니다. 이 스택 메모리는 함수가 실행 될때만 할당되는 휘발성 메모리라서
스택 변수는 위치한 함수 밖에서는 접근이 불가합니다. 

이번에는 Add 함수나 Sub 함수에서 sum을 증감시키는 순간을 어셈블리 언어로 해석해보면 

mov eax, (sum이 저장되어 있던 메모리)
icn eax,
mov (sum이 저장되어 있던 메모리), eax 

이렇게 세줄로 sum++ 이 표현되어 있습니다. C++ 에서는 한줄이 코드가 좀더 컴퓨터에 가까운 언어인 어셈블리로 
다시 보면 3줄짜리 코드인겁니다.

그러면 왜 한방에 sum이 있는 메모리에 inc 로 값을 증가 시키지 않고 3줄로 나눠서 하는걸까요?
이건 어쩔 수 없는 일입니다. CPU 에서 연산을 할때 어떤 곳에 있는 데이터를 꺼내오고 그 데이터를 연산하는것을 
동시에 할 수 없습니다. 애초에 설계가 그렇게 되어 있기 때문입니다. 

데이터를 가져오는 위치도 아무렇게나 가져오는게 아니로 CPU 안에있는 레지스터라고하는 메모리로 가져옵니다.
이런 이유가 있어도 결국 3줄의 코드로 실행되는건 마찬가지입니다. 3줄의 코드가 멀티쓰레드 환경에서 어떻게 동작하는지를 알아 보겟습니다. 

예시에서는 백만번씩을 반복하고 있지만 지금은 딱 한번씩만 증감하는 함수라고 치고 멀티쓰레드 환경에서 두 함수를 동시에 실행했다고 해보겠습니다.
그러면 처음에 Add 함수에서 sum이 0 인 상태에서 eax 로 가져오는 부분이 실행될텐데 그런데 마침 Sub 함수에서도 sum에서 0이라는값을 Sub의 
eax에 가져옵니다. 
이후로 각자 eax를 1 더하거나 1 빼준 다음 원래 sum이 저장되어있는 위치에 가져다 놓을텐데 이 작업들이 멀티쓰레드 환경에서 동시에 실행되다 보니까 
어떤 함수가 먼저 실행되는지를 모릅니다. 그래서 그때 그때 어떤 쓰레드가 간발의 차이로 먼저 실행 되었는지에 따라 결과가 바뀝니다.

이런 서로 공유 데이터를 건드리고 있다고 인지하지 못하고 있는 중에 각자 할 일을 하는게 문제인겁니다. 

이 공유 메모리를 동시에 건드리는게 문제이기도 하지만 동시에 장점이기도 합니다. 

장점인 이유는 사용할 데이터를 공유 메모리 한곳에 두고 같이 읽기만 한다면  괜한 메모리 낭비 없이 사용할수 있겠지만 

문제는 데이터를 읽기만 하는게 아니라 수정을 하기 시작한다면 그때 부터 문제가 발생합니다.

앞으로 공용데이터를 건드리는 문제에는 동기화 라는 용어가 등장합니다.
지금 예시로 든 문제도 ++, -- 연산자가 어셈블리언어로 보면 실제로는 3줄짜리 코드이기 때문에 발생하는 문제 입니다. 만약이 이 3줄이 한번에 뿅 일어난다고 
하면 현제같은 문제가 발생하지 않을 겁니다. 

동기화 기법은 여러가지가 있는데 그 중에 이번에 배울 기법은 Atomic 이라고 합니다. 

Atomic이라는 용어에서 Atom 이라는 단어는 원자를 뜻하죠 고전 물리학에서는 더이상 쪼개지지 않는 입자를 원자 Atom이라고 불렀습니다.
그래서 이 Atomic 이라는 용어를 프로그래밍에서 가져다 사용하면서 말하고 싶은 것은 
All or Nothing 전부 실행이 되거나 아니면 아예 실행이 되지 않거나 하게끔 하고 싶은겁니다. 

그리고 이 Atomic 이라는 기법은 지금 멀티쓰레드를 배우는 중에도 등장했지만 나중에 데이터 베이스를 배울때도 등장할겁니다. 

DB에서 사용되는 경우를 잠깐 살펴보자면 

DB 에서의 Atomic 예시
 - A 라는 유저 인벤에서 집행검을 빼고 
 - B 라는 유저 인벤에 집행검을 추가 
 
 위의 두줄을 아토믹기법으로 실행해야 합니다. 그 이유는 위의 줄이 실행된다음 알지못하는 이유로 접속이 끊겼다면 
 A의 유저의 인벤토리에서 집행검이 사라지기만 하는 상황이 됩니다. 그러면 그냥 아이템하나가 증발하는겁니다. 그렇기 때문에 이 두줄은 모두 실행되거나
 아니면 둘다 실행되지않아야 합니다.



이제 다시 우리 예제에 Atomic을 적용 시켜 보겠습니다.

예전에는 운영체제 마다 Atomic을 사용하는 방법이 달랐다고 합니다. 윈도우즈 같은경우는 Interlocked 류 함수를 사용하는 방법이었다고 하는데 
C++ 11 이후 모던 C++ 부터는 atomic을 공용 라이브러리로 만들어서 어떤 운영체제건 같에 똑같이 사용할 수 있게 하였다고합니다. 

사용하는 방법은 간단한데 

#include <atomic>
atomic<int32> sum = 0;

이렇게 atomic이라는 라이브러리를 추가하고 atomic 클래스 객체로 변수를 만드는겁니다. 타입은 역시 템플릿 문법으로 받을 수 있습니다. 

이제 atomic 객체로 만들어진 sum 변수를 ++ 혹은 -- 연산을 하게되면 아까 알아봤던 3줄의 어셈블리 코드가 각각 실행되는것이 아닌 
전부 실행되던가 아니면 실행되지 않던가 하는 원자 상태가 됩니다. 

그냥 
sum++;
sum--;
으로 사용해도 되지만 이 sum 이라는 변수가 아토믹인지 아닌지 햇갈리기 때문에 티를 내기 위해 
sum.fetch_add(1); 
이런식으로 사용하기도 합니다. 효과는 같습니다.

적용해서 다시 프로그램을 실행해 보면 정상적으로 0으로 출력됩니다.

아토믹을 적용한 변수에 대한 쓰레드들의 진행은 대략 이렇게 진행될겁니다.
동시에 실행된 t1쓰레드와 t2쓰레드가 경합을 벌여서 먼저 실행된 쓰레드가 완료 될때 까지 느렸던 쓰레드가 살짝 대기를 하게 되고
이 순서의 우위는 CPU에 영향을 받습니다. 

sum.fetch_add 에 중단점을 걸어 디버그를 실행하고 디스어셈블리로 살펴보면 이전에는 3줄로 이뤄졌던 코드가 fetch_add라는 함수로 연결되게끔 바뀌어 있습니다. 

주의 할 점은 아토믹을 사용하면 연산이 생각보다 많이 느려집니다. 그러니까 꼭 필요한 상황에서 사용해야 하는거지 아무대나 사용하면 안되겠습니다. 

첫번째 동기화 방법 아토믹을 알아 봤습니다.