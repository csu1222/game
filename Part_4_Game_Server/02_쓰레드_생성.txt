

        쓰레드 생성


이번 시간엔 쓰레드를 생성하고 구동시켜서 정보를 체크하는 실습을 해보겠습니다.

실습은 GameServer 프로젝트에서 할것입니다. 이번시간에만 실습한번하고 삭제할 내용이다 보니까 다른 프로젝트에서 
진행해도 별 상관없습니다.   

멀티쓰레드 환경으로 본격적으로 들어가기 앞서 

지금까지 그냥 사용하고 있던 

cout << "Hello World!" << endl;

이런 코드는 생각보다 무거운 작업입니다. 
그냥 숫자의 더하기 빼기같은 작업과 달리 Hello World 라는 문자열을 모니터에 출력하도록 
System Call (OS 커널 요청) 을 하고 있는겁니다. 

그리고 쓰레드를 생성하는것도 우리가 멋대로 할 수 있는게 아니라 운영체제에 요청을 하고 운영체제에서 처리를 해줘야 합니다.

운영체제에 요청을 하기 위해서는 운영체제마다 정해진 API를 활용해야 합니다. 그리고 당연히 운영체제가 Windows인지 Rinux인지에 따라
API가 다릅니다.

보통 사용하고 있는 운영체제가 윈도우즈다 보니깐 윈도우즈 API를 사용하기위해 

#include "Windows.h"

int Main()
{
    ::CreateThread();
}
이렇게 쓰레드를 생성할 수 있지만 이 방법은 윈도우즈에서만 유효한 방법입니다. 

만약 정말 만약에 리눅스로 운영체제를 바꾼다면 위의 방법으로 구현한 서버는 수정할 내용이 대단히 많을겁니다. 

하지만 최근 C++ 11 에서 부터 쓰레드 생성하는것이 표준으로 들어왔습니다.

#include <thread>

이 헤더를 통해서 윈도우즈건 리눅스건 공통되게 쓰레드를 만들수 있게 바뀌어서 이런 모던한 방법을 사용하는걸 권장한다고 합니다.

물론 서버 같은 경우에는 클라이언트처럼 안드로이드, ios 처럼 환경이 자주 바뀌는것이 아니라 
어떤 환경하나를 정하고 거기서 구동이 되도록 만들면 그 환경에서 평생 구동할것이긴 하지만 
혹시 만약에 라도 다른 운영체제에서도 호환이되도록 만들고 싶으면 지금처럼 thread 헤더를 이용하는게 좋을겁니다.

참고로 한국에서 서버는 아직도 윈도우즈 서버를 많이 운영한다고 합니다. 
하지만 해외로 넘어가게 되면 리눅스를 선호한다고 합니다.
그래서 한국에서 윈도우즈 서버로 만들어서 중국에 퍼블리싱을 했더니 중국에서 리눅스 서버로 변환해달라고 강하게 요청했다는 썰이 있습니다. 
이런 경우를 생각해서라도 표준적으로 돌아가도록 서버를 만드는게 좋을 것 같습니다.

결론은 앞으로 이 프로젝트에서는 thread 헤더를 활용할것이라는 겁니다. 


아무튼 쓰레드를 만드는코드는 생각보다 단순합니다. 

void HelloThread()
{
	cout << "Hello Thread" << endl;
}

int main()
{
	std::thread t(HelloThread);

}

그저 Hello Thread 라는 문자열을 출력하는 함수를 만들었고 Main 함수에서는 객체를 만들듯이 t라는 이름의 쓰레드를 만들었습니다. 
근데 기본생성자가 아닌 인자로 HelloThread 함수를 주고 있습니다. 

이것은 t 라는 쓰레드가 만들어지자 마자 실행될 함수를 지정해 줄수 있는것과 같습니다. 이것을 '엔트리 포인트'라고 한답니다. 
어떻게 진행되는것이냐면 

std::thread t(HelloThread); 이 코드가 실행되자마자 새로운 쓰레드가 만들어 지면서 그 쓰레드가 실질적으로 HelloThread 코드를 실행하고 
종료가 될겁니다.

이게 그냥 Main 함수에서 HelloThread 함수를 호출하는것과 무슨 차이가 있는지 생각해보면 
이전처럼 Main함수에 HelloThread를 호출하면 Main 쓰레드가 Main 함수 의 코드를 쭉 진행하면서 HelloThread 함수에 다다르면 그 코드를 진행하고 
넘어가는건데 

따로 새로운 쓰레드를 만들어서 HelloThread를 생성자의 인자로 주게 되면 Main 쓰레드는 t 쓰레드를 만드는 코드에서 쓰레드를 만들고 그냥 지나치고 
만들어진 새로운 쓰레드가 HelloThread 코드를 실행하는겁니다.

이전에는 Main 쓰레드가 코드들을 순서대로 읽어 내려간다면 t 쓰레드를 만드는 순간부터 t 쓰레드와 Main 쓰레드가 동시에 실행되는겁니다.

여기까지 하고 한번 테스트 해볼겁니다.HelloThread 밑에 Main 쓰레드가 Hello Main 이라고 출력하도록 하고 한번 디버깅을 실행해 보면 
에러메세지가 뜹니다. 
그 이유는 우리가 실질적으로 쓰레드 객체를 하나 만들었는데 이 t 라는 쓰레드 객체가 Main 함수 안에 만들어 지고 Main 함수가 먼저 끝나 버리면 
이렇게 에러메세지가 뜹니다.
그래서 Main 쓰레드 쪽에서 호출한 쓰레드 객체를 책임지고 기다려 줘야합니다.
그때 사용되는 함수가 

t.join() 함수입니다. 
join 함수는 t 라는 쓰레드객체가 끝날때 까지 Main 쓰레드가 기다려 주는 함수인데 

그러면 t는 언쩨 끝날까요? 아까 위에서 Main 함수가 먼저 끝났듯이 생성할때 쥐어준 HelloThread함수가 끝날때 t 도 같이 끝납니다. 

t가 끝나는 조건을 알았는데 그럼 궁금해지는게 HelloThread 함수안에 무한 루프를 만들어 두면 어떻게 되냐면 t.join을 영영 기다리면서 
끝나지 않게 되는겁니다.

하여듵 join 함수를 추가한다음 디버깅을 실행해보면 에러메세지 없이 잘 실행됩니다. 

그리고 이번엔 중단점을 하나 잡아 볼건데 HelloThread 함수 안에 잡아서 디버깅을 실행 해 볼겁니다. 
디버깅 화면중에 상단을 보면 쓰레드 란이 있습니다. 거길 보면 쓰레드가 여러개 있는걸 볼 수 있고 그중에 주 쓰레드 라고 되어 있는걸 선택해 보면 
Main 함수의 t.join() 에 멈춰 있고 다른 쓰레드를 선택 해보면 HelloThread 함수 안에 있는걸 볼 수 있습니다. 
즉, 우리가 MMO 서버를 만들게 되면 다양한 쓰레드가 여기에 뜰 테니까 각 쓰레드가 뭘하는지를 체크 할 수 있습니다.

다음은 이제 쓰레드 객체에서 사용되는 함수들을 알아볼겁니다. 
몇가지가 있는데 

	t.hardware_concurrency();
	t.get_id();
	t.detach();
	t.joinable();
	t.join();

이 다섯가지 함수들이 가장 중요하게 사용되는 함수들입니다. 

먼저 hardware_concurrency 는 CPU 코어의 개수를 알고 싶을때 사용합니다. 

	int32 count = t.hardware_concurrency();  // CPU 코어 개수?

int32 타입으로 반환을 받는데 CPU 코어개수는 이전에 OT 시간에 말했듯이 멀티 코어 환경에서 실질적으로 동시에 구동할수 있는 쓰레드의 개수가 
CPU 코어 개수에 영향을 받는다고 했는데 그 정보를 추출하는 함수라고 볼 수 있습니다. 
그런데 이 함수가 100% 정확하진않고 경우에 따라서 정보를 추출할 수 없으면 0을 리턴한다고 합니다. 

get_id 함수는 쓰레드의 아이디를 반환합니다. 쓰레드는 생성될때 마다 고유한 id 가 생성되는데 0,1,2,3.. 이렇게 순서대로는 아니지만 각 쓰레드의 고유한 
값이기는합니다. 

	auto id = t.get_id();		// 쓰레드 마다 부여되는 ID

반환은 std::thread::id 타입이라서 간편하게 auto로 받아주고 있습니다. 

detach 함수는 연결되어있던 쓰레드 간의 연결을 끊어줍니다. 

	t.detach();			// main 쓰레드와 t 쓰레드와의 연결고리를 끊어준다 

이게 무슨 말이냐면 방금 실습에서 Main 함수내에서 t 라는 쓰레드 객체를 만들고 HelloThread함수를 쥐어 줬었습니다. 이러고 그냥 실행하면 에러 메세지가 떴었습니다.
이유는 t 쓰레드가 종료되기 전에 먼저 Main 쓰레드가 종료되어서 였고 이걸 해결하기 위해 t쓰레드가 종료되길 기다리는 함수 join을 사용했었습니다. 
그런데 detach는 Main 쓰레드와 t 쓰레드의 관계를 끊어서 서로 독립적으로 행동하게합니다. 
얼핏보기에는 join과 같은 역할을 한것처럼 에러메세지 없이 프로그램을 잘 실행 시킨거 같이 보이지만 그 로직은 다릅니다. join은 두 쓰레드의 연결을 유지한채로 
Main의 종속되어 있는 t 쓰레드가 끝나기를 기다린 것이고 detach는 Main 쓰레드와 t쓰레드를 분리 시켜서 Main쓰레드가 t 쓰레드 보다 먼저 종료되도 
상관없도록 만듭니다.
그런데 detach 로 t를 분리하게 되면 Main에서는 더이상 t에 대한 정보나 상태를 추출할 수 없습니다.
그래서 이 detach 는 왠만해서는 활용하지 않을겁니다. 

joinable 함수는 아까처럼 detach 상태라거나 연동된 쓰레드가 없는지를 판별하기 위해 사용됩니다.
어떤 상황에서 사용되냐면 처음에 thread t 를 만들면서 HelloThread 함수를 연동시켜서 t가 생성 되자마자 HelloThread가 실행되도록 만들어 놨는데
사실 이걸 한 줄에 동시에 만들 필요는 없습니다.

    std::theard t;

    t = std::thread(HelloThread);

이렇게 미리 만들어 두고 나중에 함수를 연동해도 됩니다. 이렇게 했을때 위에서 아무것도 없이 t를 선언했을때는 사실 아무런 기능을 하지않습니다. 쓰레드가 
작동하는게 아니고 t = std::thread(HelloThread); 이 부분에서 비로소 작동을 하는것입니다.
 
    std::theard t;
    auto id_1 = t.get_id();

    t = std::thread(HelloThread);
    auto id_2 = t.get_id();

이렇게 실행해보면 id_1 은 0이라고 나오고 id_2 는 제대로된 아이디가 나올겁니다. 이때 joinable의 실제 코드를 가보면 이 get_id 를 한 값이 0인지 아닌지를 
반환하는 함수입니다. 
그래서 joinable 은 join을 할 수 있는지 체크하는 방식으로 사용되는게 일반적입니다. 

if (t.joinable())
    t.join();

이렇게 쓰레드를 사용하는것은 어려운 개념은 아니고 이렇게 사용하면 됩니다. 
더 요약하자면 hardware_concurrency 도 그렇게 자주 사용할 것도 아니고 get_id 도 id를 가지고 판별할때 아니면 별로 사용할 일이 없으니 
결국 쓰레드를 생성하고 함수를 연동하고 끝나기를 기다리는것 을 유의 하면됩니다. 

추가로 쓰레드를 생성할때 곧바로 함수를 연동시키는 방법과 선언만 미리하고 나중에 함수를 연동시키는 방법이 있었는데 
선언과 연동을 따로하는 일이 그렇게 많을까 생각 할 수도 있습니다. 
그치만 생각보다 사용할 일이 있는데 
이런 경우입니다. 

vector<std::thread> v;      이렇게 쓰레드를 벡터로 관리한다고 해보겠습니다. 

v.resize(10);               v를 resize하면 일단 선언만 한 빈 쓰레드 객체가 10개 생성되는겁니다. 생성하자마자 연동했다면 더 복잡했을겁니다. 


다음으로 배워볼것은 쓰레드를 사용할 함수가 인자를 받는다면 어떨까요?


void HelloThread_2(int32 num)
{
	cout << num << endl;
}
이런 함수를 쓰레드 객체에 넘겨주고 싶습니다.

하는 법은 간단합니다. 객체의 생성자에 함수를 넘겨주고 쉼표 다음 인자를 넘겨주시면됩니다. 

	std::thread t(HelloThread_2, 10);

어떻게 이런 방식으로 실행되는지 thread 원본 코드를 따라가 보면 theard 객체를 생성할때 템플릿 문법으로 인자를 받아주고 있습니다. 
템플릿의 첫번째 인자는 함수를 받아주고 두번째로 Argument 인자를 받아줍니다. 

그런데 인자를 받는 문법이 _Arg&&... _Ax 이렇게 되어있습니다. 이 문법은 C++ 11 에서 추가된 문법으로 
_Arg 인자가 이후로 한개 올 수도 있고, 두개 올 수도 있고... 이렇게 다수의 인자를 받을 수 있게 해주는 문법입니다.

여기의 자세한 문법은 이후에 다룰 것이니까 간단하게만 알아보았습니다.


여기까지 알아본 내용을 실습해볼겁니다. 

int main()
{

	vector<std::thread> v;

	for (int i = 0; i < 10; i++)
	{
		v.push_back(std::thread(HelloThread_2, i));
	}

	for (int i = 0; i < 10; i++)
	{
		if (v[i].joinable())
			v[i].join();
	}

	cout << "Hello Main" << endl;
}

쓰레드를 벡터로 관리하고 총 10개의 쓰레드를 for문으로 만들고 다시 for문을 돌면서 각 v[i]가 joinable한지 체크 하고 join까지 해주는
실습입니다. 

이 코드를 실행해보면 우리가 v에 push_back 했던 순서대로 출력되지도 않고 endl 도 제대로 되지 않고 뒤죽 박죽으로 출력되는걸 알 수 있습니다.
결과도 매번 다릅니다. 

왜 이러냐면 쓰레드를 구동했을때 이 쓰레드들은 병렬적으로 실행되기 때문에 무슨 쓰레드가 먼저 실행되는지를 알지도 못하고 순서를 보장하지 못합니다. 

하지만 그럼에도 불구하고 다수의 쓰레드를 생성하고 구동하는 실습을 해보았습니다.

나중에 가면 이 각각의 thead 는 단순한 함수를 처리하는게 아니라 어떤 쓰레드는 클라이언트를 처리하고 어떤 쓰레드는 네트워크처리를하는 등 
복잡한 일들을 병렬적으로 진행 할 수 있게 될겁니다.

그래도 이번 시간에 쓰레드를 구동하면서 heap영역, 데이터 영역의 메모리를 공용으로 관리하는 부분이 없었으므로 반쪽짜리 내용이었습니다.
일단 기초적인 쓰레드 생성 방법을 알아 봤습니다.