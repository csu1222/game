


            DeadLock


이전 시간에는 멀티쓰레드 환경에서 공유 데이터를 동시에 수정할때의 동기화 기법중 Lock 에 대해 알아보았습니다. 
Lock 을 걸고 푸는 함수 lock, unlock 이 있었고 이 사이에서 실행되는 코드는 한번에 한 쓰레드만 진행 할 수 있도록 교통정리를
해주었습니다. 

그리고 lock 과 unlock 은 한 세트로 이루어져있어야 하고 만약 lock 은 했지만 unlock을 하지 않았다면 그때 부터 코드가 멈춰버리는 
교착상태 (DeadLock) 현상이 발생하기때문에 일일히 챙겨주기보다는 
자동으로 챙길 수 있는 lock_guard 클래스나 unique_lock 클래스를 사용한다고 배웠었습니다.

하지만 lock_guard, unique_lock 을 사용함으로 앞으로 모든 상황에서 데드락을 예방할수 있는건아닙니다. 
lock, unlock 짝을 안 맞춰서 데드락이 걸리는 상황은 사실 초보적인 실수이고 
이런 실수 말고도 데드락이 발생하는 경우도 있습니다. 

일반적으로 MMO 서버에서 크래시가 나는 경우에서 가장 높은 확률로는 null point 크래시 라고 nullptr 인 곳을 잘못 참조해서 크래시가 일어나고
그 외에 오늘 주제인 데드락 문제도 top 5 에 들 만큼 자주 등장하는 크래시 입니다. 

오늘 실습을 위한 임시 클래스들을 만들어 줄것입니다. AccountManager, UserManager 입니다. 
AccountManager 클래스의 헤더에는 Account 라는 클래스가하나 더 정의 되는데 이건 말 그대로 계정이 가지고 있을 기능과 데이터를 정하는 클래스이고 
그 계정을 관리하는게 AccountManager 클래스입니다.
우선 static 을 사용해서 싱글톤으로 AccountManager 객체를 만들어 줍니다. 이제 AccountManager 객체는 프로젝트에서 유일합니다. 
가지고 있을 기능으로는 id 를 키로 사용해서 계정을 가져오는 기능 GetAccount 가 있다고 해보겠습니다. 
이때 서버에서는 멀티쓰레드 환경으로 동작할테니 mutex를 추가하고 lock_guard를 GetAccount 함수 시작할때 객체를 생성해줄겁니다. 
계정을 가져오고 하는 상세한 기능은 그냥 넘어가고 이런식이라는 틀만 잡아줍니다. 
그리고 나서는 로그인 하는 프로세스 ProcessLogin 를 멤버함수로 추가 해줄겁니다. 여기서도 lock_guard 객체를 만들어 줍니다. 

UserManager 에서도 AccountManager에서 했던것과 대칭적으로 User 클래스로 유저가 가지고있을 기능과 데이터를 설정하고 
GetUser, ProcessSave 라는 멤버 변수도 만들어 줍니다. 여기서도 각각 lock_guard<mutex> 객체를 만들어 줍니다. 


여기까지 만들어 보고 다시 AccountManager로 가보겠습니다. 
여기서 로그인을 할때 Account 에 관련된 User 들을 로드하고 또 UserManager에 저장하는 기능이 필요하다고 해보겠습니다. 
그러려면 AccountManager 에서 UserManager를 include 하고 ProcessLogin 안에서 
	User* user = UserManager::Instance()->GetUser(100);
이런 식으로 100이라는 id를 가진 유저를 가져온다고 해보게습니다. 

지금 이 상황에서는 ProcessLogin 함수에서 처음에 AccountManager의 mutex 를 사용해서 락을 걸고 UserManager::Instance()->GetUser 
를 호출하면서 UserManager의 mutex도 락을 걸고 있는겁니다. 
한술 더 떠서 UserManager::ProcessSave 에서도 어째선지 Account 객체가 필요해서 GetAccount를 했다고 하면 이제 
User, Account 양쪽에서 서로 2중 락을 걸게됩니다. 

아직은 실제 실행은 하지 않고 있으니까 GameServer.cpp 로 돌아가서 쓰레드 두개를 만들어봅니다. 

void Func1()
{
	for (int32 i = 0; i < 1; i++)
	{
		UserManager::Instance()->ProcessSave();
	}
}

void Func2()
{
	for (int32 i = 0; i < 1; i++)
	{
		AccountManager::Instance()->ProcessLogin();
	}
}


int main()
{
	std::thread t1(Func1);
	std::thread t2(Func2);

	t1.join();
	t2.join();

	cout << "Jobs Done" << endl;
}

이렇게 실험을 할겁니다. 처음에는 반복을 1번만 하는 사양으로 테스트 하는데 몇번 반복하다 보면 그냥 제대로 실행이 될때도 있고 
어쩔때는 데드락이 걸리기도 합니다.

다음으로 반복을 늘려서 100 정도로 해보면 거의 확실하게 데드락이 걸리는걸 볼 수 있습니다. 

왜 이런현상이 일어나는지 중단점을 잡고 디버깅을 해보겠습니다. 
디버깅중 쓰레드들을 보는 방법을 배웠었는데 그걸로 t1, t2 쓰레드를 선택해보고 호출스택을 보면 t1은 Func1을 실행하다가 
ProcessSave 중 GetAccount 에서 걸려있고 t2는 반대로 Func2->ProcessLogin->GetUser 에서 걸려 있습니다. 
이게 전형적인 데드락 상황입니다. 

데드락이 발생하면 쓰레드들이 서로의 락이 풀리기를 둘다 기다리는 교착상태가 됩니다.


좀더 자세히 알아보겠습니다. 

먼저 락 이라는것 부터 다시 알아보면 예시로 화장실문이라고 비유를 들었습니다. 먼저 사용하는 사람이 화장실문을 잠그고 
다 사용하면 문을 열고 나오면 다음 사람이 들어가서 잠그고 일을 보는 것 같은 개념이었습니다.

여기까지가 락을 하나만 사용하는 개념이고 

경우에 따라 자물쇠가 두개인 상황이 됩니다. 현실에서는 화장실에 자물쇠를 두개 가진 화장실은 없겠지만 일단 이런 상황이 있다고 해보겠습니다. 

자물쇠가 두개인 화장실은 자물쇠 두개 동시에 잠가야지만 안에 들어갈 권한을 얻을수 있다고 볼 수 있는데 
만약에 운이 나쁘게 자물쇠 1번을 t1 이라는 사람이 잠그고 자물쇠 2번은 t2 라는 사람이 잠그고 있는 경우가 되었다고 해보겠습니다. 

화장실에 들어갈 수 있는 조건이 자물쇠 두개 모두 잠그는 것이었으니까 t1, t2 둘 모두 남은 자물쇠를 잠그려고 노력할겁니다.

여기서 발생하는 문제는 서로 자기가 들고 있지 않는 자물쇠를 열어주기를 기다리고 있는 상황입니다. 하지만 서로 양보는 하지 않을겁니다. 
사람으로 비유를 했지만 CPU 코어가 양보같은걸 하진 않을것이기 때문입니다. 

그러면 다시 돌이켜서 왜 이 문제가 발생했는지 생각해 보면 자물쇠가 두개가 있어서 문제가 발생하긴 했지만 
자물쇠가 두개라고 항상 문제가 발생하는것은 아니었습니다. 교착상태에 빠진이유는 두 사람이 서로 다른 자물쇠를 풀려고 해서 생기는 문제 였습니다.
서로 엇갈리게 자물쇠를 열려고 시도 하면 다음 자물쇠를 열려는 시도에서 데드락이 걸려버립니다. 

해결하기 위해서는 자물쇠를 푸는 순서에 규칙을 만들게 되면 될것같습니다. 만약 자물쇠 1번을 먼저 풀어야 한다는 규칙을 만들게 되면 처음 1번 자물쇠에 
접근하는 시점에서 경합의 승부가 나기 때문에 그렇습니다. 

그리고 이 해결법이 아까 실습한 AccountManager 와 UserManager 의 상황과 비슷합니다.

이전 까지는 


void AccountManager::ProcessLogin()
{
	// accountLock
	lock_guard<mutex> guard(_mutex);

	// userLock
	User* user = UserManager::Instance()->GetUser(100);

}

void UserManager::ProcessSave()
{
	// userLock
	lock_guard<mutex> guard(_mutex);


	// accountLock
	Account* account = AccountManager::Instance()->GetAccount(100);

}

이렇게 각자 자신의 mutex가 먼저 락이 되도록 하는 순서여서 엇갈리고 있는데 


void UserManager::ProcessSave()
{
	// accountLock
	Account* account = AccountManager::Instance()->GetAccount(100);


	// userLock
	lock_guard<mutex> guard(_mutex);


}
UserManager::ProcessSave 에서 account 락이 먼저 오도록 순서를 조절해주면 교착상태가 안나고 잘 진행되는걸 볼 수 있습니다.

이론상으로는 이렇게 락의 순서를 맞춰주는걸로 해결이 가능한데 
실제 코드에서는 항상 락 순서를 신경쓰는게 거의 불가능합니다. 

데드락이 까다로운 점이 어쩔때는 발생하고 어쩔때는 발생하지 않고 하는 점이 까다롭습니다.

아까 얘기한대로 한번씩만 실행하면 발생하지 않을 때도 있는데 게임 개발을 할때는 데드락이 걸리지 않다가 나중에 
접속자가 많아지면서 꼭 그때 데드락이 걸리는 상황이 있습니다. 

실제 서비스에서 극악의 확률로 일주일에 한번 발생하는 데드락은 개발중에는 잡기가 대단히 어렵습니다. 
그러니 한번 일단 버그가 났을때 호출스택을 살펴보면서 최대한 수정하는것이 좋습니다.


데드락을 완전히 예방하는 방법은 없습니다.
하지만 최소화 하기위한 몇가지 패턴이 있습니다. 

락끼리 순서를 맞춰주기 위해 락에 번호를 부여하는겁니다. 락에도 id를 부여하는겁니다. 
이렇게 부여된 id에따라 무슨 락을 먼저 잡을지 체크할수 있는 방법이 있기는 한데 이 방법도 확실하지는 않습니다.
왜냐면 결국 Lock 의 아이디를 부여하는것도 손수 하는것이기 때문에 방대한 양의 코드에서 손수 부여해야한다는것은 무언가 놓칠가능성이 너무 
많기 때문입니다.

결국 데드락은 미연에 완전히 방지하거나 하는 개념은 아니고 최대한 방지를 한다음 데드락이 발생했다면 빨리 대응을 하는 방법으로 처리해야 합니다. 


- 추가 

	// 참고 
	mutex m1;
	mutex m2;
	std::lock(m1, m2);	// m1.lock(); m2.lock();

	// adopt_lock : 이미 lock된 상태니까, 나중에 소멸될 때 풀어주기만 해
	lock_guard<mutex> g1(m1, std::adopt_lock);
	lock_guard<mutex> g2(m2, std::adopt_lock);

이런 std::lock 이라는 함수가 있습니다. 이 함수가 하는일은 인자로 받은 다수의 mutex를 lock 해주는데 이때 락이 꼬이지 않도록 내부적으로 어떤 순서로 
lock을 해줍니다. 
unlock 까지는 해주지 않는데 그걸 해주기 위해서 lock_guard 를 사용합니다. 

일반적인 lock_guard는 생성하면서 락을 걸고 시작하는데 두번째 인자로 std::adopt_lock 을 주면 이미 lock상태인 mutex를 인자로 줄 수 있고 
소멸될때만 알아서 unlock을 해줍니다.


오늘 강의에서는 데드락이라는 현상에 대해 알아보기는 했는데 뚜렷한 해결방법을 찾지는 못했습니다. 락을 하는 순서에 따라 잘 실행 될 수도 있고 
아니면 데드락일걸릴 수도 있는것과 lock 이라는 어느 상황에서는 사용할 수 있는 std 함수도 있었습니다.

강사님이 데드락을 잡는 방법은 락의 순서를 맞추기 위해 LockManager를 따로 만들고 사이클이 발생하는지를 체크합니다. 
사이클은 자료구조중에 그래프에서 순환구조를 이루는 상태입니다. 
그래프 알고리즘에서 사이클이 일어나는지 안일어 나는지 알 수 있는 알고리즘이 있는데 그걸 활용하기도 합니다. 