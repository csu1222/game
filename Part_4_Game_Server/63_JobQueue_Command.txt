

    JobQueue Command 패턴


디자인 패턴중 커맨드 패턴이 굉장히 유용하게 사용될 경우가 많다고 합니다. 

쉽게 이해하기 위해서 식당의 비유를 들어보겠습니다. 

일반적인 식당에서 주문을 한다면 테이블에 손님이 앉아서 벨을 누르고 직원이 와서 주문을 받을겁니다. 
이때 식당이 크지 않다면 주문을 받은 직원이 주방까지가서 직접 조리를 할것입니다. 그리고 이 것이 사실 지금까지 만들었던 서버 방식이기도합니다. 

서버 프로그래밍으로 보면 테이블에 앉아서 주문을 하는 손님이 Session 이라고 볼 수 있고 주방은 Room이라고 볼 수 있습니다. 
클라이언트 쪽에서 패킷을 보내 요청을 하였다면 요청을 받은 쓰레드가 그대로 요청에 따라 Add, Leave, Broadcast등을 실행 했습니다. 

작은 규모라면 괜찮을 수 있는데 좀 더 큰 규모에서 경합이 심해지는 상황이라면 같은 메뉴를 만들기 위해서 주방의 하나 밖에 없는 화구에 직원들이 몰려드는겁니다. 
사실상 직원수가 많음에도 실제 동시에 일하는 직원은 하나 뿐이고 나머지는 그냥 기다리게 될겁니다. 

그러면 규모가 큰 식당에서는 어떻게 일처리하는지를 떠올려 봅시다. 주방장이 따로 있고 서빙하는 직원이 따로 있을겁니다. 주문을 받는 직원은 직접 요리까지 하는게 아닌 
주문서를 받아 주방장에게 넘겨줄겁니다. 그리고 주문서에는 손님이 요청한 사항들을 다 적을 수 있을겁니다. 주방장은 직접 주문을 들은것은 아니지만 주문서를 보고
손님이 원하는 요리를 할 수 있습니다. 

이런 방식으로 주문을 처리하는것의 장점은 서로 영역이 분리가 되어서 서버는 서빙과 주문을 받고 주방장은 일을한다는 분업화된 작업에 집중 할 수 있습니다. 
그리고 주문을 받는 시점과 요리를 하는 시점이 나뉠수 있다는 것도 중요합니다. 그러다 보니 만약 주문서가 들어가고 요리에 착수되기 전에 손님의 주문 변경을 할 수 있다는 
점도 있습니다. 

이것이 커맨드 패턴의 핵심이라고 합니다. 
커맨드 패턴은 결국 요청을 캡슐화 해서 주문서로 만드는게 핵심입니다. 프로그래밍에서는 이 주문서를 클래스, 함수객체 (Function Object, Functor)같은 형태로 다룰것입니다.

이제 요청사항, 일감을 Job이라고 부를것입니다. 

본격적으로 JobQueue를 만드는 코드를 배워보겠습니다. 

***

지금까지 간단하게 동작하는 채팅프로그램을 만들어 봤습니다. 여러 클라이언트가 Room에 모여 채팅을 하는 방식으로 만들었는데 이 Room에서의 모든 동작들에 
락을 걸어놓은 방식이었습니다.

락을 잡는 방식이 작은 프로젝트에서는 가능하지만 프로젝트가 커질수록 무리가 가는 방식이라고도 했습니다. 

우리 Room에서는 Enter, Leave, Broadcast 라는 간단한 세가지 기능만 동작하도록 만들었는데 이것을 커맨드 방식으로 구현해보겠습니다. 

가장 기초적인 Job 기법인 IJob 의 구조를 보겠습니다. 

class IJob
{
public:
	virtual void Execute() { }
};

class HealJob : public IJob
{
public:
	virtual void Execute() override
	{
		// _target을 찾아서
		// _target->AddHP(_healValue);
		cout << _target << "한테 힐" << _healValue << "만큼 힐 줌" << endl;
	}
	
public:
	uint64 _target = 0;
	uint32 _healValue = 0;
};

상위 클래스로 job을 실행하는 Execute 함수 같은걸 만들어 두고 세부적인 기능을 자식 클래스로 만드는것입니다. 


	// Test Job
	{
		// [일감 의뢰 내용] : 1번 유저에게 10만큼 힐을 줘라
		// 행동 : Heal
		// 인자 : 1번 유저, 10이라는 힐량
		HealJob healJob;
		healJob._target = 1;
		healJob._healValue = 10;

		// 나중에 
		healJob.Execute();
	}

이런 코드로 실행하게 되는데 healJob 객체는 스택메모리가 아닌 힙메모리에 동적할당하는것이 나을것입니다. 일단 객체를 원하는 인자와 행동으로 만들어 뒀다가 나중에 
실행할수 있는게 핵심입니다. 

이런 기초적인 방식이 직관적인것은 맞습니다. 하지만 필요한 기능마다 클래스를 늘려줘야 한다는 것이 귀찮고 또 위험합니다. 
그래도 이런 방식을 사용하는 프로젝트가 꽤 많다고 합니다.

JobQueue 첫 시간이다 보니 템플릿을 활용해 더 발전하는것은 이후 강의에서 할것이고 이번시간은 이 원시적인 내용을 도입해 우리 프로젝트를 수정해볼것입니다.

이제 위의 Job들을 모아 관리해줄 JobQueue를 만들어 보겠습니다. 

#include "Job.h"

using JobRef = shared_ptr<IJob>;

class JobQueue
{
public:
	void Push(JobRef job)
	{
		WRITE_LOCK;
		_jobs.push(job);
	}

	JobRef Pop(JobRef job)
	{
		if (_jobs.empty())
			return nullptr;

		JobRef ret = _jobs.front();
		_jobs.pop();
		return ret;
	}

private:
	USE_LOCK;
	queue<JobRef> _jobs;
};

우리 프로젝트에 도입하는것은 Room 클래스에 도압하면 됩니다. 
지금 Room도 전역으로 하나만 사용하고 있고 기능도 Enter, Leave, Broadcast 세가지 밖에 없었습니다.


// Room Jobs
class EnterJob : public IJob
{
public:
	EnterJob(Room& room, PlayerRef player) : _room(room), _player(player)
	{
	}

	virtual void Execute() override
	{
		_room.Enter(_player);
	}

public:
	Room& _room;
	PlayerRef _player;
};

Room의 기능중 Enter요청을 처리할 job을 만들었습니다. 구조가 간단한데 이상태로는 굳이 job을 사용해야 하나 싶습니다. 어짜피 _room.Enter를 하면 락이 걸리는건 똑같은데 싶습니다. 
그래서 Room에 Job을 도입하면서 부터는 락을 잡지 않고 마치 싱글 스레드 환경처럼 코딩을 합니다. 

// IJob을 도입하면서 락을 잡지 않고 싱글 스레드환경인것 처럼 코딩합니다.
class Room
{
	friend class EnterJob;
	friend class LeaveJob;
	friend class BroadcastJob;
private:
	void Enter(PlayerRef player);
	void Leave(PlayerRef player);
	void Broadcast(SendBufferRef sendBuffer);

public:
	// 멀티 스레드 환경에서는 일감으로 접근 
	void PushJob(JobRef job) { _jobs.Push(job); }
	void FlushJob();

private:
	map<uint64, PlayerRef> _players;

	JobQueue _jobs;
};

멤버 변수로 JobQueue가 추가 되었습니다. 그리고 각 기능을 Job으로 만들어 잡큐에 푸시 해줄것입니다. 실행은 FlushJob 로 해줄것인데 
지금 처럼 푸시와 실행을 따로 만들어 관리하는 방법도 있고 아니면 푸시를 할때 한번 체크해서 다른 누군가 실행을 하고 있지 않으면 자신이 실행을 하도록 하는 방법도 있습니다. 

이제 잡을 사용하면서 락을 잡지 않을것이기 때문에 Enter, Leave, Broadcast 함수는 직접 접근하면 안되고 잡을 통해 실행되어야 합니다. private로 막고 각 기능의 잡 클래스를 
프렌드 클래스로 지정해 열어 줍니다. 

class LeaveJob : public IJob
{
public:
	LeaveJob(Room& room, PlayerRef player) : _room(room), _player(player)
	{
	}

	virtual void Execute() override
	{
		_room.Leave(_player);
	}

public:
	Room& _room;
	PlayerRef _player;
};

class BroadcastJob : public IJob
{
public:
	BroadcastJob(Room& room, SendBufferRef sendBuffer) : _room(room), _sendBuffer(sendBuffer)
	{
	}

	virtual void Execute() override
	{
		_room.Broadcast(_sendBuffer);
	}

public:
	Room& _room;
	SendBufferRef _sendBuffer;
};

나머지 LeaveJob, BroadcastJob 입니다. 

FlushJob의 구현부를 아직 안만들었습니다. 만들어보자면 
void Room::FlushJob()
{
	while (true)
	{
		JobRef job = _jobs.Pop();
		if (job == nullptr)
			break;
		job->Execute();
	}
}


이제 테스트를 진행하면 되는데 이전과 다르게 Enter, Leave, Broadcast를 private로 닫아 놨기 때문에 프로젝트 이곳 저곳에서 에러가 뜰겁니다. 

클라이언트의 플레이어가 룸에 들어가는 부분이었던 Enter코드입니다. 

GRoom.Enter(player);	// WRITE_LOCK

락을 잡아가면서 동작하는 Enter 였는데 이제 이것을 

	GRoom.PushJob(MakeShared<EnterJob>(GRoom, player));

이렇게 하면 바로 Enter가 실행되는것이 아니고 잡큐에 담아 두기만 하는것입니다. 
이후 원래 코드에서는 입장 성공했다는 S_ENTER_GAME 패킷을 클라쪽으로 넘겨주었습니다. 그런데 지금 보면 실제 Enter를 한게 아니라 예약만 걸었는데 
답장을 주는것은 이상할 수 있습니다. 그럴때는 나중에 EnterJob을 Execute할때 S_ENTER_GAME패킷을 전송한다는 식으로 수정해도 될것입니다. 
지금은 그냥 IJob방식을 구현하는데 집중해보겠습니다.

Enter 다음으로 처리할 버그는 Broadcast부분입니다. 이것 역시 BroadcastJob을 사용하는 방식으로 바꿔 줘야 합니다. 

GRoom.Broadcast(sendBuffer)  에서 GRoom.PushJob(MakeShared<BroadcastJob>(GRoom, sendBuffer)); 이렇게 수정합니다. 

이렇게 하면 잡 큐에 일감들을 밀어 넣는 것 까지는 완료되었는데 밀어넣은 일감을 실행하는 부분이 필요합니다. 
즉, 요리사가 필요한데 따로 일감처리할 스레드를 만들기 보다도 일단은 메인 스레드에서 일감을 처리해주겠습니다. 

GameServer.cpp

#include "Room.h"

	while (true)
	{
		GRoom.FlushJob();
		this_thread::sleep_for(1ms);
	}

이런 코드를 추가한겁니다. 

흐름이 어떻게 되는지를 보면 누군가는 PushJob 으로 일감을 넣고 있고, 누군가는 FlushJob으로 일을 처리하고 있는겁니다. 

이제 테스트를 하기 위해서 다시 클라이언트, 서버를 동시에 실행해보면 이전과 같이 채팅으로 Hello World! 가 막 출력이 될것입니다. 
결과만 보면 어디가 달라졌는지를 티가 안날 수 있지만 일단 최대한 경합을 줄여서 동작하게끔 수정했다는걸 알아야 합니다. 

이 컨샙을 잘 숙지하고 다음 시간으로 넘어가야 합니다. 
지금 만든 이 방식이라고 전혀 락을 걸지 않는것은 아닙니다. 짧게 거는겁니다. JobQueue의 Push, Pop 함수에서 락을 걸고 있는걸 알 수 있습니다. 
멀티스레드 환경에서 꼭 걸어야만 하는 부분에 락을 걸어 사용하고 있습니다. 

지금 방식에서는 FlushJob을 만약 여러 스레드에서 동작하고 있다면 역시 문제가 될것입니다. JobQueue::Pop을 하면서 경합이 생기기 때문에 꼭 하나의 스레드만 
FlushJob을 호출하고 있도록 해줘야 겠습니다. 

기초적인 Job 을 적용 해봤는데 
앞으로 컨텐츠 작업을 해야하는데 추가되는 기능마다 전부 Job 클래스를 만들어 줘야 하고 또 friend class도 적어줘야 한다면 정말 귀찮고 또 위험한 작업이 될것입니다.

좀 더 쉽게 만들 수 있는 방법을 이후 시간에 배워볼것입니다. 