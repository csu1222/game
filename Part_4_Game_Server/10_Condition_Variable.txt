

            Condition Variable 조건 변수 


이번 주제인 조건 변수 Condition Variable 은 이전 시간에 알아본 Event의 변주입니다. 
지난시간 Windows API를 이용해서 Event를 만들고 이 Event의 Signal을 참조하는것으로 불필요한 대기하는것을 방지하는 
실습을 해봤습니다. 

/*  Event 복습&추가
그런데 이전 시간의 실습을 한 코드도 아쉬운 점이 있습니다. 
지난번의 가정처럼 한 10초의 한번씩 데이터를 밀어넣는 코드라면 이전 시간처럼 Event를 사용하는게 이상하지 않은데 
그게 아니라 Producer 에서 sleep 없이 그냥 무한 루프를 돌면서 데이터를 밀어 넣는다고 가정해보겠습니다.
그리고 Consumer 함수에서는 지금껏 밀어 넣어진 데이터를 꺼내 출력하고 있었는데 
데이터 값 대신 그때 마다의 queue에 담겨있는 데이터의 갯수를 출력해보겠습니다. 

어떻게 될지 예상을 해보면 막연히 Producer에서 데이터를 한번 밀어넣고 Signal을 켜줄테니까 
Consumer 에서도 한번 데이터를 꺼낼 테니까 q.size() 는 0 으로 유지될것 같습니다. 

실제로 실행해보면 q.size는 계속 증가합니다. 
그러니까 어떻게 보면 Event 자체는 SetEvent 함수로 Signal을 켜주는걸로 Consumer 에 신호를 주고 있지만 락으로 묵여 있지 않기 때문에
묘한 순서의 틀어짐이 발생할 수 있을겁니다. 

Producer에서 Signal을 킨 순간 Consumer 에서 WaitForSignalObject 가 통과 된 후 락을 잠그고 q의 데이터를 꺼내는 과정이 진행될 텐데 
이중에서 WaitForSignalObject와 락을 잠그는 사이에 약간의 시간이 걸리고 락이 걸리기 전에 Producer에서는 다시 루프를 돌면서 
q에 데이터를 밀어 넣게 됩니다.
그러면 사실 데이터를 꺼내지도 않았는데 데이터는 그 사이에 여러번 데이터가 밀어넣어 질 수 있다는 겁니다.

이렇게 단순한 상황 말고 한번에 여러 쓰레드가 Consumer의 역할을 한다거나 하는 더 복잡한 상황이 있다고 하면
당연히 더욱 빈번히 발생할겁니다. 

그러다 보니 지금 처럼 Producer, Consumer 딱 끊어서 만들게 되면 실질적으로 데이터가 계속 누적이 되는 상황이 발생할 수 있다는 말입니다. 
이 데이터 누적을 당장 해결하기 위해 Consumer안의 데이터를 처리하는 부분을 if 문이 아니라 while 문으로 만들어서 한번 락이 걸리면 
누적된 데이터를 전부 처리하도록 만든다 하는 방법도 있겠지만 

정말 중요한것은 Event 와 Lock은 별개로 생각해야한다는게 되겠습니다.

쉽게 생각해서 Producer 함수의 SetEvent 를 Lock 의 범위 안에 넣어주면 되지 않을까 싶은데 당연하게도 이 방법으로 해결 할 수 없습니다. 
Producer의 Lock 범위에 들어간 SetEvent는 락이 걸려있는 유저 레벨의 쓰레드에 명령을 하는것이 아니라 커널 영역의 Event의 Signal을 
켜주는 것이고 Consumer 의 WaitForSignalObject 에서도 마찬가지로 커널영역의 신호를 참조하는것입니다. 
거기에 더해서 이 WaitForSignalObject 와 데이터를 뽑아 쓰는 코드 중간에 걸리는 시간 동안 Producer 역할을 하는 쓰레드가 자체적으로 
여러번 루프를 도는것은 그대로 입니다. 

대부분의 경우에도 Event를 사용한다고 해도 멀티쓰레드 환경에서 사용할것이다 보니 락도 병행해서 사용할 겁니다.
*/


여기까지 이전 시간의 배운 Event의 아쉬운 점에 대해 알아 봤고 

지금 부터 오늘의 주제인 조건 변수 Condition Variable 에 대해 알아보겠습니다. 
이 조건변수도 표준에 들어간 내용이다 보니 

    condition_variable cv; 

이렇게 바로 꺼내 사용할 수 있습니다. 아마 mutex 헤더에 포함되어 있을겁니다. 그러다 보니 이 condition_variable 을 사용할때 독립적으로 
사용하는게 아니라 표준 mutex와 짝지어서 사용해야하고 

그게 아니라 좀 더 일반적인 상황까지 사용하고 싶다면 

    #include <condition_variable>
    condition_variable_any cv;

이렇게 따로 라이브러리도 추가하고 뒤에 _any 가 붙은 타입을 사용해야합니다. 
일단 오늘은 mutex와 함께 사용하는 기본 버전을 알아볼겁니다. 


condition_variable 을 사용하는 법은 Event와 굉장히 비슷한데 Event와 의 가장 큰차이가 있습니다. 
바로 condition_variable은 User-Level Object 유저 레벨 오브젝트 라는것입니다. 

유저레벨 오브젝트와 커널레벨 오브젝트의 차이점은 커널은 다른 프로그램까지 적용될 수 있는 오브젝트라면 유저레벨 오브젝트는 자신이 속한 
프로그램 내에서만 유효하다는 점입니다. 
물론 이론적으로 그렇다는것이고 평범한 게임 프로그램은 다른 프로그램과 연계할 필요는 없을겁니다. 

그리고 condition_variable 은 그렇게 어려운 개념은 아니고 Event와 거의 비슷하게 동작하는데 Lock과 짝을 지어서 동작할것이라는 게 다른점입니다. 

어떻게 진행되는지를 보면 
    1) Lock을 잡고
    2) 공유 변수 값을 수정
    3) Lock을 풀고 
    4) 조건변수 통해 다른 쓰레드에게 통지
이렇게 진행됩니다. 이전 Producer 코드를 다시 보면 

void Producer()
{
	while (true)
	{
		{
			unique_lock<mutex> lock(m);
			q.push(100);
		}

		cv.notify_one(); // wait 중인 쓰레드가 있으면 딱 1개를 깨운다

		// this_thread::sleep_for(1000ms);
	}
}

unique_lock을 만들면서 락을 잡고, q.push 로 공유 변수의 값을 수정하고 중괄호로 찝은 영역을 빠져나오면서 unique_lock이 소멸과 동시에 락이 풀립니다. 
그리고 나서 조건변수로 다른 쓰레드에게 통지하면되는겁니다.  
조건변수를 사용할때 notify_one 과 notify_all 이 있는데 여기서는 one 을 사용합니다. wait 중인 쓰레드 1개만 깨우는 메소드입니다. 

그러면 wait하는 쪽 Consumer 에도 조건변수를 적용해주겠습니다.

void Consumer()
{
	while (true)
	{

		unique_lock<mutex> lock(m);
		cv.wait(lock, []() { return q.empty() == false; });
		// 1) Lock을 잡고 
		// 2) 조건 확인
		// - 만족 O -> 빠져 나와서 이어서 코드를 진행 
		// - 만족 X -> Lock을 풀어주고 대기 상태로 전환 

		{
			int32 data = q.front();
			q.pop();
			cout << q.size() << endl;
		}
	}
}

이렇게 조건변수의 대기를 겁니다. wait의 인자로 뭘 받는지를 먼저 알아볼건데 첫번째로 unique_lock을 받아서 참조합니다. 그리고 두번째로 
람다 함수를 받는데 내용이 wait를 빠져나올 조건입니다. 

왜 unique_lock을 받냐면 lock_guard와 unique_lock의 차이점이 unique_lock에서는 생성과 동시에 락을 잡기도 하고 아니면 이후에 명시적으로 
락을 잡을수도 있었습니다. Consumer가 첫번째 루프일때는 unique_lock을 생성하면서 동시에 락을 잡겠지만 만약의 2) 의 조건확인을 하고 만족하지 않았을때 
Lock 을 풀어주고 대기 상태로 전환한다고 했습니다. 다시 대기가 풀릴때는 위의 Producer의 cv.notify_one으로 쓰레드를 깨워줬을때 인데 
이때 다시 1) 부터 Lock을 잡는 부분이 명시적으로 다시 락을 잡는 부분입니다. 그래서 unique_lock을 사용합니다. 

두번째 인자인 람다식은 오랜만에 봐서 낯선데 [](){} 이 세가지 괄호는 각각 캡쳐블록, 매개변수, 표현식을 말합니다. 
캡쳐 블록은 람다식이 작성된 지역변수를 가져다 사용할때 어떤 식으로 가져올것인지를 고릅니다. [=]은 지역변수를 값 복사 방식으로 가져오고 기본적으로 const 값으로 가져옵니다. 
[&]은 지역변수를 참조방식으로 가져오고 람다식 내에서 수정을 할경우 원본 데이터도 수정됩니다. 
매개변수부분은 일반적인 함수의 매개변수와 비슷하게 사용됩니다. 람다식으로 만든 함수의 인자를 넘겨줄때 사용되는것 같습니다. 
그리고 표현식에서는 이 람다식에서 받은 인자, 외부 변수들을 어떻게 가공할것인지를 말합니다. 
위에서는 [](){ return q.empty() == false; } 이렇게 표현되고 있는데 [] 는 지역변수를 참조하지 않을것이라는 말입니다. q는 전역변수이기 때문에 접근됩니다. 
() 도 매개변수가 필요하지 않아서입니다. 표현식인 return q.empty() == false; 은 cv.wait에서 요구하는 표현식입니다. 
이 값이 true라면 q가 비어있지 않다라는 말이고 다음 으로 q의 데이터를 처리하는 코드로 진행되고 
false 라면 q가 비어있기 때문에 여기서 첫번째 인자로 받은 lock을 풀고 쓰레드를 대기 시킵니다. 

추가로 이전에는 while( q.empty() == false ) 같이 q가 비었는지 를 체크 했었는데 그 부분이 wait 안으로 들어가면서 체크할 필요가 없어집니다.
q에 데이터가 있다면 코드가 진행되면서 다음 루프를 돌것이고 q에 데이터가 없다면 거기서 대기를 하면서 다음 데이터가 들어올때 까지 기다릴 태니까 
그 후의 while 이 필요 없어집니다. 

다시 이제 Producer 와 Consumer 에서 어떻게 진행되는지를 따라가보면 
먼저 Producer와 Consumer 역할을 하는 쓰레드가 각각 t1, t2 라고 하면 거의 동시에 실행되고 만약 t2가 먼저 실행된다면 cv.wait에 걸려서 일단 대기에 들어갑니다. 
t1이 실행되면 while을 돌면서 락을 걸고 q에 데이터를 밀어 넣습니다. 그리고 락을 풀고 나와 cv.notify_one() 으로 wait가 걸린 쓰레드가 있다면 대기를 풉니다. 
이때 늦게 실행된 t2 이건 먼저 실행된 t2이건 락이 걸리면서 조건을 확인하는데 Producer에서 q에 데이터를 밀어 넣었으니 다음 코드로 진행됩니다. 
그러면 q가 빌때 까지 데이터를 처리하고 나서 q가 비었다 하면 다시 wait에 걸려서 대기로 들어가게 됩니다. 


여기서 이런 의문이 들 수 있습니다. 애당초 Producer에서 cv.notify_one 으로 대기중인 쓰레드를 깨우면 그때는 q에 데이터가 들어갔다는 말이니까 
굳이 Consumer에서 cv.wait 에 조건을 걸지 않아도 되는게 아닌가? 
의문을 정리해보면 notify_one을 했으면 항상 조건식을 만족하는게 아닐까? 입니다. 
이상황을 Spurious Wakeup (직영하면 가짜 기상?) 이라고 하는데 

q.push 와 cv.notify_one 도 분리되어 있고 Consumer에서 락을 잡는 사이에도 또 다른 쓰레드가 끼어들어서 q의 데이터를 꺼내 사용할 수도 있습니다. 
이러면 notify_one으로 대기 쓰레드를 깨우기는 했는데 중간에 데이터가 없어진상황에서 코드가 진행 될 수도 있는겁니다.그래서 
다시 확인해서 진짜로 q에 데이터가 있는지 확인하는겁니다. 즉, notify_one을 할 때 lock을 잡고 있는 것이 아니기 때문에 다시 한번 조건을 체크해야합니다. 

또 다른 생길 수 있는 질문이 notify_one을 하는 순서를 꼭 따라야 하는가 
그러니까 
		{
			unique_lock<mutex> lock(m);
			q.push(100);
		    cv.notify_one();
		}
이렇게 실행 되면 안되는 것인가 라는 질문이 생길 수도 있습니다. 이 방식도 권장되지는 않지만 동작은 합니다. 
이럴때의 문제가 무엇이냐면 
락을 잡고 있는 중에 notify_one을 실행하면 wait 에서도 깨어나서 동작하기 시작하면서 먼저 하는 동작이 Lock을 잡는다 입니다. 
Lock을 획득하려고 할 텐데 notify_one 을 한 쓰레드에서 락을 풀어주지않으면 wait 측에서 lock을 획득할 때 까지 대기를 타면서 시도를 합니다.

그러니까 t1이 락을 놔줘야 t2가 락을 획득할수 있는겁니다.