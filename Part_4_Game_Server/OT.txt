

            Part 4 게임 서버 오리엔테이션 


선수 지식 : 기초적인 C++지식 (SQL + Python)

강의 대상 : 
    - 서버 프로그래머 취업 준비생
    - 서버 지식이 궁금한 현업 클라이언트 프로그래머


게임서버란 무엇인가? 온라인상에서 여러 플레이어가 플레이 할 수 있게 중계해주는 프로그램을 서버라고 합니다. 
그래서 전투, 아이템, 퀘스트, 업적, 인공지능등 MMORPG 상에 존재하는 모든 컨텐츠 들을 운영하고 게임 정보를 
클라이언트에게 전달하는 관제사의 역할을 서버가 담당하게 됩니다. 

게임 서버 공부부터 난이도가 많이 올라간다고 합니다. 이전까지는 게임서버를 공부하기 위한 자료가 딱 정해진게 없고 
이곳저곳에서 가져다가 공부를 해야했지만 이 강의를 통해 대략적인 게임 서버 프로그래머가 되기 위한 교양을 쌓을 수 있다고 합니다. 


-- 서버 개론 --

# 많이 받는 질문
- 서버 공부를 어디서 부터 시작할지?
- 회사에서 리눅스 서버를 공부하라고 하는데 책추천?

- 서버는 뭔가 느낌상 심오하고 어렵고 비밀스러운 기술?


    서버란 무엇일까?
- 다른 컴퓨터에서 연결이 가능하도록 대기 상태에서 상시 실행중인 프로그램 (일반적으로 이 프로그램이 실행되고 있는 컴퓨터 자체를 가리키기도함)

자주 하는 비유로 
클라이언트는 영화를 찍는것과 비슷하다
서버는 영업중인 식당과 비슷하다

영업중인 식당(서버)의 특징
- 손님이 올 수 있도록 식당을 열고 대기중인 상태.
- 손님이 오면 식장 메뉴/정책에 따라 서비스 제공.

    서버의 종류
1. Web Server (aka. HTTP Server)
- <테이크아웃 포장 전문 식당>
-- 손님이 음식을 받아서 떠나면, 그 이후론 연락이 끊긴다.
-- 질의/응답 형태

2. Game Server(aka. TCP Server, Binary Server, Stateful Server ...)
- <일반 식당>
-- 서빙 직원이 와서 손님에게 물어볼 수도 있고.
-- 손님이 추가 주문을 하기도 하고.
-- 실시간 Interaction이 있다!

왜 웹 서버와 게임 서버가 다른가? 

  WEB SERVER <테이크아웃 전문>
- 드물게 정보를 요청/갱신한다.
- 실시간 Interaction이 필요하지 않다.
- 식장에서 손님한테 먼저 접근할 일은 없다 .(물 따라드릴까요? <- NO)
- 주문 후 손님이 바로 떠나면, 손님의 상태를 당분간 잊고 지낸다. (Stateless)

  WEB SERVER 제작은?
Web Server는 단순히 게임에 국한되지 않고, 웹 서비스를 만드는 데 사용.
ex) 구글, 아마존, 네이버 등등.

처음부터 만드는 경우는 사실상 없고, 프레임워크를 하나 골라서 사용
ex) ASP.NET (C#)
    Spring (Java)
    NodeJS (Javascript)
    Django, Falsk (Python)
    PHP
    ...


  GAME SERVER <일반 식당>
- 요청/갱신 횟수가 많다.
- 실시간 Interaction이 필요하다.
- 언제라도 직원이 손님한테 접근 가능해야 한다.
- 손님이 식당에 머무는 동안, 손님의 상태를 보며 최상의 서비스를 제공한다 (Stateful)

  GAME SERVER 제작은?
게임/장르에 따라 요구사항이 너무나도 다르다.
  최적의 프레임워크라 것이 존재하기 애매함.

ex) 회전 초밥/삼겹살/호텔 뷔페/국밥
  메뉴가 다른데 식당 인테리어와 채용 직원 수가 동일할 수 없다.

그럼 무엇을 고려해야 할까?

고려할 대상                                          /  게임서버의 유사성
---------------------------------------------------------------------------------------------
손님 한도 (몇 명까지 받을 수 있는지)                   / 최대 동시 접속자
한 방에 들어갈 수 있는 손님의 일행 한도 (인테리어)      / 게임 장르 및 채널링
직원 역할 구분 (겸직 가능)                            / 게임 로직(요리사),네트워크(서빙),DB(결제)
직원은 몇 명 둘지?                                    / 쓰레드 개수
요리사/서빙/결제 직원 비율을 어떻게?                   / 쓰레드 모델
주문은 어떻게 받을까? (손님이 불러서? 벨?)             / 네트워크 모델
손님이 기다릴 수 있는 시간 한도(패스트 푸드? 고급?)     / 반응성(FPS,MMORPG...)
장부 및 결제는 어떻게                                 / 데이터 베이스

배울 주제 
멀티 쓰레드(Concurrency) : 직우너들 고용하고 운영하는 것.
네트워크 : 직원들이 손님과 어떤 방식으로 대화를 할지.
DB : 결제 및 장부 처리를 어떤 방식으로 할지.
게임 로직 : 손님들의 주문을 신속하고 맛있게 요리하는 것.
서버 구조 : 위에서 정한 정책에 맞는 식당의 인테리어에 대해 고민하는 것.


-- 환경 설정 -- 

본격적인 서버 강의에 들어가기 앞서 환경 설정부터 하고 시작하겠습니다. 
Visual Studio 새 프로젝트 만들기 -> 콘솔 앱 -> 솔루션 이름, 경로, 프로젝트 이름 정하기 
까지 했다면 일단 콘솔 앱 프로젝트가 하나 만들어 졌을겁니다. 

솔루션 이름은 Server 라고 했고 처음 만든 프로젝트 이름은 GameServer 라고 만들었습니다. 
여기에 총 3개의 프로젝트가 있도록 만들어 줄것입니다. Server 프로젝트는 서버를 구동할 프로젝트이고 
Client 프로젝트라고 서버를 구동하기 위한 더미 클라이언트를 하나 만들어 줄것입니다. 
마지막으로 ServerCore 라고 서버의 기능들을 모두 담아 놓을 라이브러리 프로젝트까지 만들어 주겠습니다.

GameServer 솔루션 우클릭 -> 추가 -> 새 프로젝트 -> 콘솔 앱 생성 -> 이름: DummyClient 로 생성

GameServer 솔루션 우클릭 -> 추가 -> 새 프로젝트 -> 정적 라이브러리 생성 -> 이름: ServerCore 로 생성

여기서 ServerCore 를 만들때 동적 라이브러리(DLL)와 정적 라이브러리(lib) 중 골라서 만들 수 있는데 
두 방식의 차이점은 
정적 라이브러리의 경우 프로젝트를 빌드할때 실행파일에 라이브러리 내용들이 한번에 저장되는 방식이고 
동적 라이브러리는 프로젝트 빌드를 해도 외부의 dll 파일이 같이 있어야 프로그램 실행할때 읽어서 사용하는 방식입니다.

두 방식의 장단점이 있는데 정적 라이브러리는 파일관리가 쉽고, 프로그램의 수정 사항이 있을 때 빌드를 새로 해야 하고
동적 라이브러리는 파일을 이동할때 dll 파일도 같이 관리해야하는 불편함이 있는 대신 dll 만 수정할 수 있는 점이 있습니다. 

일단 우리 프로젝트에서는 한번 만들고 나서 수정해 가면서 사용할것이 아니라 실습용, 교육용이기 때문에 
간편하게 정적 라이브러리 방식으로 만들었습니다. 


다음은 만든 프로젝트들의 실행 파일들을 관리할 폴더를 하나 만들어 주겠습니다. 

Server 솔루션 우클릭 -> 파일 탐색기에서 폴더 열기 -> Binary 라는 이름의 폴더 생성

이 Binary 폴더에 실행 파일들을 모아줄것입니다. 지금은 GameServer가 하나지만 나중에는 더 많아 질 수 있는데 
실행 파일들을 각각 관리하면 어지럽기 때문에 한곳에 모아주는 겁니다.

그리고 폴더를 하나 더 만들겁니다. 

Server 솔루션 우클릭 -> 파일 탐색기에서 폴더 열기 -> Libraries 라는 이름의 폴더 생성

이름 그대로 라이브러리들을 모아두는 폴더 입니다. 아까 만든 ServerCore 프로젝트도 라이브러리죠 
Libraries 를 만드는 이유는 우리가 이번 강의에서 만든 라이브러리를 따로 관리하고 외부에 공개해서 따로 판매를 한다던가 
하지는 않겠지만 나중에 가면 다양한 용도로 외부에서 만든 라이브러리를 가져와서 사용하거나 하고 싶을 수 있기 때문에 
그런 외부 라이브러리들을 모아 두기 위해 만들었습니다. 

Libraries\Debug
Libraries\Release
라는 Libraries아래에 디버그용도, 릴리즈용도로 사용할 두 폴더를 만들어 주겠습니다.
왜 이걸 만드냐면 간혹가다가 디버그 모드로 우리가 서버 코어를 빌드 한다음 라이브러리가 디버그 모드로 만들어 졌는데 
다른 버전은 릴리즈 버전으로 만들면 버전이 꼬이는 경우가 있다고 합니다.

하여튼 이렇게 폴더들을 만들어 주면 되겠습니다.

이제 이 폴더들을 경로설정해주겠습니다.

ServerCore 우클릭 -> 속성 -> 상단의 구성을 모든구성으로 플랫폼을 모든 플랫폼으로 설정 -> 출력 디렉토리 편집 ->
$(SolutionDir)Libraries\$(Configuration)\ 입력

원래 출력 디렉토리는 $(SolutionDir)$(Configuration)\ 가 어느 경로를 뜻하냐면 
SolutionDir는 현재 Server 솔루션의 경로를 자동으로 추적해주는 것입니다. 거기에 Configuration 은 현재 디버그 상태인지 
릴리즈 상태인지를 물어 보는겁니다. 
그 사이에 Libraries 경로를 끼워 넣어서 아까 만든 폴더 안으로 경로를 설정해주었습니다.

잘 설정 되었는지 확인을 해보겠습니다. ServerCore 프로젝트를 한번 빌드 해주고 설정 해줬던 경로로 가보면 lib 파일이 생성되어있는걸 
확인 할 수 있습니다. 
나중에 이 경로에 모인 lib 파일들을 GameServer에서 읽고 ServerCore의 기능들을 가져다 사용할 수 있게 되는겁니다.

다음으로 ServerCore에서 손봐줄 것은 기본적으로 만들어져있는 필터들을 정리해주겠습니다. 
기본 필터로 리소스, 헤더, 소스 라는 필터들이 있는데 이런 식으로 관리하지 않을것이고 

새로 Network, Utils 라는 두가지 필터를 추가해준 다음 원래 있던 모든 파일들을 Utils아래로 이동 시켰습니다. 
그 후 원래 있던 필터들을 지워주고 

헤더 파일중에 framework.h 라는 헤더를 열어보면 

#define WIN32_LEAN_AND_MEAN             // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.

이 코드 한줄 밖에 없습니다. 그냥 이 코드를 pch.h에서 #include "framework.h" 되어있는곳에 치환 해주고 
framework.h를 삭제 해주었습니다.

ServerCore.cpp 파일도 별 역할을 하지 않을것이라서 지워 주었습니다. 

그리고 새로 CorePch라는 클래스를 추가 해주었습니다. 
Part 2 에서 배웠듯이 Pch 는 PreCompiledHeader 로 미리 컴파일된 헤더인데 이 헤더를 공용 헤더처럼 사용해서 
잡다한 헤더 include나 정의들을 모아두는겁니다. 

그런데 잘쓰고 있는 Pch.h 는 어쩌고 CorePch를 또 만들어 주냐면 
ServerCore 프로젝트 안에 있는 Pch.h 는 다른 외부 프로젝트에서 접근할 수 없습니다. 해당 프로젝트 내에서만 접근가능한 헤더이고 
외부에서 가져다 사용하려면 새로 만들어 줘야 하는겁니다.

다시 추가를 해줄겁니다. 이번에는 클래스 추가가 아니라 새 항목에서 헤더 파일만 만드는데 이름을 Types.h 라고 하겠습니다. 
이 파일에는 이후에 우리가 프로젝트에서 매크로처럼 이름을 바꿔 사용할 것들을 담아줄겁니다. 
#pragma once

using BYTE = unsigned char;
using int8 = __int8;
using int16 = __int16;
using int32 = __int32;
using int64 = __int64;
using uint8 = unsigned __int8;
using uint16 = unsigned __int16;
using uint32 = unsigned __int32;
using uint64 = unsigned __int64;

이렇게 자주 사용될 데이터형을 편하게 사용하도록 따로 빼준겁니다.

CorePch 에 앞으로 사용할 헤더들을 추가 해주었습니다. 
#pragma once

#include "Types.h"
#include <vector>
#include <list>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>

#include <iostream>
using namespace std;

void HelloWorld();

마지막의 HelloWorld 함수는 다른 프로젝트에서 ServerCore를 잘 읽고 있는지 확인하는 용도입니다.

#include "pch.h"
#include "CorePch.h"

void HelloWorld()
{
	cout << "Hello Server!" << endl;
}


그리고 CorePch를 원래 있던 Pch에서 include 해주겠습니다. 
#pragma once

#define WIN32_LEAN_AND_MEAN             // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.

#include "CorePch.h"

이제 다시 빌드를 해줄건데 서버 같은경우에는 환경을 64 비트에서 실행해줄겁니다. 그래야 메모리를 더 넓게 사용할 수 있습니다.
빌드가 성공했다면 다음으로 넘어가겠습니다. 



    GameServer 프로젝트로 갑니다. 
ServerCore 에서 했던 것 처럼 필터 정리부터 했습니다. 
Main, Utils 필터 추가 
리소스 파일, 소스 파일, 헤더 파일 필터 제거 

원래 있던 GameServer.cpp 는 Main 필터로 이동 

그리고 GameServer는 처음에는 pch 가 없습니다. 그래서 새로 만들어 주는데 Utils 필터 아래로 클래스 추가를 했습니다. 
이 GameServer 프로젝트의 pch 도 마찬가지로 자주 사용할 헤더나 라이브러리를 pch 헤더 한곳이 몰아 넣어서 관리하는 용도로 사용할겁니다.

그런데 그냥 pch라는 이름으로 클래스를 만들었다고 pch의 용도대로 동작하는것은 아닙니다. 설정을 해줘야 하는데 

GameServer 프로젝트 우클릭 -> 속성 -> C/C++ 항목의 미리 컴파일된 헤더 -> 미리 컴파일된 헤더 사용 , 미리 컴파일된 헤더 파일 이름을 pch.h 로 변경

또 한가지 해줄것

pch.cpp 우클릭 -> 속성 -> C/C++ 항목 미리 컴파일된 헤더 -> 미리 컴파일된 헤더 란을 만들기로 변경

이렇게 설정해줘야 합니다. 여기까지 pch 를 활용할 준비를 한것이고 
다음은 GameServer.cpp 파일에서 pch 를 include 하게끔 추가 해줍니다.

이제 하고 싶은것은 ServerCore 프로젝트에서 외부에 넘겨주기 위해 만든 CorePch 를 연결해주는 작업입니다. 
방법이 두가지 있습니다. 

GameServer 속성 -> C/C++ 일반 -> 추가 포함 디렉터리 경로 설정 후 -> 링커 일반-> 추가 라이브러리 디렉터리 설정 
하는 방법이 있고 아니면 

GameServer 속성 -> VC++ 디렉터리 -> 포함 디렉터리, 라이브러리 디렉터리 
에서 설정하는 방법이 있습니다. 

이중에 밑에것이 좀 더 간편하기 때문에 밑에 버전으로 설정해주었습니다.

포함 디렉터리 편집을 들어가서 새 경로를 추가해주는데 
$(SolutionDir)ServerCore\ 
이렇게 포함 디렉터리를 추가해주고 

라이브러리 디렉터리는 
$(SolutionDir)Libraries\
를 추가해줍니다. 

그리고 나서 
GameServer 속성 -> 링커 / 입력  -> 추가종속성
에서 ServerCore.lib를 가져오도록 등록할 수 있는데 이 방식은 라이브러리를 추가할때마다 다시 해줘야 하니까 

GameServer/pch.h 에 직접 타이핑하는 방법이 있습니다 .

#pragma once

#define WIN32_LEAN_AND_MEAN             // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.

#ifdef _DEBUG
#pragma comment(lib, "Debug\\ServerCore.lib")
#else
#pragma comment(lib, "Release\\ServerCore.lib")
#endif 

#include "CorePch.h"

GameServer/pch.h 의 내용은 이렇게 됩니다. 

이렇게 GameServer 프로젝트와 ServerCore 프로젝트를 연결해 봤는데 
이걸 테스트하기위해서 Corepch 에 HelloWorld 라는 함수를 만들었었습니다. 내용은 Hello Server 라는 텍스트를 콘솔에 출력하는 함수인데
두 프로젝트가 잘 연결되었는지 확인하기 위해 GameServer.cpp 의 Main 함수에서 호출해보면 잘 실행되는걸 알 수 있습니다.  

거기에 더해서 디버깅도 두 프로젝트를 넘어 다니면서 할 수도 있습니다. 

여기까지 GameServer, ServerCore 프로젝트의 환경설정이 되었고 나머지 하나 DummyClient 를 설정 해주겠습니다. 
내용은 아까의 반복입니다. 


ServerCore 에서 했던 것 처럼 필터 정리부터 했습니다. 
Main, Utils 필터 추가 
리소스 파일, 소스 파일, 헤더 파일 필터 제거 
Main 필터로 DummyClient.cpp 이동, Utils 필터 아래에 pch 클래스 추가

DummyClient 프로젝트 우클릭 -> 속성 -> C/C++ 항목의 미리 컴파일된 헤더 -> 미리 컴파일된 헤더 사용 , 미리 컴파일된 헤더 파일 이름을 pch.h 로 변경

pch.cpp 우클릭 -> 속성 -> C/C++ 항목 미리 컴파일된 헤더 -> 미리 컴파일된 헤더 란을 만들기로 변경

DummyClient 속성 -> VC++ 디렉터리 -> 포함 디렉터리, 라이브러리 디렉터리 
$(SolutionDir)ServerCore\ 
이렇게 포함 디렉터리를 추가해주고 
라이브러리 디렉터리는 
$(SolutionDir)Libraries\

// DummyClient\pch.h 
#pragma once

#define WIN32_LEAN_AND_MEAN             // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.

#ifdef _DEBUG
#pragma comment(lib, "Debug\\ServerCore.lib")
#else
#pragma comment(lib, "Release\\ServerCore.lib")
#endif 

#include "CorePch.h"

DummyClient 에서도 HelloWorld 를 실행 해보니 잘 동작합니다. 



- 추가 
처음에 솔루션 폴더에서 빌드한 결과물들을 Binary 폴더에 모아두고 싶었는데 이 부분을 까먹었습니다. 
지금은 x64 폴더에 실행파일들이 모아집니다.

DummyClient, GameServer 두 프로젝트 모두 공통입니다. 

우클릭 속성 -> 일반 출력 디렉토리 -> 편집

이렇게 들어가서 $(SolutionDir)$(Configuration)\ 으로 되어 있는데 
$(SolutionDir)Binary\$(Configuration)\ 이렇게 둘 다 수정해줍니다

다시 두 프로젝트를 빌드 해보면 의도한 대로 Binary 폴더 안에 실행 파일들이 생성됩니다.

이렇게 생성된 파일중 exe 파일을 서버 머신에 가져가서 띄우면 될겁니다.