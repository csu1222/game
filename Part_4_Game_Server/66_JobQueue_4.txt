


        JobQueue 4


Job과 JobQueue를 만드는 세가지 방법에 대해 알아봤습니다. 
Job으로 사용할 클래스를 직접 하나 하나 만드는 방법도 알아 봤고, 템플릿과 함수포인터, tuple 을 사용해서 Functor로 사용하는방법,
두번째 방법과 비슷하지만 람다 식으로 표현해 사용하는 방법등을 알아봤습니다.

이 중 어떤 방식을 사용하던지 상관 없고 각자의 선택입니다. 
다만 조심해야할 것은 람다 캡쳐를 하건, functor를 만들건 아니면 클래스로 들고 있건 shared_ptr 로 들고 있는 순간 생명 주기를 관리하기는 쉽지만
사이클이 일어 나지 않도록 잘 관리해 줘야 할것입니다. 

이전 시간에 만들었던 JobSerializer 코드를 얘로 든다면 

class JobSerializer : public enable_shared_from_this<JobSerializer>
{
public:
	void PushJob(CallbackType&& callback)
	{
		auto job = ObjectPool<Job>::MakeShared(std::move(callback));
		_jobQueue.Push(job);
	}

	template<typename T, typename Ret, typename... Args>
	void PushJob(Ret(T::*memFunc)(Args...), Args... args)
	{
		shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
		auto job = ObjectPool<Job>::MakeShared(owner, memFunc, std::forward<Args>(args)...);
		_jobQueue.Push(job);
	}

	virtual void FlushJob() abstract;

protected:
	JobQueue _jobQueue;
};

이중에 함수포인터를 인자로 받는 버전의 PushJob에서 Job을 만들때 owner를 넘겨줍니다. 이 owner가 자신을 shared_ptr로 들고 있는건데 
자신을 shared_ptr로 들고 있으면 끝까지 참조 카운트가 줄지 않아 메모리 릭이 일어나게 된다는겁니다. 
그래서 위의 코드에 추가로 Job을 더이상 안쓴다고 할때 Job을 날려주는 ClearJob 같은 함수를 만들어 주면 좋습니다. 


아무튼 이번시간의 주제는 이것보다 좀 더 까다로운 내용입니다. 
현재 구현한 Job의 작동방식을 보면 Job을 넣는 함수 따로 실행하는 함수 따로 만들어 두었습니다.
ClientPacketHandler 에서 입장과 채팅할 Job을 실컷 넣고 메인스레드에서는 Flush해주고 있습니다. 

Room이 한 두개 면 지금처럼 해도 상관 없겠지만 나중에 가면 Room을 많이 사용하게 되면 말이 다르다고 했습니다. 
그 중에서서도 심리스 MMO 게임에서는 각 acter 단위 (각 플레이어, 몬스터, npc 등)로 Room을 배치하는 경우가 있다고 했습니다. 

이런 경우 즉 FlushJob을 할 대상이 몇천 몇만이 될 수도 있다는 것입니다. 
그러면 어느 스레드에서 이 많은 일감을 처리해야 해야 하냐는것입니다.
일일히 일감을 순회하면서 처리하는것도 귀찮을 뿐더러 만약 일감이 없다고 해도 무한루프를 돌면서 체크하고 있는것도 미련한 짓이기는 할겁니다.
물론 멀티스레드 시간에 알아본 조건변수 (Condition variable)을 사용해 조건에 맞을 경우에만 스레드를 살리는 방법도 있을겁니다. 
그것도 한두개 여야 말이 되지 개체가 50만 정도 되면 조건변수를 일일히 배치하는건 말이 안될것입니다. 

쓸만한 방법중 하나가 PushJob에서 Job을 밀어넣고 실행하는것 까지를 한번에 하도록 해주는 방법입니다. 
이 방법은 이전 Session 코드중 Send코드에서도 사용했었습니다. 

void Session::Send(SendBufferRef sendBuffer)
{
	// 연결이 되어있는지 체크
	if (IsConnected() == false)
		return;

	// 스택 메모리에 이 Send명령을 예약해야하는지를 만들었습니다.
	bool registerSend = false;

	// 락을 거는 범위를 조절합니다. 
	{
		WRITE_LOCK;

		_sendQueue.push(sendBuffer);

		if (_sendRegistered.exchange(true) == false)
			registerSend = true;
	}

	// 락의 범위 밖에서 RegisterSend를 호출하면서 스레드 끼리 정체되는걸 줄였습니다.
	if (registerSend)
		RegisterSend();
}

Session::Send 에서는 그냥 sendQueue에 넣고 빠져 나올건지 아니면 실행까지 해줄건지를 체크해주고 있었습니다. 처음으로 도착한 스레드가 실행까지 해주게 되고 
그 실행 도중에 도착한 스레드들은 sendQueue에 넣기만하는 식으로 동작합니다. 

이렇게 하면 편리한게 처리해주는 스레드 하나를 정해 무한루프를 돌게 하는게 아닌 돌아가면서 그때 그때 처음 도착한 스레드가 일을 처리까지 해주는 것입니다. 
이것을 Job에도 적용시키는게 이번시간의 주제 입니다.


*** 

먼저 이전에 만들었던 JobQueue 클래스 파일들에서 이제는 JobQueue라는 이름보다는 LockQueue 라는 이름으로 바꿔 줄것인데 
왜냐하면 앞으로 다른곳에서도 이 락을 잡고 있는 큐를 사용할 수도 있을겁니다. Job 전용이라기 보다는 좀 더 범용성있는 이름으로 수정하는것입니다. 
그러다 보니 JobRef를 직접 들고 있는것 보다 템플릿으로 큐로 관리할 데이터를 직접 지정하는 편이 범용성이 있을것같습니다. 	

template<typename T>
class LockQueue
{
public:
	void Push(T item)
	{
		WRITE_LOCK;
		_items.push(item);
	}

	T Pop()
	{
		if (_items.empty())
			return T();

		T ret = _items.front();
		_items.pop();
		return ret;
	}

	void PopAll(OUT Vector<T>& items)
	{
		WRITE_LOCK;
		while (T item = Pop())
			items.push_back(item);
	}

	void Clear()
	{
		WRITE_LOCK;
		_items = Queue<T>();
	}

private:
	USE_LOCK;
	Queue<T> _items;
};

추가로 우리가 만들었던 STLAllocator 를 활용하도록 Queue고 바꿔주었고 아까 말했던 큐안에있는 아이템들을 다 날려주는 Clear, 아이템들을 다 꺼내 반환하는 PopAll 을 추가로 만들어 줬습니다.
이제 Job 필터쪽에서 관리할 일이 아니니깐 Utils 필터쪽에서 관리하도록 옮겨줍니다.

이제 부품 하나를 맘대로 수정했으니 온갖 버그가 발생할겁니다. 하나씩 잡아주겠습니다. 
생각보다 많지는 않은데 pch.h에서 파일이름이 JobQueue에서 LockQueue로 바뀐걸 수정해주고 JobSerializer 에서 JobQueue를 사용하던걸 마찬가지로 LockQueue로 수정
그리고 LockQueue<JobRef> _jobQueue 라는 멤버 변수로 수정합니다. 

JobSerializer라는 클래스의 이름을 JobQueue로 바꿔주겠습니다. 원래 JobSerializer에서 하던일이 JobQueue 들고 있으면서 Job을 Push 해주거나 FlushJob해주는 역할이었으니깐 
JobQueue라고 불러도 무방합니다. 

class JobQueue : public enable_shared_from_this<JobQueue>
{
public:
	void PushJob(CallbackType&& callback)
	{
		auto job = ObjectPool<Job>::MakeShared(std::move(callback));
		_jobs.Push(job);
	}

	template<typename T, typename Ret, typename... Args>
	void PushJob(Ret(T::*memFunc)(Args...), Args... args)
	{
		shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
		auto job = ObjectPool<Job>::MakeShared(owner, memFunc, std::forward<Args>(args)...);
		_jobs.Push(job);
	}

	virtual void FlushJob() abstract;

	void ClearJobs() { _jobs.Clear(); }

protected:
	LockQueue<JobRef> _jobs;
};

그리고 오늘 필요한것은 FlushJob 부분인데 따로 함수를 만들어 abstract로 만들어서 상속받은 쪽에서 만들어 사용하라고 했지만 
이제는 그렇게 하는게 아니라 PushJob을 할때 경우에 따라 내가 처음으로 Job을 밀어 넣은 스레드라고 하면 실행까지 하게끔 수정을 해볼겁니다.	

위 클래스에 추가로 private 영역을 만들고 Job을 Push하는 함수를 따로 또 만들고, 처리하는 함수 Execute를 또 만들었습니다. 
그리고 PushJob에서 Job을 만들고 _jobs.Push를 하는걸 private에 있는 Push에 넘겨주는 형태로 바꿨습니다. 
또 PushJob이라는 이름이 단순히 Job을 밀어 넣는거같으니 좀 다른 이름으로 DoAsync 라는 이름으로 바꿨습니다. 
protected 영역에는 내가 지금 Push를 하는 첫번째 스레드인지를 체크하기 위한 아토믹변수 _jobCount를 만들었습니다. 
class JobQueue : public enable_shared_from_this<JobQueue>
{
public:
	void DoAsync(CallbackType&& callback)
	{
		Push(ObjectPool<Job>::MakeShared(std::move(callback)));
	}

	template<typename T, typename Ret, typename... Args>
	void DoAsync(Ret(T::*memFunc)(Args...), Args... args)
	{
		shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
		Push(ObjectPool<Job>::MakeShared(owner, memFunc, std::forward<Args>(args)...));
	}

	void				ClearJobs() { _jobs.Clear(); }

private:
	void				Push(JobRef&& job);
	void				Execute();

protected:
	LockQueue<JobRef>	_jobs;
	Atomic<int32>		_jobCount = 0;
};


그리고 Push와 Execute의 구현부를 보겠습니다. 

void JobQueue::Push(JobRef&& job)
{
	const int32 prevCount = _jobCount.fetch_add(1);
	_jobs.Push(job); // WRITE_LOCK

	// 첫번째 Job을 넣은 스레드가 실행까지 담당
	if (prevCount == 0)
	{
		Execute();
	}
}
Push에서는 현재 _jobCount 를 prevCount에 받고 있습니다. Atomic의 함수에서 fetch_add는 현재값을 리턴한 다음 ()안의 값을 더해주는 함수였습니다.
현재 카운트를 얻은 다음은 _jobs.Push를 하고 있습니다. LockQueue::Push를 하는것인데 이 함수 내부에서 WRITE_LOCK을 잡아주면서 동작하였습니다. 
이후 prevCount를 체크해 내가 처음으로 Push를 한 스레드라면 실행 Execute까지 해줍니다. 

void JobQueue::Execute()
{
	while (true)
	{
		Vector<JobRef>	jobs;
		_jobs.PopAll(jobs);

		const int32 jobCount = static_cast<int32>(jobs.size());
		for (int32 i = 0; i < jobCount; i++)
			jobs[i]->Execute();

		// 남은 일감이 0개 라면 종료
		if (_jobCount.fetch_sub(jobCount) == jobCount)
		{
			return;
		}
	}
}
실행하는 Execute 함수입니다. _jobs의 원소들을 모두 받아줄 빈 벡터 jobs를 만들고 LockQueue::PopAll로 전부 꺼내줍니다. 
이 PopAll 에서도 WRITE_LOCK을 잡고 동작합니다. job들을 다 꺼낸 jobs의 size 를 jobCount라고 받아놓습니다. 그리고 for 문을 돌면서 각 Job들을 실행해줍니다. 
이 동작들이 모두 while(true) 안에서 반복하고 있을텐데 계속 한 스레드가 루프를 돌기보다는 일감을 다 처리했으면 빠져나와 다른 일을 하는게 좋을것입니다. 
그 방법으로 JobQueue 에서 따로 아토믹으로 관리하던 _jobCount에 fetch_sub(jobCount) 를 해주는데 이때 반환값, 즉 jobCount를 빼기전 _jobCount 가 jobCount와 값이 같다면 
모든 일감을 처리했다는 뜻일 겁니다. 그러면 함수를 빠져나오기 위해 return을 합니다. 


그런데 이 코드의 순서를 마음대로 바꾸면 또 문제가 생깁니다. 
카운트를 세고나서 카운트 증가 후 잡을 밀어넣기 순서, 또 잡을 실행한 다음 실행한 만큼 카운트를 줄여주는 순서를 지켜야 합니다.

왜 이런 순서를 지켜야 하냐면 만약 자신이 처음으로 잡을 밀어 넣은 스레드라서 Execute를 하는 중이라고 하면 그 코드가 실행중인 동안에 다른 스레드가 또 일감을 
밀어 넣을 수 있습니다. 멀티스레드 환경이기 때문입니다. 
예를들어서 지금까지 쌓인 일감이 10개라고 해보겠습니다. _jobCount가 10이라는것입니다. 그러면 그 일감을 처리하는 스레드에서 처리한 만큼 _jobCount에 fetch_sub를 해주게 될건데 
그 중간에 다른 스레드에서 일감을 하나 밀어 넣어서 _jobCount = 11 이 되었다고 해보겠습니다. 하지만 아직 _jobs.Push() 는 실행 되지 않아서 
Execute중인 스레드의 jobCount는 10인 상태라면 Execute 후반 코드인 _jobCount와 jobCount의 크기 비교하는 곳에서 11 == 10 으로 일치하지 않아 
return으로 빠져나오지 못하고 다시 루프를 실행하게 됩니다. 

그러니까 Push에서 카운트를 하는 코드와 LockQueue::Push를 하는 코드를 하나로 묶어서 락을 잡는 식으로 하던가 아니면 따로 따로 동작할거라면 지금 처럼 
카운트, push 순으로 동작해야합니다. 

	_jobs.Push(job); // WRITE_LOCK
	const int32 prevCount = _jobCount.fetch_add(1);

이런 순서로 만들었다면 운이 나쁘게 Execute하던 스레드가 있고 다른 스레드에서 Push를 하고 카운트를 하는 도중에 Execute 스레드에서 카운트 체크를 하게 되면 
_jobCount - jobCount 가 -1 이 되어버립니다. 


*** 

이제는 코드를 수정했으니 다시 에러를 잡아야 합니다. 

에러가 나는 부분은 제일 먼저 Room클래스 파일들에서 JobSerializer.h를 include 하고 있던걸 JobQueue 로 이름을 바꿔줍니다. 
그리고 FlushJob을 override 해 사용하고 있던게 이제는 필요 없어 졌기 때문에 날려줍니다. 

다음 에러는 GameServer 코드입니다. 메인 스레드에서 FlushJob을 해주고 있었습니다. 역시 이 부분도 날려줍니다. 앞으로는 따로 스레드 하나가 담당해 Execute하는게 아닌 
Push를 하는순간 적절한 스레드가 일감을 처리해줄겁니다. 

다음 에러는 ClientPacketHandler 쪽입니다. Handle_C_ENTER_GAME, Handle_C_CHAT 에서 GRoom->PushJob() 이렇게 호출해주던 함수이름이 DoAsync로 바뀌었습니다. 

이제 다시 빌드해 실행해보면 Hello World를 정상적으로 주고 받는 콘솔을 볼 수 있습니다. 

***

이번시간에 도입한 방법의 장점은 따로 일감을 처리해주는 스레드를 두는게 아닌 일감을 밀어 넣는 스레드중 적당한 스레드가 그때 그때 일감을 처리해준다는것입니다. 

그래도 아직은 수정할 부분이 있습니다. 간단하게 포트폴리오를 만들때는 지금도 충분하지만 
진짜 MMORPG에서 사용할것이라 유저 몇천명, 몬스터 몇십만이 있다고 가정해보겠습니다. 

그런 상태에서 JobQueue 방식으로 처음으로 도착한 스레드가 처리한다고 하고 

1)만약 일감이 너무 많이 몰리면 어떻게 될까요?
그러니까 일감을 어느 스레드가 처리하고 있는 와중에 계속해서 일감을 밀어 넣고 있는겁니다. 
일감을 처리하는 스레드 입장에서는 빨리 일감을 털어야 리턴을 하고 빠져나갈것인데 계속 들어오다보면 사실상 일감 처리 전용 스레드가 되는겁니다. 

일반적으로 MMORPG에서는 렉이 걸리긴 걸릴건데 그렇다면 공평라게 나뉘어서 렉이 걸려야지 어느쪽은 렉이 없는데 한쪽만 렉이 엄청걸리는건 안좋습니다. 
그래서 한쪽에서만 몰빵된다는게 문제입니다. 

2)DoAsync 타고 타고 가서 - 절대 끝나지 않는 상황(일감이 한 스레드에 몰빵)
이것도 사실 1번과 비슷한 말이 될 수 있는데 우리 코드에서는 예를들어 Room::Enter에서 계속 해서 DoAsync()가 호출되서 막 비동기 코드를 밀어 넣었다고 가정을 해보겠습니다 
타고 타고 들어가보면 JobQueue에서 Execute를 하고 있는데 이 Execute를 타고 가다보니 다른 객체의 Execute를 또 실행해 여러 객체의 Execute를 담당하게 될 수도 있다는것입니다. 
정말 운이 나쁘게 첫번째 스레드가 여유로울때 Execute를 시작했는데 나비효과로 다른 객체의 일감을 건드리고 건드리면서 결국 모든 객체를 담당하게 될수 있습니다. 
반면 다른 스레드는 그냥 누군가 Execute하고 있구나 하면서 바로 빠져나오게 될 수 도 있습니다. 