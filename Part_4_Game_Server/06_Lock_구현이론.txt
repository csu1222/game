


        Lock 구현 이론


Lock에 대해 간단한 실습과 이해를 해보았습니다. 

표준에서 제공하는 mutex 만 사용하는것이 아닌 직접 Lock을 기초적으로 구현해보기 위한 이론시간입니다. 
Lock은 서버 프로그래밍 그리고 멀티쓰레드를 다룰때 항상 달고 살아야 하는 개념이고 또 면접에서도 많이 묻는 질문이라고 합니다. 

Lock을 구현기위해 우리가 하고 싶은것은 자물쇠를 만들어서 안에 누가 들어가 있으면 다른 사람들은 대기를 해야 한다는 기능? 상황? 입니다.
그리고 이게 상호배타적으로 한번에 한명만 들어가 있어야 할겁니다.

그런데 여기서 여러가지 생각할 점이 있는데 밖에 있는 사람 기준으로 안에 누가 있다고 가정할때 어떤 정책을 취할것인가가 두번째 문제입니다. 
기다리는걸 참을 수 있는 사람도 있고 아니면 기다리는걸 못참는 사람도 있을겁니다. 

지금까지 배운 것 처럼 락이 열리지 않으면 무작정 기다리는 경우도 있을것이고 아니면 락을 어느정도 기다리다가 안열리면 잠시후에 다시 와보는 
경우도 있을겁니다. 
어느 정책을 따르냐에따라 성능이 달라지기도 합니다.

먼저 그냥 무작정 기다리는 정책을 생각해보면 다음순서를 기다리면서 혹시 빨리 자리가 날 수 있다면 바로바로 들어갈 수 있어서 
효율적입니다. 단점은 지루함이죠 그러니까 기다리는동안 아무것도 못한다는 겁니다. 
무작정기다리는 방식이 일반적으로 락을 구현할때 스핀 락에 해당합니다.

일단 자리로 돌아가서 나중에 다시 오는 방법은 문이 잠겨있는걸 확인하면 일단 제자리로 돌아가서 할일 하다가 적당히 시간이 지났다 싶으면 
다시 열렸나 확인해보는 방법입니다. 다시 왔을때 문이 열렸을지 아니면 아직 안열렸거나 이미 다른 사람이 또 들어갔을지 확실성이 없습니다.
밖에서 기다리는 사람(쓰레드) 입장에서는 가만히 기다리는 시간이 없고 자신은 할일을 하면서 효율적인것 처럼 보이지만 사실 화장실을 가는 
일에 대해서는 앞에서 기다리는것보다 효율이 안좋습니다. (sleep 방식)

마지막으로 또 다른 방법이 있습니다. 약간 갑질을 하는 방법인데 자물쇠가 잠겨있으니 무작적 기다리기도 뭐하고 그냥 돌아 갔다 오기도 뭐하니까
근처 직원을 시켜서 화장실이 열리면 알려달라고 부탁하는 방법입니다. 
기다리던 사람 입장에서는 앞에서 기다리지 않아서 다른일을 할 수도 있고 화장실이 비면 바로 알려주러 올테니 확실성까지 갖추게된 
최적의 방법이지만 
다른 사람 (직원)의 리소스를 가져다 사용해야 한다는 것입니다. (event 방식)


또 다른 고려해봐야 할 점이 있습니다. 뭐냐면 sleep 방식이나 event 방식에서는 제자리로 돌아가는 이동 비용이 발생하고 스핀 락에서는 그냥 
앞에서 기다리니까 이동 비용은 따로 들지 않습니다.

이 부분을 프로그래밍에서는 '컨택스트 스위칭' 이라고 합니다.

/*
컨텍스트 스위칭

쓰레드 이론 시작할때 예시로 들었던 식당 예시를 다시 떠올려 보면 
한식, 일식, 페밀리 레스토랑 이라는 각각의 식당이 있으면 각자의 가게에 여러 설비들이 있고 직원들(쓰레드)이 근무를 하고 있을겁니다. 
그리고 직원들은 영혼(CPU코어)을 받아야 움직이는 상황이었습니다. 

그런데 이때 사실상 직원이 식당에만 있는게 아니라 식당들을 관리하는 식당 관리자에도 직원이 한명있을겁니다. 

이 부분이 자주 간과하는 부분인데 여러 프로그램에 각 쓰레드가 실행되는 것에 더해서 운영체제 자체의 백그라운드 프로그램들도 있기 때문에 
결국 CPU코어가 할당되어야 합니다.

언젠가 운영체제에 대해 배울때 알겠지만 프로그램이 실행될때 커널모드와 유저모드가 있습니다. 유저 모드는 현제 모니터에 표시되는 메모장,
인터넷 브라우저, 비쥬얼 스튜디오 같은 프로그램이고 커널 모드는 직접 확인할수는 없지만 운영체제가 돌아가기 위해서 관리를 하고 있는 프로그램들 
입니다. 

다시 식당의 비유로 돌아와서 한식의 직원에 영혼을 연결했다가 일식의 직원에 영혼을 옮기려면 바로 한식 -> 일식 으로 옮길 수 있는게 아니라 
기본적으로 식당 관리자에 있는 직원에게 영혼을 옮겼다가 일식 직원으로 옮겨야 합니다. 

한식 -> 식당관리자 -> 일식 

그러니까 유저 레벨에서 커널 레벨로 돌아가는 부분이 컨텍스트 스위칭이라고 합니다. 
*/ 

즉, 화장실에 갔다가 잠겨있길레 자리로 돌아오는 과정이 컨텍스트 스위칭입니다.

그런데 유저레벨에서 커널레벨로 왔다 갔다하는게 생각보다 부하를 많이 받습니다. 왜냐면 곧이 곧대로 영혼만 왔다갔다 하는게 아니라 실질적으로 
쓰레드를 실행하기 위한 부가적인 정보가 많이 있습니다. 
무슨 얘기냐면 직원(쓰레드)이 어디에 있었고 무엇을 하고 있었는지 등을 레지스터에 저장하게 되는데 이때 다른 직원에 영혼을 할당해주려고 하면 
레지스터의 데이터들을 전부 RAM에 복사하고 새 직원의 정보들을 RAM에서 가져와 복원 시켜줘야 합니다. 
이래야 직원들을 돌아가면서 영혼이 들어가는데 다음 작업을 연속적으로 계속해서 이어 갈 수 있습니다. 

이런 과정들이 있어야 하기 때문에 유저레벨과 커널레벨을 넘어다니는게 부하가 걸리는 겁니다. 그렇다고 해서 컨텍스트 스위칭은 절대로 하면 안되는
건아니고 어쩔 수 없이 해야합니다. 이미 우리가 사용하고 있는 모든 프로그램들이 이렇게 동작하고 있습니다. 

우리가 자주 사용하던 cout 콘솔 출력도 하드웨어와 관련된 동작이기때문에 유저레벨에서 멋대로 하드웨어를 조작하는건 불가능합니다.
cout 코드를 실행하면 유저 레벨에서 그 명령을 커널레벨로 가지고 가서 시스템 관리자가 대신 실행해줍니다. 즉 우리는 유저레벨에서 커널레벨에게 요청을
보내는 것이지 직접 실행하는것은 아닙니다.

정리하자면 코어가 쓰레드를 순회하면서 유저레벨과 커널레벨을 왕복하는데 이게 컨텍스트 스위칭이고 이건 꽤 무거운 작업이다.
하지만 절대로 사용하면 안되는것은 아니고 할 수 있으면 피하는게 좋은 정도이다.



그러면 다시 처음으로 돌아가서 락을 구현하기 위해 하고자 하는것 먼저 도착한 쓰레드가 코드를 실행하는동안 락으로 잠그고 이후에 도착한 쓰레드는 
락이 열릴 때 까지 기다려야 합니다. 

락이 열릴 때 까지 기다리는 방법에는 세가지가 있었는데 
첫째, 그냥 무작정 기다리는 방법이 있는데 이 방법을 지금 보면 컨텍스트 스위칭 비용이 없는 방법인겁니다. 
  이 방법은 먼저 도착한 쓰레드의 동작이 금방끝날것이라는 보장이 있다면 효율적으로 동작 하는 방법입니다. spin lock 이라고 합니다. 
만약 실행되는 동작이 너무 오래걸린다면 스핀 락의 장점이 쓸모없게 되어 버립니다. 그럴 경우 두번째, 세번째의 방법을 사용하는게 나은데 
두번째, 일단 자리로, 나중에 다시 오는 방법입니다. 
세번째, 일단 자리로 가는데 다른 쓰레드에게 락이 열리는지 확인하도록 하고 연락이 오면 다시 오는 방법입니다. 

그런데 꼭 위의 세가지 방법중 한가지만을 선택해서 사용해야하는것은 아니고 상황에 따라 섞어서 사용해도 됩니다.
잠깐 기다리다가 너무 오래걸리면 잠시 커널레벨로 돌아갔다가 다시 돌아온다던가 하는 방식으로 작업 할겁니다. 

어떻게 구현해야할지는 이어서 공부를 해볼겁니다. 