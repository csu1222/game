


            SpinLock


이전 시간에 배웠던 락의 종류 중에 락이 걸려있으면 계속 기다리는 스핀락에 대해 배워보겠습니다. 

스피락은 게임 프로그래머 면접에서 자주 등장하는 주제입니다.
왜 자주 등장하는지 이유를 생각해보면 게임 프로그래머가 알고 있어야 하는 중요 개념중 하나인 멀티쓰레드관련 내용을 
스핀락만 물어보면 이 사람이 정말 멀티쓰레드를 잘 이해하고 있는지를 알 수 있어서 자주 물어 보는것 같습니다. 

시작하기 전에 오늘의 목표는 이것입니다.

int32 sum = 0;
mutex m;

void Add()
{
	for (int i = 0; i < 100000; i++)
	{
		lock_guard<mutex> gaurd(m);
		sum++;
	}
}

void Sub()
{
	for (int i = 0; i < 100000; i++)
	{
		lock_guard<mutex> gaurd(m);
		sum--;
	}
}

int main()
{
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;
}

mutex 와 lock_guard를 사용해서 t1, t2 쓰레드를 진행 시켜서 결과적으로 sum 이 0이 되는데 

여기서 mutex를 우리가 직접 구현해보고 결과도 똑같이 sum이 0이 되는가가 오늘의 목표입니다. 

첫번째로 아무런 배경지식 없이 구현해본 SpinLock입니다. 

class SpinLock
{
public:
	void lock()
	{
		while(_locked)
		{

		}

		_locked = true;
	}

	void unlock()
	{
		_locked = false;
	}

private:
	bool _locked = false;
};

변수로 bool 타입 변수를 들고 있는데 자물쇠를 생각하면서 열렸는지 안열렸는지를 체크하기 위한 데이터로 만들었습니다. 
lock 함수와 unlock 함수는 lock_guard의 메소드들과 호환이 되어야 하기 때문에 소문자로 만들었고 
안에서는 _locked가 true라면 계속 뺑뺑이를 돌면서 기다리다가 자기 차례가 되면 _locked가 true 가 된다고 생각하면서 만들었고 
unlock은 바로 _locked를 false로 밀어주고 있습니다. 

엉성한것 같지만 한번 적용해보겠습니다.
int32 sum = 0;
SpinLock spinLock;

void Add()
{
	for (int i = 0; i < 100000; i++)
	{
		lock_guard<SpinLock> gaurd(spinLock);
		sum++;
	}
}

void Sub()
{
	for (int i = 0; i < 100000; i++)
	{
		lock_guard<SpinLock> gaurd(spinLock);
		sum--;
	}
}

이렇게 mutex 대신 직접 만든 SpinLock 객체를 사용해보았습니다.

빌드를 해보면 일단 빌드까지는 통과되는데 실행했을때 결과가 0이 아닌 엉뚱한 결과가 나오고 매번 값이 달라집니다. 
즉 이방법은 어딘가 부족하다는겁니다. 

먼저 _locked 변수의 타입을 volatile bool 타입으로 사용해야합니다. 
처음보는 키워드인 volatile 는 C# 이나 JAVA 에서도 사용되는 키워드이지만 C++ 에서는 좀 다른 의미로 사용된다고 합니다.
volatile은 컴파일러에게 최적화를 하지 말아달라고 부탁하는 것에 불과합니다. 
C#에서는 위의 의미에 더해서 메모리 배리어나 가시성에 대한 내용도 있다고 합니다.

/*
volatile 키워드를 좀 더 알아보면 
컴파일러에게 최적화를 하지 말아 달라는 요청이 무슨 의미냐면

int32 a = 0;
a = 1;
a = 2;
a = 3;
a = 4; 
cout << a << endl;

이렇게 a라는 int32 변수를 0으로 초기화한다음 순서대로 1,2,3,4 라는 값을 넣어보고 마지막으로 a를 콘솔 출력을 해보겠습니다. 
지금 적은 코드를 곧이 곧대로 어셈블리로 번역해서 실행하면 1,2,3,4 값을 넣는 무의미한 내용까지 모두 번역될겁니다. 
하지만 비주얼 스튜디오에서 Debug 모드가 아니라 Release 모드로 바꾸면 이 모드는 온갖 최적화가 다 들어가게 됩니다. 

Release 모드로 바꾸고 a를 출력하는 부분에 중단점을 걸고 디버깅을 실행 해보겠습니다.
디스어셈블리 창으로 보면 a에 1,2,3,4 라는값을 넣었음에도 불구하고 맨 마지막 4를 넣는 부분만 어셈블리코드로 적혀 있습니다. 
사실상 컴파일러 입장에서는 위의 코드를 분석해보면 1,2,3 을 a에 넣는 행위가 이해가 안가는겁니다. 그냥 바로 4를 넣으면 되지 않나 
해서 그렇게 번역하는겁니다.

이때 아까 배운 volatile 키워드를 붙여서 다시 디버깅해보면 이번에는 코드들 모두 제대로 번역되어있습니다. 
이것이 최적화를 하지 말아 달라는 volatile의 의미입니다.
*/

그러면 SpinLock의 멤버 변수에 volatile 을 사용하는 의미는 무엇일까요 

bool flag = true;

while (falg)
{

}

이렇게 flag라는 변수를 트루로 만들어서 while 무한루프를 만들어 보겠습니다. 또 빌드를 하고 중단점을 찍어서 살펴보면 
flag를 정의하는 부분이 디스어셈블리에서는 생략되고 while문이 실행되는 곳에서 곧바로 어디론가 점프 해버리고 있습니다.
그러니까 실질적으로 flag를 없는 셈치고 진행하는겁니다. 
flag는 그냥 true 상태인 변수고 while도 그냥 실행하면 true값이 주어지면서 무한루프를 하기 때문입니다. 

이런 내용을 알고나서 다시 SpinLock의 코드를 보면 _locked 라는 bool 변수를 체크해서 true라면 무한 루프를 돌다가 unlock으로 _locked가 false 
가 되면 다음으로 진행되는 식으로 구현해놨는데 
이부분이 컴파일러가 최적화를 하면 _locked라는 변수 자체가 아예 없는셈 치는데 volatile 키워드로 _locked를 살려서 하면 
잘 동작하지 않을까 하는 생각으로 사용합니다.

하지만 volatile을 적용하고 다시 실행 해봐도 그대로 입니다. 


그러면 결국 뭐가 문제인지 더 궁금해집니다.

스핀락의 이론을 좀 더 살펴보겠습니다. 
/*
스핀락 이론 

스핀락이란 락이 걸려있으면 다음에 온 쓰레드가 커널레벨로 돌아가지 않고 락이 풀릴때 까지 기다리는 방식의 락이었습니다. 

화장실의 비유에서는 많은 사람이 화장실을 두고 경합하는데 누군가 화장실을 사용하고 있으면 앞에서 기다리는 방법을 사용하고 있는겁니다. 
그런데 잘 생각해보면 운좋게 먼저 화장실에 도착한 사람은 화장실을 들어간다 라는 동작과 자물쇠를 잠근다라는 동작이 동시에 이뤄져야 말이 됩니다.
그렇지 않으면 첫번째로 도착한 사람과 두번째로 도착한 사람이 자물쇠를 잠그기 전에 거의 동시에 화장실에 들어간다면 
한 화장실에 두명이 들어가게 됩니다. 

예전에 int++ 이라는 연산자도 사람이 보기에는 한순간에 int를 1 증가시키는 연산자였지만 컴퓨터 입장에서는 int라는 변수의 값을 레지스터에 가져오고 
그 레지스터에 1을 더하고 다시 int자리에 1 증가한 값을 가져다 놓는 3줄의 코드로 진행되었습니다.

지금도 마찬가지로 락에 대한 상태를 체크하는 코드와 락을 거는 코드가 두부분에 걸쳐서 일어나기 때문에 일어나는 일입니다. 
그래서 락의 상태체크와 락을 거는행위까지가 원자적으로 한번에 일어나거나 아니면 아예 일어나지 않아야 된다는겁니다.
*/

SpinLock 클래스의 lock 함수를 다시 보면 이렇습니다.
	void lock()
	{
		while(_locked)
		{

		}

		_locked = true;
	}

while 문으로 락이 잠겨있는지 확인하는 코드와 _locked를 true로 변경시키는 코드 두부분으로 나뉘어져 있습니다. 
정말로 다수의 쓰레드가 동시에 실행이 되면 while 문 부분을 정말 간발의 차이로 동시에 통과하게 되면 두 쓰레드 모두 락을 통과 했구나 하면서 
_locked을 잠그게 됩니다.

결국 해결하기 위해서는 예전에 공동메모리를 수정하는 실슴 ++ 연산자 부분에서 atomic을 사용해서 해결했던것 처럼 lock 내부 코드들을 atomic으로 묶어 
줘야 합니다. 

이럴때 사용하는 함수가 있습니다. 

CAS (Compare-And-Swap) 라고 하는데 이 기법 역시 이전에는 운영체제마다 따로 사용하는 API가 있었는데 현재는 
공통으로 묶여 있고 사용방법은 변수를 atomic으로 감싸주면 atomic 안에 포함되어 있습니다. 그리고 이 atomic에는 volatile 기능도 겸하고 있습니다. 

private:
	atomic<bool> _locked = false;

_locked를 이렇게 해주면 됩니다. 

atomic 이라는 클래스 자체가 원자적으로 사용하겠다 라는 의미를 가지고 있었습니다. ++,-- 같은 연산자도 원자적으로 동작시켜주는데 
다른 함수들이 또 여기에 묶여 있습니다. 

오늘 살펴보는 개념이 굉장히 중요한 개념이고 나중에 락 프리 프로그래밍에서도 중요하게 등장하게 됩니다. 

atomic 에서 CAS 를 뜻하는 함수 이름은 compare_exchange_strong 입니다. 

	_locked.compare_exchange_strong(); 

이 함수의 시그니처를 보면 bool 을 반환하고 인자로는 bool& _Expected, const bool _Desire 를 받습니다. 
이게 환경이나 언어에 따라 모양이 조금씩 다릅니다. 사용방법은 비슷하지만 함수의 형태 자체는 조금씩 달라질겁니다. 

일단 C++ 에서는 어떤 의미인지 의사코드로 한번 표현해보겠습니다.

		bool expected;
		bool desired;

		_locked.compare_exchange_strong(expected, desired);

시그니처에서 알려주고 있는데로 변수를 만들어서 일단 넘겨줘 봤습니다. 
이때 expected는 우리가 _locked 라는 값이 무엇일지 예상을 해주고 있는겁니다. 
우리 상황에서는 expected를 일단 false로 두고 desired는 true 로 줘보겠습니다. 

		bool expected = false;
		bool desired = true;

		_locked.compare_exchange_strong(expected, desired);

이러면 compare_exchange_strong가 bool을 리턴하는데 이 코드를 풀어서 설명해보겠습니다. 
		
		// CAS 의사 코드 
		if (_locked == expected)
		{
			expected = _locked;
			_locked = desired;
			return true;
		}
		else
		{
			expected = _locked;
			return false;
		}

compare_exchange_strong는 내부적으로 이런 동작을 하고 있는겁니다. _locked 의 실제 값과 예상했던 expected가 같은지를 체크하면서 
같다면 _locked의 값을 expected에 담아주고 _locked에는 desired 값을 넣어준 다음 true를 반환합니다. 
_locked 와 expected 가 같지 않다면 그냥 false 를 반환합니다. 
이 작업을 한방에 실행해주고 있습니다. 

그래서 이 코드가 정확이 무슨 의미인지 살펴보면 
compare_exchange_strong 함수에서는 이함수를 호출한 atomic 변수 여기서는 _locked입니다. 이 _locked 의 값이 expected 임을 기대 하고 
있고 만약 _locked의 값이 expected 의 값인 false 라면 desired 의 값 true로 바꿔 주기를 원하는겁니다. 
그래서 변경이 되었다면 이 compare_exchange_strong의 가장 먼저 진입한 쓰레드는 _locked 를 true 로 바꿔주고 일을 보게 됩니다. 
늦은 쓰레드는 expected와 _locked가 일치 하지 않아서 false가 됩니다.

그런데 실패 했을때 bool의 참조 타입으로 받은 expected가 _locked의 값을 가지고 끝난다는 단점이 있습니다. 

실제 사용방법은 이렇습니다.

		while (_locked.compare_exchange_strong(expected, desired) == false)
		{
			expected = false;
		}

compare_exchange_strong 가 true 가 될 때 까지 시도를 하는데 한번 실패하면 expected가 true의 값을 가져버리게 되니까 다음 반복때 다시 사용하도록 
false로 값을 바꿔 주고있습니다.

그래서 compare_exchange_strong 에서 이전에 만들었던 두 부분으로 나뉘었던 코드를 하나로 묶은겁니다.

추가로 SpinLock::unlock 함수의 내용을 보면 이전엔 그냥 

	_locked = false;

이렇게 설정해주고 있었습니다. 하지만 지금 _locked는 atomic 변수가 되었고 _locked가 bool 인지 아닌지 확실하지 않기때문에 
atomic의 내부 함수를 사용해서 false로 바꿔줍니다.
	void unlock()
	{
		//_locked = false;
		_locked.store(false);
	}



결국 처음에 만들었던 SpinLock 과 논리적으로는 동일하지만 처리하는 코드들을 atomic 하게 묶는 부분이 추가 된겁니다.

이제 다시 빌드, 실행을 해보면 정상적으로 sum의 값이 0으로 나오는걸 알 수 있습니다.


이렇게 SpinLock을 구현해봤는데 
이게 정말 효율적인지를 다시 생각해보면 만약 경합이 붙은 쓰레드들중 락을 점유하고 있는 다른 쓰레드가 락을 금방 놔줄것 같다면 
경합에서 진 쓰레드가 굳이 다시 커널모드로 돌아가는 컨텍스트 스위칭을 하지 않고 유저모드에서 뺑뺑이를 돌면서 기다리는게 맞을것이고 
만약 먼저 락을 점유한 쓰레드가 오래동안 락을 놔주지 않는다면 기다리는 쓰레드 입장에서는 무식한 방법이 될겁니다. 

스핀락의 특징으로 뺑뺑이를 돌면서 락을 시도한다는 것도 있는데 무한 경쟁을 하면서 무한 루프를 돌기 시작하면 CPU 점유율이 확 높아진다는 
특징도 있습니다. 
만약 컨텍스트 스위칭으로 다른 쓰레드에게 코어 소유권을 넘겨줬으면 CPU 점유율이 낮아지면서 다른 쓰레드가 그걸 적절하게 사용할 수 있게 되지만 
스핀락에서 while을 무한히 유지한다면 CPU의 성능 일부를 쓸데없이 낭비하고 있는것이긴 합니다. 