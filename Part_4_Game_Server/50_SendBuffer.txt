


        SendBuffer


이번 내용은 SendBuffer 입니다. 이전 시간에 이어서 버퍼에 대한내용인데 RecvBuffer와는 달리 SendBuffer에는 좀 더 까다로운 점이 있었습니다. 

SendEvent안에 sendBuffer를 들고 있게끔해서 구현을 했었습니다. 
이 방식의 문제가 무엇인지를 짚어보겠습니다. 

void Session::Send(BYTE* buffer, int32 len)
{
	// TEMP
	SendEvent* sendEvent = A_new<SendEvent>();
	sendEvent->owner = shared_from_this();		// ADD_REF
	sendEvent->buffer.resize(len);
	::memcpy(sendEvent->buffer.data(), buffer, len);

	WRITE_LOCK;
	RegisterSend(sendEvent);

}
이  Session::Send 함수를 보면 인자로 버퍼와 그 길이를 받고 있습니다. 
그리고 함수 내에 SendEvent 객체를 만들고 sendEvent의 owner를 Send를 호출하고 있는 Session 객체 자신으로 설정하고 
buffer에는 인자로 받은 걸 memcpy로 복사하고 있습니다. 
이 복사라는 동작이 문제인데 Send라는 행위가 얼마나 자주 일어날지 모르는 상황에서 매번 복사를 하는 방식으로 동작하면 성능상 많은 비용이 발생합니다. 

나중에 가면 클라이언트나 서버 쪽에서 Send를 하는 일이 비일비재하게 될겁니다. 지금 테스트야 단순하게 동작하는지만 확인하기 위해 에코 서버로 한번 보낸 데이터를 
주고받고만 하고 있었습니다. 
지금처럼 서버와 클라이언트가 1 : 1로 만 통신하는 경우가 간혹 있지만 MMORPG에서 대부분의 경우에는 1대 다수의 통신을 하게 됩니다.
예를 들면 서버쪽에서 월드에 몬스터가 스폰되었다는 정보를 접속한 클라이언트중 하나에게만 보내는게 아니라 모든 클라이언트에게 전달해야 하기 때문에 
이 서버에 클라가 100명이 접속해 있다고 하면 Send도 100번을 호출해야 합니다. 이 상황에서 SendBuffer를 복사하는 방식으로 구현 했다면
엄청난 성능 손실이 일어나게 되는것입니다.  

그래서 복사 방식말고 다른 방식을 사용하는 SendBuffer를 만들어 볼것인데 내용이 많습니다. 
그 중 이번 시간에는 가장 간단한 방식으로 SendEvent에 임시로 만들어 뒀던 버퍼를 클래스형태로 꺼내 구현해보겠습니다. 

***
-- SendBuffer

/*
-------------------------
	SendBuffer 선언부 
-------------------------
*/

// 이전에 SendEvent에 임시로 만들어 놨던 버퍼를 클래스화 해서 만들어 보겠습니다. 
class SendBuffer : public enable_shared_from_this<SendBuffer>
{
public:
	SendBuffer(int32 bufferSize);
	~SendBuffer();

	BYTE* Buffer() { return _buffer.data(); }
	int32 WriteSize() { return _writeSize; }
	int32 Capacity() { return static_cast<int32>(_buffer.size()); }

	void CopyData(void* data, int32 len);

private:
	Vector<BYTE>	_buffer;
	// 매번 버퍼의 모든 용량을 사용하지는 않을것이고 그때 그때 버퍼의 일부분만 사용할 수 있습니다. 
	int32			_writeSize = 0;
};

실제 버퍼역할을 Vector<BYTE>로  만들어 줬고 버퍼의 사이즈를 생성자에서 받고 있습니다. 버퍼와 별개로 _writeSize라는 값도 가지고 있는데 
이 값은 버퍼의 영역 중에서도 매번 모든 영역을 사용하는 것은 아닐것이기 때문에 실제로 사용할 영역의 크기 값입니다. 
따로 Capacity 라는 함수에서는 버퍼의 실제 크기를 반환하기도 합니다. 

/*
-------------------------
	SendBuffer 정의부
-------------------------
*/

SendBuffer::SendBuffer(int32 bufferSize)
{
	_buffer.resize(bufferSize);
}

SendBuffer::~SendBuffer()
{
}

void SendBuffer::CopyData(void* data, int32 len)
{
	// 복사하려는 데이터 크기가 버퍼사이즈를 넘어 오버 플로우가 일어나는지 체크
	ASSERT_CRASH(Capacity() >= len);

	// 어찌 됐건 버퍼에 데이터를 저장하려면 한번은 복사를 해야합니다. 
	::memcpy(_buffer.data(), data, len);
	_writeSize = len;
}

이렇게 간단하게 만들어 봤습니다. 
이제 실질적으로 이 클래스를 사용할부분을 떠올려 보겠습니다. 
GameServer 코드에서 임의적으로 컨텐츠 세션처럼 GameSession 이라고 만들어 테스트를 하고 있었습니다. 
그 안에서 에코 서버 처럼 OnRecv() 를 하며 바로 Session::Send() 를 호출하고 있습니다. 
이때 Send에게 버퍼를 인자로 주기 전에 지금 만든 SendBuffer 객체를 만들어 거기에 데이터를 저장하고 그걸 Send에게 넘겨주는 방식으로 해보겠습니다. 

그런데 위에서 말했다시피 Send는 한번에 여러 클라이언트에게 이 SendBuffer를 동시에 넘겨주면서 송신을 하게 될테니까 
SendBuffer 자체에서 RefCount를 해줘야 합니다. 왜냐하면 클라마다 Send를 호출해주게 될것이고 Send는 이어서 RegisterSend, 또 WSASend 를 호출하면서 
WSABUF 에게 SendBuffer를 담아 WSASend를 호출해 주게 됩니다. IOCP에 등록된 일감들은 SendBuffer객체를 참조해 데이터 전송을 실행하게 될것이기 때문에 
혹시라도 중간에 SendBuffer 객체가 삭제 되지 않도록 RefCount를 해줘야 하는것입니다. 

RefCount를 우리 프로젝트에서는 Types.h 에서 끝에 Ref를 붙여서 편하게 사용하고 있었습니다. 

-- Types.h
// shared_ptr 을 간편히 
using IocpCoreRef = std::shared_ptr<class IocpCore>;
using IocpObjectRef = std::shared_ptr<class IocpObject>;
using SessionRef = std::shared_ptr<class Session>;
using ListenerRef = std::shared_ptr<class Listener>;
using ServerServiceRef = std::shared_ptr<class ServerService>;
using ClientServiceRef = std::shared_ptr<class ClientService>;
using SendBufferRef = std::shared_ptr<class SendBuffer>;


-- GameServer

class GameSession : public Session
{
public:
	~GameSession()
	{
		cout << "~GameSession" << endl;
	}
	virtual int32 OnRecv(BYTE* buffer, int32 len) override
	{
		cout << "OnRecv Len = " << len << endl;

		// 받은 데이터를 SendBuffer에 한번은 복사해 들고 있고 
		// Send를 호출할때 마다 이걸 참조하도록 합니다. 
		SendBufferRef sendBuffer = MakeShared<SendBuffer>(4096);
		sendBuffer->CopyData(buffer, len);
		
		Send(sendBuffer);
		return len;
	}

	virtual void OnSend(int32 len) override
	{
		cout << "OnSend Len = " << len << endl;
	}
};

테스트 코드에서는 이렇게 사용할 수 있을것입니다. 처음 한번은 SendBuffer 에 복사를 하고 이후 Send를 호출할때는 이 객체를 참조하도록 하는것입니다. 

그러면 Sessin::Send도 이에 맞게 수정을 해야 합니다. 

-- Session

Session 에서 추가로 멤버 변수 

	SendEvent _sendEvent; 

를 들고 있을것입니다. 이렇게 수정하면서 덩달아 같이 수정해야할 함수들이 있습니다. Send(), RegisterSend(), ProcessSend(), Dispatch() 입니다.


void Session::Send(SendBufferRef sendBuffer)
{
	// 이전에는 SendEvent를 Send 호출때마다 생성하고 삭제 하고 있었는데 
	// 그 이유는 Send 안에서 RegisterSend를 호출 할때 마다 인자로 넘겨줘야 했었습니다.
	// 그래서 RegisterSend를 매번 Send에서 호출해주는게 아닌 최초에 한번 호출 해준 다음 
	// ProcessSend를 마칠때 다시 RegisterSend를 호출하도록 해주면 같은 SendEvent를 계속 사용할 수 있습니다. 

	// TODO
	// 현재 RegisterSend가 걸리지 않은 상태라면, 걸어준다 
	// 만약, 이미 RegisterSend가 처리되지 않은 상태라서 다시 걸지 못한다면 Queue에 넣어준다 
	WRITE_LOCK;

	_sendQueue.push(sendBuffer);
	
	if (_sendRegistered.exchange(true) == false)
		RegisterSend();
}


void Session::RegisterSend()
{
	// RegisterSend를 Send에서 매번 호출하는게 아닌 처음만 호출하고 ProcessSend에서 다음번 
	// RegisterSend를 호출하도록 하면서 _sendEvent를 멤버 변수로 들고 있을 수 있게 되었습니다. 
	// Send에서 WRITE_LOCK 을 사용하면서 한번에 한 스레드에서만 호출되도록 되었습니다.
	if (IsConnected() == false)
		return;
	
	_sendEvent.Init();
	_sendEvent.owner = shared_from_this();	// ADD_REF

	// 보낼 데이터를 SendEvent에 등록 
	{
		// 왜 중첩해서 락을 잡느냐 하면 나중에 혹시 RegisterSend를 락을 안잡고 호출하게 
		// 바뀔 수 도 있기 때문에 2중으로 잡고 있습니다. 
		WRITE_LOCK;
		
		// 기존 SendEvent.buffer는 BYTE 타입을 받는 vector였습니다. 지금은 SendBufferRef를 받는 
		// vector로 수정했습니다. 

		// Send때 _sendQueue에 넣어두었던 SendBufferRef를 꺼내 sendEvent에 연결해주고 있는데 왜 굳이 이렇게 하느냐?
		// 보낼 SendBufferRef가 WSASend를 호출한 후부터는 사라지지 않도록 보존을 해야하는데 
		// 중간에 _sendQueue 에서 꺼내다가 SendBufferRef의 RefCount 가 0이 되면 삭제가 될 수 있기때문에
		// 삭제 되지 않도록 SendEvent가 참조 하고 있게 하는것입니다. 

		// _sendQueue가 빌때 까지 반복하는 것으로 간단하게 만들겠습니다. 
		int32 writeSize = 0;
		while (_sendQueue.empty() == false)
		{
			SendBufferRef sendBuffer = _sendQueue.front();

			// 꺼낸 버퍼들의 writeSize를 더해가면서 추적하는 이유는 
			// 실제 버퍼의 capacity를 넘으면 안되기 때문에 중간에 끊어 주기 위함
			writeSize += sendBuffer->WriteSize();

			// TODO : 예외 체크 
			
			_sendQueue.pop();
			_sendEvent.sendBuffers.push_back(sendBuffer);
		}
	}



	// WSABUF 를 보낼때 여러 개를 뭉쳐서 한번에 보낼 수도 있었습니다. 
	// Scatter-Gather (흩어져 있는 데이터들을 모아서 한방에 보낸다)

	Vector<WSABUF> wsaBufs;
	wsaBufs.reserve(_sendEvent.sendBuffers.size());
	for (SendBufferRef sendBuffer : _sendEvent.sendBuffers)
	{
		WSABUF wsaBuf;

		wsaBuf.buf = reinterpret_cast<char*>(sendBuffer->Buffer());
		wsaBuf.len = static_cast<LONG>(sendBuffer->WriteSize());

		wsaBufs.push_back(wsaBuf);
	}


	DWORD numOfBytes = 0;
	if (SOCKET_ERROR == ::WSASend(_socket,/*동적배열의 시작주소*/ wsaBufs.data(), static_cast<DWORD>(wsaBufs.size()), OUT & numOfBytes, 0, &_sendEvent, nullptr))
	{
		// 진짜 실패인지 PENDING 상태인지 체크 
		int32 errorCode = WSAGetLastError();
		if (errorCode != WSA_IO_PENDING)
		{
			HandleError(errorCode);
			_sendEvent.owner = nullptr; // RELEASE_REF
			_sendEvent.sendBuffers.clear(); // RELEASE_REF
			_sendRegistered.store(false);
		}
	}
}

void Session::ProcessSend(int32 numOfBytes)
{
	_sendEvent.owner = nullptr;	// RELEASE_REF
	_sendEvent.sendBuffers.clear(); // RELEASE_REF
	

	if (numOfBytes == 0)
	{
		Disconnect(L"Recv 0");
		return;
	}

	// 컨텐츠 코드에서 오버라이딩
	OnSend(numOfBytes);

	// _sendQueue에 데이터가 남았는지 아닌지에 따라 계속 RegisterSend를 호출해줄것인지 
	// 다음번 Send호출을 기다릴것인지 나뉩니다.
	WRITE_LOCK;	// _sendQueue는 멀티스레드 환경에서 동시 접근할 수 있기 때문
	if (_sendQueue.empty())
		_sendRegistered.store(false);
	else
		RegisterSend();
}



void Session::Dispatch(IocpEvent* iocpEvent, int32 numOfBytes)
{
	switch (iocpEvent->eventType)
	{
	case EventType::Connect:
		ProcessConnect();
		break;
	case EventType::Disconnect:
		ProcessDisconnect();
	case EventType::Recv:
		ProcessRecv(numOfBytes);
		break;
	case EventType::Send:	// SendEvent를 멤버 변수로 들고 있게 되어 인자로 받지 않습니다.
		ProcessSend(numOfBytes);
		break;
	}
}

이렇게 Session쪽 코드를 수정했습니다. 
그런데 RegisterSend 코드중 _sendEvent.sendBuffers 라는 곳에 다가 _sendQueue에 담긴 SendBufferRef들을 담아 주고 있었습니다. 
이 부분의 SendEvent를 조금 수정 했었습니다. 

/*
----------------
	SendEvent
----------------
*/
class SendEvent : public IocpEvent
{
public:
	SendEvent() : IocpEvent(EventType::Send) { }

	// 이전에는 BYTE 타입으로만 버퍼를 받고 있었는데 이제 SendBuffer 단위로 
	// 받아 관리하도록 하였습니다. 
	Vector<SendBufferRef> sendBuffers;
};


ServerCore 쪽 코드는 다 수정했습니다. 테스트 코드인 GameServer, DummyClient 코드들을 보겠습니다.

*** 

-- DummyClient

이전에 대강 보낼 문자열이 담긴 버퍼의 식별자를 sendBuffer 라고 지었었는데 오늘 작업한 코드에는 혼동이 생길 수 있으니 sendData로 수정했습니다. 

테스트의 흐름을 되집어 보겠습니다. 연결을 하면서 클라이언트 쪽 세션에서 Connect를 할때 재정의 함수인 OnConnect와 동시에 Send 로 데이터를 서버에 보내게됩니다. 
이 후 서버쪽에서는 OnRecv로 데이터를 받음과 동시에 그대로 돌려 보내고 클라도 마찬가지로 받음과 동시에 돌려보내는 서로 에코 서버 형태를 취하게 됩니다. 

이 과정중에 OnConnect와 OnRecv의 안에 Send를 호출하는 부분을 오늘 강의 내용애 맞춰 수정해주겠습니다. 

class ServerSession : public Session
{
public:
	~ServerSession()
	{
		cout << "~ServerSession" << endl;
	}

	virtual void OnConnected() override
	{
		// 연결할때 Send를 한번 합니다. 
		cout << "Connected To Server" << endl;

		SendBufferRef sendBuffer = MakeShared<SendBuffer>(4096);
		sendBuffer->CopyData(sendData, sizeof(sendData));

		Send(sendBuffer);
	}
	
	virtual int32 OnRecv(BYTE* buffer, int32 len) override
	{
		cout << "OnRecv Len = " << len << endl;

		// 1초에 한번 전송하기위함 
		this_thread::sleep_for(1s);

		SendBufferRef sendBuffer = MakeShared<SendBuffer>(4096);
		sendBuffer->CopyData(buffer, len);

		Send(sendBuffer);
		return len;
	}

	virtual void OnSend(int32 len) override
	{
		cout << "OnSend Len = " << len << endl;
	}

	virtual void OnDisconnected() override
	{
		cout << "Disconnected" << endl;
	}
};

GameServer 쪽 코드는 이미 Session 코드를 수정하기 전에 수정했었습니다. 

테스트를 해볼 차례입니다. 

하지만 에러가 났습니다. 이전에 만들었던 LockProfiler 쪽 에러입니다. 

*** 
-- LockProfiler
왜 뜬금없이 여기서 에러가 발생하는가 하면 이전에 만들다가 그냥 넘어간 부분입니다. 

처음 Lock을 배우면서 DeadLock 현상이 생기는 구조가 되면 일부러 크래시를 내서 그때 그때 고칠수 있도록 하는 클래스가 DeadLockProfiler는 클래스 였습니다. 

하지만 처음 만들때의 DeadLockProfiler는 멀티스레드 환경을 고려하지 않고 만들었다 보니 락들이 쌓이는 _lockStack 이라는 것을 전역으로 열어둔것이었습니다. 
_lockStack 이란 lockId 라고 하는 락마다의 아이디를 key 로 삼아 락을 쌓아간 순서를 저장하는 컨테이너 입니다. 

멀티스레드 환경에서는 각 스레드 마다 

스레드 1 : 0번 -> 1번 -> 2번
스레드 2 : 3번 -> 1번 -> 5번 

이런식으로 번호를 가진 락을 순서대로 잡아가는것이 락 스택이라고 합니다. 

공용으로 열어두다 보니 여러 스레드에서 각자 락을 잡을때 하나의 락스택에 순서없이 저장되다 보니 꼬이게 됩니다. 

해결법은 간단한데 TLS(Thread Local Storage)로 옮겨서 각 스레드 마다 각자 한개씩 가지고 있도록 해주면 됩니다. 
아예 DeadLockProfiler 를 TLS로 하던가 아니면 _lockStack 이라도 TLS 로 옮기면 됩니다.

-- CoreTLS
TLS 를 설정하는 파일들을 따로 만들어 놨었습니다. 
CoreTLS.h 파일에는 

#include <stack>

extern thread_local std::stack<int32>	LLockStack;

cpp 파일에는 	

thread_local std::stack<int32>	LLockStack;

를 추가해주면 됩니다. 그리고 이름도 _lockStack 에서 LLockStack 으로 모든 프로젝트에 걸처 바꿨습니다. 

***
-- 테스트 
다시 테스트를 시작하면 이제는 의도한대로 데이터를 주고 받는걸 확인 할 수 있습니다. 

한가지 더 테스트를 하려고 하는데 지금처럼 매우 제한된 상황이 아닌 일반적인 상황을 가정하고 테스트 해보겠습니다. 

-- 브로드 캐스팅 
이제는 슬슬 브로드 캐스팅이라는 용어에 익숙해 져야하는데 그 예시를 들기위해 GameServer 프로젝트에 클래스 추가를 두개 해보겠습니다.

GameSessionManager, GameSession 이라는 이름의 헤더 파일, cpp 파일들을 만들어 줬습니다. 이미 GameSession이라는 클래스로 테스트를 하고 있었지만 그 코드는 잠시 이름을 바꿔두고 
브로드 캐스팅을 하기 위한 준비를 합니다. 

-- GameSession

#include "Session.h"
/*
-------------------------
	GameSession 선언부 
-------------------------
*/
class GameSession : public Session
{
public:
	~GameSession()
	{
		cout << "~GameSession" << endl;
	}

	virtual void OnConnected() override;
	virtual void OnDisconnected() override;
	virtual int32 OnRecv(BYTE* buffer, int32 len) override;
	virtual void OnSend(int32 len) override;
};

#include "GameSession.h"
#include "GameSessionManager.h"

/*
-------------------------
	GameSession 정의부
-------------------------
*/

void GameSession::OnConnected()
{
	// 접속과 동시에 세션 매니저에 등록
	GSessionManager.Add(static_pointer_cast<GameSession>(shared_from_this()));
}

void GameSession::OnDisconnected()
{
	// 접속과 반대 
	GSessionManager.Remove(static_pointer_cast<GameSession>(shared_from_this()));
}

int32 GameSession::OnRecv(BYTE* buffer, int32 len)
{
	cout << "OnRecv Len = " << len << endl;

	SendBufferRef sendBuffer = MakeShared<SendBuffer>(4096);
	sendBuffer->CopyData(buffer, len);
	
	// 데이터를 받았으면 자신 연결되 있는 클라뿐만 아니라 세션 매니저의 모든 세션에 Send
	GSessionManager.Broadcast(sendBuffer);

	return len;
}

void GameSession::OnSend(int32 len)
{
	cout << "OnSend Len = " << len << endl;
}


-- GameSessionManager

/*
--------------------------------
	GameSessionManager 선언부 
--------------------------------
*/

#include "Session.h"

class GameSession;

using GameSessionRef = std::shared_ptr<GameSession>;
// GameSession 들을 묶어 관리하는 매니저가 될것입니다. 
// 물론 이미 Service라는 클래스로 Session 뿐만아니라 주소 구조체, 소켓, iocpCore 등을 관리하고 있었지만
// GameSessionManager는 좀 더 컨텐츠쪽에서 편하게 사용하기 위해 묶어 관리합니다. 
class GameSessionManager
{
public:
	void Add(GameSessionRef session);
	void Remove(GameSessionRef session);
	void Broadcast(SendBufferRef sendBuffer);

private:
	USE_LOCK;
	Set<GameSessionRef> _sessions;
};

// 사용하기 쉽게 전역 객체로 만들어 줬습니다. 
extern GameSessionManager GSessionManager;


/*
--------------------------------
	GameSessionManager 정의부 
--------------------------------
*/
#include "GameSessionManager.h"
#include "GameSession.h"

GameSessionManager GSessionManager;

void GameSessionManager::Add(GameSessionRef session)
{
	WRITE_LOCK;
	_sessions.insert(session);
}

void GameSessionManager::Remove(GameSessionRef session)
{
	WRITE_LOCK;
	_sessions.erase(session);
}

void GameSessionManager::Broadcast(SendBufferRef sendBuffer)
{
	// 매니저가 관리하는 모든 세션에 대해 Send를 실행해 주고 있습니다. 
	// 이전에는 Send의 인자로 데이터를 직접 넘겨주고 내부에서 SendBuffer에 복사를 매번 해줬었는데
	// 지금은 인자로 넘겨주기 전에 한번만 복사가 일어나고 이 후 부터는 그 주소만을 넘겨주고 있습니다.
	WRITE_LOCK;
	for (GameSessionRef session : _sessions)
	{
		session->Send(sendBuffer);
	}
}


이렇게 위와 같이 한번에 세션들을 묶어 관리하는 상황에서 한 세션이 Recv를 했다고 고대로 연결된 상대에게만 데이터를 보내는게 아니라 
자신과 같이 매니저로 묶인 모든 세션에게 데이터를 보내는것이 브로드캐스트 입니다. 

이 코드대로 테스트를 진행해보면 점점 보내는데이터의 크기가 커진다는것을 확인할 수 있는데 
왜 이러냐면 현제 클라이언트쪽에서 총 5개의 세션을 만들어 문자열을 보내고 각각 매칭된 세션 수 만큼 서버쪽에서도 세션을 만들어 받습니다. 
이때 세션을 만들고 연결이 되는 동시에 다섯 세션들을 세션매니저에 등록이 되고 한 세션이 데이터를 수신해도 다섯 세션에게 데이터를 발신합니다. 
이것을 멀티스레드 환경에서 진행이 되다 보니 보내는 데이터가 곂쳐서 나갈 때가 있습니다. 
그러면 클라이언트쪽에서는 받은 그대로를 다시 서버쪽으로 보내고 이후로는 반복하며 점점 주고 받는 버퍼의 크기가 커지는 것입니다. 