


        Object Pool 


이전 시간까지 메모리 풀을 만들어 보았습니다. 이 정도 내용에서 필요에 따라 조금만 더 첨삭하면 충분히 실전에서 쓰일만한 
성능이 나온다고 합니다. 

그래도 완벽히 만족한다고 할 수는 없는데 그 이유중 하나가 우리가 만든 메모리 풀에서는 일정 크기마다 메모리를 저장해 두었다가 비슷한 
크기의 사이즈의 메모리가 필요하다고 하면 가져다가 쓰는 식이었습니다. 

이게 딱히 큰 문제라는것은 아니지만 왜 아쉽다고 하는지 예시를 들어보겠습니다. 
한번 메모리 오염이 일어났었는데 메모리 오염이 일어난 채로 메모리를 메모리 풀에 반납을 하였고 또 반납된 메모리는 비슷한 크기의 다른 데이터가 
사용할테고 그러면 그 데이터에도 메모리 오염이 일어납니다. 이걸 금방 찾아내지 못하고 한참후에 발견한다면 최초에 왜 메모리 오염이 발생했는지 
원인을 찾기 힘듭니다. 
왜냐하면 메모리 풀에서 꺼낸 메모리가 크기만 비슷하다고 하면 사용한 데이터가 무엇이든 아무거나 사용가능 했기 때문인데 
애당초 단일 클래스 하나가 하나의 메모리 풀을 점유해서 사용하는 형태였다고 하면 어느 메모리풀에서 문제가 발생했으면 그 메모리 풀을 점유하고 있는
클래스 코드를 찾아보면 문제를 좀 더 쉽게 알 수 있었을겁니다. 

그런 의미에서 오늘 주제는 오브젝트 풀링입니다. 이전 주제였던 메모리 풀링이 더 넓은 영역을 커버하는 주제 였고 
오브젝트 풀링은 그 안에서 일정 영역을 차지하는 방식입니다. 

이전 메모리 풀을 만든 방식에서 메모리 풀을 고르는 기준이 생성할 데이터의 크기였던 걸 이제는 같은 클래스 끼리 메모리 풀을 고르도록 하는게 다릅니다. 


->  Object.h

    오늘 테스트할 헤더를 ServerCore 프로젝트 > Memeory 필터 아래에 추가해주고 시작하겠습니다. 

    #pragma once
    #include "Types.h"
    #include "MemoryPool.h"

    template<typename Type>
    class ObjectPool
    {
    public:
        template<typename... Args>
        static Type* Pop(Args&&... args)
        {
            Type* memory = static_cast<Type*>(MemoryHeader::AttachHeader(s_pool.Pop(), s_allocSize));
            new(memory) Type(forward<Args>(args)...); 
            return memory;
        }

        static void Push(Type* obj)
        {
            obj->~Type();
            s_pool.Push(MemoryHeader::DetachHeader(obj));
        }
    private:
        static int32		s_allocSize;
        static MemoryPool	s_pool;
    };

    template<typename Type>
    int32 ObjectPool<Type>::s_allocSize = sizeof(Type) + sizeof(MemoryHeader);

    template<typename Type>
    MemoryPool ObjectPool<Type>::s_pool{ s_allocSize };
    
    일단 템플릿을 사용할 것입니다. 그래서 같은 클래스끼리 묶어 줄건데 따로 cpp 파일을 만들어서 정의 해주지 않을 것이기 때문에 CorePch를 로딩하지 못해서 
    다른 파일들을 읽어오지 못합니다. 그래서 직접 include 도 해줍니다. 여기서는 Types.h MemeoryPool.h 를 추가합니다. 

    private 밑으로 추가할 멤버 변수는 allocSize와 MemoryPool 입니다. 그런데 둘 다 static 변수로 만들어 줄겁니다. 클래스 안에 만든 static 변수는 
    아예 전역 변수처럼 하나만 존재 할 수 있는게 아니라 클래스 별로 하나씩만 존재할수 있습니다. 그런데 템플릿을 적용한 클래스다 보니 
    템플릿이 달라질때 마다 각각 별도의 클래스로 인식되다 보니 Type이 다른 ObjectPool 은 각각의 allocSize와 MemeoryPool을 가지고 있을겁니다. 
    또 이름은 static 변수이니 앞에 s_ 를 붙여서 s_allocSize, s_pool 이라고 지었습니다. 

    그리고 static 변수의 초기화는 클래스 외부에서 해주어야 하는데 문법은 이렇습니다. 
    template<typename Type>
    '변수타입' '포함된 클래스<Type>'::'변수이름' = '초기화 내용'

    다음으로 public 아래에 들어갈 함수들 차례입니다. 여기도 각각 static 으로 만들어 주었습니다. 
    예전에 만들었던 A_new, A_delete 의 구조를 가져와 만들었는데 

    Pop은 추가로 가변 템플릿을 넣어서 여러 생성자에 대응 할 수 있도록 하였습니다. 이 ObjectPool 에서 Pop 을하면 한번에 그 클래스의 생성까지도 하게끔 만들었는데 
    먼저 메모리를 확보합니다. memory 라는 만들 클래스의 포인터 변수를 만들고 그 값을 s_pool.Pop을 해오고 있는데 이때 MemeoryPool::AttachHeader 를 거쳐서 
    실제 객체가 시작하는 주소를 가져오고 또 static_cast로 Type* 로 캐스팅해서 memory에 담아주고 있습니다. 
    이때의 memory는 해당 클래스의 크기를 가진 메모리 이긴하나 비어있고 생성자를 호출해줘야합니다. 
    placement new 문법으로 생성자를 호출해주었습니다. 

    Push는 이제 사용하지 않을 객체를 삭제하고 메모리를 s_pool에 반납하는 함수입니다. 유의해야 할점은 s_pool에 반납할때 객체 앞에 붙어있을 MemoryHeader가 시작하는 
    주소로 반납을 해야 한다는건데 MemoryHeader::DetachHeader 로 할 수 있습니다. 

    위의 Pop과 Push는 이전시간들에 만들었던 MemoryPool 클래스의 기능을 가져다 사용하고 있습니다. 그러면 이전 시간과 다를게 없지 않나 할 수 있는데 
    다른점은 이 ObjectPool에서는 템플릿으로 받은 클래스 타입마다 각각 메모리 풀이 만들어 진다는 것이고 
    이전 메모리 풀에서는 아예 GMemory 를 생성하면서 여러 크기의 메모리 풀들을 만들고 생성할 객체의 크기에 따라 골라 사용하는것이 다릅니다. 


이제 테스트를 해보겠습니다. 그 전에 지금 만든 ObjectPool 을 CorePch에 추가해두겠습니다. 

->  GameServer.cpp 

    테스트용으로 두 클래스를 만들어 보겠습니다. 

    class Knight
    {
    public:
        int32 _hp = rand() % 1000;
    };

    class Monster
    {
    public:
        int64 _id = 0;
    };


    그리고 ObjectPool의 사용예시는 이렇습니다. 
    int main()
    {
        // 생성
        Knight* k1 = ObjectPool<Knight>::Pop();
        // Pop의 인자에는 만약 만들고자하는 클래스가 여러개의 생성자가 있을때 그에 맞는 인자를 넣어줄 수 있습니다. 

        // 삭제
        ObjectPool<Knight>::Push(k1);
        // k1 이라는 객체는 삭제하고 사용한 메모리는 반납합니다. 
    }

    여기서 아쉬운점이 매번 사용할때 마다 ObjectPool<Knight> 을 붙이면서 짝을 맞춰줘야 하는가 가 아쉽습니다. 지금은 그냥 맞춰사용하면되지 뭐 할 수 있는데 
    코드가 복잡해지고 덩치가 커지다 보면 실수로도 기본 delete 를 사용하거나 아니면 A_delete를 사용할 수도 있습니다. 
    그렇기 때문에 당연히 이대로 그냥 사용하지는 않는다고 합니다. 

    shared_ptr 을 이용하면 ObjectPool을 Pop하고 Push 하는걸 알아서 관리해줄겁니다. 그걸 어떻게 해주냐면 지금까지는 make_shared를 가지고 생성을 했었습니다. 
    이 make_shared는 기본버전 new delete를 사용하게 되는데 그래서 메모리 풀링을 하거나 오브젝트 풀링을 하려고 하면 이 기본버전으로는 안됩니다. 

    shared_ptr를 초기화 할때 중괄호 초기화를 하면서 두가지 인자를 넣어 줄 수 있는데 첫번째 인자로 포인터를 직접 만들어서 넣어주고
    두번째는 이 포인터의 삭제자를 넣어줄 수 있습니다. 

    이런식으로 되는겁니다. 

    shared_ptr<Knight> sptr = { ObjectPool<Knight>::Pop() , ObjectPool<Knight>::Push };

    ObjectPool<Knight>::Pop() 라는 방식으로 객체를 생성해 그 포인터를 넘겨줄 것이고 이 shared_ptr가 삭제될때는 ObjectPool<Knight>::Push라는 방식으로 
    삭제를 할것이라는 의미입니다. 

    위의 코드를 타이핑하는것도 귀찮다고 하면 매크로를 만들거나 ObjectPool 에 함수로 만들어 줄 수도 있을겁니다. 
    
	static shared_ptr<Type> MakeShared()
	{
		return shared_ptr<Type> ptr = { Pop(), Push };
	}
    이런 함수를 ObjectPool 안에 만들어 주면 

    share_ptr<Knight> k1 = ObjectPool<Knight>::MakeShared();
    이런 코드로 share_ptr을 만들어 줄 수 있을 겁니다. 

    int main()
    {
        Knight* knights[100];

        for (int32 i = 0; i < 100; i++)
            knights[i] = ObjectPool<Knight>::Pop();

        for (int32 i = 0; i < 100; i++)
        {
            ObjectPool<Knight>::Push(knights[i]);
            knights[i] = nullptr;
        }

        shared_ptr<Knight> sptr = { ObjectPool<Knight>::Pop() , ObjectPool<Knight>::Push };
    }
    다음은 이렇게 knights 라는 100개 짜리 배열을 만들어서 오브젝트 풀로 생성과 삭제를 하였습니다. 
    이러면 어떤 일이 되느냐면 MemoryPool 클래스를 보면 해당 메모리 풀에 여분의 메모리가 없다면 새로 메모리를 할당하고 여분이 있다면 여분을 반환합니다. 
    위의 코드에서는 100개의 Knight 객체 만큼의 메모리를 쭉 할당을 받고 다시 그 메모리들을 오브젝트 풀에 Knight 버전 메모리 풀에 넣어주고 있습니다. 
    그러면 100 까지 Knight 객체는 새로 커널영역에 메모리를 할당해달라고 하지 않고 유저영역 안에서 미리 만들었던 메모리를 가져다 사용하게 됩니다. 

    꼭 이런 정책을 사용할 필요는 없고 이런 식으로 미리 메모리 할당을 받는 정책도 있고 아니면 실제로 필요해서 생성할때 메모리 할당을 받는등 정책은 정하기 나름입니다. 


->  MemoryPool 

    다시 메모리 풀 파일로 왔습니다. 위에서 메모리 풀을 테스트하면서 보니까 메모리 풀의 변수중에 메모리를 몇개나 사용하고 있는지를 추적하는 
    _allocCount 라는게 있었습니다. 이 값은 Pop을 하면 1이 늘고 Push를 하면 1이 줄었습니다. 
    사용중인 메모리 갯수이니까 햇갈리지 않게 이름으 _useCount 라고 바꿔 보겠습니다. 

    그리고 비슷하게 지금 메모리 풀에 메모리가 몇개나 있는지를 추적해 보면 디버깅을할때 유용할 것 같습니다. _reserveCount 라고 atomic<int32> 로 만들어주었습니다. 
    Push를 하면 풀에 메모리를 넣은 것이니까 _reserveCount.fetch_add(1) 을 해주면 되고 
    Pop에서는 풀에 메모리가 없다면 새로 만들어 반환하는데 이건 풀에서 꺼낸게 아니니까 그냥 통과하고 풀에 메모리가 있어서 꺼낼때는 그때 _reserveCount.fetch_sub(1); 을 
    하도록 수정했습니다.


->  GameServer

    이제 다시 아까 테스트하던 코드에서 sptr을 만들던 부분에 중단점을 걸고 실행해보면 그때 Knight 클래스의 오브젝트 풀에서 _reserveCount는 100이고 _useCount 는 0입니다. 
    잘 동작하고 있습니다.
    
    그리도 당연한 얘기지만 지금 코드에서는 Knight 에 대한 오브젝트 풀이었고 Monster를 또 오브젝트 풀로 만들면 이건 따로 Monster의 오브젝트 풀이 동작합니다. 

여기까지가 오브젝트 풀에 대한 내용입니다. 메모리 풀을 배웠었고 그 메모리 풀을 사용하는 걸 응용하면 오브젝트마다의 메모리 풀을 만들어 사용할 수 있다는걸 알 수 있었습니다. 



    - 추가 내용 - 
여기서 끝내도 되기는 하지만 아직 아쉬운 점이 있습니다. 메모리 풀을 사용하는 방식은 메모리를 해제하지 않기 때문에 바로바로 해제하는 StompAllocator 와 같이 사용할 수 없다는게
아쉽습니다. 

개발할때 StompAllocator로 메모리 오염을 잡아낼수 있는게 굉장히 중요한 부분이라고 합니다. 

그렇기 때문에 어떻게 사용할지 정책을 골라줘야합니다.
일단은 방법은 배워 두는게 좋을것입니다. 

CoreMacro를 보면 디버깅 모드에서 사용하는 얼로 케이터를 PoolAllocator 로 바꿔 두었었습니다. 여기서 일단은 PoolAllocator로 실행한다고 하되 내부에서 진짜로 
메모리 풀링을 적용해서 할당할지 아니면 스톰프 얼로케이터로 할당할지를 정해주겠습니다. 

->  Memory.h 

    Memory 헤더로 가서 이전에 만들어 뒀던 A_new, A_delete 코드를 조금 수정하겠습니다. 
    
    template<typename Type, typename... Args>
    Type* A_new(Args&&... args)
    {
        Type* memory =	static_cast<Type*>(PoolAllocator::Alloc(sizeof(Type)));
        
        // placement new	할당된 메모리에 생성자를 호출해주는 문법 
        // new(객체를 만들어줄 공간) 객체의 템플릿(std::forward<Args>(인자들)...);
        new(memory) Type(std::forward<Args>(args)...);

        return memory;
    }

    template<typename Type>
    void A_delete(Type* obj)
    {
        obj->~Type();
        PoolAllocator::Release(obj);
    }

    이전에 매크로로 만들어 뒀던 A_alloc, A_release 을 다시 직접 PoolAllocator의 Alloc, Release 로 바꿔 주었습니다. 


그리고 CoreMacro.h에 가서 A_alloc, A_release 부분의 매크로를 일단 삭제해줍니다. 

이제는 A_new를 사용하면 메모리 풀을 사용하는 PoolAllocator를 사용할 수도 있고 아니면 오브젝트 풀을 사용하는 ObjectPool<>::Pop() 을 골라서 사용할 수도 있을겁니다. 
그중 일단 ObjectPool부터 수정해보겠습니다. 


->  ObjectPool.h

    Pop 함수를 수정합니다. 

    template<typename... Args>
    static Type* Pop(Args&&... args)
        {
    #ifdef _STOMP
            MemoryHeader* ptr = reinterpret_cast<MemoryHeader*>(StompAllocator::Alloc(s_allocSize));
            Type* memory = static_cast<Type*>(MemoryHeader::AttachHeader(ptr, s_allocSize));
    #else
            Type* memory = static_cast<Type*>(MemoryHeader::AttachHeader(s_pool.Pop(), s_allocSize));
    #endif
            new(memory) Type(forward<Args>(args)...); 
            return memory;
        }
    
    중간에 ifdef 을 사용하였습니다. _STOMP 를 사용한다고 하면 메모리 할당을 StompAllocator로 할당을 하고 아니라면 원래 대로 ObjectPool에서 할당을 받도록 하였습니다. 

    
        static void Push(Type* obj)
        {
            obj->~Type();
    #ifdef _STOMP
            StompAllocator::Release(MemoryHeader::DetachHeader(ptr));
    #else
            s_pool.Push(MemoryHeader::DetachHeader(obj));
    #endif
            
        }
    Push도 ifdef 으로 _STOMP 일때는 StompAllocator::Release로 해제하고 아니라면 s_pool 에 반납합니다. 

이렇게 수정하면 ObjectPool 클래스는 말이 오브젝트 풀이지 사실은 스톰프 얼로케이터도 같이 사용하고 있는겁니다. 이 조건을 나중에는 좀 더 세밀하게 일정 클래스를 필요에 맞게 
스톰프 얼로케이터 를 사용해서 정밀하게 메모리 오염을 검사해주는 방법도 있을겁니다. 

이제는 _STOMP 매크로를 관리하는 법은 프로젝트 속성에서 관리하는 방법도 있고 아니면 Types.h 같은 공용 헤더에 
#define _STOMP 를 선언했다가 주석처리를 했다가 하면서 사용합니다. 

#define _STOMP 를 선언하고 ObjectPool 을 보면 _STOMP 버전의 코드가 활성화 되있는걸 볼 수 있습니다. 


이제 Memory.cpp 로 가서 메모리 풀을 사용하는 버전에도 똑같은 작업을 해줄겁니다. 

->  Memory.cpp
    
    void* Memory::Allocate(int32 size)
    {
        MemoryHeader* header = nullptr;

        const int32 allocSize = size + sizeof(MemoryHeader);

    #ifdef _STOMP
        header = reinterpret_cast<MemoryHeader*>(StompAllocator::Alloc(allocSize));
    #else
        if (allocSize > MAX_ALLOC_SIZE)
        {
            // 할당할 데이터의 사이즈 + 메모리 헤더의 크기가 메모리 풀링 최대 크기를 넘어가면 일반 할당
            header = reinterpret_cast<MemoryHeader*>(::_aligned_malloc(allocSize, SLIST_ALIGNMENT));
        }
        else
        {
            // 메모리 풀에서 꺼내온다
            header = _poolTable[allocSize]->Pop();
        }
    #endif

        return MemoryHeader::AttachHeader(header, allocSize);
    }
    아까와 비슨한 ifdef 코드를 추가 했습니다. 

    void Memory::Release(void* ptr)
    {
        MemoryHeader* header = MemoryHeader::DetachHeader(ptr);

        const int32 allocSize = header->allocSize;
        ASSERT_CRASH(allocSize > 0);

    #ifdef _STOMP
        StompAllocator::Release(header);
    #else
        if (allocSize > MAX_ALLOC_SIZE)
        {
            // 메모리 풀링 최대 크기를 벗어 났으니 일반해제
            ::_aligned_free(header);
        }
        else
        {
            // 메모리 풀에 반납한다
            _poolTable[allocSize]->Push(header);
        }
    #endif
    }


이제 이렇게 해서 메모리 오염을 잡고싶을때와 메모리 풀링을 사용할때를 간편하게 사용할수 있게 되었습니다. 

마지막으로 오브젝트 풀을 사용해서 객체를 만들때 share_ptr로 만들면 생성 소멸을 알아서 관리해 준다고 했었습니다. 
그것과 비슷하게 A_new, A_delete도 share_ptr에서 사용가능하도록 만들어 주겠습니다. 

->  Memory.h
    template<typename Type>
    shared_ptr<Type> MakeShared()
    {
        return shared_ptr<Type>{ A_new<Type>(), A_delete<Type> };
    }
    이런 ObjectPool에 있던 함수와 비슷하게 만들어 주었습니다. 


shared_ptr<Knight> sptr2 = MakeShared<Knight>();
앞으로는 메모리 풀을 사용하는 객체도 이렇게 만들어 줄 수 있습니다. 