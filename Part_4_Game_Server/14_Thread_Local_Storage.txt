

        Thread Local Storage


이어서 이번 주제는 쓰레드 로컬 스토리지 소위 TLS 에 대한 내용입니다. 
생각보다 쉬운 내용이지만 쉽고 어렵고를 떠나서 앞으로 매우 유용하게 사용할 개념입니다. 


TLS를 사용해야 할 필요성을 알아보기 위해 또 다시 비유를 해보겠습니다. 식당의 비유를 하면서 멀티쓰레드의 개념, 
코어의 할당, 락에 대한 개념도 알아 봤었습니다. 

나중에 직접 멀티쓰레드 프로그래밍을 하다보면 알게 되겠지만 락이라는게 꼭 화장실에만 사용하는게 아니라 여러 분야에 사용하게 될겁니다. 
식당을 운영하면서 주방, 결제 프론트, 손님 테이블 이렇게 업무 분야가 나뉘어져 있고 주방에 두명, 손님 테이블에 두명, 결제 프론트에 한명
이렇게 인원을 배분해 놓는다고 하더라도 항상 배분한 대로만 있을수는 없을겁니다. 
손님 테이블에서 어떤 주문을 받아서 주방에 얘기하러 가기도 해야할것이고 주방에서도 주문을 확인하려고 손님 테이블에 물어볼 수도 있고 
결제 프론트도 손이 밀려서 서빙을 하다 다른 손님 테이블 직원이 결제 프론트에서 일을 할 수도 있을겁니다.

그러다 보면 직원들이 한쪽으로 쏠리는 현상이 생길 수도 있을 뿐만 아니라 그러다보면 경합 조건이 일어날 수도 있기 때문에 각 업무 부분 마다 
락을 걸어서 접근 할 수 있는 직원의 수에 제한을 둘 수 있을겁니다.

MMORPG 예를 들어 '와우'라고 했을때 와우 서버안에서도 게임 로직, DB, 클라이언트 , 로그 등 여러 부분으로 나뉘어져 동작하고 있을때 
어느 필드 쟁이 일어나서 해당 맵의 플레이어의 스킬 로직에 많은 쓰레드가 몰릴 수 도 있는겁니다. 

멀티쓰레드에서 가장 중요한 것 중 하나는 쓰레드를 여러개 사용하는것도 중요하지만 그 여러 쓰레드들에게 일감이 고르게 분배되는것이 중요합니다. 
일감이 몰리면 쓰레드 간의 경합이 일어나게 될것이고 락에 대해 알아 봤을때 락으로 조절을 한다고 해도 일감이 몰리면 먼저 도착한 쓰레드가 
일을 다 처리할 때 까지 다른 쓰레드는 놀고 있어야 한다는 상황이 발생할 수 있습니다. 

이런 상황에서 TLS란 무엇이고 어떻게 활용할 수 있는지 알아보자면 예를들어서 식당의 손님들이 많이 왔고 모두 한식을 시키게 되면 
기본적인 밑반찬들을 세팅해줘야 할겁니다. 그러면 아무 일도 없다가 손님들의 밑반찬세팅을 해줘야 하기 때문에 직원이 몰리게 될것이고 
그러면 한번에 일을 할 수 있는 사람은 제한되기 때문에 효율이 많이 떨어질겁니다. 
이때 직원 하나가 밑반찬 하나만 들고 왔다 갔다 하는게 아니라 한 사람이 큰 쟁반에 한번에 여러 밑반찬을 옮기면 훨씬 효율적일 겁니다. 

이와 같이 쓰레드가 공용 데이터에 접근할때 이 공용 데이터가 저장되어 있는 공간은 Heap영역(new), 데이터 영역(static 변수) 라고 합니다. 
그리고 각 쓰레드는 각자 실행하는 함수의 스택 메모리를 가지고 있을겁니다. 이 스택 메모리는 다른 쓰레드에서는 접근할 수 없고 자신만 접근할 수 
있고 휘발성이 있는 영역입니다. 

그리고 쓰레드들이 Heap영역, 데이터 영역에 접근하려고 하면 한번에 하나의 쓰레드만 접근 가능하도록 락으로 동기화를 유도해주었습니다. 
사실 이 중간에 아직 설명을 하지 않은 TLS 라는 영역이 하나 더 있습니다. 
TLS Thread Local Storage 용어를 보면 알 수 있듯이 쓰레드마다 로컬로 가지고 있는 저장 공간입니다. 쓰레드 마다 별도로 하나씩 가지고 있는데 
공용 저장공간에 쓰레드들이 데이터를 한번에 하나씩만 가져 간다면 더욱 많은 경합이 일어날 것인데 
그게 아니라 쓰레드가 한번 공용 저장공간에 접근했을때 사용할 데이터를 충분히 많이 한번에 가져다가 TLS 에 가져온 다음 이후 TLS에서 필요한 데이터를 
하나씩 처리한다면 처음에 데이터 덩어리를 TLS로 옮겨오는 동작 이후로는 별도의 경합이 일어나지 않게 됩니다. 

그럼 비슷해보이는 스택과 TLS는 뭐가 다른 것인가 하는 의문이 생길 수 있습니다.
비슷하다고 볼 수 있지만 스택은 사실 함수를 위한 메모리 라고 보는게 정확할겁니다. 함수가 끝나서 스택 메모리가 해제되면서 유효하지 않게 된다면 
거기 담아 두었던 데이터들은 이후로 사용할 수 없게 될겁니다. 
지금까지는 쓰레드에게 할당했던 함수들이 그냥 단일 함수로만 끝났지만 재귀적 함수라던지, 아니면 다른 함수와 연계된 함수의 역할을 하게 되면 
어느 함수의 스택메모리에 데이터를 저장했는지에 따라 손실이 날 수도 있게 될겁니다. 
반면 TLS는 하나의 쓰레드 만의 공용 저장공간이라고 볼 수 있을겁니다. 말이 이상한데 전체 공용 저장공간은 여러 쓰레드가 접근하면서 경합이 일어 나기 
때문에 쉽게 사용할 수 없지만 TLS에 가져온 데이터 덩어리는 각 쓰레드가 자유롭게 사용할수 있는 공용 저장공간처럼 사용됩니다. 

이걸 또 어떻게 비유할 수 있나면 동물원에 갔다고 해보겠습니다. 동물원에 여러 동물들이 있는데 집단 생활을 하는 대형 동물 예시로 호랑이 우리에 
사육사가 고기덩어리를 던져 줬다고 해보겠습니다. 처음에는 여러 호랑이가 막 고기덩어리로 몰려 들었다가 계속 몰려서 고기를 먹으면 불편하다 보니 
각 호랑이 마다 자기가 먹을 만큼 고기를 떼어 혼자 있을만한 곳으로 가져가서 천천히 먹는 모습을 종종 볼 수 있습니다. 
이것과 비슷하다고 볼 수 있습니다. 뷔페에서 자기 그릇에 덜어 자기 테이블로 가서 조금 씩 먹는것도 비슷하겠습니다.

TLS는 이렇게 필요한 데이터를 덜어놓고 사용할 수도 있고 아니면 쓰레드를 만들때 부터 필요한 데이터를 TLS에 만들어서 필요할 때 사용하는것도 가능합니다. 
이렇듯 TLS는 응용할 수 있는 부분이 많습니다. 나중에 가면 send buffer 같은 네트워크 통신할때 필요한 버퍼 같은것도 경합을 해서 가져오기 보다는 TLS에 
만들어 두고 바로 가져다 사용하도록 만들 겁니다. 이 내용은 지금 당장은 잘 모르지만 차후에 배우면서 복습을 할 수 있을 겁니다.

정리하자면 TLS(Thread Local Storage)는 쓰레드 마다 할당된 전역 메모리 같은 겁니다. 전체 전역 메모리에 경합을 줄이는 용도로도 사용하고 
쓰레드를 만들때 나중에 필요한 데이터를 TLS에 직접 만들어 두는것도 가능한 여러모로 응용 할 수 있는 메모리 입니다. 


- 실습 

TLS를 실습해볼건데 예전 C++11 이전에는 운영체제 마다 TLS를 사용하는 방법이 조금씩 달랐다고 합니다. 
__declspec(thread) int32 vlaue; 
윈도우에서는 위와 같은 방법으로 TLS를 사용했다고 하는데 이제 모던 C++ 이후로는 이런 방법은 잊어도 됩니다. 

thread_local int32 LThreadId = 0;

말 그대로 변수 앞에 thread_local 이라는 키워드를 붙여주면 일반 전역 변수가 아닌 TLS 변수가 되고 일반적으로는 앞에 대문자 L 을 붙여줌으로 
구분을 한다고 합니다. 

쓰레드를 만들때 각 쓰레드의 아이디를 부여할 때가 있습니다. 그때 사용했던 get_id 라는 메소드는 0,1,2,3.. 같이 연속된 id가 부여되는게 아닌
쓰레드마다 유일하기는 하지만 딱히 규칙성없는 id가 붙습니다. 
	thread t;
	t.get_id();

만약 규칙성 있게 id를 부여하고 싶은 상황이라고 해보겠습니다. 


thread_local int32 LThreadId = 0;

void ThreadMain(int threadId)
{
	LThreadId = threadId;

	while (true)
	{
		cout << "HI! I am Thread " << LThreadId << endl;
		this_thread::sleep_for(1s);
	}
}

int main()
{
	vector<thread> threads;

	for (int32 i = 0; i < 10; i++)
	{
		int32 threadId = i + 1;
		threads.push_back(thread(ThreadMain, threadId));
	}

	for (thread& t : threads)
		t.join();
}

LThreadId 라고 TLS 변수를 사용해서 threads 라는 벡터에 각각 쓰레드를 10개를 담고 생성되는 순서에 따라 아이디를 할당해 
출력했습니다. 

만약 LThreadId 가 TLS 변수가 아니라 그냥 전역 변수였다고 한다면 쓰레드들이 각각 출력하는 아이디는 for문으로 threads를 채울수록 
가장 큰 숫자로 덮어씌워져서 모두 10이라는 id를 출력할것입니다. 
하지만 thread_local 키워드를 사용함으로써 각 쓰레드에서 LThreadId는 자신 만의 아이디를 유지하게 됩니다.

지금 실습처럼 쓰레드 마다 하나씩 할당할 데이터로 사용할 수도 있고 아니면 따로 사용해야 할 데이터들을 담아두고 사용하는 방법도 있을겁니다 

// thread_local queue<int32> LQ;
// LQ에 데이터를 채워 필요한 쓰레드를 만들때 넘겨주면 그 쓰레드 만의 queue 가 됩니다. 


이렇게 TLS의 사용법도 실습 해보았습니다. 
앞으로는 변수 선언때 thread_local 이 붙어 있다면 TLS 구나 생각해주면 될겁니다. 

그리고 이후 강의에서도 TLS변수라면 변수명 앞에 L을 붙여서 표기 할 것이고 추가로 그냥 전역 변수의 경우는 변수명 앞에 G 를 붙여서 표기할 것입니다.


여기까지 해서 멀티쓰레드에 대해 알아야 할 내용을 한바퀴 돌았다고 할 수 있습니다. 
생각보다 내용이 많았던것 같지는 않지만 이 내용들을 이리저리 조합해서 앞으로는 자료구조들도 만들어 보고 하는 식으로 익숙해지는 시간을 
가져보겠습니다. 