

        Lock Free Stack


이전 시간에 만들었던 락 기반의 스택, 큐와 달리 이번에는 락을 사용하지 않는 버전의 스택을 만들어 볼겁니다. 

이런 락을 사용하지 않는 버전을 Lock Free Programming 이라고 하는데 
이 락 프리 프로그래밍은 호불호가 갈리는 영역이라고 합니다. 
이해하기나 구현하기에 난이도가 높지만 실질적으로 락 기반 자료구조에 비해 더 성능이 좋지도 않은 탓인데 
락 기반의 프로그래밍에서 발생할 수 있는 경합 상황이나 데드락을 방지하고 락으로 제한하는게 없으므로 더 빨리 구동될것이라는 
개념입니다. 
하지만 실상은 동기화를 맞춰주기 위해서 복잡한 과정을 거쳐야 합니다. 


LockFreeStack 을 만들어 보면서 알아보겠습니다. 이전 시간에 만들었던 ConcurrentStack 클래스 안에서 
LockStack 아래쪽에 만들어 주겠습니다.

이 락 프리 스택은 이전처럼 기존 스택을 래핑하는 방식이 아니라 직접 만들어야 락프리 방식으로 만들 수 있습니다. 


template<typename T>
class LockFreeStack
{
	struct Node
	{
		Node(const T& value) : data(value)
		{

		}

		T data;
		Node* next;
	};
    // 먼저 노드를 기반으로 만들어 줄겁니다. 들고 있을 데이터와 다음 노드를 가리킬 next를 들고 있습니다. 생성할때 받은 인자를 
    // data 에 대입합니다. 

public:
	// 새로운 노드 [value] 를 만들어서 기존 스택의 맨 앞에 붙이고 
	// head 를 새로 만든 노드를 가리키게 한다 
	// 1) 새 노드를 만들고 
	// 2) 새 노드의 next = head
	// 3) head = 새 노드 
	void Push(const T& value)
	{
		Node* node = new Node(value);

		node->next = _head;

		_head = node;
	}



private:
	// [ ][ ][ ][ ][ ]
	// [head] 
    // 연결된 노드들중 가장 앞에 있는 head의 포인터를 알고 있으면 전체를 들고 있는것과 마찬가지 일겁니다. 
	atomic<Node*> _head;
    
};

일단은 struct Node 와 Push 일단 만들기는 했는데 

	void Push(const T& value)
	{
		Node* node = new Node(value);

		node->next = _head;

		_head = node;
	}

이 Push 함수는 싱글쓰레드에서는 잘 작동할겁니다. 하지만 지금은 멀티쓰레드 환경에서 작동하는걸 기준으로 생각해야 합니다. 
먼저 첫번째 줄인 새 노드를 만드는 코드는 아무런 문제가 없습니다. new 로 새로 만드는 Node 객체는 heap 영역에 있기는 하지만 
그 객체를 참조하고 있는 포인터 자체는 Push 함수의 스택메모리에 있기 때문에 다른 쓰레드에서 접근할 방법이 없습니다. 
두번째 줄 부터가 문제인데 _head는 지금 만들고 있는 LockFreeStack 클래스를 공용으로 여러 쓰레드에서 사용한다면 _head는 동시에 여러 쓰레드가 
접근할 수 있습니다. 
그런데 node->next = head; 이 코드와 _head = node; 이 코드는 나눠져 있기 때문에 이 두 코드 사이에 다른 쓰레드가 새치기해서 수정될 수 있는겁니다. 
node 라는 새 노드가 진짜 가장 나중에 추가된 최신 노드가 아니게 될 수 있는겁니다. 
	// 1) 새 노드를 만들고 
	// 2) 새 노드의 next = head
	// 3) head = 새 노드 
그러면 이걸 어떻게 처리해야 하냐면 이전에 배운 CAS(Compare And Swap) 을 사용하는겁니다. 
	void Push(const T& value)
	{
		Node* node = new Node(value);

		node->next = _head;

		while (_head.compare_exchange_waek(node->next, node) == false)
		{

		}
	}

_head 가 node->next 와 같은지를 체크하고 같다면 head를 node로 변경하는 데 같지 않다면 false를 반환합니다. 그리고 앞 인자인 expected 를 _head로 값을 
바꿔 줍니다. 
즉 위의 코드는 node->next가 _head와 같은때 까지 반복하는 코드입니다. 

익숙하지 않아서 잘 모르겠다면 풀어서 설명하면 이렇습니다. 

if ( _head == node->next )
{
    _head = node;
    return true;
}
else 
{
    node->next = _head;
    return false;
}

그래서 이 compare_exchange_waek를 실행하기 전에 먼저 node->next = _head 를 넣어 놓았지만 그 다음 코드가 실행 될때 다른 쓰레드에서 
수정했는지를 크로스 체킹을 하는겁니다. 실패했다면 while 문을 돌면서 다시 시도하게 되고 성공했다면 의도 했던 값이 _head 안에 들어가게 됩니다. 

여기까지 만들어 보면서 알아챌 수 있는게 락 프리 프로그래밍이라고 해서 정말 경합도 없고 빠르게 동작하는게 아닙니다. 
그냥 락을 잡지 않았다는 의미이지 만약 이 LockFreeStack::Push 를 백개의 쓰레드가 동시에 시도한다면 CAS을 하는 순간에 새치기를 당했다고 하면 
다시 while 을 돌면서 시도해야 합니다. 
이때 정말 운이 나쁘면 계속 통과하지 못하고 루프만 돌고 있어야 합니다. 이 상황을 라이브 락이라고 하는데 
결국은 락 프리 프로그래밍이라고 해도 대기가 없는 기법은 아니라는걸 알 수 있습니다. 

일단은 락 프리 Push 를 만들어 봤는데 간단한 편이었습니다. 

이번엔 TryPop을 만들어 보겠습니다. 
	// 1) head 읽기
	// 2) head->next 읽기
	// 3) head = head->next
	// 4) data 추출해서 반환 
	// 5) 추출한 노드를 삭제

Pop은 시작부터 head에 접근해야합니다. head는 다른 쓰레드에서도 접근 할 수 있어서 CAS를 사용해야한다고 했습니다. 
bool TryPop(T& value)
	{
		Node* oldHead = _head;

		/*if (_head == oldHead)
		{
			_head = oldHead->next;
			return true;
		}
		else
		{
			oldHead = _head;
			return false;
		}*/

		while (oldHead && _head.compare_exchange_weak(oldHead, oldHead->next))
		{
			// oldHead = _head;
		}

		if (oldHead == nullptr)
			return false;

		// 데이터를 복사할때 메모리가 부족해서 크래시 날 수도 있지만 예외를 잡지 않았음
		value = oldHead->data;

		// 잠시 삭제 보류 (이중 삭제의 우려)
		//delete oldHead;

		// C#, Java 같이 GC가 있으면 사실 여기서 끝
		return true;
	}

그리고 _head 가 만약에 nullptr 이었다, 즉 LockFreeStack이 비어 있었다면 Pop이 실패해야 하므로 CAS 때에 null 체크를 한번 해주고 
nullptr 이라면 false를 반환해줍니다. 

또 oldHead를 반환한 후에는 oldHead 를 삭제해줘야 하는데 여기도 멀티쓰레드에서는 문제가 일어날 수 있습니다. 
어느 두 쓰레드가 거의 동시에 TryPop을 실행해서 value 에 반환하는데 까지 같은 Node를 반환했다고 해보고 다음 코드인 delete 
가 둘 중 하나가 간발의 차로 먼저 삭제하게 되면 이어서 삭제를 시도하는 쓰레드에서는 이미 삭제된 메모리를 다시 삭제하려고 하는 문제가 생깁니다. 

이 문제는 GC(Garbage Collector) 가 있는 C#, Jave 같은 언어라면 신경쓰지 않아도 되지만 C++에서는 신경써야 합니다. 

해결하기 전에 삭제를 보류한 상태에서 잘 돌아 가는지를 한번 테스트 해볼겁니다. 객체가 삭제되지 않기 때문에 메모리가 계속 늘어날테지만 
일단 시도해보면 잘 실행되지만 프로세스 메모리가 쭈욱 올라가는걸 볼 수 있습니다. 

이제 이 Node 객체를 안전하게 삭제하는 방법을 알아볼 차례인데 당연하게 누군가가 이 객체를 참조 하지 않을 때 까지 기다렸다가 삭제하게끔 유도해야 합니다. 

락 프리 기법은 최근에도 많은 연구가 진행되고 그에 따른 많은 방법들이 발표가 됩니다. 
그 중에서 가장 단순하고 직관적인 방법에 대해 알아보겠습니다. 

LockFreeStack 의 노드를 지우는 TryPop 메소드 안에서 Node 객체를 함부로 지울 수 없는 이유는 여러 쓰레드가 동시에 TryPop을 할때 어느 쓰레드에서는 
oldHead를 이미 지우는데 다른 쓰레드에서는 접근할려고 할 수 있기 때문입니다. 

그러면 Push는 여러 쓰레드에서 사용할 수 있도록 열어주고 TryPop에는 하나의 쓰레드만 접근가능하게 만들던가 할 수도 있는데 그런데 
일반적으로 자료구조를 만들면서 이런 규칙을 항상 지켜지도록 할 수 없기 때문에 

누군가가 참조 하고 있으면 이 객체를 삭제할 수 없고 아무도 참조하고 있지않은 상태에서야 삭제를 하면 될겁니다. 
말로만 들으면 쉬워 보입니다. 
이것을 가장 쉽게 실행할 수 있는 방법은 무엇이냐면 예전 스마트 포인터에서 shared_ptr 처럼 누군가 자신을 참조하고 있는가를 카운트 하는 방식이 있었습니다. 
이 방식을 LockFreeStack에 적용하면 어떨까 하는 생각이 듭니다. 

그래서 추가 멤버 변수가 있습니다. 

	atomic<uint32> _popCount = 0;	//  Pop을 실행중인 쓰레드 개수 

_popCount 는 Pop을 같이 실행중인 쓰레드의 개수를 말합니다. 
TryPop을 들어오는 순간에 각 쓰레드가 _popCount 의 개수를 1씩 늘려주고 자신이 TryPop을 빠져나오면 카운트를 1 줄이게 될겁니다. 

여기서 oldHead를 나 혼자 사용하고 있으면 삭제를 할 것이고 그게 아니라면 나중에 삭제해달라고 리스트에 넣어 놓고 지울때 꺼내 지우게 될겁니다. 
그래서 나중에 지울 리스트를 또 멤버 변수에 추가합니다. 

	atomic<Node*> _pendingList;		// 삭제 되어야 할 노드들 (첫번째 노드만)

지울 리스트 중에 가장 앞의 Node 만 들고 있어도 사실 쭉 next로 연결되어서 딸려 올겁니다. 

이제 이 _popCount, _pendingList를 적용할건데 Push 메소드에는 딱히 사용하지 않아도 될겁니다. 왜냐면 Push 메소드에서 만드는 새로운 노드는 
heap 영역에 만들어진다고 해도 그걸 가리키는 포인터는 각 함수의 스택메모리에 위치해서 다른 쓰레드가 접근할 수 없기 때문이었습니다. 

반면 TryPop은 시작부터 공통적으로 사용할 _heap에 접근해서 heap 영역에 있는 노드 객체에 접근하기 때문에 다른 쓰레드가 동시에 참조하는 문제가 생깁니다. 

코드를 순서대로 보면 

	bool TryPop(T& value)
	{
		++_popCount;
		// 함수에 들어오자 마자 일단 _popCount를 하나 늘립니다. 

		Node* oldHead = _head;

		while (oldHead && _head.compare_exchange_weak(oldHead, oldHead->next) == false)
		{
		}

		if (oldHead == nullptr)
		{
			--_popCount;
			// 여기서 oldHead 가 nullptr 일때 니까 원래 스택에 아무런 데이터가 없을때 입니다. 일단 TryPop을 나가니까 _popCount도 줄입니다.
			return false;
		}
		// 여기까지 진행된 메소드는 oldHead에 맨 앞에 있던 노드를 들고 있고 _head 는 한 칸 후퇴 했음으로 
		// 따로 떨어져 나온 노드를 확보한겁니다. 

		value = oldHead->data;
		TryDelete(oldHead);	
		// 이곳에 확보한 oldHead를 삭제하기 시도하는 함수를 따로 만들어서 실행해 주겠습니다. 
		return true;
	}


이어서 TryDelete 를 만들어 볼텐데 의사 코드로 적어 보면 이렇습니다. 
1) 데이터 분리
2) 카운트 체크 
3) 나 혼자면 삭제 

안에서 먼저 _popCount를 체크해서 1이라면 현제 TryPop에 접근한 쓰레드가 나 혼자라는 뜻이기 때문에 oldHead를 삭제 해도 괜찮은 상태로 보고 
delete 해줍니다. 

그런데 여기서 아 맞다 멀티 쓰레드 환경이면 _popCount == 1 이라는 조건문을 통과하고 delete 하는 중간에 또 다른 쓰레드가 접근해 버릴 수도 있지 않은가 
생각이 듭니다. 
여기서 함수가 실행되는 순서를 봐야 합니다. 인자로 받은 oldHead 라는 노드는 이미 CAS 를 통과한 후입니다. TryPop 에서 새로 pop 할 노드를 정할때 
그 때 _head가 가리키는 노드가 pop할 노드가 되고 CAS를 지난 다음은 _head는 이미 다음 pop할 노드를 가리키고 있습니다. 
즉 이때 _popCount가 1이라면 oldHead는 다른 쓰레드가 접근 할 수 없다는 말입니다. 
물론 이건 데이터를 먼저 분리(CAS) 하고 카운트 체크를 했기때문에 가능하고 혹시 순서를 바꿔서 카운트 체크부터하고 데이터를 분리하면 중간에 다른 쓰레드가 
끼어들 여지가 있을겁니다. 

일단 인자인 oldHead 는 삭제 할 것이기는 한데 이왕 혼자인거 삭제 예약했다던 리스트의 다른 데이터 들도 삭제해보면 좋을겁니다.  
그러기엔 먼저 설령 _popCount가 1인 상태로 들어 왔다고는해도 멋대로 지워도 되는지는 아직 모릅니다.  
어떻게 알 수 있냐면 먼저 pendingList를 함수내의 스텍메모리의 변수로 가져올겁니다. 이때 atomic의 메소드인 exchange를 사용할건데 
이 메소드는 Load와 Write가 동시에 되는것이었습니다. 원래 _pendingList은 스택변수로 가져오고 _pendingList는 nullptr로 write를 해주겠습니다. 

왜 _pendingList는 다시 체크 해야 했냐면 인자인 oldHead는 이미 데이터를 분리해둔 다음 _popCount를 체크했으니 삭제가 가능하였는데 
_pendingList는 그 사이에 다른 쓰레드가 다시 접근할 수 있는 상태이기 때문입니다. 그래서 위에서 스택 변수에 가져옴으로 인해 데이터 분리를 하였고 
그럼 다시 카운트를 또 체크해보면 삭제가 가능하다고 확신할 수 있을겁니다. 

구현하기 위해서 몇가지 헬퍼함수가 필요합니다. 
	void ChainPendingNodeList(Node* first, Node* last)
	{
		last->next = _pendingList;

		while (_pendingList.compare_exchange_weak(last->next, first) == false)
		{
		}
	}

	void ChainPendingNodeList(Node* node)
	{
		Node* last = node;
		while (last->next)
			last = last->next;

		ChainPendingNodeList(node, last);
	}

	void ChainPendingNode(Node* node)
	{
		ChainPendingNode(node, node);
	}

	// [ ][ ][ ][ ][ ]
	static void DeleteNodes(Node* node)
	{
		while (node)
		{
			Node* next = node->next;
			delete node;
			node = next;
		 }
	}

ChainPendingNodeList 시리즈는 만약 _pendingList를 삭제하려고 체크하는 도중에 다른 쓰레드가 끼어들었으면 분리했던 데이터를 제자리로 가져다 
놓기 위한 헬퍼함수입니다. 

DeleteNode는 다른 쓰레드가 끼어들지 않아서 _pendingList가 삭제 진행하기 위한 헬퍼함수 입니다. 

이 헬퍼 함수들은 LockFreeStack의 TryPop에서 또 이 DeleteNodes 라는 헬퍼함수 안에서 사용될 헬퍼함수들입니다. 
_popCount가 1일때 DeleteNodes안으로 들어온 oldHead를 삭제하는 김에 쌓여있던 _pendingList 의 데이터들을 삭제 가능한지를 살펴보고 있는것인데 

oldHead를 삭제 시도하는 함수를 의사코드로 적으면 이럴겁니다. 
1) _popCount가 1인지 아닌지를 체크 
2) _popCount가 1이면 3번으로, 아니라면 8번으로
3) 이왕 혼자서 참조하고 있는거 쌓여있는 _pendingList를 스택메모리의 node라는 변수로 분리해서 가져와 본다 
4) node를 분리하는 중에 다른 쓰레드가 끼어들었을지 모르니 다시 --_popCount == 0 인지를 체크한다 
5) --_popCount == 0 이라면 아직 다른 쓰레드가 끼어 들지 않았으니 node의 데이터들을 모두 삭제
6) --_popCount == 0 이 아니라면 중간에 다른쓰레드가 끼어들었으니 분리했던 node를 다시 _pendingList에 가져다 놓는다 
7) 일단 oldHead는 아무도 참조하고 있지 않은게 확실하니 삭제 하고 종료
8) 다른 쓰레드가 끼어들었으므로 oldHead 삭제를 미루고 _pendingList에 추가 후 --_popCount; 하고 종료



- 결과 및 정리 
이제 이 코드를 다시 테스트 해보겠습니다. 
Lock Free 방식으로 잘 구현 했음에도 약간 문제가 될 수 있는 부분이 있는데 Push를 sleep 없이 그냥 무한 루프로 밀어 넣는다고 하면 
Pop이 상대적으로 느리고 또 cout도 느린속도에 또 하나의 이유가 될수 있습니다. 그래서 Pop이 Push 되는 속도를 따라 잡지 못하고 
계속 데이터가 쌓일 수 있습니다. 

실제로 실행해보면 프로세스 메모리가 계속 늘어나는걸 볼 수 있습니다. 이건 버그가 나서 의도한대로 동작하지 않은게 아니라 
Push가 너무 빠르다 보니 생기는 문제입니다. 

일단 해결하는 방법은 Push에 sleep_for로 약간 지연시간을 주는 방법이 있겠습니다. 


이렇게 해서 락프리 프로그래밍을 맛보기로 조금 알아 봤습니다. 많이 연구되는 내용들 가운데 그나마 가장 단순한 방식을 실습해본겁니다. 



----------------------------------------------------------------------------------------------------------------------


LockFreeStack 2번째

지난시간에 이어서 락프리 스택에 대한 내용을 더 알아볼것입니다. 

저번은 _popCount를 사용하는 방법의 락프리 프로그래밍이었고 이번에는 다른 방식으로 구현하는 락프리스택입니다. 

_popCount를 사용하는 이유가 스택의 데이터를 삭제할때 이중 삭제가 일어나는걸 방지하기 위해서였습니다. 
그런데 C# 이나 Jave 같은 프로그래밍 언어에서는 알아서 GC가 삭제를 해주기 때문에 신경쓸 필요가 없다고도 말했었습니다.

그러면 포인터를 생 포인터를 사용하지 않고 스마트 포인터를 사용하면 C#같이 사용할 수 있지 않을까 생각이 듭니다.
여기서 이번 강의가 시작됩니다. 
LockFreeStack을 스마트 포인터 기반으로 바꿔보고 그에 따른 문제점을 알아보겠습니다. 


	struct Node
	{
		Node(const T& value) : data(make_shared<T>(vlaue)), next(nullptr)
		{

		}

		shared_ptr<T> data;
		shared_ptr<Node> next;
	};
먼저 Node 구조체 부터 data나 다음 노드를 가리키는 next도 shared_ptr로 바꿔주었습니다. 

그리고 _head도 atomic이 아니라 shared_ptr로 바꿉니다. 
private:
	shared_ptr<Node*> _head;

Push에서도 shared_ptr를 사용하도록 바꾸게 되면 이전에 CAS를 사용한 부분이 에러가 날겁니다. compare_exchange_waek는 atomic 객체 안에 포함되어있는 
메소드이기 때문입니다. 
그러면 어떻게 해야하냐면 의미적으로 똑같은 std 함수가 있습니다. 
		
		while (std::atomic_compare_exchange_weak(&_head, &node->next, node) == false)
		{

		}
	
이 std::atomic_compare_exchange_weak 은 첫번째 인자로 비교할 데이터를 넣는다는게 다릅니다. 

다음은 TryPop입니다. 
이전에는 TryPop이 성공했는지 실패했는지를 bool로 반환하고 인자에 Pop한 데이터를 넣어서 반환했는데 
이번 버전에서는 색다르게 shared_ptr<T> 를 직접 반환하는 방식으로 만들어 볼겁니다. 

가장 먼저 하는 일이 _head가 가리키고 있는데이터를 분리하는 과정인데 
oldHead라는 shared_ptr<Node> 에 _head를 대입해 넣어 줘야합니다. 그런데 _head 가 이제는 atomic 객체가 아니다 보니 단순한 대입에서도 
원자적으로 동작하지 않습니다. 이걸 원자적으로 동작 하도록 하는 std 함수를 사용해야 합니다. 

		shared_ptr<Node> oldHead = std::atomic_load(&_head);

다음은 마찬가지로 데이터 분리를 CAS로 마무리 해줍니다. 
		while (oldHead && std::atomic_compare_exchange_weak(&_head, &oldHead, oldHead->next) == false)
		{

		}

다음은 oldHead 가 널 포인터 일때는 아무것도 없는 shared_ptr를 반환해주면 되고 아니라면 oldHead에는 데이터가 들어있다는 말이 되니까 
oldHead->data를 반환해주면 됩니다. 
shared_ptr 이다 보니 함수가 종료되면서 알아서 아무도 참조하지 않을때 객체를 삭제해줄겁니다. 

이제 이 코드를 실행해 보면 잘 동작하는걸 볼 수 있습니다. 

그런데 여기서 한가지 문제가 무엇이냐면 
shared_ptr 이 락 프리 방식으로 동작할것이라는 보장이 없습니다. 각자의 하드웨어에 따라 다를수 있지만 이걸 체크하기 위해서는 
아무 shared_ptr 을 만든다음 atomic_is_lock_free 라는 함수로 테스트를 해보면 됩니다. 

하지만 대부분의 상황에서는 shared_ptr은 락프리 방식으로 동작하지 않습니다. 
이번 강의에서 만들어본 코드가 락프리 프로그래밍을 스마트 포인터로 구현해보고자 하는것이었는데 shared_ptr 자체가 락 기반 방식이었다면 아무 의미가 없어집니다.

동작하는 건 알았는데 락 프리 방식은 아니다 라는걸 알 수 있습니다. 

그러면 shared_ptr 와 비슷한 느낌으로 뭔가 노드의 레퍼런스 카운트를 해주면 락 프리를 구현할 수 있다는 이야기입니다.
락을 쓰지 않는 레퍼런스 카운트를 직접 구현하겠다는겁니다. 

이름은 CountedNodePtr 이라는 구조체를 만들겁니다. 

	struct CountedNodePtr
	{
		int32 externalCount = 0;
		Node* ptr = nullptr;
	};

이 CountedNodePtr 이라는 구조체는 Node의 포인터와 카운트를 같이 들고 있을겁니다. 

Node 구조체에서도 shared_ptr 대신 이 CountedNodePtr를 사용해야합니다.

	struct Node
	{
		Node(const T& value) : data(make_shared<T>(value))
		{

		}

		shared_ptr<T> data;
		atomic<int32> internalCount = 0;
		CountedNodePtr next;
	};

internalCount 라는 카운트가 하나 추가 되었는데 자세한 설명은 나중에 하겠습니다. next를 CountedNodePtr로 바꿨습니다. 
그리고 LockFreeStack이 들고 있는 멤버 변수이 _head 도 atomic<CountedNodePtr>로 사용합니다. 

private:
	atomic<CountedNodePtr> _head;

결국 shared_ptr 대신 사용하는 CountedNodePtr 는 Node* 의 포인터와 참조 되는 횟수 externalCount를 같이 관리하겠다는게 이번 아이디어입니다. 
물론 이 방식도 진짜 락프리 방식으로 동작하는지 아닌지는 각 환경에 따라 테스트를 해봐야 겠지만 한번에 락프리 방식으로 동작하지 않는다고 해도 
나중에 가서 고칠 방법이 있습니다. 

보통 64 비트 운영체제에서 포인터는 64비트, int32 는 32 비트 이지만 포인터라는 주소를 꼭 모든 비트를 활용할 필요는 없습니다. 
환경에 따라 실질적으로 48 비트만 주소를 표기하는데 사용할 경우도 있을겁니다. 
만약 주소 표기에 48비트만 사용한다면 externalCount 를 16비트만 사용해서 CountedNodePtr 자체를 64비트 내에 낑겨 넣을 수도 있을겁니다. 
그런식으로 따로 락을 잡지 않아도 원자적으로 동작하게끔 할 수 있을겁니다. 

다음으로 Push 함수의 코드입니다. 

	void Push(const T& value)
	{
		// 스택메모리안에서의 동작
		CountedNodePtr node;
		node.ptr = new Node(value);
		node.externalCount = 1;

		// 여기부터 공용 메모리 
		node.ptr->next = _head;
		while (_head.compare_exchange_weak(node.ptr->next, node) == false) 
		{
		}
	}

인자로 value 를 받아서 새로 추가할 노드를 만드는데 그냥 기본적으로 그냥 new 로 만들고 있습니다. 멀티 쓰레드 환경에서 이럴 수 있는 이유는 
node가 생성되는 위치가 스택메모리이기 때문에 다른 쓰레드가 접근할 수 없어서 입니다. 
하지만 _head에 연결하는 코드부터는 다른 쓰레드가 개입할 여지가 생기기 때문에 CAS로 경합을 관리하고 있습니다.

Push 는 저번 시간부터 그나마 쉬운 부분이었습니다. 

다음은 Pop입니다. 

TryPop에서 가장먼저 _head가 가리키는 노드를 분리했어야 합니다. oldHead 라는 이름이 CountedNodePtr 에 _head를 대입하였습니다. 
_head에 있던 노드는 사실은 포인터와 노드를 참조하고 있는 애들의 카운트를 관리하고 있는 형태였었습니다. 

그래서 그냥 oldHead를 만들었다고 바로 사용할 수 있는건 아닙니다. 
oldHead를 참조할 수 있는 권리 참조권을 발급 받아야 하는데 (여기서 말하는 참조권은 정식 명칭은 아니고 편의상 부르는 명칭입니다.)
거의 동시에 TryPop에 접근한 쓰레드 들은 각자의 oldHead 에 똑같은 데이터를 받았을 수 있습니다. 그럴때 쓰레드 서로 번호표를 뽑는 느낌인겁니다. 

번호표를 뽑는 동작을 헬퍼 함수로 따로 빼서 관리할것입니다. 

	void IncreaseHeadCount(CountedNodePtr& oldCounter)
	{
		while (true)
		{
			CountedNodePtr newCounter = oldCounter;
			newCounter.externalCount++;

			if (_head.compare_exchange_strong(oldCounter, newCounter))
			{
				oldCounter.externalCount = newCounter.externalCount;
				break;
			}
		}
	}
이 함수는 _head 를 oldHead에 담으면서 그 시점의 oldHead가 들고 있는 포인터는 원하던 데이터이긴 하나 externalCount는 참조를 하면서도 카운트가 늘지 않은 상태이고 
그 카운트가 늘어난 상태인 newCounter 라는 노드로 _head를 바꿔치는 시도를 하고 있는겁니다. 

가장 먼저 실행한 쓰레드는 oldCounter 와 _head가 같을 것이고 externalCount 가 1인 newCounter를 _head에 담게 될겁니다. 간발의 차로 
먼저 실행하지 못한 쓰레드들은 이미 externalCount가 1인 _head와 자신이 들고 있는 oldCounter가 같지 않기 때문에 다음 루프를 돌면서 다시 externalCount++ 된 
상태를 반복해가면서 각자 번호표를 뽑아 갈겁니다. 
번호표를 뽑아가면서 스택으로 부터 분리된 oldHead도 카운트 수를 갱신하고 브레이크를 합니다. 

그리고 이 구조라면 externalCount 라는 값은 앞으로 계속 늘기만 할거고 줄지 않을겁니다. 나중에 쓰레드가 참조를 끝낼때도 카운트가 내려가지 않는다는 말입니다. 

IncreaseHeadCount 를 통과한 상태의 oldHead는 이제 데이터 말고 externalCount 자체는 고유한 순번을 가지게 된다는 말입니다. 

그런 oldHead에서 데이터의 포인터를 봐서 값이 nullptr 이었다면 애초에 스택에 데이터가 없었다는 말입니다. 
빈 포인터를 반환하고 함수를 종료하고 

oldHead.ptr 이 null 이 아니라면 데이터를 반환하면서 스택에서 지워야 하는데 
이때 oldHead는 여러 쓰레드가 참조하고 있을 수 있습니다. 데이터 자체는 같은걸 참조 할 수 있는데 각각 카운트가 다른거죠 

그래서 데이터를 뽑아내고 삭제하기 위해서 소유권이라는 걸 획득해야 합니다. (소유권도 임의로 지은 용어입니다.)
이 소유권 획득은 가장 먼저 ptr->next 로 _head 를 바꿔치기 한 쓰레드가 승자가 됩니다. 

참조권과 소유권을 모두 얻은 쓰레드가 데이터를 스택에서 분리하는겁니다. 

if (_head.compare_exchange_strong(oldHead, ptr->next))

이런 조건을 통과하면 소유권을 가진다고 할 수 있는데 이때 _head 와 oldHead가 같은지 체크할때 포인터의 데이터 뿐만아니라 externalCount 까지 같은 쓰레드가 
통과 될겁니다. 

위 조건을 통과해서 소유권을 가진 상태라면 이 데이터를 반환 할수 있습니다. 

그런데 반환하고 나서는 데이터를 삭제해야하는데 삭제해도 되는가는 또 다른 문제입니다.
이전 시간에도 알아 봤듯이 데이터를 참조하고 있는 쓰레드가 하나 뿐이어야 삭제를 해도 되는 상황인데 
위의 IncreaseHeadCount 를 통과해서 넘어온 쓰레드들은 externalCount는 다를 지라도 데이터 자체는 동일한 데이터를 참조하고 있습니다. 

이제부터는 삭제를 하기 위해 시도 해볼겁니다. 그러기 위해서는 나말고 누가 있는가? 를 체크해야 합니다. 
먼저 코드르 보면서 설명을 하겠습니다. 	
		// 나말고 누가 또 있는가?
		const int32 countIncrease = oldHead.externalCount - 2;
		if (ptr->internalCount.fetch_add(countIncrease) == -countIncrease)
			delete ptr;
이 코드가 ptr을 참조하고 있는게 나밖에 없는지를 체크하는 코드입니다.

코드에 등장하는 externalCount 와 internalCount 의 의미에 대해 알아볼건데 

초기값이 externalCount 는 1 부터 시작했었고 internalCount 는 0 부터 시작 했었습니다. 
externalCount는 번호표 뽑는것 같은 참조권을 의미하는 카운트였습니다. 이 카운트는 같이 참조하는 쓰레드가 많아 질수록 늘어나기만 하는 카운트 입니다. 
더 이상 데이터를 사용 안 할때가 되면 internalCount를 1 줄여주게 됩니다. 이게 기본 상태인데 
여기서 만약에 데이터를 참조하는 쓰레드가 한개 뿐인 상황이라고 한다면 메모리에서 삭제 해줄수 있을겁니다. 

코드를 보면 countIncrease라는 변수는 externalCount - 2 입니다. 쓰레드 하나만 참조하고 있다면 externalCount 는 2 일것이고 countIncrease는 0이 될겁니다. 
그러면 조건문에서 ptr->internalCount 에 fetch_add 를 통해 0을 더해줄테고 그리고 0을 더해주기 이전의 값을 -countIncrease와 같은지를 체크합니다. 
이러면 이 데이터를 삭제시도하는 첫번째 쓰레드라는걸 인지해서 ptr을 삭제 할 수 있습니다. 
이 경우는 굉장히 이상적인 상황이고 

만약에  데이터에 접근하는 쓰레드가 많아서 참조권을 가진 쓰레드가 많았다면 externalCount 는 2가 아닌 더 큰 수였을것입니다. 
예를들어 총 3개의 쓰레드가 데이터의 참조권을 획득했다고 한다면 externalCount는 4 입니다. 
여기서 또 countIncrease를 계산해보면 4 -2 = 2 가 되고 거기에 internalCount에 countIncrease를 fetch_add 를 하면 기존에 0이었을 값을 반환하고 
-countIncrease (-2) 와 비교하면 false가 되기 때문에 데이터를 삭제하지 못합니다. 

/*
fetch_add 가 조금 햇갈릴 수 있는데 이 메소드는 인자의 값을 객체에 더해주기는 하지만 반환하는 값은 더하기 이전의 값을 반환합니다. 
값이 0인 a 에 2라는 수를 fetch_add 한다면 
a.fetch_add(2) == 0 == true;
입니다. 저 코드 반환값과 별개로 a는 저 시점에 값이 2가 되었지만 fetch_add의 반환은 0을 반환하는것입니다. 
*/

데이터를 분리한 다음 혼자서 데이터를 참조하고 있지 않다면 그냥 데이터를 리턴하고 끝인데 이러면 데이터는 누가 삭제 해줘야 할까요?
같이 참조하고 있던 쓰레드중 하나가 삭제해줘야 합니다. 

데이터 분리에 성공하지 못한경우의 쓰레드들은 아래와 같은 조건문을 거치게 됩니다. 
	else if (ptr->internalCount.fetch_sub(1) == 1)
	{
		// 참조권은 얻었으나, 소유권은 실패 -> 뒷수습은 내가 한다.
		delete ptr;
	}
위의 비교인 3개의 쓰레드가 있었다면 가장 처음 데이터를 분리한 쓰레드는 데이터값 을 반환하고 이 함수를 빠져나갔을것이고 
두번째 쓰레드 부터 위의 else if 문에 들어오게되는데 두번째 쓰레드의 ptr->internalCount 는 그 시점에서 2라는 값을 가지고 있을겁니다. 
첫번째 쓰레드가 값을 더해주고 나갔기 때문입니다. 그러면 fetch_sub 메소드도 마찬가지로 반환값은 연산 전의 값을 반환하지만 연산자체는 인자안의 값을 빼줄겁니다. 
즉 2 == 1 이라는 조건문이고 false 이기 때문에 이 대로 두번째 쓰레드는 TryPop을 빠져나갑니다. 
세번째 쓰레드가 조건문으로 들어오면 ptr->internalCount의 값은 1일것입니다. 똑같이 계산해보면 1 == 1 이 되고 참이므로 조건문 안으로 들어가 데이터를 
삭제해주게 됩니다. 

그래서 한번에 여러 쓰레드가 같은 데이터를 참조하게 되면 간발의 차라도 먼저 소유권을 획득한 쓰레드가 값을 반환하고 나머지 쓰레드중 가장 늦은 쓰레드가 
데이터를 삭제하고 마무리 하는것입니다. 

쉽게 비유하자면 회사에 여러 직원이 출근했다가 마지막으로 퇴근하는 직원이 불단속, 문단속을 하고 가는 느낌입니다. 

이렇게 실습 해본 락프리 프로그래밍은 역시 많은 사람이 연구했던 결과입니다. 
다 배우고 난 뒤 생각해보면 이론으로는 이해가 가지만 코드에서 진짜 그대로 작동하는지는 수학적, 논리적 점검이 필요하기 때문에 
개인적으로 직접 만들어 사용하면 위험 할 수 있습니다. 


이렇게 해서 락프리 프로그래밍의 두번째 방식으로 스택을 구현해 봤습니다. 

그 소감으로 먼저 락프리가 정말 락기반 보다 빠를지를 생각해 봐야하는데 일단 Pop을 대상으로 생각해보면 
참조권획득, 소유권획득 두가지 경쟁에서 이긴 쓰레드만 실질적으로 데이터를 뽑아낼 수 있는것이고 나머지 쓰레드는 별 쓸모 없이 다시 while 문을 돌아야 합니다. 
승리한 쓰레드 외에는 그냥 다시 같은 루프를 반복하게 되는데 멀티쓰레드에서 락을 걸지 않는다는 것 굉장히 아름답지만 
경합이 걸릴 경우에는 모든 로직을 처음부터 다시 진행해야한다는 점이 빈번하게 발생한다는것입니다. 



t1에서 푸시 10 
s._head.ptr.data 는 10 externalCount == 1

t2,t3 에서 TryPop 
{
	//t2
	oldHead는 externalCount == 1, data == 10 
	IncreaseHeadCount 에서 newCounter에 oldHead를 복사 
	newCounter.externalCount++;
	CAS _head(externalCount ==1 , data == 10) 과 oldHead(externalCount ==1 , data == 10) 를 비교 같다면 
	_head = newCounter;
	oldCounter의 externalCount 도 newCounter와 같게 2 복사 후 탈출 
}
{
	// t3
	oldHead는 externalCount == 2, data == 10 
	IncreaseHeadCount 에서 newCounter에 oldHead를 복사 
	newCounter.externalCount++;
	CAS _head(externalCount ==2 , data == 10) 과 oldHead(externalCount ==2 , data == 10) 를 비교 같다면 
	_head = newCounter;
	oldCounter의 externalCount 도 newCounter와 같게 3 복사 후 탈출 
}