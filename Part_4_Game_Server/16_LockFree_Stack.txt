

        Lock Free Stack


이전 시간에 만들었던 락 기반의 스택, 큐와 달리 이번에는 락을 사용하지 않는 버전의 스택을 만들어 볼겁니다. 

이런 락을 사용하지 않는 버전을 Lock Free Programming 이라고 하는데 
이 락 프리 프로그래밍은 호불호가 갈리는 영역이라고 합니다. 
이해하기나 구현하기에 난이도가 높지만 실질적으로 락 기반 자료구조에 비해 더 성능이 좋지도 않은 탓인데 
락 기반의 프로그래밍에서 발생할 수 있는 경합 상황이나 데드락을 방지하고 락으로 제한하는게 없으므로 더 빨리 구동될것이라는 
개념입니다. 
하지만 실상은 동기화를 맞춰주기 위해서 복잡한 과정을 거쳐야 합니다. 


LockFreeStack 을 만들어 보면서 알아보겠습니다. 이전 시간에 만들었던 ConcurrentStack 클래스 안에서 
LockStack 아래쪽에 만들어 주겠습니다.

이 락 프리 스택은 이전처럼 기존 스택을 래핑하는 방식이 아니라 직접 만들어야 락프리 방식으로 만들 수 있습니다. 


template<typename T>
class LockFreeStack
{
	struct Node
	{
		Node(const T& value) : data(value)
		{

		}

		T data;
		Node* next;
	};
    // 먼저 노드를 기반으로 만들어 줄겁니다. 들고 있을 데이터와 다음 노드를 가리킬 next를 들고 있습니다. 생성할때 받은 인자를 
    // data 에 대입합니다. 

public:
	// 새로운 노드 [value] 를 만들어서 기존 스택의 맨 앞에 붙이고 
	// head 를 새로 만든 노드를 가리키게 한다 
	// 1) 새 노드를 만들고 
	// 2) 새 노드의 next = head
	// 3) head = 새 노드 
	void Push(const T& value)
	{
		Node* node = new Node(value);

		node->next = _head;

		_head = node;
	}



private:
	// [ ][ ][ ][ ][ ]
	// [head] 
    // 연결된 노드들중 가장 앞에 있는 head의 포인터를 알고 있으면 전체를 들고 있는것과 마찬가지 일겁니다. 
	atomic<Node*> _head;
    
};

일단은 struct Node 와 Push 일단 만들기는 했는데 

	void Push(const T& value)
	{
		Node* node = new Node(value);

		node->next = _head;

		_head = node;
	}

이 Push 함수는 싱글쓰레드에서는 잘 작동할겁니다. 하지만 지금은 멀티쓰레드 환경에서 작동하는걸 기준으로 생각해야 합니다. 
먼저 첫번째 줄인 새 노드를 만드는 코드는 아무런 문제가 없습니다. new 로 새로 만드는 Node 객체는 heap 영역에 있기는 하지만 
그 객체를 참조하고 있는 포인터 자체는 Push 함수의 스택메모리에 있기 때문에 다른 쓰레드에서 접근할 방법이 없습니다. 
두번째 줄 부터가 문제인데 _head는 지금 만들고 있는 LockFreeStack 클래스를 공용으로 여러 쓰레드에서 사용한다면 _head는 동시에 여러 쓰레드가 
접근할 수 있습니다. 
그런데 node->next = head; 이 코드와 _head = node; 이 코드는 나눠져 있기 때문에 이 두 코드 사이에 다른 쓰레드가 새치기해서 수정될 수 있는겁니다. 
node 라는 새 노드가 진짜 가장 나중에 추가된 최신 노드가 아니게 될 수 있는겁니다. 
	// 1) 새 노드를 만들고 
	// 2) 새 노드의 next = head
	// 3) head = 새 노드 
그러면 이걸 어떻게 처리해야 하냐면 이전에 배운 CAS(Compare And Swap) 을 사용하는겁니다. 
	void Push(const T& value)
	{
		Node* node = new Node(value);

		node->next = _head;

		while (_head.compare_exchange_waek(node->next, node) == false)
		{

		}
	}

_head 가 node->next 와 같은지를 체크하고 같다면 head를 node로 변경하는 데 같지 않다면 false를 반환합니다. 그리고 앞 인자인 expected 를 _head로 값을 
바꿔 줍니다. 
즉 위의 코드는 node->next가 _head와 같은때 까지 반복하는 코드입니다. 

익숙하지 않아서 잘 모르겠다면 풀어서 설명하면 이렇습니다. 

if ( _head == node->next )
{
    _head = node;
    return true;
}
else 
{
    node->next = _head;
    return false;
}

그래서 이 compare_exchange_waek를 실행하기 전에 먼저 node->next = _head 를 넣어 놓았지만 그 다음 코드가 실행 될때 다른 쓰레드에서 
수정했는지를 크로스 체킹을 하는겁니다. 실패했다면 while 문을 돌면서 다시 시도하게 되고 성공했다면 의도 했던 값이 _head 안에 들어가게 됩니다. 

여기까지 만들어 보면서 알아챌 수 있는게 락 프리 프로그래밍이라고 해서 정말 경합도 없고 빠르게 동작하는게 아닙니다. 
그냥 락을 잡지 않았다는 의미이지 만약 이 LockFreeStack::Push 를 백개의 쓰레드가 동시에 시도한다면 CAS을 하는 순간에 새치기를 당했다고 하면 
다시 while 을 돌면서 시도해야 합니다. 
이때 정말 운이 나쁘면 계속 통과하지 못하고 루프만 돌고 있어야 합니다. 이 상황을 라이브 락이라고 하는데 
결국은 락 프리 프로그래밍이라고 해도 대기가 없는 기법은 아니라는걸 알 수 있습니다. 

일단은 락 프리 Push 를 만들어 봤는데 간단한 편이었습니다. 

이번엔 TryPop을 만들어 보겠습니다. 
	// 1) head 읽기
	// 2) head->next 읽기
	// 3) head = head->next
	// 4) data 추출해서 반환 
	// 5) 추출한 노드를 삭제

Pop은 시작부터 head에 접근해야합니다. head는 다른 쓰레드에서도 접근 할 수 있어서 CAS를 사용해야한다고 했습니다. 
bool TryPop(T& value)
	{
		Node* oldHead = _head;

		/*if (_head == oldHead)
		{
			_head = oldHead->next;
			return true;
		}
		else
		{
			oldHead = _head;
			return false;
		}*/

		while (oldHead && _head.compare_exchange_weak(oldHead, oldHead->next))
		{
			// oldHead = _head;
		}

		if (oldHead == nullptr)
			return false;

		// 데이터를 복사할때 메모리가 부족해서 크래시 날 수도 있지만 예외를 잡지 않았음
		value = oldHead->data;

		// 잠시 삭제 보류 (이중 삭제의 우려)
		//delete oldHead;

		// C#, Java 같이 GC가 있으면 사실 여기서 끝
		return true;
	}

그리고 _head 가 만약에 nullptr 이었다, 즉 LockFreeStack이 비어 있었다면 Pop이 실패해야 하므로 CAS 때에 null 체크를 한번 해주고 
nullptr 이라면 false를 반환해줍니다. 

또 oldHead를 반환한 후에는 oldHead 를 삭제해줘야 하는데 여기도 멀티쓰레드에서는 문제가 일어날 수 있습니다. 
어느 두 쓰레드가 거의 동시에 TryPop을 실행해서 value 에 반환하는데 까지 같은 Node를 반환했다고 해보고 다음 코드인 delete 
가 둘 중 하나가 간발의 차로 먼저 삭제하게 되면 이어서 삭제를 시도하는 쓰레드에서는 이미 삭제된 메모리를 다시 삭제하려고 하는 문제가 생깁니다. 

이 문제는 GC(Garbage Collector) 가 있는 C#, Jave 같은 언어라면 신경쓰지 않아도 되지만 C++에서는 신경써야 합니다. 

해결하기 전에 삭제를 보류한 상태에서 잘 돌아 가는지를 한번 테스트 해볼겁니다. 객체가 삭제되지 않기 때문에 메모리가 계속 늘어날테지만 
일단 시도해보면 잘 실행되지만 프로세스 메모리가 쭈욱 올라가는걸 볼 수 있습니다. 

이제 이 Node 객체를 안전하게 삭제하는 방법을 알아볼 차례인데 당연하게 누군가가 이 객체를 참조 하지 않을 때 까지 기다렸다가 삭제하게끔 유도해야 합니다. 

락 프리 기법은 최근에도 많은 연구가 진행되고 그에 따른 많은 방법들이 발표가 됩니다. 
그 중에서 가장 단순하고 직관적인 방법에 대해 알아보겠습니다. 

LockFreeStack 의 노드를 지우는 TryPop 메소드 안에서 Node 객체를 함부로 지울 수 없는 이유는 여러 쓰레드가 동시에 TryPop을 할때 어느 쓰레드에서는 
oldHead를 이미 지우는데 다른 쓰레드에서는 접근할려고 할 수 있기 때문입니다. 

그러면 Push는 여러 쓰레드에서 사용할 수 있도록 열어주고 TryPop에는 하나의 쓰레드만 접근가능하게 만들던가 할 수도 있는데 그런데 
일반적으로 자료구조를 만들면서 이런 규칙을 항상 지켜지도록 할 수 없기 때문에 

누군가가 참조 하고 있으면 이 객체를 삭제할 수 없고 아무도 참조하고 있지않은 상태에서야 삭제를 하면 될겁니다. 
말로만 들으면 쉬워 보입니다. 
이것을 가장 쉽게 실행할 수 있는 방법은 무엇이냐면 예전 스마트 포인터에서 shared_ptr 처럼 누군가 자신을 참조하고 있는가를 카운트 하는 방식이 있었습니다. 
이 방식을 LockFreeStack에 적용하면 어떨까 하는 생각이 듭니다. 

그래서 추가 멤버 변수가 있습니다. 

	atomic<uint32> _popCount = 0;	//  Pop을 실행중인 쓰레드 개수 

_popCount 는 Pop을 같이 실행중인 쓰레드의 개수를 말합니다. 
TryPop을 들어오는 순간에 각 쓰레드가 _popCount 의 개수를 1씩 늘려주고 자신이 TryPop을 빠져나오면 카운트를 1 줄이게 될겁니다. 

여기서 oldHead를 나 혼자 사용하고 있으면 삭제를 할 것이고 그게 아니라면 나중에 삭제해달라고 리스트에 넣어 놓고 지울때 꺼내 지우게 될겁니다. 
그래서 나중에 지울 리스트를 또 멤버 변수에 추가합니다. 

	atomic<Node*> _pendingList;		// 삭제 되어야 할 노드들 (첫번째 노드만)

지울 리스트 중에 가장 앞의 Node 만 들고 있어도 사실 쭉 next로 연결되어서 딸려 올겁니다. 

이제 이 _popCount, _pendingList를 적용할건데 Push 메소드에는 딱히 사용하지 않아도 될겁니다. 왜냐면 Push 메소드에서 만드는 새로운 노드는 
heap 영역에 만들어진다고 해도 그걸 가리키는 포인터는 각 함수의 스택메모리에 위치해서 다른 쓰레드가 접근할 수 없기 때문이었습니다. 

반면 TryPop은 시작부터 공통적으로 사용할 _heap에 접근해서 heap 영역에 있는 노드 객체에 접근하기 때문에 다른 쓰레드가 동시에 참조하는 문제가 생깁니다. 

코드를 순서대로 보면 

	bool TryPop(T& value)
	{
		++_popCount;
		// 함수에 들어오자 마자 일단 _popCount를 하나 늘립니다. 

		Node* oldHead = _head;

		while (oldHead && _head.compare_exchange_weak(oldHead, oldHead->next) == false)
		{
		}

		if (oldHead == nullptr)
		{
			--_popCount;
			// 여기서 oldHead 가 nullptr 일때 니까 원래 스택에 아무런 데이터가 없을때 입니다. 일단 TryPop을 나가니까 _popCount도 줄입니다.
			return false;
		}
		// 여기까지 진행된 메소드는 oldHead에 맨 앞에 있던 노드를 들고 있고 _head 는 한 칸 후퇴 했음으로 
		// 따로 떨어져 나온 노드를 확보한겁니다. 

		value = oldHead->data;
		TryDelete(oldHead);	
		// 이곳에 확보한 oldHead를 삭제하기 시도하는 함수를 따로 만들어서 실행해 주겠습니다. 
		return true;
	}


이어서 TryDelete 를 만들어 볼텐데 의사 코드로 적어 보면 이렇습니다. 
1) 데이터 분리
2) 카운트 체크 
3) 나 혼자면 삭제 

안에서 먼저 _popCount를 체크해서 1이라면 현제 TryPop에 접근한 쓰레드가 나 혼자라는 뜻이기 때문에 oldHead를 삭제 해도 괜찮은 상태로 보고 
delete 해줍니다. 

그런데 여기서 아 맞다 멀티 쓰레드 환경이면 _popCount == 1 이라는 조건문을 통과하고 delete 하는 중간에 또 다른 쓰레드가 접근해 버릴 수도 있지 않은가 
생각이 듭니다. 
여기서 함수가 실행되는 순서를 봐야 합니다. 인자로 받은 oldHead 라는 노드는 이미 CAS 를 통과한 후입니다. TryPop 에서 새로 pop 할 노드를 정할때 
그 때 _head가 가리키는 노드가 pop할 노드가 되고 CAS를 지난 다음은 _head는 이미 다음 pop할 노드를 가리키고 있습니다. 
즉 이때 _popCount가 1이라면 oldHead는 다른 쓰레드가 접근 할 수 없다는 말입니다. 
물론 이건 데이터를 먼저 분리(CAS) 하고 카운트 체크를 했기때문에 가능하고 혹시 순서를 바꿔서 카운트 체크부터하고 데이터를 분리하면 중간에 다른 쓰레드가 
끼어들 여지가 있을겁니다. 

일단 인자인 oldHead 는 삭제 할 것이기는 한데 이왕 혼자인거 삭제 예약했다던 리스트의 다른 데이터 들도 삭제해보면 좋을겁니다.  
그러기엔 먼저 설령 _popCount가 1인 상태로 들어 왔다고는해도 멋대로 지워도 되는지는 아직 모릅니다.  
어떻게 알 수 있냐면 먼저 pendingList를 함수내의 스텍메모리의 변수로 가져올겁니다. 이때 atomic의 메소드인 exchange를 사용할건데 
이 메소드는 Load와 Write가 동시에 되는것이었습니다. 원래 _pendingList은 스택변수로 가져오고 _pendingList는 nullptr로 write를 해주겠습니다. 

왜 _pendingList는 다시 체크 해야 했냐면 인자인 oldHead는 이미 데이터를 분리해둔 다음 _popCount를 체크했으니 삭제가 가능하였는데 
_pendingList는 그 사이에 다른 쓰레드가 다시 접근할 수 있는 상태이기 때문입니다. 그래서 위에서 스택 변수에 가져옴으로 인해 데이터 분리를 하였고 
그럼 다시 카운트를 또 체크해보면 삭제가 가능하다고 확신할 수 있을겁니다. 

구현하기 위해서 몇가지 헬퍼함수가 필요합니다. 
	void ChainPendingNodeList(Node* first, Node* last)
	{
		last->next = _pendingList;

		while (_pendingList.compare_exchange_weak(last->next, first) == false)
		{
		}
	}

	void ChainPendingNodeList(Node* node)
	{
		Node* last = node;
		while (last->next)
			last = last->next;

		ChainPendingNodeList(node, last);
	}

	void ChainPendingNode(Node* node)
	{
		ChainPendingNode(node, node);
	}

	// [ ][ ][ ][ ][ ]
	static void DeleteNodes(Node* node)
	{
		while (node)
		{
			Node* next = node->next;
			delete node;
			node = next;
		 }
	}

ChainPendingNodeList 시리즈는 만약 _pendingList를 삭제하려고 체크하는 도중에 다른 쓰레드가 끼어들었으면 분리했던 데이터를 제자리로 가져다 
놓기 위한 헬퍼함수입니다. 

DeleteNode는 다른 쓰레드가 끼어들지 않아서 _pendingList가 삭제 진행하기 위한 헬퍼함수 입니다. 

이 헬퍼 함수들은 LockFreeStack의 TryPop에서 또 이 DeleteNodes 라는 헬퍼함수 안에서 사용될 헬퍼함수들입니다. 
_popCount가 1일때 DeleteNodes안으로 들어온 oldHead를 삭제하는 김에 쌓여있던 _pendingList 의 데이터들을 삭제 가능한지를 살펴보고 있는것인데 

oldHead를 삭제 시도하는 함수를 의사코드로 적으면 이럴겁니다. 
1) _popCount가 1인지 아닌지를 체크 
2) _popCount가 1이면 3번으로, 아니라면 8번으로
3) 이왕 혼자서 참조하고 있는거 쌓여있는 _pendingList를 스택메모리의 node라는 변수로 분리해서 가져와 본다 
4) node를 분리하는 중에 다른 쓰레드가 끼어들었을지 모르니 다시 --_popCount == 0 인지를 체크한다 
5) --_popCount == 0 이라면 아직 다른 쓰레드가 끼어 들지 않았으니 node의 데이터들을 모두 삭제
6) --_popCount == 0 이 아니라면 중간에 다른쓰레드가 끼어들었으니 분리했던 node를 다시 _pendingList에 가져다 놓는다 
7) 일단 oldHead는 아무도 참조하고 있지 않은게 확실하니 삭제 하고 종료
8) 다른 쓰레드가 끼어들었으므로 oldHead 삭제를 미루고 _pendingList에 추가 후 --_popCount; 하고 종료



- 결과 및 정리 
이제 이 코드를 다시 테스트 해보겠습니다. 
Lock Free 방식으로 잘 구현 했음에도 약간 문제가 될 수 있는 부분이 있는데 Push를 sleep 없이 그냥 무한 루프로 밀어 넣는다고 하면 
Pop이 상대적으로 느리고 또 cout도 느린속도에 또 하나의 이유가 될수 있습니다. 그래서 Pop이 Push 되는 속도를 따라 잡지 못하고 
계속 데이터가 쌓일 수 있습니다. 

실제로 실행해보면 프로세스 메모리가 계속 늘어나는걸 볼 수 있습니다. 이건 버그가 나서 의도한대로 동작하지 않은게 아니라 
Push가 너무 빠르다 보니 생기는 문제입니다. 

일단 해결하는 방법은 Push에 sleep_for로 약간 지연시간을 주는 방법이 있겠습니다. 


이렇게 해서 락프리 프로그래밍을 맛보기로 조금 알아 봤습니다. 많이 연구되는 내용들 가운데 그나마 가장 단순한 방식을 실습해본겁니다. 

