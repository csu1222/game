

        Stomp Allocator

지난시간에 우리 강의에서 사용할 커스터마이징 가능한 베이스 얼로케이터를 만들어 봤고 기본 틀을 잡아 줬습니다.

이어서 오늘 배워볼 내용은 BaseAllocator다음으로 만들 Stomp Allocator 입니다. 
스톰프 얼로케이터는 버그를 잡는데 유용한 얼로케이터인데 특히 메모리 오염 버그가 C++ 프로그래밍에서 가장 골치가 아픈 버그입니다.
아무래도 C++은 메모리를 직접 조작하고 또 메모리 오염이 발생하자마자 크래시가 나지 않을 수도 있고 그래서 몇일 몇주동안 
많은 데이터가 오염이 되고 이후 나중에 사고가 터지면 언제서부터 문제였는지 알기도 힘들게 될 수 도 있기 때문입니다.

컴파일러도 못잡고 아무리 봐도 문제가 없어 보이는 코드이고 매우 위험한 상황이고 한 프로젝트에서 여러 사람이 맡았던 코드들 중 어느 
코드가 건들면 터지는 폭탄인지 모르는 상황에서 인력이 교체되고 하면 나도 모르게 밟으면 큰일나느겁니다. 
또 메모리 오염이 일어나면 코드가 예측범위에서 벗어납니다. 만약 메모리 오염으로 어떤 계정의 골드를 건드렸다고 하면 
그 골드량에 관련되어있던 코드들도 오동작을 하게 되고 우르르 문제가 될겁니다. 

C++을 처음 다뤄보면 그냥 조심하면 되겠지 하고 생각할 수 있는데 코드가 복잡해지고 여러 패턴에 의해 버그가 발생하게됩니다. 


-- 메모리 오염 개론 --
스톰프 얼로케이터를 배우기 전에 먼저 메모리 오염에 대한 개론을 살펴보고 시작하겠습니다.

가장 뻔한 케이스는 메모리를 해제한 다음 그 위치의 데이터를 사용하는것입니다. 

Knight* k1 = new Knight();
k1->_hp = 100;
k1->_mp = 10;
delete k1;
k1->_hp = 100;

코드로 읽기에는 당연히 k1을 delete 한 후 _hp에 접근하려고 하니까 크래시가 날것 같지만 실행해보면 의외로 그냥 통과 됩니다. 그래서 더 골치 아프기도 합니다.
delete k1; 이 줄에 중단점을 잡고 디버깅 실행을 하고 VS 의 디버깅 도구중에 메모리를 볼 수 있는 창이 있습니다. 그걸로 k1 의 메모리를 확인하면서 
한줄 실행을 하면 _hp와 _mp가 있던 부분의 메모리가 d로 쫙 밀립니다. 
그리고 나서 다음줄인 k1->_hp에 접근하는 부분을 또 실행하면 d로 밀렸던 부분의 메모리를 강제로 십진법으로는 100, 16진법으로는 64 라는 값으로 수정됩니다. 

delete를 했다고 메모리가 d로 쭉 밀리는것은 디버깅 모드이기 때문입니다. 실제 릴리즈 모드에서는 꼭 눈에 잘보이도록 d로 밀어주지 않기 때문에 
더욱 찾기가 어렵습니다. 또 지금은 delete를 한다음 바로 수정을 했으니 그냥 수정이 되었나 보다 할 수 있지만 
실제 게임처럼 멀티쓰레드 환경에서 실행되는 프로그램은 k1이 delete 되고 다음 코드가 실행되는 사이에 다른 쓰레드가 밀린 그 메모리를 사용할 수 있습니다. 
그러면 다른 용도로 사용하고 있는 메모리를 이제는 전혀 상관없는 값인 100으로 수정되면 큰일 일겁니다. 게다가 메모리 어디에 할당이 되는지는 컴퓨터에서 
적절히 정하고 있기 때문에 메모리 주소까지 일일히 지정해서 할수 없을 수 있습니다. 
이 경우를 Use-After-Free 라고합니다. 이게 첫번째 메모리 오염의 문제 입니다. 
어떻게 해결해야 할지 생각해보면 객체를 delete 한뒤 포인터를 nullptr 로 밀어주면 이후 포인터에 접근하면 nullptr에 접근한다고 크래시가 나면서 디버깅을 할 수 
있을것 같습니다. 하지만 이게 생각보다 쉽지 않은 문제인게 
지금처럼 k1이라는 포인터를 혼자서만 참조 하고 있는게 아니라 예를 들어 vector에 담아서 여러 포인터를 한번에 관리하고 있었다던가 아니면 다른 객체가 멤버 변수로 
들고 있다던가 하면 k1 삭제후 nullptr로 밀어줘도 그 주소를 들고 있는 다른 객체들이 있을수 있다는 겁니다. 
Use-After-Free 문제는 new, delete 에 대한 문제이고 이 문제를 해결하기 위한 방안으로 스마트 포인터를 배웠었습니다. 그래서 스마트 포인터를 사용하면 
문제를 해결할 수 있기는 합니다. 객체를 생성하면서 이 객체를 참조하는 포인터의 수를 카운팅하고 이 카운팅이 확실하게 0이 되었을때 진짜 delete를 하면
섣불리 delete로 해제된 메모리를 다른 용도의 데이터가 확보하지 못하게 될겁니다. 

이렇게 일단 Use-After-Free 문제를 해결했다고 하고 다음 메모리 오염문제 유형을 알아보겠습니다. 

강사님의 경험인데 서비스 중인 게임에서 딱 1바이트 오염이 자꾸 일어나서 2주정도 간격으로 계속 크래시가 났다고 합니다. 1바이트가 어떤 포인터가 참조하고 있던 메모리
주소값을 건드리고 있어서 이상하게 동작해서 일어나는 버그였다고 합니다.
대강 이런 코드였는데 
	vector<int32> v{ 1,2,3,4,5 };
	for (int32 i = 0; i < 5; i++)
	{
		int32 value = v[i];
		
		// TODO
		if (value == 3)
		{
			v.clear();
		}
	}
v라는 벡터를 순회하는 루프였고 그 안에서 원소값이 어떤조건에 걸리면 벡터 자체를 clear로 밀어주는 코드였다고 합니다. 원래는 이렇게 밀어준 다음 루프를 빠져 나와야하는데 
그 부분을 까먹은겁니다. 그렇게 되면 value가 3인 반복에서 v 자체가 밀리니까 4, 5 값들도 싹 사라졌을겁니다. 그런데 루프는 이미 없는 인덱스를 참조하려고 할겁니다. 
이후 그 아무것도 없는 부분을 그냥 읽기만 하면 상관없지만 또 반복문 내부에서 수정까지 했으니까 메모리 오염이 일어날겁니다. 
지금 위의 코드를 그냥 실행해보면 컴파일러에서 크래시를 내줄 확률이 높지만 실제 서비스하는 게임에서는 이런 문제를 컴파일러가 못잡아 내고 그냥 실행시켜버리는 
경우도 있다고 합니다. 

그리고 마지막으로 자주 등장하는 버그는 캐스팅 문제 때문에 발생하는 메모리 오염입니다. 
캐스팅이라고 하면 float 에서 int 로 캐스팅하는것도 있지만 클래스끼리 상속관계일때 도 캐스팅이 있습니다. 

class Player
{
public:
	Player() { }
	virtual ~Player() { }
};

class Knight : public Player
{
public:
        Knight() { }
        ~Knight() { } 
private:
        int32 _hp = 100;
        int32 _mp = 10;
}

int main()
{
        Player* p = new Player();
        Knight* k = static_cast<Knight*>(p);
}

이런 상황일때 일단 Player 객체를 만들었는데 나중에 왠지 Knight 클래스에서 사용가능한 스킬을 사용하고 싶어서 위와 같이 static_cast를 하였는데 이렇게 되면 
엉뚱한 메모리를 건드릴 수 있기때문에 문제입니다. 상위 클래스에서 하위 클래스로 캐스팅 하기 위해서는 dynamic_cast를 해야하는데 동작이 무겁기 때문에 
남발하지는 않습니다. 그래서 static_cast를 주로 사용하는데 문제는 p가 Player 였지 Knight가 아니었다는 겁니다. 
캐스팅후 _hp와 _mp를 건드리면 메모리 오염이 일어날것입니다. 처음 객체를 만들때 할당받은 메모리 보다 초과 해서 건드려야 하기 때문입니다. 
이때 크래시가 날수도 있고 안 날수도 있는데 아까 말했다시피 크래시가 안날때가 더욱 골치 아픕니다. 

이렇게 알아본 메모리 오염 사례들을 잡기 위해서 오늘의 주제인 Stomp Allocator 를 배워야 하겠습니다. 


-- Stomp Allocator -- 

스톰프 얼로케이터를 배우기위해서는 기본적인 운영체제의 메모리 관리에 대한 기초지식이 필요합니다. 운영체제에 대해 너무 깊히 들어가지는 않을겁니다.
이 부분이 대학을 다녀보지 못한 학원 출신 서버 프로그래머에게 취약한 부분입니다. 클라이언트에서는 게임 엔진에서 메모리 관리까지 잘 해주기 때문에 
신경 조금 덜 써도 되었지만 서버 프로그래머에게는 메모리 관리가 성능에 매우 중요한 부분을 차지 하다 보니 서버 프로그래머를 뽑을때 신경써서 뽑는 부분이라고 합니다.

// 가상 메모리 기본
int main
{
	int* num = new int;
	*num = 100;

	int64 address = reinterpret_cast<int64>(num);
	cout << address << endl;

	delete num;
}

위의 코드에서는 int를 동적할당한 포인터 num과 그 주소를 reinterpret_cast으로 포인터의 주소를 정수로 캐스팅 해 address라는 변수에 담았습니다. 
이때 만약 이 address 의 주소값을 전혀 다른 프로젝트를 하나 켜서 접근하고 또 수정까지 한다면 서로 다른 프로젝트에서 수정한 포인터의 값이 달라질까요?

정답은 아니다 입니다. 운영체제의 기본 내용인데 서로 다른 프로그램은 서로 간섭을 할 수 없습니다. 
왜 분명 주소를 기억해 건드리고 있는데 영향을 줄 수 없냐면 사실 address가 알려주는 주소가 실제 메모리 주소가 아니고 가상주소이기 때문입니다. 

그럼 가상주소가 있다는 것은 실제 주소도 있다는 말일겁니다. 물리적 부품인 렘에는 실제 주소가 부여 되어 있고 운영체제에의해서 어떤 프로그램을 실행하게 되면 
렘의 일정부분 들을 짜집기 해와서 해당 프로그램 내에서만 유효한 주소를 부여하는데 렘에서 공간을 짜집기 해오는데에는 크기도 순서도 상관없이 가져오기 때문에 
프로그래머가 굳이 주소를 노려서 건드리기는 쉽지 않을겁니다. 

그러면 왜 이렇게 조각조각의 메모리를 가져와서 가상메모리로 활용하는가 하는 생각이 듭니다. 왜냐면 이전 멀티쓰레드 시간에서도 알아 봤던 
유저 레벨, 커널 레벨과 관련있습니다. 
우리가 유저 레벨에서 여러 프로그램을 켜놓고 있다고 하겠습니다. 메모장, 크롬 브라우져, 비주얼 스튜디오 등을 실행하고 있고 
그리고 실상 이 프로그램들을 관리하고 있는것이 커널 레벨에서 관리해주고 있고 이 커널 영역을 움직이고 있는것이 OS 코드입니다. 


컴퓨터를 사용하면서 메모장을 사용하다가 괜히 크롬이 크래시가 난다거나 하는 상황이 일어나면 안될겁니다. 서로 메모리를 침범하면 안된다는 겁니다. 
그러면 해커들이 불법 프로그램을 설치하게 하면 이 컴퓨터 전체를 마음대로 수정할 수 있게 됩니다. 결국 운영체제에서 선택한 방법은 유저레벨의 프로그램은 서로 
침범할 수 없게 만든겁니다. 메모장, 크롬, 비주얼 스튜디오 는 서로 절대 침범할 수 없습니다. 하지만 가상메모리라는 방법으로 각 프로그램 내에서는 
이 컴퓨터의 렘이라는 장치를 그대로 가져다 사용한다는 착각을 하도록 만듭니다. 
그래서 설령 두 프로그램에서 어쩌다가 똑같은 주소를 사용하고 있다고 해도 실제 렘에서는 전혀 다른 위치를 사용하고 있는것입니다. 

이렇게 가상메모리가 무엇인지를 잠깐 알아보았고 운영체제를 더 깊히 알아볼것은 아니기 때문에 이제 다른 이야기를 할건데 

메모리를 관리할때 사용하는 여러가지 기법에 대해 알아볼겁니다. 

만약 우리가 2GB의 메모리를 사용한다고 해보겠습니다. 
그러면 이 2GB라는 메모리에 추가적으로 옵션을 줄 수 있습니다. 어느 부분은 읽기와 쓰기가 되고 어느 부분은 읽기는 되지만 쓰기가 안되고 하는등 
2GB 안에서도 영역을 찝어서 레벨을 관리할수 있다는 겁니다. 
근데 이 2GB 라는 메모리를 1바이트 단위로 세세하게 정책을 정해주려고 하면 적어도 정책을 정해주는 부분만 추가로 2GB라는 메모리가 필요할겁니다.
2GB의 메모리를 관리하기 위해 추가로 2GB를 사용한다는것은 말도안되는 낭비일겁니다. 
그래서 운영체제에서는 메모리를 관리할때는 페이지 단위로 관리한다고 합니다. 여기서 페이지는 4KB 정도의 크기라고 합니다.

페이지를 좀더 알기 쉽게 비유를 들자면 아파트 분양 조합이나 모델하우스를 가보면 아파트 완공도를 미니어쳐로 만들어서 보여줍니다. 
실제 아파트가 지어질 땅은 따로 있지만 아직 지어지지도 않았고 일일히 돌아다녀 살필 수도 없다 보니 축소해서 보여줍니다. 
이것과 비슷하게 2GB 라는 메모리를 4KB로 축소해서 이부분은 읽기만 가능하고 이부분은 읽기 쓰기가 가능하고를 묘사하는 것을 페이징이라고 합니다. 

페이징을 사용하는 이유가 정책(보안) 때문만은 아니고 여러 이유가 있다고합니다. 다른 이유는 운영체제를 배울때 알게 될것이고 
지금 우리 관심사는 보안정책을 페이징으로 관리한다는 것입니다. 

SYSTEM_INFO 라는 struct 객체에서 현재 기기의 정책을 확인할 수 있습니다. 
int main()
{
	
	SYSTEM_INFO info;
	
	::GetSystemInfo(&info);

	info.dwPageSize; // 4KB (0x1000) 페이지 크기
	info.dwAllocationGranularity; // 64KB (0x10000) 메모리 할당할때 배수

}
info 라는 SYSTEM_INFO 객체를 만들고 그 주소(포인터)를 GetSystemInfo 라는 시스템 함수에 주면 컴퓨터의 정보를 받아 옵니다. 
그리고 중단점을 잡아서 디버그 모드를 실행해보면 info안에 담긴 데이터를 살펴보면 실제로 dwPageSize는 4096 즉 4KB 이고 
dwAllocationGranularity는 64KB 임을 확인할 수 있습니다.

다음으로 알아볼 것은 지금까지 메모리 할당을 위해서 new delete 를 사용하고 있었는데 엄밀히 말해서 이 키워드는 C++의 표준 키워드이지 
운영체제의 키워드는 아닙니다. Windows 나 Linux 에서 new 라는 명령어를 사용해서 메모리를 할당하고 있지 않고 실제 사용하는 명령어가 따로 있다는 말입니다. 

윈도우에서는 그 메모리 할당과 해제를 하는 함수가 
::VirtualAlloc();
::VirtualFree();
이 두가지 함수입니다. 이게 무슨 역할을 하는지는 윈도우즈 문서를 확인하면 되는데 대강 알아보면 
VirtualAlloc 함수는 총 네가지 인자를 받습니다. 
첫번째로는 메모리할당 받을 시작 주소를 받습니다. 이 인자는 null값을 줘도 되는데 null을 주게 되면 알아서 
주소를 할당해 달라고 하는 셈입니다. 
두번째가 할당받을 메모리의 크기입니다. 우리가 ::malloc을 할때 주는 인자값이 이것과 같았습니다. 
세번째 인자는 AllocationType 이라고 해서 어떤식으로 요청을 할것인지를 고릅니다. 그 메모리 공간을 예약만 하고 나중에 실제 할당 받을것인지 아니면 
예약과 동시에 실제 할당까지 받을것인지 등등 여러 옵션이 있다고 할 수 있습니다. 예시로 만약 실제 할당과 예약을 동시에 하고 싶다면 
인자로 MEM_COMMIT | MEM_RESERVE 를 주면 된다고 합니다. 
마지막 네번째 인자로는 여러가지 보안 정책을 설정해 줄 수 있습니다. 말 그대로 할당받은 메모리를 읽기만 할것인지 읽기 쓰기 다 허용할 것인지를 설정 해줄 수 있습니다. 
VirtualFree는 첫번째로 Free 할 포인터를 주고 두번째로 Free 한 후의 남길 메모리 크기, 세번째로 그 메모리를 해제하려면 MEM_RELEASE를 사용합니다.

	int* test = (int*)::VirtualAlloc(NULL, 4, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	*test = 100;

	::VirtualFree(test, 0, MEM_RELEASE);	

이런식으로 사용하는데 기존의 new delete 와 다르게 여러 세부적인 옵션들을 설정해 줄 수 있습니다. 

왜 VirtualAlloc, VirtualFree 까지 사용해야 하느냐면 이 함수들은 운영체제에 직접 요청하는 함수입니다. 그래서 VirtualFree 이후 test의 값에 접근하게 되면 
바로 크래시가 납니다. 이게 아까와 다른겁니다. 아까는 크래시가 날 수도 안 날 수도 있고 그래서 메모리오염을 바로 못 잡아 더 큰일이 생길 수 있었습니다. 

new delete 는 실제로 운영체제에게 곧바로 메모리를 날려달라고 하지 않을 수도 있다는걸 역으로 알 수 있습니다. 
new delete 에서는 유동적으로 메모리를 관리합니다. 강의 초반에 메모리 할당을 널널하게 받는 것과 비슷합니다. 

그래서 VirtualAlloc, VirtualFree 같은 경우는 매번 엄밀하게 메모리를 할당 받고 해제를 하기 때문에 프로그램의 속도가 느려지지만 디버그 모드에서만 사용하여
메모리 오염을 잡아 낼 수 있다는 것을 활용해서 Stomp Allocator 를 만들어 보겠습니다.


-> 	Allocator 클래스 

	이전에 만들었던 BaseAllocator 다음으로 StompAllocator 클래스 코드를 작성할겁니다. 
	
	class StompAllocator
	{
		enum { PAGE_SIZE = 0x1000, };
	public:
		static void* Alloc(int32 size);
		static void		Release(void* ptr);
	};

	PAGE_SIZE라는 열거형이 추가 되었는데 ::VirtualAlloc의 두번째 인자로 할당 받을 메모리의 사이즈를 요청했었는데 스톰프 얼로케이터 내부적으로는 할당하는 메모리를
	페이지 단위로 관리하기 때문에 페이지 사이즈의 배수에 해당하는 메모리를 할당받습니다. 그런 페이지수를 쉽게 계산하기 위해 PAGE_SIZE를 활용할것입니다. 
	(아까 4의 크기로 넘겨 주었지만 사실은 4096바이트 만큼 할당 받았을 겁니다.)

	void* StompAllocator::Alloc(int32 size)
	{
		// 반올림 
		const int64 pageCount = (size + PAGE_SIZE - 1) / PAGE_SIZE;

		return ::VirtualAlloc(NULL, pageCount * PAGE_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	}

	void StompAllocator::Release(void* ptr)
	{
		::VirtualFree(ptr, 0, MEM_RELEASE);
	}

	정의부는 이렇습니다. 
	Alloc 에서 인자로 받은 할당 받을 메모리의 크기를 PAGE_SIZE 의 배수에 올림을 한 pageCount를 계산합니다. 
	그리고 아까 알아본 ::VirtualAlloc 에 각 인자들을 넣어줍니다. 

	Release 에서도 마찬가지로 알아 봤듯이 메모리 해제를 해줍니다. 


이제 BaseAllocator를 간편히 쓰려고 만들었던 매크로가 있는데 그부분도 수정해줘야합니다. 

-> 	CoreMacro

	
	/*===================
			Memory
	=====================*/

	#ifdef _DEBUG
	#define A_alloc(size)			StompAllocator::Alloc(size)
	#define A_release(ptr)			StompAllocator::Release(ptr)
	#else
	#define A_alloc(size)			BaseAllocator::Alloc(size)
	#define A_release(ptr)			BaseAllocator::Release(ptr)
	#endif

	디버그 모드일때 사용하는 얼로케이터를 스톰프 얼로케이터로 바꿔 줬습니다. 
	앞으로는 디버그 모드일때 매번 A_new, A_delete 때 할당과 해제를 해주게 될겁니다. 릴리즈 모드일때는 delete를 해도 실제로 메모리 해제 까지는 가지 않고 
	한 페이지 (4KB) 내의 데이터를 적당히 사용하다가 해제를 할 텐데 
	스톰프 얼로케이터를 사용하면서 얼마나 작은 메모리를 사용하더라도 4KB 씩 할당과 해제를 반복합니다. 

	그럼에도 개발 단계에서 메모리 오염을 잡아 줄 수 있다는 점에서 의미가 있을겁니다. 



이제 다시 GameServer.cpp 에서 테스트를 해볼 수 있습니다. Knight 객체를 우리가 만든 A_new, A_delete 연산자를 사용해서 생성과 소멸을 시킨다음 
Knight 객체의 데이터에 접근하는 테스트를 할건데 CoreMacro에서 StompAllocator를 사용할 때와 BaseAllocator를 사용할때를 비교할겁니다. 

베이스 에서는 잡아주지 못한 메모리 오염을 스톰프에서는 잡아 줄 수 있는 걸 확인 할 수 있습니다. 


이렇게 해서 스톰프 얼로케이터로 Use-After-Free 문제는 해결 하였는데 오버플로우 문제를 해결해주진 못하고 있습니다. 
오버플로우 문제는 클래스간의 캐스팅에서 생기는 문제인데 부모 클래스로 처음 생성한 객체를 하위 자식 클래스로 캐스팅하려고 할때 확장된 부분이 
유효하지 않은 메모리를 건드리는 문제입니다. 

Knight 클래스의 용량이 8바이트라고 하고 생성하면 4KB 크기의 할당된 메모리 안에 8바이트 짜리 객체가 어딘가 위치하게 됩니다. 이때 캐스팅을 통해 
오버 플로우가 된다고 하더라도 4KB의 널널한 메모리 안에서 일어나는 일이기 때문에 스톰프 얼로케이터가 이상함을 체크하지 못합니다. 
하지만 실제 프로그램 동작에서는 예상치 못한 버그가 발생할 수 있는 상황입니다. 

그러면 오버플로우 문제는 어떻게 잡아줄것인지를 알아볼건데 StompAllocator 코드를 조금 수정하면 해결가능한데 
메모리를 할당하고 객체를 만드는 주소가 메모리의 맨 앞에 위치하는게 아니라 메모리의 맨 뒤에 위치하도록 만드는 겁니다. 그러면 오버플로우가 일어나게 되면 
할당받은 메모리를 벗어나게 될겁니다. 하지만 조삼모사 처럼 반대로 언더 플로우 문제는 잡아 주지 못하게 되는데 
주로 오버플로우가 많이 일어나고 언더플로우 문제는 거의 일어 나지 않기 때문에 이런 식으로 임시 해결을 하는겁니다.

void* StompAllocator::Alloc(int32 size)
{
	// 반올림 
	const int64 pageCount = (size + PAGE_SIZE - 1) / PAGE_SIZE;
	const int64 dataOffset = pageCount * PAGE_SIZE - size;

	void* baseAdddress = ::VirtualAlloc(NULL, pageCount * PAGE_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	return static_cast<void*>(static_cast<int8*>(baseAdddress) + dataOffset);
}

dataOffset 이라는 변수는 메모리가 할당되는 크기에 생성될 객체의 크기만큼을 뺀 값입니다. 그 위치부터 객체를 생성하면 딱 메모리의 맨 뒤에 위치할겁니다. 

그리고 ::VirtualAlloc에서 반환되는 주소를 baseAdddress라는 변수에 받아줍니다. 이 주소는 할당한 메모리의 맨 앞주소를 반환할겁니다. 
이 두 변수 dataOffset 와 baseAdddress를 더한 주소를 반환하게 되면 이후 A_new 연산자에서 그 위치에 생성자를 호출할겁니다. 

그런데 return 뒤 코드에 static_cast가 두개 있습니다. 왜 그러냐면 가장 안쪽부터 살펴보면 dataOffset 은 int64 타입의 변수이고 baseAdddress는 
::VirtualAlloc의 반환 값이다 보니 void* 타입입니다. 둘 다 실제로는 2진법의 신호일테지만 데이터 타입에 따라 어떻게 해석할지가 변하고 
어떻게 연산할지가 변하다 보니 두 변수를 더할 수 있게 캐스팅을 해주는 겁니다. 또 int8* 로 캐스팅하는 이유는 주소를 가리킬때 1바이트 단위로 이동하여야
우리가 원하는 위치에 정확히 이동할수 있기 때문입니다. 계산이 끝났으면 원래대로 void* 로 캐스팅해 반환합니다. 


void StompAllocator::Release(void* ptr)
{
	const int64 address = reinterpret_cast<int64>(ptr);
	const int64 baseAddress = address - (address % PAGE_SIZE);
	::VirtualFree(reinterpret_cast<void*>(baseAddress), 0, MEM_RELEASE);
}

다음은 릴리즈 함수인데 함수를 릴리즈 할때도 릴리즈 시작 주소가 할당 받았던 메모리의 뒤쪽의 주소일겁니다. 하지만 릴리즈에는 할당 메모리의 시작주소를 
인자로 넘겨줘야 하기 때문에 계산을 해줘야 하는데요 

아이디어는 이렇습니다. 메모리를 할당할때 항상 dwAllocationGranularity 라는 시스템 인포 값의 배수로 주소를 할당한다고 했습니다. 이 값이 64KB 0x10000 
이라고 했는데 그 말은 또 PAGE_SIZE 로도 나누어 떨어진다는 말입니다. 

그래서 baseAdddress 에는 address라는 주소에다 PAGE_SIZE 를 나누고 남은 나머지를 빼면 메모리의 시작 주소를 알 수 있습니다. 
(저는 잘 이해가 가지 않아서 간단한 예시로 이해 했는데 총 0부터 120 까지의 주소가 있다고 하고 한 페이지를 4라고 하였습니다. 
그리고 넘겨 받은 인자의 주소를 55라고 해봤습니다. 그러면 55 - (55 % 4) 가 메모리를 할당받은 시작 주소라는 말일겁니다. 55 % 4 는 3이고 
55-3 = 52 라는 주소부터 메모리를 할당하였다고 볼수 있습니다. 이런 식으로 간략하게 예시를 들어 이해했습니다.

이렇게 스톰프 얼로케이터의 릴리즈도 만들어 봤습니다. 


여기까지 알아본 결과 스톰프 얼로케이터에도 여러가지 버전이 있다는걸 알수 있습니다. 객체를 할당할 주소를 어떻게 하느냐에 따라 오버플로우를 잡을수 있게 만들건지
아니면 언더 플로우를 잡을 수 있게 만들건지를 고를 수 있습니다.


-- 정리
오늘 배운 스톰프 얼로케이터라는 방법을 통해 정말 잡기 어렵고 터지면 또 대형사고를 치는 메모리 오염을 개발 단계에서 미리 잡을 수 있다는 걸 배웠습니다. 
메모리를 매우 낭비하는 방법이기는 하지만 실제 서비스때 고생하는것보다는 나은 해결책입니다.