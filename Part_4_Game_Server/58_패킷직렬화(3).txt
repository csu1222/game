


            패킷직렬화 (3)



지난시간까지 받은 버퍼의 내용을 복사해서 사용하는것이 아니라 버퍼자체를 포인터로 가르켜사용하면서 복사비용을 한번 줄이는 방법을 알아 봤습니다. 

읽는쪽은 이렇게 해봤지만 아직 쓰는쪽은 알아 보지 않았습니다. 쓰는것도 마찬가지로 복사해 쓰는게 아닌 곧바로 꽂아주는것이 가능하다고 합니다. 

*** 
-- ServerPacketHandler

오늘 작업은 ServerPacketHandler 파일에서 작업하긴 할건데 지난시간에 작업했던 ClientPacketHandler 파일에 있는 일부 코드들을 복붙해서 재사용할것입니다. 
가져갈것은 PacketIterator, PacketList 클래스들을 가져갈겁니다. 
지금은 손으로 복사하고 있지만 나중에 가면 다 자동화 처리를 해줄것입니다. 
그리고 ClientPacketHandler.cpp에 넣어놨던 PKT_S_TEST 라는 패킷 설계 구조체도 ServerPacketHandler쪽으로 복사 해줍니다. 

버퍼를 만들어주던 함수인 ServerPacketHandler::Make_S_TEST() 함수를 이제는 사용하지 않을것입니다. 과감하게 삭제해줍니다. 

이전에 버프들의 아이디와 남은시간을 따로 구조체로 관리하면서 vector에 담아 가변데이터를 버퍼에 넣고 있었는데 이 부분이 PKT_S_TEST안으로 들어 갔으니 
기존 구조체는 삭제합니다. 

그리고 PKT_S_TEST::Validate() 라는 함수는 받은버퍼중 고정 데이터의 크기가 PKT_S_TEST만큼이 맞는지 또 그 안에 적힌 가변데이터 헤더를 가지고 계산한 
전체 패킷의 길이와 패킷 헤더에 적힌 길이가 맞는지를 확인하는 함수였습니다. 
이 함수는 데이터를 받는쪽에서 필요한 함수다 보니까 데이터를 주는쪽인 ServerPacketHandler 에서는 필요없기 때문에 삭제합니다. 

그러면 이제 PKT_S_TEST는 앞으로 정말 패킷의 설계역할만 하도록 하고 따로 데이터를 쓰는 역할의 클래스 PKT_S_TEST_WRITE 라는 걸 따로 만들어 주었습니다. 
PKT_S_TEST_WRITE를 만들고 보니 GetBuffsList() 함수도 PKT_S_TEST에서는 없어도 될것같습니다. 삭제해줍니다. 

#pragma pack(1)
struct PKT_S_TEST
{
	struct BuffsListItem
	{
		uint64 buffId;
		float remainTime;
	};

	uint16 packetSize;
	uint16 packetId;
	uint64 id;
	uint32 hp;
	uint16 attack;
	// 가변길이 데이터를 묘사하는 데이터 
	uint16 buffOffset; // 가변길이 데이터가 시작하는 인덱스
	uint16 buffCount;
};

// 데이터를 쓰기 위한 클래스 
class PKT_S_TEST_WRITE
{
public:
	using BuffsListItem = PKT_S_TEST::BuffsListItem;
	using BuffsList = PacketList<PKT_S_TEST::BuffsListItem>;

	// 고정데이터들을 인자로 받는 생성자 
	PKT_S_TEST_WRITE(uint64 id, uint32 hp, uint16 attack)
	{
		// 이전 Make_S_TEST 에서 해주던 코드를 생성자에서 합니다. 
		_sendBuffer = GSendBufferManager->Open(4096);
		_bw = BufferWriter(_sendBuffer->Buffer(), _sendBuffer->AllocSize());

		// PKT_S_TEST를 예약해두고 커서는 가변 데이터의 시작 위치로 옮깁니다. 
		_pkt = _bw.Reserve<PKT_S_TEST>();
		_pkt->packetSize = 0; // 패킷의 전체 사이즈는 아직 채워줄 수 없습니다. to Fill
		_pkt->packetId = S_TEST;
		_pkt->id = id;
		_pkt->hp = hp;
		_pkt->attack = attack;
		_pkt->buffsOffset = 0; // 처음엔 일단 0으로 둡니다.
		_pkt->buffsCount = 0; // 버프의 갯수도 아직 모릅니다. 

		// 가변데이터가 개입될 부분은 아직 모르지만 일단 고정 데이터들은 생성자에서 채워줬습니다.
	}

	// 가변데이터인 BuffsList를 채워줄 함수
	BuffsList ReserveBuffsList(uint16 buffCount)
	{
		// vector나 list 같은 STL 컨테이너들은 실시간으로 각각의 데이터 들을 추가할 수 있었습니다.
		// 하지만 지금 버퍼를 채우는 방식에서는 실시간 데이터 추가는 어렵습니다. 
		// 가변길이 데이터가 두 종류만 되더라도 다른종류의 가변데이터가 섞이면서 문제가 됩니다.
		// 그래서 버퍼를 곧바로 채우는 방식에서는 이 함수처럼 가변데이터의 길이를 딱 지정한 다음 진행하는 경우가 많습니다.
		// BufferWriter::Reserve가 count를 받는 식으로 수정했습니다. 
		BuffsListItem* firstBuffListItem = _bw.Reserve<BuffsListItem>(buffCount);
		
		// 생성자때 채워주지 못했던 데이터를 채워줍니다.
		// buffOffset은 _pkt의 시작주소에서부터 가변데이터가 시작하는 주소까지의 인덱스 같은것이었습니다. 
		_pkt->buffsOffset = (uint16)firstBuffListItem - (uint16)_pkt;
		_pkt->buffsCount = buffCount;

		// 반환은 예약된 버퍼를 BuffsList로 만들어 반환합니다. 
		return BuffsList(firstBuffListItem, buffCount);
	}
    
	// 데이터들을 다 밀어 넣은 다음 마무리하는 함수
	SendBufferRef CloseAndReturn()
	{
		// 패킷 사이즈를 최종 계산 
		_pkt->packetSize = _bw.WriteSize();

		_sendBuffer->Close(_bw.WriteSize());

		return _sendBuffer;
	}

private:
	// 버퍼를 쓸데 필요한 객체들을 들고 있겠습니다.
	PKT_S_TEST* _pkt = nullptr;
	SendBufferRef _sendBuffer;
	BufferWriter _bw;
};
#pragma pack()

PKT_S_TEST_WRITE 에서는 Make_S_TEST에서 하던 작업을 합니다. 생성자에서 고정데이터인 PKT_S_TEST 만큼을 예약하면서 채워줄 수 있는 데이터들은 채워주고 
가변데이터와 관련된 데이터들은 이후 ReserveBuffsList 에서 채워줍니다. 또 ReserveBuffsList에서는 가변데이터의 갯수를 인자로 받아서 가변데이터의 총 크기만큼을 
예약해 반환합니다.

*** 

-- GameServer
여기까지 하고 한번 실습을 해보겠습니다. 

서버에서 클라이언트에 버퍼를 뿌리는 부분입니다.

	while (true)
	{
		// PKT_S_TEST_WRITE 객체를 만들어서 버퍼를 채웁니다. 
		PKT_S_TEST_WRITE pktWriter(1001, 100, 10);
		
		PKT_S_TEST_WRITE::BuffsList buffsList = pktWriter.ReserveBuffsList(3);

		buffsList[0] = { 100, 1.5f };
		buffsList[1] = { 200, 2.3f };
		buffsList[2] = { 300, 0.7f };

		// 여기까지 pktWriter로 고정데이터와 가변데이터까지 다 채운다음은 총 데이터 길이를 채워줍니다. 
		SendBufferRef sendBuffer = pktWriter.CloseAndReturn();

		GSessionManager.Broadcast(sendBuffer);

		this_thread::sleep_for(250ms);
	}

이전에는 여기서 SendBufferRef를 Open 하고 BufferWriter로 데이터를 쓸 범위를 집고나서 그 안에 들어갈 데이터를 따로 vector 객체롤 만든 후 for문을 돌면 다시 SendBufferRef에 
넣어줬습니다. 하지면 지금은 PKT_S_TEST_WRITE 객체를 만듬과 동시에 SendBufferRef 와 고정데이터를 집어넣고 가변데이터도 따로 객체에 복사하는 과정이 아닌 SendBufferRef의 범위에 포함되어있는
buffsList를 가지고 직접 집어넣습니다. 

당연히 이상태에서 실행을 해보면 제대로 동작합니다. 

하지만 찝찝한 부분이라고 하면 buffsList를 예약할때 갯수를 미리 정해두고 그것만 사용해야 하는것이 아쉽습니다. 

만약 가변길이 데이터가 지금처럼 한가지만 있는게 아니라 다중으로 등장한다고 해보겠습니다. 
 
*** 

-- 다중 가변길이 데이터

패킷 구조를 표현하던 XML 파일인 PDL로 다중 가변길이 데이터를 표현해보겠습니다.

<?xml version="1.0" encoding="utf-8"?>
<PDL>
	<Packet name="S_TEST" desc="테스트 용도">
		<Field name="id" type="uint64" desc=""></Field>
		<Field name="hp" type="uint32" desc=""></Field>
		<Field name="attack" type="uint16" desc=""></Field>
		<List name="buffs" desc="">
			<Field name="buffId" type="uint64" desc=""></Field>
			<Field name="remainTime" type="float" desc=""></Field>
			<List name="victims">
				<Field name="userId" type="uint64"></Field>
			</List>
		</List>
	</Packet>
</PDL>

왜인지 모르겠지만 buffs 라는 리스트 안에 다시 victims 라는 리스트가 들어있습니다. 상황을 풀어서 보면 버프들이 있고 그 버프들의 피해자를 또 리스트로 들고 있는것입니다. 
상황자체는 말이 안되는것 같지만 일단 실습을 위해 그렇다고 넘어가겠습니다. 

이제 이 다중 가변길이 데이터를 처리하기 위한 실습을 해보면서 이번시간에 작업한 버퍼를 직접 밀어넣는 방식의 단점에 대해 알아보겠습니다. 

위의 설계를 보면 위의 내용중 PKT_S_TEST 안에 BuffsListItem 이라는 구조체에서 각각 버프에 대한 id, remainTime 정보를 들고 있었는데 추가로 이 버프의 피해자를 리스트로 들고 
있을것입니다. 

하지만 현재 패킷설게에서는 맨앞에 고정길이 데이터와 패킷 자체의 헤더 그리고 뒤에 이어올 가변길이 데이터의 헤더를 두고 그 가변길이 데이터 헤더의 정보에 따라 이어서 가변길이데이터가 오도록 했었습니다. 


struct PKT_S_TEST
{
	struct BuffsListItem
	{
		uint64 buffId;
		float remainTime;

		// victims List
		uint16 victimsOffset;
		uint16 victimsCount;
	};

	uint16 packetSize; // 공용 헤더
	uint16 packetId; // 공용 헤더
	uint64 id; // 8
	uint32 hp; // 4
	uint16 attack; // 2
	uint16 buffsOffset;
	uint16 buffsCount;
};

이런식이 될겁니다. 그러면 간단하게 표현해보자면 

[PKT_S_TEST][BuffsListItem BuffsListItem BuffsListItem] 

이런형태였다가 victimsList가 추가되면 BuffsListItem 뒤에 victims의 헤더정보가 더 붙는다는것입니다. 


-- PKT_S_TEST_WRITE 

데이터를 만들 쪽 코드를 보겠습니다. 

PKT_S_TEST_WRITE 에서 victims 를 편하게 사용하기 위한 using을 추가합니다. 

using BuffsVictimsList = PacketList<uint64>; 

여기서 victims에 대한 크기를 따로 struct를 만들지 않고 임의로 64바이트 정도 크기를 지닌 데이터라고 가정하고 만들겠습니다. 

PKT_S_TEST_WRITE의 생성자, 또 ReserveBuffsList 에서는 기존의 고정데이터, 가변데이터를 만들고 있습니다. 
여기에 더해서 victims를 예약하는 함수를 하나 더 만들겠습니다. 

	BuffsVictimsList ReserveBuffsVictimsList(BuffsListItem* buffsItem, uint16 victimsCount)
	{
		uint64* firstVictimsListItem = _bw.Reserve<uint64>(victimsCount);
		buffsItem->victimsOffset = (uint64)firstVictimsListItem - (uint64)_pkt;
		buffsItem->victimsCount = victimsCount;

		return BuffsVictimsList(firstVictimsListItem, victimsCount);
	}

함수 원리는 ReserveBuffsList 와 비슷한데 좀 다른점은 인자로 BuffsListItem의 포인터를 받고 있는다는 것입니다. 
BuffsListItem은 고정데이터바로 뒤에 그대로 붙고 헤더도 PKT_S_TEST 객체인 _pkt안에 있기 때문에 _pkt에 직접 헤더 내용을 넣으면 되지만 
VictimsList의 헤더는 BuffsListItem 구조체 안에 있기 때문에 그 헤더를 채워주려면 인자로 받아야 합니다. 

다음은 이제 이 코드를 활용하는 쪽인 GameServer 코드를 볼 차례인데 조금 복잡하기때문에 주의해 알아보겠습니다. 

-- GameServer

	while (true)
	{
		// PKT_S_TEST_WRITE 객체를 만들어서 버퍼를 채웁니다. 
		PKT_S_TEST_WRITE pktWriter(1001, 100, 10);
		
		PKT_S_TEST_WRITE::BuffsList buffsList = pktWriter.ReserveBuffsList(3);

		buffsList[0] = { 100, 1.5f };
		buffsList[1] = { 200, 2.3f };
		buffsList[2] = { 300, 0.7f };

		// BuffsList를 하나씩 순회하면서 그 뒤에 victims의 가변길이 데이터를 만들어 줍니다.
		PKT_S_TEST_WRITE::BuffsVictimsList vic0 = pktWriter.ReserveBuffsVictimsList(&buffsList[0], 3);
		{
			vic0[0] = 1000;
			vic0[1] = 2000;
			vic0[2] = 3000;
		}
		PKT_S_TEST_WRITE::BuffsVictimsList vic1 = pktWriter.ReserveBuffsVictimsList(&buffsList[1], 1);
		{
			vic1[0] = 1000;
		}
		PKT_S_TEST_WRITE::BuffsVictimsList vic2 = pktWriter.ReserveBuffsVictimsList(&buffsList[2], 2);
		{
			vic2[0] = 1000;
			vic2[1] = 2000;
		}
		// 이런 식으로 리스트 안에 리스트를 만듭니다. 
		// 물론 좀 더 편하게 관리하고 싶으면 계층적으로 관리해서 PKT_S_TEST_WRITE 안에서 다 관리하는게 아니라
		// BuffsListItem 안에 Reserve 함수 같은걸 따로 만들어 주는게 좋을것입니다. 

		SendBufferRef sendBuffer = pktWriter.CloseAndReturn();

		GSessionManager.Broadcast(sendBuffer);

		this_thread::sleep_for(250ms);
	}

얼핏봐도 관리하기 힘들어 보입니다. 이 상태로는 사용하기에 위험할수 있습니다. 값을 손수 넣는 과정에서 엉뚱한 값을 넣는다거나 
Reserve를 안하고 데이터를 밀어넣는 실수를 할수도 있습니다. 그러니까 이 코드 자체가 직관적이지 않다는 것입니다. 

지금은 첫 실습인 만큼 가장 단순한 형태로 구현해도 이정도인데 가변데이터끼리 더욱 복잡해졌을때는 훨씬 문제가 될겁니다. 

성능과 개발 편의사이에 무엇을 중점에 둘지를 결정해야할것입니다.

이전시간에도 말했듯이 구글에서 만든 라이브러리중 FlatBuf 가 이런 방식입니다.
성능에서는 장점이 있고 사용하는것이 불편하다는것도 똑같습니다. 

오늘 만든 데이터 쓰기 코드와 대칭하도록 읽기 코드도 수정해 실습을 해보겠습니다. 

-- ClientPacketHandler
ClientPacketHandler의 PKT_S_TEST에서도 victims에 대한 내용을 추가해야합니다. 

#pragma pack(1)
struct PKT_S_TEST
{
	struct BuffsListItem
	{
		uint64 buffId;
		float remainTime;

		// 다중 리스트 
		uint16 victimsOffset;
		uint16 victimsCount;

		// BuffsListItem 내부에서도 사이즈 비교를 하고 잘왔는지를 bool로 반환하고 인자인 size에다가
		// 확인한 데이터 크기를 더해줄겁니다. 
		bool Validate(BYTE* packetStart, uint16 packetSize, OUT uint32& size)
		{
			// victims 까지 합한 데이터 사이즈가 packetSize보다 크다면 문제가 있습니다.
			if (victimsOffset + victimsCount * sizeof(uint64) > packetSize)
				return false;

			// 통과했다면 패킷의 사이즈에 더해줍니다.
			size += victimsCount * sizeof(uint64);
			return true;			
		}
	};

	uint16 packetSize;
	uint16 packetId;
	uint64 id;
	uint32 hp;
	uint16 attack;
	// 가변길이 데이터를 묘사하는 데이터 
	uint16 buffOffset; // 가변길이 데이터가 시작하는 인덱스
	uint16 buffCount;
	
	// 패킷의 내용이 정상적으로 처리되고 있는지를 확인하는 함수 
	bool Validate()
	{
		uint32 size = 0;
		size += sizeof(PKT_S_TEST);
		// 이 체크는 적어도 고정데이터들은 들어와 있는지를 확인
		if (packetSize < size)
			return false;

		// Buffs 가변데이터 크기 추가 
		if (buffOffset + buffCount * sizeof(BuffsListItem) > packetSize)
			return false;
		
		size += buffCount * sizeof(BuffsListItem);

		// BuffsList를 순회하면서 victims 데이터의 크기를 확인합니다. 
		BuffsList buffsList = GetBuffsList();
		for (int32 i = 0; i < buffsList.Count(); i++)
		{
			if (buffsList[i].Validate((BYTE*)this, packetSize, OUT size) == false)
				return false;
		}

		// 최종 크기 비교
		if (size != packetSize)
			return false;


		return true;
	}

	using BuffsList = PacketList<PKT_S_TEST::BuffsListItem>;
	using BuffsVictimsList = PacketList<uint64>;

	// BuffsList를 꺼내는 함수
	BuffsList GetBuffsList()
	{
		// PKT_S_TEST의 시작주소에 buffOffset 만큼을 더하면 가변데이터의 시작 주소입니다. 
		// BYTE* 가 1바이트짜리니까 uint16인 buffOffset을 더하면 주소가 나옵니다.
		BYTE* data = reinterpret_cast<BYTE*>(this);
		data += buffOffset;

		// 반환할때는 다시 PKT_S_TEST::BuffsListItem*로 캐스팅해서 PakcetList의 생성자에 넘겨줍니다.
		return BuffsList(reinterpret_cast<PKT_S_TEST::BuffsListItem*>(data), buffCount);
	}

	BuffsVictimsList GetBuffsVictimsList(BuffsListItem* buffsItem)
	{
		BYTE* data = reinterpret_cast<BYTE*>(this);
		data += buffsItem->victimsOffset;

		return BuffsVictimsList(reinterpret_cast<uint64*>(data), buffsItem->victimsCount);
	}
};
#pragma pack()

먼저 BuffsListItem 에 victimsOffset, victimsCount 를 추가하였고 이제 패킷의 사이즈를 체크하는 함수인 Validate의 코드도 수정했습니다. 
이전에는 BuffsListItem 사이즈만 체크하고 말았었지만 이제는 victims도 있기 때문에 사이에 코드를 더 넣었습니다. 
그 과정중에서 victims 만을 Validate 하는 함수도 BuffsLIstItem 구조체에 추가했습니다. 

이제 데이터를 읽는 역할의 함수 Handle_S_TEST도 수정합니다. 

void ClientPacketHandler::Handle_S_TEST(BYTE* buffer, int32 len)
{
	BufferReader br(buffer, len);

	// 버퍼의 데이터를 굳이 임시 객체에 복사하지 않아도 되지 않을까?

	// BYTE 배열인 buffer를 바로 캐스팅해서 PKT_S_TEST로 해석을 합니다.
	PKT_S_TEST* pkt = reinterpret_cast<PKT_S_TEST*>(buffer);

	// PacketSession::OnRecv를 지나오면서 일단 PacketHeader 만큼은 들어 있다고 보장할 수 있습니다. 
	// 그 헤더에 적힌 사이즈와 버퍼크기를 비교하기는 했는데 그게 오염되어 있는지는 확인해봐야합니다. 

	// Validate 에서 순서대로 고정데이터까지는 들어왔는지 들어왔다면 그 내용들을 가지고 가변데이터들 까지 제대로 들어왔는지를 
	// 확인합니다. 
	if (pkt->Validate() == false)
		return;

	// 여기까지 왔다면 일단 pkt 라는 포인터가 buffer에 있는 데이터들을 PKT_S_TEST로 해석합니다.

	// 그렇다면 이전처럼 가변데이터들도 굳이 새로 객체를 만들어 받아줄 필요없이 
	// 데이터들의 주소를 알수 있기때문에 곧바로 접근 할 수 있을겁니다. 
	// 데이터에 접근하기 편하게 헬퍼 클래스를 만들었습니다.

	// 가변데이터를 PacketList로 관리해 줍니다. 

	PKT_S_TEST::BuffsList buffs = pkt->GetBuffsList();

	// buffs는 buffer의 데이터를 복사한게 아닌 그냥 포인터로 가리키고 있는것입니다. 

	// 따로 꺼내 저장하는게 아닌 PacketList에 만들어둔 [] 연산자로 직접 접근할수 있게 됩니다. 
	cout << "BuffCount : " << buffs.Count() << endl;

	for (auto& buff : buffs)
	{
		cout << "Buff Info : " << buff.buffId << " " << buff.remainTime << endl;

		PKT_S_TEST::BuffsVictimsList victims =  pkt->GetBuffsVictimsList(&buff);
		cout << "Victims Count : " << victims.Count() << endl;
		for (auto& victim : victims)
		{
			cout << "Victim : " << victim << endl;
		}
	}
}

이런식으로 패킷을 읽어볼수 있게 해 줬습니다.

실제로는 매번 이렇게 보는게 아닌 PDL.xml 파일같은걸로 자동화 해서 함수들이나 기능들이 만들어지도록 해줘야 하는데 이것도 좀 까다롭습니다. 
이렇게 패킷 직렬화 FlatBuf 버전을 마치도록 하고 

다음시간부터는 구글 ProtoBuf 연동해 볼것입니다. 