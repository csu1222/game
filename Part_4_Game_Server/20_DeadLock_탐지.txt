

        DeadLock 탐지 


락의 순서가 꼬여서 발생하는 데드락 현상이 생각보다 빈번하게 발생합니다. 

실제 서비스에서 서버에 크래시가 나는 케이스중에서 
nullptr 체크를 누락하는게 가장 많은 경우이고, 데드락에 의해 상황이 꼬이는 경우도 top 5 안에는 드는 케이스입니다.

미리 예방하기 어려운 이유는 개발단계에서는 문제가 되지않던 코드가 라이브 서비스에 들어가서 문제가 되는 경우가 있기 때문입니다. 
원인만 판별이 된다면 버그를 잡는것은 어려운 축에 드는 작업이 아닙니다. 

그래서 결국 우리 서버 엔진에서도 데드락을 미리 탐지할 수 있는 기법을 도입하면 전반적으로 많은 도움이 되는데 
그 중에서도 여러 알고리즘이 있습니다. 

예를 들면 락 하이락키 라는 방법은 락마다 번호를 할당하고 일종의 구조를 직접 정의한 다음 락의 번호가 큰 숫자에서 작은 숫자로만 락을 걸수 
있다고 규정하는 방법이 있습니다. 
이 방법의 문제점은 처음부터 구조를 직접 정의하려면 미래에 만들 모든 구조를 다 예상하고 거기에 맞춰서 락들을 만들어야 한다는 것에 있습니다. 
구조 자체적으로 모순이 생길 수 있고 그 모순을 고치려면 또 더욱 많은 노력이 들어갑니다. 

이번에 알아볼 방법은 그래프를 응용해서 사이클을 판별하는 방법으로 데드락을 예방할것입니다. 

자료구조 파트때 알아봤던 그래프가 선수지식이기 때문에 간단하게 다시 복습해보겠습니다. 


-- 그래프 -- 

정점과 간선으로 이뤄진 자료구조인데 

정점 Vertex : 데이터를 표현
간선 Edge : 정점들을 연결하는데 사용 

그래프를 구성할 데이터들을 정점으로써 표현하고 각 정점들은 간선으로 이어져 있습니다. 
정점과 간선들에는 어디로 향하는지 방향을 정할 수도 있고 정하지 않을 수도 있습니다. 그리고 간선마다 가중치를 설정해서 정점사이에 이동하는 비용을 
표현할 수도 있습니다. 

그래프는 비선형 자료구조 이고 표현할 수 있는 것들이 굉장히 많습니다. 
선형 자료구조로는 물리세계의 모든 데이터를 표현할 수 없지만 비선형 자료구조인 그래프는 더욱 확장된 범위의 데이터를 표현할 수 있는데 

예를들어서 소셜 네트워크 관계도, 마인드맵, 지하철 노선도, 네비게이션 등이 있습니다. 

오늘 사용할 그래프는 방향 그래프입니다. 방향정보 까지 추가된 그래프입니다. 

그래프를 표현하는 방법은 여러가지 있지만 2차 배열을 사용해서 표현하는 방법이 일반적입니다.

vector<vector<int32>> adjacent = vector<vector<int32>>(
        {
                {0, 1, 0, 1, 0, 0},
                {1, 0, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 0},
                {0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 0},
        });

이런식으로 2차 배열로 표현을 하는데 읽는 방법은 adjacent[from][to]  순으로 읽으면 됩니다.
 예를 들어서 adjacent[0][1] 의 값이 1이라면 0번 정점에서 1번정점으로 정점이 이어져 있다는 것입니다. 

그리고 DFS (Depth First Search) 에 대한 내용도 복습해보자면 깊이 우선 탐색으로 탐색을 진행하는데 안으로 계속 파고드는 특성이 있습니다. 
자료구조 시간에 비유하기를 용감한 전사와 같다라고 했습니다. 이어져 있는 간선이 있으면 우선적으로 가보는 방법입니다. 

그래프는 리스트와 다르게 데이터를 순회하는 방법이 여러가지 있을겁니다. 각각의 아무 정점부터 순회를 시작할 수 있고 깊이 우선이냐 너비 우선이냐에 따른 
방법도 나뉠겁니다. 

DFS 의 코드는 전형적인 재귀적인 방식으로 만들어 집니다. 
어느 정점A에서 DFS를 시작하면 정점A와 인접한 모든 정점들을 찾습니다. 그리고 아직 그 정점을 방문하지 않았다면 인접한 정점에서 다시 DFS를 실행합니다. 
이게 DFS의 간단한 복습이었고 

그러면 DFS를 한번 돌리면 모든 정점을 순회할 수 있느냐? 그건 아닙니다. 인접한 정점들만 탐색하기 때문에 방향이 반대로 이어져 있거나 동떨어져있는 정점은 
발견할 수 없습니다. 그래서 모든 정점을 순회하고 싶다면 아예 모든 정점에서 DFS를 실행해야 합니다. 모든 정점에 실행하니 성능에 낭비가 있을것 같지만 
한번 방문한 정점은 외부에 기록을 해두어서 최대한 낭비를 줄이면 됩니다. 


이제 간단하게 알아본 이 그래프라는 자료구조로 어떻게 데드락을 판별하는 방법이 무엇이냐가 중요합니다. 

그래프의 사이클 판별이라는 분야를 봐야하는데 왜 사이클 판별을 알아야 하는지를 생각해보면 
그냥 그래프가 아니라 락을 거는 순서를 그래프로 표현했다고 해보면 그래프를 이루는 정점들은 각각 클래스라고 하겠습니다.
예를 들어서 0번 정점이 Player Manager, 1번 정점은 Account Manager 라는 클래스라고 하고 이 상태에서 Player Manager 객체에서 락을 잡은 상태에서 
Account Manager의 락을 중첩해서 잡았다고 하면 0번 정점에서 1번 정점으로 향하는 간선이 생긴 것이라고 표현할 수 있습니다. 

여기서 데드락이 발생하는 상황은 순서가 거꾸로 뒤바뀌는 상황이 있다고 했습니다. 현제 0번 이 락을 잡은 중에 1번 을 또 락을 잡고 있는 상태에서 
다른 코드에서는 1번이 먼저 락을 잡은 중에 0번을 같이 락을 잡으려고 하는 상황이 발생할 때 데드락이 발생하는겁니다. 
그런데 꼭 두 정점끼리 서로 락을 잡는 것만 문제 되는것은 아니고 0,1,2 번 정점이 있다고 하면 0->1->2->0 순으로 락을 잡고 있는 상태도 
사이클이 발생했다고 하고 또 데드락이 됩니다. 

결국 중요한 내용은 그래프의 사이클을 판별할 수 있으면 이걸 데드락의 탐지에 써먹을 수 있다는것입니다. 
이 판별법을 항상하는것은 아니고 디버그 모드에서만 사용하면 프로그램의 실사용 성능에 문제되는것도 없을겁니다.

그러면 사이클 판별은 어떻게 하는것인가?
DFS를 하면서 추가적인 정보를 남겨놓으면 됩니다. DFS가 좋은점이 순회를 하는것에 그치지 않고 동시에 이런 저런 정보를 남겨두면 유용하게 사용할 수 있습니다. 

DFS를 돌리게 되면 가장 깊이 까지 일단 들어가 보면서 대략적인 구조를 알아올 수 있는데 
세가지 용어가 새로 등장합니다. 
- 순방향 간선
- 교차 간선
- 역방향 간선
먼저 순방향 간선이 무엇이냐면 가장 일반적인 간선입니다. DFS 를 시작한 정점에서부터 정점을 발견해 나가는데 먼저 발견된 정점에서 나중에 발견된 정점으로 이어진
간선을 순방향 간선이라고 합니다. 
이제 이 순방향 간선이 아닌 간선이 교차간선이거나 역방향 간선이 됩니다. 

다른 예시로 왜인지 모르겠지만 3번 정점부터 DFS 를 진행하니 4번 정점을 발견하고 순방향 간선으로 이어져 있는걸 알게 되고 거기서 탐색이 끝났습니다. 
다음 DFS 시도로 5번 정점부터 시도하게 되는데 인접한 정점이 여기서도 4번 정점입니다. 
이러면 4번 정점은 3번 정점의 DFS 에서 이미 발견된 정점이기 때문에 5 -> 4 의 간선이 순방향간선은 아닙니다. 
그렇다는것은 교차간선이나 역방향 간선 둘 중 하나라는것인데 어떻게 판별이 되는것이냐면 
3번부터 시작된 DFS에서 3번 정점과 4번 정점을 하나의 그룹으로 묶이게 되는데 다른 DFS 에서 시작된 다른 그룹에 의해 발견되었으면 교차 간선이라고 합니다. 
그래서 5 -> 4 이 간선은 교차간선이 되는겁니다. 
교차간선은 남이 먼저 발견한 정점을 나중에 발견한 것이라고 할 수 있습니다. 이 경우는 딱히 사이클이 발생한 상황이 아닙니다. 

마지막 역방향 간선이 진짜 사이클이 발생한 상황이라고 할 수 있습니다. 
이번 예시에서는 0번 정점에서 DFS를 돌렸을때는 0 -> 1, 0 -> 3 이렇게 연결이 되었고 그런데 1번 정점을 기준으로 DFS를 돌리면
1 -> 0 , 1 -> 3 이렇게 연결이 되어있다고 하겠습니다. 
그런데 이중에 방문한 순서를 생각해보면 0번을 방문하고 1번을 방문했는데 1번을 발견하고 0번을 발견하는 간선도 있습니다. 
발견한 순서대로 간선이 이어지는게 아니니 교차간선이거나 역방향 간선일겁니다. 그런데 같은 그룹이 아닌 정점에서 부터 연결되고 있는 간선이라면 교차간선이지만 
지금은 그게 아니라 아직 그룹이 확실히 정해진게 아니라 DFS를 재귀적으로 탐색하고 있는 도중에 발견한것이고 이것이 역방향 간선이라고 합니다. 
또 역방향 간선이 사이클이 발생했다고 할 수 있습니다. 

그래서 그래프 사이클 판별 알고리즘에서는 DFS를 실행하면서 두가지 정보를 추적해야 하는데 
- 방문한 순서를 추적하는 데이터 
- DFS 사이클이 끝나서 정리가 된 그룹인지, DFS 사이클 중에 발생한 상황인지를 체크하는 데이터
이 알고리즘을 가지고 사이클이 발생하였는지를 판별하고 그걸 락의 구조에 적용해서 데드락을 판별하는 것까지 코드로 구현해볼겁니다. 


- 코드 

새로 추가할 클래스는 ServerCore 프로젝트 아래 Thread 필터 아래에 DeadLockProfiler 라는 이름의 클래스를 추가해줄겁니다. 
이 클래스가 할 일은 Lock 객체를 만든후 WriteLock 이나 WriteUnlock을 할때 DeadLockProfiler 코드를 끼워넣어서 디버그 모드일때는 락의 정보를 
넘겨 받아서 그래프 알고리즘을 체크해서 데드락이 발생하는지를 체크할겁니다. 

->      DeadLockProfiler

        // 헤더 파일 
        
        class DeadLockProfiler
        {
        public:
                void PushLock(const char* name);
                void PopLock(const char* name);
                void CheckCycle();

        private:
                void Dfs(int32 index);
        private:
                unordered_map<const char*, int32>	        _nameToId;
                unordered_map<int32, const char*>	        _idToName;
                stack<int32>					_lockStack;
                map<int32, set<int32>>				_lockHistory;

                Mutex _lock;

        private: 
                vector<int32>	        _discoveredOrder;	// 노드가 발견된 순서를 기록하는 배열
                int32		        _discoveredCount = 0;	// 노드가 발견된 순서
                vector<bool>	        _finished;		// Dfs(i)가 종료되었는지 여부
                vector<int32>	        _parent;
        };

        헤더 코드는 이렇습니다. PushLock, PopLock 에서는 락을 받아오거나 팝을 할때 어떤 락에 대한것인지를 구분 할 수 있어야 겠습니다. 
        그래서 락을 구별 할 수 있는 이름, 아이디를 받습니다. 나중에는 락의 아이디를 따로 타입을 만들어서 관리할 수도 있고 아니면 
        지금처럼 문자열이 아닌 int 형 으로 아이디를 관리할 수도 있지만 일단 지금은 문자열 타입으로 락의 아이디를 관리하겠습니다. 

        다음 CheckCycle은 실제 사이클이 일어났는지 아닌지를 판별할 함수입니다. 이어서 Dfs를 시작하는 함수를 정의하고 

        멤버 변수로는 그래프 알고리즘을 실행하기 위해 필요한 데이터들을 들고 있을겁니다. _nameToId, _idToName은 서로 락의 이름으로 찾으면 그 락의 
        번호를 받아오던지 아니면 락의 번호로 찾으면 그 락의 이름을 받아오도록 하는 데이터입니다. 
        _lockStack은 락이 실행되는걸 스택으로 추적해줄겁니다. _lockHistory는 어떤락이 몇번 몇번째 락을 잡았는지 추적해줄겁니다. 
        아까 그래프에서 0번 락이 1번락을 잡았다라고하면 0번에서 1번으로 향하는 간선이 만들어 지게될것인데 그 간선에 해당하는 정보를 _lockHistory로 관리할겁니다. 
        _lock은 멀티쓰레드 환경에서 안전하게 동작하게끔 락을 하나 잡을겁니다. 

        따로 private 를 나눠서 또 멤버 변수가 있는데 이부분은 사이클을 판별하는 알고리즘을 돌리기 위한 임시적인 데이터들을 모아두는겁니다. 사이클을 돌릴때 마다
        초기화해서 사용할 변수들입니다. 
        _discoveredOrder라고 하는것은 사이클을 판별하기 위해서는 접근한 순서를 추적해야 했었는데 그것입니다. 
        _discoveredCount는 노드가 발견된 순서를 추적하기 위해 카운팅을 해줄겁니다. 
        _finished는 i번째 락에서 시작하는 Dfs(i) 가 종료되었는지를 추적할것이고 
        _parent는 나를 발견한 부모 정점이 누군지를 추적할것입니다.

        그러면 이제 멤버 함수들을 하나씩 살펴볼건데 차례대로 PushLock부터 보겠습니다. 
        
        // cpp 파일
        
        void DeadLockProfiler::PushLock(const char* name)
        {
                LockGuard guard(_lock);

                // 아이디를 찾거나 발급한다.
                int32 lockId = 0;

                auto findIt = _nameToId.find(name);
                if (findIt == _nameToId.end())
                {
                        lockId = static_cast<int32>(_nameToId.size());
                        _nameToId[name] = lockId;
                        _idToName[lockId] = name;
                }
                else
                {
                        lockId = findIt->second;
                }

                // 잡고 있는 락이 있었다면 
                if (_lockStack.empty() == false)
                {
                        // 기존에 발견되지 않은 케이스라면 데드락 여부를 다시 확인한다.
                        const int32 prevId = _lockStack.top();
                        if (lockId != prevId)
                        {
                                set<int32>& history = _lockHistory[prevId];
                                if (history.find(lockId) == history.end())
                                {
                                        history.insert(lockId);
                                        CheckCycle();
                                }
                        }
                }
                
                _lockStack.push(lockId);
        }
        가장먼저 락 가드를 잡아줍니다. 
        그리고 인자로 받은 락의 이름을 가지고 찾거나 처음이라면 발급을 합니다. auto findIt = _nameToId.find(name) 으로 찾은 findIt가 end가 아니라면 이미 한번 발급을 했었다는 
        말이고 그러면 바로 lockId에 값을 넣어주면 되지만 findIt이 end() 이터레이터 라면 처음 등록하는 Id 라는것입니다. 
        발급은 _nameToId 의 사이즈를 int32 로 캐스팅해서 아이디로 발급하였습니다.

        일단 아이디를 찾았거나 발급을 받았으면 이미 잡고 있는 락이 있는지를 체크할겁니다. 현재 잡고있는 락을 _lockStack에 담아둘건데 이게 empty() == true 라면 잡고있는 락이 없다
        는 말이고 그러면 그냥 락을 잡아주면 되니 _lockStack.push(lockId)를 해줍니다.
        empty() == false라면 이미 어디선가 락을 잡고있다는 말입다. _lockStack의 top 을 prevId 라고 꺼내서 lockId와 비교하고 있는데 이 두 값이 같다면 같은 락안에서 또 같은 락을
        건겁니다. 이말이 무엇이냐면 하나의 락을 중첩해서 잡는 중인것이고 이건 그냥 LockCount만 늘리고 진행해었습니다. 그래서 그냥 통과 시키면 됩니다.
        반면 lockId와 prevId 가 같지 않다면 이건 먼저 락이 걸린중에 다른 락을 또 걸고 있다는 것입니다. 이럴때는 _lockHistory[prevId] 의 값을 체크해서 
        혹시 이전에 같은 순서로 락을 잡았던 적이 있는지를 체크합니다. 예전에 한번 잡아봤고 통과했다는것은 이번시도에도 문제 없이 통과할것이라는 말이되기 때문에
        만약 이전에 이 순서로 락을 잡았던 적이 없다면 history에 추가를 하고 사이클이 잡혔는지 테스트하는 멤버 함수인 CheckCycle 를 호출합니다. 

        PushLock을 첫 순서로 알아봤는데 이해가 잘 안갈 수 있습니다. 왜냐면 이후로 알아볼 코드들이 유기적으로 연결되어 있기 때문에 중간중간 이가 빠져있기 때문입니다. 
        일단 대충 이런 구조인것을 기억한다음 전체 코드를 보고 다시 복습할때는 더욱 잘 이해가 갈것입니다. 

        CheckCycle을 보기 전에 함수 선언한 순서대로 PopLock부터 보겠습니다. 
        
        void DeadLockProfiler::PopLock(const char* name)
        {
                LockGuard guard(_lock);

                if (_lockStack.empty())
                        CRASH("MUTIPLE_UNLOCK");

                int32 lockId = _nameToId[name];
                if (_lockStack.top() != lockId)
                        CRASH("INVALID_UNLOCK");

                
                _lockStack.pop();
        }
        기본적으로 _lockStack의 top을 pop 해주려는게 목적입니다. 하지만 멀티쓰레드에서 안전하게 동작하기 위해서 몇가지 추가하고 체크할게 있는데 먼저 락가드를 걸어야 합니다. 
        그리고 나서 _lockStack.pop() 을 하려고 하는데 만약 _lockStack이 비어있다면 이상사태이겠습니다. 그래서 그럴때는 크래시를 내주고 또 pop하려는 락의 이름을 인자로 받아서
        _nameToId에서 검색해 가져옵니다. lockId 라는 변수에 담을건데 이 lockId와 _lockStack.top() 이 같지 않다면 PopLock하는 순서가 꼬인것입니다. 그러므로 크래시를 내주고 
        다 통과했다면 정상적으로 pop할 수 있는 상태이니 _lockStack.pop() 을 해주고 끝납니다. 

        이제 사이클을 판별하는 주요 함수인 CheckCycle을 보겠습니다. 
        void DeadLockProfiler::CheckCycle()
        {
                // 사이클 체크에 필요한 중간 임시 변수들을 초기화
                const int32 lockCount = static_cast<int32>(_nameToId.size());
                _discoveredOrder = vector<int32>(lockCount, -1);
                _discoveredCount = 0;
                _finished = vector<bool>(lockCount, false);
                _parent = vector<int32>(lockCount, -1);

                for (int32 lockId = 0; lockId < lockCount; lockId++)
                        Dfs(lockId);

                // 연산이 끝났으면 정리한다
                _discoveredOrder.clear();
                _finished.clear();
                _parent.clear();
        }
        일단 _lockStack에 몇개의 락이 들어있는지를 lockCount에 캐스팅해서 받았습니다. 그리고 _discoveredOrder, _parent는 lockCount의 크기에 -1이라는 값을 가진 
        vector로 초기화를 했습니다. 둘 다 -1이라면 아직 발견하지 못한 락인것이고 값이 0이상이 되면 각각 데이터가 들어가있는것입니다. 
        _discoveredCount는 이제 탐색이 시작할 것이니 0, _finished도 이제 시작하니까 모든 값이 false 부터 시작할겁니다. 
        CheckCycle 을 실행할때마다 위의 임시 데이터들은 초기화가 될겁니다. 
        
        그리고 나서 이제 Dfs를 모든 락에 대해 실행을 해줄것입니다. 

        연산이 끝났으면 임시데이터를 정리해주는 코드를 실행해 주면서 끝납니다. 
        
        이렇게 3가지 부분으로 나뉩니다. 1) 변수 초기화, 2) 연산, 3)변수 정리

        다음은 Dfs를 보겠습니다. 
        
        void DeadLockProfiler::Dfs(int32 here)
        {
                // 이미 방문한 상태이면 바로 리턴
                if (_discoveredOrder[here] != -1)
                        return;

                // 여기 부터 아직 방문하지 않은 상태

                // 방문하고 있는 정점에 순번을 매기면서 카운팅도 같이 하고 있습니다.
                _discoveredOrder[here] = _discoveredCount++;

                // 모든 인접한 정점을 순회한다. 인접한 정점은 _lockHistory 기록됩니다.

                
                auto findIt = _lockHistory.find(here);
                // _lockHistory에 기록된 정점이 없다면 처음 으로 등록된 락 
                if (findIt == _lockHistory.end())	
                {
                        _finished[here] = true;
                        return;
                }

                // 여기부터는 다른 락이 걸려있는 상태에서 다시 락이 걸린 경우 
                // 사이클을 판별해야함

                set<int32>& nextSet = findIt->second;
                for (int32 there : nextSet)
                {
                        // 아직 방문한 적이 없다면 방문한다.
                        if (_discoveredOrder[there] == -1)
                        {
                                _parent[there] = here;
                                Dfs(there);
                                continue;
                        }

                        // here가 there 보다 먼저 발견되었다면, there는 here의 후손이다.(순방향 간선)
                        if (_discoveredOrder[here] < _discoveredOrder[there])
                                continue;

                        // 순방향이 아니고 Dfs(there)가 아직 종료하지 않았다면, 
                        // there는 here의 선조이다.(역방향 간선)
                        if (_finished[there] == false)
                        {
                                printf("%s -> %s\n", _idToName[here], _idToName[there]);

                                int32 now = here;
                                while (true)
                                {
                                        printf("%s -> %s\n", _idToName[_parent[now]], _idToName[now]);
                                        now = _parent[now];
                                        if (now == there)
                                                break;
                                }
                                CRASH("DEADLOCK_DETECTED");
                        }
                }

                _finished[here] = true;
        }

        Dfs() 의 내용이 은근히 길고 복잡해 보입니다. 그래도 차근차근 해석해 보겠습니다. 
        가장 먼저 조건문으로 걸러주고 있는것은 인자로 받은 정점의 번호로 이 락을 이전에 Dfs로 탐색한적이 있는지를 체크하고 있는데 
        한번 CheckCycle을 할때마다 락을건 순서대로 _discoveredOrder에 값을 1부터 차례대로 부여받을 것입니다. 그러므로 값이 -1 이 아니라면 이미 탐색을 마친 
        락이라는것이기 때문에 바로 리턴으로 넘겨줍니다. 

        첫 조건문을 통과한 락들은 아직 방문하지 않은 정점이란것입니다. 방문을 했다는 의미로 _discoveredOrder[here]에 값을 채워줄건데 _discoveredCount++ 로 
        1부터 값을 채워줌과 동시에 카운팅도 하고 있습니다. 

        그리고 나서 인접한 정점들을 순회하는데 인접한 정점들이라는것은 PushLock을 하면서 _lockStack.top() 에 있는 락의 번호가 가장 오래된 push 된 락일것인데
        이 락의 아이디를 _lockHistory에서 탐색해 가져온 set<int32> 입니다. 이걸 history라고 부른다면 여기에는 PushLock을할때 이미 어떤락이 잡혀있다면 
        history에서 한번 찾아보고 없다면 insert후 CheckCycle을 하였었습니다. 

        Dfs에서 인접한 정점들을 순회하는것은 현재 Dfs를 실행하고 있는 락, 정점인 here를 가지고 _lockHistory.find(here) 한 이터레이터 findIt 을 만들고
        만약 이 findIt이 _lockHistory.end() 라면 인접한 정점이 없는것이니 Dfs가 끝났다는 의미로 _finished[here]를 true 로 바꾸고 리턴합니다. 
        이게 아니라면 인접한 정점이 있는 상황입니다. 여기부터는 사이클 판별을 해야하는데 

        findIt.second는 인접한 정점들이 있는 set<int32> 입니다. nextSet이라는 이름의 변수로 받아준다음 이 nextSet을 순회할겁니다. 
        for (int32 there : nextSet) 이렇게 순회를 할건데 there에 해당하는 정점을 이전에 방문한적이 있는지 없는지를 먼저 체크해야합니다. 
        만약 아직 방문한적이 없다면 _parent[there] = here; 로 저장한 다음 방문합니다. 방문한다는것은 Dfs(there) 로 재귀적 함수를 실행한다는것입니다. 

        반면 방문을 한적이 있다면 현재 here가 there보다 먼저 방문했는지를 알아보면 이게 순방향 간선인지 아닌지를 알 수 있습니다. 
        누가 먼저 방문했는지를 체크하려면 _discoveredOrder 를 확인하면되는데 _discoveredOrder에는 PushLock을 한 순서대로 번호가 매겨지는데 즉 
        누가 먼저 락을 걸었는지가 기록되어 있습니다. here가 there보다 값이 작다면 here가 먼저 락을 걸고 난 다음 there가 락을 거는 상황이고 이것은 순방향 간선입니다.
        그러면 그냥 continue을 해주면 되고 아니라면 그때 부터 순방향 간선이 아닌 교차간선이거나 역방향 간선이라는 말입니다. 

        이중에 역방향 간선을 판별하면 이게 데드락 상황일건데 역방향 간선과 교차간선의 차이는 Dfs가 Dfs가 종료된 다음 한 그룹이 묶인 다음 이 정점을 방문한것인지 
        아니면 Dfs가 실행중에 이 정점을 방문한것인지의 차이입니다. Dfs가 끝났는지 여부는 _finished 라는 vector<bool> 이 추적을 하고 있었기 때문에 알 수 있습니다. 
        만약 _finished[there] 가 true 라면 이미 Dfs가 끝나서 이미 방문된 정점을 다른 그룹의 정점에서 가리키고 있는 상황입니다. 이건 문제 되지 않기 때문에 그냥 통과합니다.
        문제가 되는것은 _finished[there] 가 false 일때 입니다. 이 때는 Dfs가 완료되기 전에 역방향 간선이 생기고 있다는 말이기 때문에 CRASH를 냅니다. 

        그리고 중간에 리턴되거나 크래시가 나지 않았다면 _finished[here] = true 를 해줘서 무사히 Dfs가 끝났음을 기록합니다. 


이렇게 DeadLockProfiler를 만들어 줬는데 그럼 이걸 어떻게 사용할 것이냐면 이전에 RW spin 락을 만들어 줬었는데 그 클래스로 가보겠습니다. 

->      Lock 클래스

        Lock 클래스의 락, 언락 함수들 4가지가 있었습니다. 
        WriteLock, WirteUnlock, ReadLock, ReadUnlock 이 함수들을 만들었을때는 인자없는 버전으로 만들었었는데 이번에 DeadLockProfiler 에서 락마다 구별을 할 수 있게
        const char* 타입의 문자열을 받기로 했었습니다. 그래서 위 4가지 함수들도 내용을 고쳐주겠습니다. 

        void WriteLock(const char* name);
	void WriteUnlock(const char* name);
	void ReadLock(const char* name);
	void ReadUnlock(const char* name);

        정의부에서는 각 함수가 시작할때 DeadLockProfiler 을 실행 해줄건데 그것도 디버그 모드 일때만 실행해줄겁니다. 

        하지만 먼저 DeadLockProfiler 객체를 전역으로 사용할 수 있게끔 만들어 주고 싶습니다. ThreadManager 처럼 CoreGlobal 에서 만들어 주겠습니다. 
        ->      CoreGlobal
                // 헤더 파일 추가 사항
                extern class DeadLockProfiler* GDeadLockProfiler;
                
                // cpp 파일 추가 사항 
                #include "DeadLockProfiler.h"
                
                DeadLockProfiler* GDeadLockProfiler = nullptr;
                
                class CoreGlobal
                {
                CoreGlobal()
                {
                        GThreadManager = new ThreadManager();
                        GDeadLockProfiler = new DeadLockProfiler();
                }
                ~CoreGlobal()
                {
                        delete GThreadManager;
                        delete GDeadLockProfiler;
                }
                }
        
        이제 Lock 함수에는 시작할때 
        #if _DEBUG
	GDeadLockProfiler->PushLock(name);
        #endif
        이 코드를 추가하고 

        Unlock 함수들에서는 
        #if _DEBUG
	GDeadLockProfiler->PopLock(name);
        #endif

        추가해주었습니다. Read락도 추가해주는것은 상호배타적 락은 은 아니지만 락을 거는 순서를 추적하는것이기 때문이고 
        그리고 디버그 모드에서만 실행하도록 하는것은 락을 걸때 데드락을 체크하기 위해 DeadLockProfiler안에서 다시 락을 거는 불필요한 과정은 디버깅할때만 허용하고 
        릴리즈에서는 좀더 속도가 빠르게 하기 위해서 입니다. 

        DeadLockProfiler 객체를 전역으로 만들지 않고 각 쓰레드마다의 TLS에 만들어 준다면 DeadLockProfiler에서 락가드를 굳이 걸어주지 않아도 되지만
        대신 그럴때는 쓰레드 간의 락이 병합되어 관측되지 않다보니까 뒤늦게 데드락을 발견하게 될겁니다. 

        락 자체의 시그니처가 변경되었으니 락가드도 수정할 내용들이 있습니다. 
        class ReadLockGuard
        {
        public:
                ReadLockGuard(Lock& lock, const char* name) : _lock(lock), _name(name) { _lock.ReadLock(name); }
                ~ReadLockGuard() { _lock.ReadUnlock(_name); }
        private:
                Lock& _lock;
                const char* _name;
        };

        class WriteLockGuard
        {
        public:
                WriteLockGuard(Lock& lock, const char* name) : _lock(lock), _name(name) { _lock.WriteLock(name); }
                ~WriteLockGuard() { _lock.WriteUnlock(_name); }
        private:
                Lock& _lock;
                const char* _name;
        };

        락가드 생성자가 이제는 const char* name 을 같이 받아주고 멤버 변수 _name에 저장할겁니다. 

거기에 락가드를 매크로로 만들어 사용하고 있었다보니 CoreMacro도 수정해야합니다. 

->      CoreMacro
        
        #define USE_MANY_LOCKS(count)	Lock _locks[count];
        #define USE_LOCK				USE_MANY_LOCKS(1)
        #define	READ_LOCK_IDX(idx)		ReadLockGuard readLockGuard_##idx(_locks[idx], typeid(this).name());
        #define READ_LOCK				READ_LOCK_IDX(0)
        #define	WRITE_LOCK_IDX(idx)		WriteLockGuard writeLockGuard_##idx(_locks[idx], typeid(this).name());
        #define WRITE_LOCK				WRITE_LOCK_IDX(0)

        typeid(this).name() 이라는 코드로 name 부분에 인자로 넣어주고 있는데 
        우선 우리가 만들 락은 클래스 내부에서 기생해 사용하는 형태로 사용하고 있었습니다. 그럴때 이 typeid 코드는 객체의 이름을 간략하게 얻어오는 코드로 
        런타임때에 객체의 이름을 name으로 사용할겁니다. 


이제는 오늘 배운 DeadLockProfiler 를 테스트 할 수 있는 상태가 되었습니다. 
실습을 진행하기 위해 인위적으로 데드락 상태를 만들겁니다. GameServer 프로젝트에서 Main 필터에 AccountManager, PlayerManager 라는 이름의 클래스를 추가 해줬습니다.
이 두 클래스파일들은 이번만 실습하고 날려줄 임시 클래스 파일들입니다. 
서로 엇갈린 순서로 서로의 락을 잡는 클래스들입니다. 

->      AccountManager

        #pragma once
        #include "pch.h"
        #include "AccountManager.h"
        #include "PlayerManager.h"

        class AccountManager
        {
                USE_LOCK;

        public:
                void AccountThenPlayer()
                {     
                WRITE_LOCK;
                GPlayerManager.Lock();
                }
                void Lock()
                {
	        WRITE_LOCK;
                }
        } GAccountManager;

->      PlayerManager

        #pragma once
        #include "pch.h"
        #include "PlayerManager.h"
        #include "AccountManager.h"

        class PlayerManager
        {
                USE_LOCK;

        public:
                void PlayerThenAccount()
                {
                WRITE_LOCK;
                GAccountManager.Lock();
                }
                void Lock()
                {
	        WRITE_LOCK;
                }

        } GPlayerManager;

그리고 이 코드들을 실행할 GameServer.cpp 의 코드는 이렇습니다. 

->      GameServer

        #include "AccountManager.h"
        #include "PlayerManager.h"


        int main()
        {
                GThreadManager->Launch([=]()
                        {
                                while (true)
                                {
                                        cout << "PlayerThenAccount" << endl;
                                        GPlayerManager.PlayerThenAccount();
                                        this_thread::sleep_for(100ms);
                                }
                        });

                GThreadManager->Launch([=]()
                        {
                                while (true)
                                {
                                        cout << "AccountThenAccount" << endl;
                                        GAccountManager.AccountThenPlayer();
                                        this_thread::sleep_for(100ms);
                                }
                        });

                GThreadManager->Join();
        }


이 상태에서 우선 DeadLockProfiler은 디버그 모드에서만 동작하도록 만들었었는데 그래서 이번엔 릴리즈 모드로 실행해보겠습니다. 
원래같으면 이 코드가 실행되면 데드락이 잡히면서 크래시가 나야합니다. 하지만 릴리즈 모드에서 실행하면 cout이 계속 일어나고 데드락을 잡지 않습니다. 

실습 클래스들의 구조는 사실 Player 락을 잡고 바로 Account 락을 잡거나 Account 락을 잡고 바로 Player 락을 잡으니 데드락이 일어날수 있는 상태입니다. 
하지만 데드락이 일어나지 않는 이유는 두 락을 잡는 사이의 시간이 너무 짧다 보니까 우연히도 락이 잡히지 않고 있는겁니다. 
지금이야 데드락이 안잡히니 데드락이 없는 코드인가보다 하고 넘어가게 될 수 있는데 그러면 실제 서비스에서 수만명이 이 코드를 실행하게 된다면 그때는 확률이 
급격히 높아지면서 몇일에 한번씩 데드락이 나는 사태가 일어날겁니다. 

인위적으로 데드락을 걸리도록 PlayerThenAccount 함수에서 락사이에 sleep_for(1ms) 정도의 텀을 둬보고 실행해 보았습니다. 
실행결과 첫 루프에서 데드락이 걸려서 프로그램이 멈춰있습니다. 

이번에는 디버그 모드에서 실행해보겠습니다. 
결과는 첫 시도에서 바로 크래시가 나면서 데드락이 일어났다는걸 알려줍니다. 
이 크래시는 실제로 쓰레드끼리 데드락이 일어나서 크래시가 난것이 아니고 락을 호출하는 순서를 추적해서 사이클이 일어나는걸 탐지후 인위적으로 크래시를 내는겁니다. 

- 정리 
오늘 내용을 정리해보겠습니다. 
DeadLock 을 판별하는것이 개발환경에서 알아내기 어려울 수 있고 실제 서비스에서 많은 클라이언트실행속에서 갑자기 문제를 일으 킬 수 있기때문에 
그전에 찾아낼 수 있는 DeadLockProfiler가 필요해집니다. 

이것은 디버그 모드에서만 동작하게끔 할것입니다. 

DeadLockProfiler 객체를 extern 전역 객체로 만들어서 여러곳에서 접근할수 있도록 할겁니다. 
락을 잡으면 PushLock, 락을 풀면 PopLock 을 하면서 _lockStack에 현재 한번에 잡고 있는 락들을 관리할것이고 
락들에 이름과 아이디를 unordered_map으로 매칭해서 관리할것입니다. 
어떤 락을 잡고 있는 중간에 다른 락이 잡히면 _lockHistory로 추적도 할것입니다. 

PushLock에서는 락의 이름을 인자로 받는데 해당 이름의 락이 처음이라면 락의 아이디를 발급후 _nameToId, _idToName에 등록을 하고 처음이 아니라면 아이디를 가져옵니다. 
또 현재 따로 잡고 있는 락이 없다면 그냥 지금 락을 잡을것이고 아니면 현재 다른 락이 잡고 있는 상태에 또 다른 락을 잡으려고 하면 _lockHistory에 등록후 
사이클을 일으키는지 CheckCycle을 실행합니다. 

CheckCycle을 보기 전에 PopLock에서는 _lockStack.pop() 을하는게 목적인데 그전에 체크해야할것이 현재 _lockStack이 비었는지 아니면 지금 pop하려는 락이 
_lockStack의 top이 아닌지를 체크합니다. 

CheckCycle에서는 결국 Dfs를 할것인데 그전에 Dfs에 필요한 임시데이터들을 초기화를 하고 Dfs all 을 합니다. 끝난후에는 사용한 임시 변수들도 정리합니다. 

주요 로직인 Dfs에서는 _nameToId에 등록되어있는 갯수만큼 for 반복을 합니다. 현재 Dfs하는 정점을 here라고 하겠습니다. Dfs는 매번 모든 인접 정점을 도는건 
아니고 한번 CheckCycle을 시도할때 마다 한번 방문한 정점은 _discoveredOrder에 순서대로 저장을 할겁니다. 이미 방문한 정점은 바로 리턴하고  
방문하지 않았다면 몇번째로 방문한지 순서대로 _discoveredOrder[here]에 저장합니다. 이제 순회를 시작하는데 인접한 정점들은 PushLock할때 _lockHistory[here]에 
저장됩니다. 만약 인접한 정점이 없다면 here의 Dfs를 종료하면서 _finished[here] = true 로 바꿔주고 리턴합니다. 
인접한 정점이 있다면 여기부터 사이클을 판별해야하는데 그 방법은 _discoveredOrder를 가지고 판별하는데 인접한 정점들을 there라는 변수에 담아서 for 루프를 도는데 
_discoveredOrder[here] < _discoveredOrder[there] 라면 순방향 간선이라는 뜻입니다. continue로 넘어가고 이외에는 교차 간선이거나 역방향 간선인것이고 
이중 역방향 간선일때 데드락이 발생하니 크래시를 내주면 됩니다. 역방향 간선을 판별하는법은 일단 _discoveredOrder[here] > _discoveredOrder[there] 이고 
_finished[there] 가 false일때 발생합니다. 
이게 무슨말이냐면 _discoveredOrder[here] > _discoveredOrder[there] 이 코드는 나중에 걸린 락 이후에 먼저 걸린 락이 다시 걸리는것입니다. 
그리고 _finished[there] 가 false 라는것은 아직 Dfs 끝나지 않았다는것이고 이것들은 역방향 간선의 조건이었습니다. 

