#include <iostream>
using namespace std;


// 오늘의 주제 : 타입 변환 (Type Conversion)

/*
갑자기 타입 변환?
malloc -> void*를 반환하고, 이를 [타입 변환]을 통해 사용했었음

------------------------------ 타입 변환 유형 --------------------------

----------------------(비트열 재구성 여부)------------------------------

[1] 값 타입 변환
	특징) 의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성
		int a = 123456789;  // 2의 보수로 표현 a의 주소에는 16진수로 075bcd15 라는 값이 저장되어 있었습니다.
		float b = (float)a; // 부동소수점 (지수 + 유효숫자) 메모리 상으로 4ceb79a3 라고 저장
		cout << b << endl;
[2] 참조 타입 변환
	특징) 비트열을 재구성하지 않고, '관점'만 바꾸는 것 (의미를 유지하지 않습니다.)
	거의 쓸일은 없지만, 포인터 타입 변환도 '참조 타입 변환'과 동일한 룰을 따르니까 1석 2조로 공부하자
		int a = 123456789;  // 2의 보수로 표현 a의 주소에는 16진수로 075bcd15 라는 값이 저장되어 있었습니다.
		float b = (float&)a; // 부동소수점 (지수 + 유효숫자) 메모리 상으로 075bcd15 라고 저장
		cout << b << endl;

----------------------------(안전도 분류)-------------------------------

[1] 안전한 변환
	특징) 의미가 항상 100% 완전히 일치하는 경우
	-> 같은 타입이면서 크기만 더 큰 바구니로 이동하는 경우
	작은바구니 -> 큰바구니 로 이동 OK! (업캐스팅)
	예시) char -> short, short -> int, int -> __int64

[2] 불안전한 변환
	특징) 의미가 항상 100% 일치한다고 보장하지 못하는 경우
	타입이 다르거나
	같은 타입이긴 하지만 큰 바구니 -> 작은 바구니로 이동하는 경우 (다운 캐스팅)


-------------(프로그래머 의도에 따라 분류)----------------------

[1] 암시적 변환
	특징) 이미 알려진 타입 변환 규칙에 따라서 컴파일러가 '자동'으로 변환

[2] 명시적 변환
	특징) 컴파일러가 위험하다고 판단해서 암시적 변환을 못할때 프로그래머가 직접 캐스팅을해 변환


-------------(아무런 연관 관계가 없는 클래스 사이의 변환)----------------------

[1] 아무런 연관 관계가 없는 클래스 사이의 '값 타입'변환
	특징) 일반적으로는 어떤 식으로든 안 됨 (예외 : 타입 변환 생성자, 타입 변환 연산자)

[2] 아무런 연관 관계가 없는 클래스 사이의 '참조 타입'변환
	클래스속성이 갯수와 타입이 다른 두 클래스가 참조로 명시적 타입변환을 해서 문법상으로는 통과되지만 실제 메모리는 관장하는 범위를 넘어 
	건드릴 수 있습니다.
	문법상 통과되는 이유는 어셈블리 단계에서 참조와 포인터가 동일하게 구동되었습니다 그래서 다른 클래스 참조 타입으로 타입변환 하게 되면
	주소만 일단 전달되고 거기의 데이터 타입은 신경쓰지 않기 때문이라고 하시는데,
	솔직히 잘 이해가 안갑니다. 포인터나 참조도 생성할때 분명 데이터 타입을 맞춰줘야 했었는데, 클래스 사이의 타입변환에서는 데이터 타입이 
	상관 없다고도 하고 모르겠습니다.
	특징) 명시적으로는 OK (위험할 수 있습니다.)


-------------(상속 관계가 있는 클래스 사이의 변환)--------------------------------
[1] 상속 관계가 있는 클래스 사이의 '값 타입' 변환
	특징) 자식 -> 부모 OK   /  부모 -> 자식 NO

[2] 상속 관계가 있는 클래스 사이의 '참조 타입' 변환
	특징) 자식 -> 부모 OK	/	부모 -> 자식 (암시적 NO) (명시적 OK)


결론 ) 
 [값 타입 변환] : 진짜 비트열도 바꾸고 논리적으로 말이 되게 바꾸는 변환
 - 논리적으로 말이 된다? (ex. Bulldog -> Dog) OK!
 - 논리적으로 말이 안된다? (ex. Dog -> Bulldog, Dog -> Knight) 안 됨!
 [참조 타입 변환] : 비트열은 냅두고 우리의 '관점만' 바꾸는 변환
 - 땡깡을 부리면(명시적 요구) 해주기 하는데, 말 안해도 '그냥' (암시적)으로 해주지는 안정성 여부랑 연관이 있음
 -- 안전하다? (ex. BullDog -> Dog) '그냥' (안시적으로) OK
 -- 위험하다? (ex. Dog -> BullDog)
 --- 메모리 침범 위험이 있는 경우는 '그냥'(암시적으로) 해주진 않음(위험하니까)
 --- 명시적으로 정말 정말 하겠다고 최종 서명을 하면 OK
*/

class Knight
{
public:
	int _hp = 10;
};

class Dog
{
public:
	Dog()
	{

	}
	// 타입 변환 생성자
	Dog(const Knight& knight)
	{
		_age = knight._hp;
	}

	// 타입 변환 연산자
	operator Knight()
	{
		Knight knight;
		knight._hp = _age + _cuteness;
		return knight;
	}
public:
	int _age = 1;
	int _cuteness = 2;
};

class BullDog : public Dog
{
public:
	bool _french;  // 프렌치 불독 인지?
};




int main()
{
	//(타입 변환 유형 (비트열 재구성 여부))
		// [1] 값 타입 변환
		{
			int a = 123456789;  // 2의 보수로 표현 a의 주소에는 16진수로 075bcd15 라는 값이 저장되어 있었습니다.
			float b = (float)a; // 부동소수점 (지수 + 유효숫자) 메모리 상으로 4ceb79a3 라고 저장
			cout << b << endl;
		}

		// [2] 참조 타입 변환
		{
			int a = 123456789;  // 2의 보수로 표현 a의 주소에는 16진수로 075bcd15 라는 값이 저장되어 있었습니다.
			float b = (float&)a; // 부동소수점 (지수 + 유효숫자) 메모리 상으로 075bcd15 라고 저장
			cout << b << endl;
		}

	// (안전도 분류)
		// [1] 안전한 변환 - 업캐스팅
		{
			int a = 123456789;
			__int64 b = a;
			cout << b << endl;
		}

		// [2] 불안전한 변환 - 다운 캐스팅, 타입이 다른 경우
		{
			int a = 123456789;
			float b = a;
			short c = a;
			cout << b << endl;
			cout << c << endl;
		}

	// (프로그래머 의도에 따라 분류)
		// [1] 암시적 변환
		{
			int a = 123456789;
			float b = a; // 암시적으로 - 손수 a를 캐스팅해서 값 변환을 하진 않았지만 컴파일러가 알아서 변환해주었습니다.
		}

		// [2] 명시적 변환
		{
			int a = 123456789;
			int* b = (int*)a;  // 명시적 - 컴파일러가 판단하기에 위험하다고 판단하더라도 손수 캐스팅을 하였습니다.
		}

	// (아무런 연관 관계가 없는 클래스 사이의 변환)
		// [1] 아무런 연관 관계가 없는 클래스 사이의 '값 타입'변환
		{
			// 멤버 타입 변환 생성자
			Knight knight;
			Dog dog = (Dog)knight;
			// 멤버 타입 변환 연산자
			Knight knight2 = dog;
		}
		// [2] 아무런 연관 관계가 없는 클래스 사이의 '참조 타입'변환
		{
			Knight knight;
			Dog& dog = (Dog&)knight; // knight는 4바이트 크기의 객체였는데 명시적으로 8바이트 크기 객체인 Dog의 참조값으로 변환했습니다.
			dog._cuteness = 12; // 지금 이 코드는 knight의 범위를 넘어서 조작 하고 있으므로 위험한상황입니다.

		}

	// 상속 관계가 있는 클래스 사이의 변환
		//[1] 상속 관계가 있는 클래스 사이의 '값 타입' 변환
		{
			// 실패 : 모든 개가 불독은 아니기 때문에
			//Dog dog;
			//BullDog bulldog = dog;

			// 반대로는?
			BullDog bulldog;
			Dog dog = bulldog;
		}

		// [2] 상속 관계가 있는 클래스 사이의 '참조 타입' 변환
		{
			//Dog dog;
			//BullDog& bulldog = (BullDog&)dog;

			BullDog bulldog;
			Dog& dog = bulldog;
		}

	return 0;
}