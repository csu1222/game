#include <iostream>
using namespace std;
#include <vector>
#include <list>
#include <deque>
#include <map>
#include <set>
#include <algorithm>

// 오늘의 주제 : 중괄호 초기화 { }

/*
	C++ 11 에서 새로운 초기화 방법이 추가되었습니다.
	
	변수를 선언하면서 
	TYPE 변수{ data };
	라는 형태로 초기화 할 수 있습니다.

	왜 굳이 이런 초기화 문법을 새로 추가 했을까요?
	C++ 에서 이전에는 지원안하다가 다른 언어들에서 지원해서 가져오는 경우가 있습니다. 
	그리고 사실 중괄호 초기화는 배열을 초기화 할때는 썼습니다. 
	int a[] = { 1, 2, 3, 4, 5 };
	이렇게 배열에서는 쓰면서 다른 변수에서는 못쓰는걸 풀어줬다는 느낌입니다.

	가령 vector를 초기화 할때
	vector<int> v1; 
	v1.push_back(1); 
	으로 하나씩 데이터를 초기화 해주거나
	vector<int> v2(10, 1);
	으로 1이라는 데이터 10개를 가진 채로 생성하고 했습니다.

	중괄호 초기화가 추가 되고나서는
	vector<int> v3{ 1, 2, 3, 4 };
	이렇게 사용할수 있게되었습니다.


	중괄호 초기화의 장점 요약
	
	1) vector등 컨테이너와 잘 어울린다.

	2) 축소 변환 방지.
	- int 변수를 double 변수에  = 대입하게되면 느슨하게 알아서 대입이 되었습니다.
	하지만 중괄호 초기화로 하게되면 축소변환이 방지가 됩니다. 엄밀히 데이터 손실이 나는걸 방지해줍니다.

	3) Bonus 클래스 선언을 명확히
	Knight k(); 
	라고 기본생성자를 이용해 객체를 생성하려고 하였지만 사실 이 문법은 함수를 선언하는 문법입니다.
	반환은 Knight고 함수이름은 k 인자와 리턴이 없는 함수이죠 
	Knight k;
	이게 기본생성자로 생성한 객체입니다.
	그런데 
	Knight k(10); 
	같이 값을 넣어서 생성자를 호출하다가 햇갈려서 k();로 생성할때가 있을겁니다.
	이럴때 중괄호 초기화 문법을 이용하면 
	Knight k{ };
	이건 온전히 기본 생성자를 이용한 객체 생성입니다.


	그러면 항상 중괄호 초기화를 사용하는게 최선인가?
	아닙니다 어떤 경우에는 중괄호 초기화를 사용하는게 방해가 되기도 합니다.
	중괄호에 복수의 인자를 받는 생성자의 경우 initializer_list를 받는 생성자를 호출하게 되는데
	우연히 같은 갯수의 인자를 받는 생성자가 있을경우 항상 initializer_list를 받는 생성자가 우선되게 됩니다.

	이런 일이 자주있을까 싶지만 대표적으로 vector를 예로 들수 있겠습니다.
	vector<int> v(10, 2); 
	이 생성자의 의미는 2라는 데이터를 10개 가지고있는 객체 v를 생성한다는 뜻입니다.
	하지만
	vector<int> v{ 10, 2 };
	는 10과 2라는 데이터를 가진 벡터 객체 v를 생성합니다.

	이렇게 의도했던 설계대로 작동하지 않을 수 있습니다.


	그래서 두가지 방법을 정하고 개발을 하면 되겠습니다.

	1) 괄호 초기화 ( ) 를 기본으로 간다
	- 전통적인 C++ (거부감이 없음)
	- vector등 특이 케이스에만 { } 사용

	2) 중괄호 초기화 { }를 기본으로 간다
	- 초기화 문법의 일치화
	- 축소 변환 방지
*/

class Knight
{public:
	Knight(int a, int b)
	{
		cout << "Knight(int, int)" << endl;
	}

	Knight(initializer_list<int> li)
	{
		cout << "Knight(initializer_list<int>)" << endl;
	}
public:
	int _hp;
};
int main()
{
	// 초기화 문법들
	int a = 10;
	int b(0);
	int c{ 0 };

	// 클래스의 경우
	Knight k1;
	Knight k2 = k1;  // 복사 생성자 (대입 연산자 X)

	Knight k3;
	k3 = k1;		// 이게 대입 연산자

	// 중괄호 초기화 클래스 버전
	Knight k4{ k2 };

	// vector같은 컨테이너에서도 사용
	vector<int> v1{ 1, 2, 3, 4, 5 };


	// 중괄호 초기화의 장점
	// 1) vector등 컨테이너와 잘어울린다.
	
	// 2) 축소 변환 방지
	int x = 0;
	//double y{ x };

	// 3) Bonus
	Knight k5{ };


	// 중괄호 초기화의 단점? 주의점?
	// 중괄호안에 복수의 인자가 오는 생성자의 경우 initializer_list라는 타입을 받는 생성자가 호출이 됩니다.
	// 하지만 만약 특정 갯수의 인자를 받는 생성자가 따로 있는경우에는?
	
	Knight k6{ 1, 2 };
	// int 두개를 받는 생성자와 initializer_list를 받는 생성자 둘다 있지만 initializer_list가 우선됩니다.

	
	

	return 0;
}