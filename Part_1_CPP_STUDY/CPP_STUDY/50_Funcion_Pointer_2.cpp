#include <iostream>
using namespace std;

// 오늘의 주제 : 함수 포인터 - 2

/*
함수 포인터 
1) 포인터			*
2) 변수의 이름		fn
3) 타입				함수


		typedef의 진실
	typedef 왼쪽 오른쪽 -> 오른쪽 (커스텀 타입 정의) 이라고 했었습니다. 하지만 
	정확히는 왼쪽/오른쪽 기준이 아니라.
	[선언 문법] 에서 typedef을 앞에다 붙이는 쪽
	
	선언 문법
	int INTEGER;
	int* POINTER;
	int FUNC();
	int ARRAY[20];
	여기서 앞에 typedef만 붙인다

	typedef int INTEGER;
	typedef int* POINTER;
	typedef int FUNC();
	typedef int ARRAY[20];

	이 중에 지금 배우고 있던 함수 포인터 FUNC* 를 대부분의 상황에서 쓸건데 
	호기심으로 포인터가 아닌 그냥 FUNC는 어떻게 동작할까요?
	함수내에 FUNC t; 라고 선언하면 보통변수였을경우 스택 메모리에 실제 값을 가진 변수가 저장되어있을 것입니다.
	근데 함수는 동작하는게 달랐죠 함수는 어떤 데이터를 들고 있는게 아니라 가져온 데이터를 어떻게 조작할까라는
	일련의 동작코드들이 있습니다. typedef로 시그니처만 정의된 FUNC는 동작 코드들 자체도 없는 상태입니다. 그래서 
	FUNC로 생성한 t를 t(); 로 실행하게되면 확인할수 없는 외부 기호 라고 에러 메세지가 뜹니다. 이 에러메세지는 
	함수를 미리 선언만하고 구현부를 만들지 않은 함수에서 뜨는 에러메세지와 매우 흡사합니다. 
	t와 같은이름 같은 시그니쳐로 실제 구현부를 만들면 신기하게도 잘 작동합니다.
	즉 FUNC의 형태의 t라는 함수가 있을것이다 라고 선언만 하는 셈이고 실제 t라는 이름의 함수 구현부가 있어야 합니다.
	실용적으로 함수타입 자체를 사용할 일은 없을거라고 합니다.

	typedef으로 함수타입을 만들고 다시 함수타입 포인터를 변수이름으로 생성하는 것 대신 한번에 만드는 법
	typedef int (*PFUNC)(int, int);
	아예 만들때부터 함수타입 이름앞에 포인터라고 표시를 해서 만드는 것입니다. 괄호를 써주는 것은 저 문법이 
	int타입 포인터를 반환하는 함수를 말하는것인지 함수 포인터 타입을 만드는 것인지 애매하기 때문입니다.

	어지간하면 함수 포인터를 한번에 만드는걸 쓰라고 합니다.
*/

/*
지금껏 배운 함수 포인터는 사실 반쪽 짜리라고 할수 있습니다. ㅜㅜ 멘붕
그 이유는 위 문법으로는 [전역 함수 / 정적 함수]만 담을 수 있다 (호출 규약이 동일한 애들)
	전역 함수 : 맨 처음 배운 함수의 형태 메인 함수 밖에서 선언된 함수들
	정적 함수 : 클래스 내부에 있는 일반적인 멤버 함수와 달리 앞에 static이 붙어있고 함수코드만 클래스 내부에 있을뿐
				클래스의 멤버 변수도 쓸수 없고 실제 작동도 전역 함수처럼 작동합니다.

애초에 일반 함수(전역함수, 정적함수)들과 멤버 함수와는 동작 방식이 달랐습니다. 일반 함수의 경우 호출하게되면 바로 
스택메모리에 인자들을 푸시하고 자신의 리턴주소를 푸시 그 후 함수의 주소로 가서 동작들을 실행하였습니다. 하지만 
멤버 함수는 바로 실행 할수 없고 일단 객체가 있고 그 객체가 자신클래스가 가지고 있는 함수를 불러오는것 이었습니다.

그러면 멤버 함수의 포인터는 어떻게 만드느냐? 일반 함수포인터와 형태가 유사합니다.
typedef int (Knight::*PMEMFUNC)(int, int);
이렇게 함수이름이 들어가는 곳에 멤버함수의 구현부를 만들듯이 넣어줍니다.

PMEMFUNC mfn;
mfn = &Knight::GetHp;
이렇게 만들었습니다. 

일반 함수 포인터와 다르게 앞에 &이 붙었습니다. 사실 일반 함수 포인터도 앞에 &을 붙여야하지만 C언어와의 호환성때문에 
생략할 수 있었는데요 멤버 함수 포인터는 생략할 수 없기때문에 일반 함수 포인터, 멤버 함수 포인터 서로 햇갈리지 않도록 
둘 다 붙여주는걸 습관화 하면 좋겠습니다.

멤버 함수 포인터를 사용하는 방법은 일단 역시 단독으로는 사용할 수 없고 객체가 필요합니다.
Knight k1;

(k1.*mfn)(1, 1);
사용법이 좀 복잡하네요 일반 함수 포인터는 직관적인 사용법이었는데 말이죠 
하지만 사실 일반 함수 포인터도 이와 비슷하게 사용할수 있고 
(*fn)(1, 2);   이렇게 
오히려 그냥 사용하는 fn(1, 2) 이 형태가 괄호와 *을 생략한 상태입니다.
괄호와 *을 사용하는 이유는 그냥 k1.mfn(1, 2) 라고 사용하면 mfn이 멤버 함수 포인터인지 아니면 진짜 mfn이라는 멤버 함수가
있는건지 명확하지 않기때문에 확실히 표현하기위해 쓴다고 합니다.

다음으로 Knight객체가 스택에 올라와 있는게 아니라 힙영역에 동적 할당으로 있어서 클래스 포인터로 있을때 입니다.
Knight* k2 = new Knight();  일 때 k2에 대해 멤버 함수 포인터를 만들어 보겠습니다.

k1 대신 (*k2)를 넣는다고 생가하면 되겠습니다.
((*k2).*mfn)(1, 2);
그리고 포인터의 주소를 타고 들어가서 그 속성에 접근하는 *(포인터).(속성) 은 (포인터)->(속성)으로도 표현된다고 했습니다.
(k2->*mfn)(1, 2);  이렇게도 표현이 가능해 집니다.

- 멤버 함수 포인터 문법은 평소에 그렇게 많이 사용되는 문법은 아니고 필요할때 구글링으로 기억을 떠올리면서 쓰는 문법이라고 
	합니다. 저희 강의에서도 나중에 서버시간에 다시 활용하게 된다고 하네요

참고로 똑같은 시그니쳐지만 다른 클래스의 멤버함수도 가리킬수 있는가가 궁금합니다. 
- 불가 typedef로 정의한 부분 자체가 어떤 클래스의 멤버함수인지 정해져있습니다.

*/

class Knight;

typedef int INTEGER;
typedef int* POINTER;
typedef int FUNC();
typedef int ARRAY[20];

// 함수 포인터 타입 한번에 만들기
typedef int (*PFUNC)(int, int);

// 멤버 함수 포인터 만들기
typedef int (Knight::* PMEMFUNC)(int, int);

int Test(int a, int b)
{
	cout << "Test" << endl;
	return a + b;
}

int t()
{
	cout << "t" << endl;
	
	return 0;
}

// 전역함수 포인터, 정적함수 포인터와 다른 멤버함수 포인터
class Knight
{
public:
	Knight() : _hp(0)
	{

	}
	static void HelloKnight()
	{
		cout << "HelloKnight" << endl;
	}
	int GetHp(int, int)
	{
		cout << "GetHp()" << endl;
		return _hp;
	}
public:
	int _hp;
};

int main() 
{
	// 함수타입 자체의 실험
	/*FUNC t;
	t()*/;


	// 함수 포인터 한번에 만들기   - 이왕이면 익숙해지자
	int (*fn)(int, int);

	// typedef로 포인터 만들기
	typedef int(FUNC_TYPE)(int, int);
	//FUNC_TYPE* fn2;

	fn = &Test;
	// fn = Test;       & 생략 가능 ( C언어 호환성 때문)
	fn(1, 2);
	(*fn)(1, 2);

	// 함수 포인터 타입 한번에 만들기

	PFUNC fn3 = Test;

	fn3(1, 2);


	// 멤버 함수 포인터 만들기
	
	PMEMFUNC mfn;

	mfn = &Knight::GetHp;

	Knight k1;

	(k1.*mfn)(1, 1);	// 멤버 함수 포인터를 사용하는 문법 : 좀 했갈립니다.
	
	
	// 클래스 포인터에 대한 멤버 함수 포인터
	Knight* k2 = new Knight();

	((*k2).*mfn)(1, 1);		// k2가 포인터이니 이렇게 하는걸 고려해볼수 있습니다.
	// * .  을 쓰는게 -> 와 동일하다고 했었습니다.
	(k2->*mfn)(1, 2);

	delete k2;



	return 0;
}