#include <iostream>
using namespace std;

// 오늘의 주제 : 포인터


// text rpg 실습에서는 지역변수를 다른 함수에서 조작 할 수 없었습니다.
// 오늘 배운 포인터로 지역변수를 조작할 수 있게 되었습니다.
void SetHp(int* hp)
{
	*hp = 100;
}

int main()
{	
	int hp = 1;
	SetHp(&hp);
	// 함수의 인자를 포인터로 받으면 지역변수의 값을 조작 할 수 있게됩니다.

	// 지금까지 사용한 방식
	// number라는 이름의 4바이트 정수 타입의 바구니를 만든다.
	// number라는 변수는 스택 메모리에 할당
	// number = 1; 이라 함은, number 바구니에 1이라는 숫자를 넣으라는 의미
	// 따라서 스택 메모리에 있는 특정 주소 (number 바구니)에 우리가 원하는 값을 넣은 셈
	// number는 비유하자면 메모리에 이름을 붙힌 것 (컴파일러가 찰떡같이 알아들어서)
	// 나쁘지 않고, 편리한데... 단점은 Text RPG 실습에서 원본수정이 필요할 때는 전역변수를 이용해야 했습니다.

	int number = 1;

	// 포인터의 형태
	// TYPE* 변수이름;
	// 일단 2가지 요소
	// - TYPE
	// - *


	// 바구니는 바구니인데...
	// [주소를 저장하는 바구니다!]
	// 변수 선언할 때 * 이 등장했다 -> 포인터 = 주소
	// - 포인터라는 바구니는 4바이트(32비트 체제) or 8바이트(64비트 체제) 고정 크기

	// &변수이름 = 변수의 주소
	int* ptr = &number;

	// 근데 남의 주소를 갖고 뭘 하라는건지?
	// 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 해라!
	// *변수이름 = 값;

	// 포탈을 타고 순간이동을 한다고 생각해보자.
	// *이 여러번 등장해서 햇갈리는데, 사용 시점에 따라서 구분해 기억하자.
	// - 변수 선언(이것은 주소를 저장하는 바구니다!)
	// - 변수를 사용할 때(포탈을 타고 순간이동)

	int value1 = *ptr;
	*ptr = 2;

	// TYPE은 왜 붙여줄까?
	// 선언때 * = 포인터라는 의미 = 주소를 저장하는 바구니 = 4or8바이트 고정크기   라는건데
	// TYPE은 그 포인터의 추가 정보를 나타내는것

	// 주소에 가면 뭐가 있는데?
	// ex) 결혼식 청첩장의 주소 = 예식장 주소
	// ex) 명함의 주소 = 회사 주소
	// 결국 TYPE은 포인터가 가리키는 주소의 데이터가 어떤 타입인지를 알려준다

	// 타입이 불일치 할때는 어떻게 될까?
	__int64* ptr2 = (__int64*)&number;

	*ptr2 = 0xaabbccddeeff;
	// int 타입이었던 number 주소로 가보면 할당 되었던 데이터 범위를 넘어서 덮어 씌워져 있었습니다.
	// C++은 이렇게 직접 메모리를 조작할 수 있다보니 이런 치명적인 실수를 하지 않도록 해야 하겠습니다.


	return 0;
}