#include <iostream>
using namespace std;
#include <vector>

// 오늘의 주제 : vector - 면접 단골

/*
	이번 단원이 STL이고 그 중 첫번째 vector 시간입니다.
	우선 STL 이 무었이냐?
	STL(Standard Template Library)
	프로그래밍할 때 필요한 자료구조/알고리즘들을 
	템플릿으로 제공하는 라이브러리

	컨테이너(Container) : 데이터를 저장하는 객체 (자료구조 Data Structure)

	vector (동적 배열)
	- vector의 동작 원리 (size/capacity)
	- 중간 삽입/삭제
	- 처음/끝 삽입/삭제
	- 임의 접근

	vector같은 동적 배열은 프로그래밍 언어라면 다른이름으로라도 하나씩 가지고 있습니다. 
	동적 배열을 왜 배워야 하는지 배열의 단점에 대해 알아보겠습니다.

	배열
	- 배열은 처음 만들때 어느 크기 만큼의 배열을 만들것인지 정하고나서는 그 배열의 크기를 늘이거나 줄일수 없습니다.

	vector의 기본 사용방법에 대해 알아보겠습니다. 
	우선 #include <vector> 를 해줍니다.
	vector는 템플릿으로 만들어져있어서 
	vector<int> v;		라고 만들면 int를 담을 vector v가 만들어집니다. 
	원래는 std::vector<int> v; 
	라고 만들어야 하지만 우리는 지금 using namespace std; 를 사용하고 있어 생략되었습니다.

	벡터는 신기하게도 크기가 늘어났다가 줄어들었다가 하는 특징이 있습니다.
	원리는 재쳐두고 무작정 사용해보게습니다. 만든 벡터 객체 v에 .을 찍어보면 사용할수 있는 기능들이 많이 나오는데
	그중 push_back이 뒤쪽으로 값들을 push 해주는 기능입니다. 
	1,2,3,4,5를 push_back해주고 
	출력을 해봐야겠습니다. 동적배열도 배열처럼 [] 이 연산자를 지원합니다. 그리고 이 배열의 크기를 얻을수 있는
	v.size(); 를이용해 for문을 돌아 일반 배열과 똑같이 하나씩 출력해 줄수 있었습니다.

	## 매우 중요한 원리
	- 어떤 마법을 부렸길래 배열을 '유동적'으로 사용한 것인가?
	vector의 원리로 두가지 로직이 있는데
	1) (여유분을 두고) 메모리를 할당한다 
	2) 여유분 까지 꽉 찼으면, 메모리를 증설한다.

	Q1) 여유분은 얼만큼이 적당할까?
	Q2) 증설을 얼만큼 해야 할까?
	Q3) 기존의 데이터를 어떻게 처리할까?

	Q1, Q2의 답을 같이 할수 있을것 같습니다. int형 vector에서 아무 값을 1000개 넣었습니다. 
	값을 넣을때마다 size, capacity를 출력했습니다. 매 반복마다 size는 1씩 올라갔지만 capacity는 1씩 올라기지 않고
	1 2 3 4 6 9 13 19 28 42 
	이렇게 올라가고 있었습니다. 규칙을 보면 여유분이 없어 질때 현재 capacity의 1.5배에 근사하게 올리고 있습니다.
	(증설이 얼마나 되는지는 컴파일러마다 다르다고 합니다.)
	[size : 실제 사용하고 있는 데이터의 갯수]
	[capatity : 여유분을 포함한 데이터의 갯수]

	그렇다면 왜 1.5배씩 여유를 두고 증설을 할까요? 그냥 size와 같이 1씩올리면 안될까요?
	이 문제는 Q3) 와 연관이 있습니다.
	Q3) 기존의 데이터를 어떻게 처리할까? 
	- 간단하게 생각하면 배열을 증설하면서 malloc같은 걸로 메모리를 확보해서 기존의 데이터와 이어서 처리하면 되지 않을끼?
	-- 배열의 특징상 메모리상으로 연속되야 하는데 배열뒤에 어떤 데이터가 있을지도 모르니 메모리를 확보할수 없습니다.
	- 그래서 메모리를 증설할때 증설할만큼의 여유가 있는 메모리를 찾아 빈 배열을 만들고 기존의 데이터를 복사해와서 빈
	배열로 가져오는것 입니다.
	이 기존의 데이터를 복사해오는 과정이 증설할때마다 이뤄져야 하니깐 여유분을 두고 증설이 되는 것입니다.

	항상 capacity가 증설되게 해야 하는 것은 아니고 만약 우리가 담을 데이터의 윤곽을 대충 알고 있다면 미리 여유분을 설정해
	놓을수 있습니다.
	.reserve(여유분); 으로 미리 설정해 놓을수 있습니다.
	reserve는 capacity를 미리 설정해놓는거라면 size(실제 사용하고 있는 데이터의 갯수)를 미리 설정하는 방법도 있습니다.
	resize(); 말그대로 사이즈를 다시 정하는 기능입니다.
	resize(1000); 으로 size를 늘린 시점의 size와 capacity를 출력해보면 둘다 1000으로 나옵니다. 

	그러면 resize후 push_back으로 내용물을 추가하면 미리 잡아놓은 메모리에 들어갈까요?
	아닙니다. resize한 부분은 이미 데이터가 자리잡고 있고 그뒤에 덛붙혀서 내용물이 들어갑니다. 
	resize로 확보한 부분에 원하는 내용물을 넣으려면 v[i] 이렇게 배열에서 각 인덱스에 내용물을 넣듯이 하면되겠습니다.

	이 vector(동적 배열)을 사용하다보면 실제 사용하는 데이터 즉 size가 줄어들때도 있을 것입니다. 
	capacity는 그래도 현재 size를 따라 줄어들지 않습니다. 
	vector의 내용물을 싹 없애는 기능인 clear를 사용후 size와 capacity를 출력해보면 size는 0, capacity는 그대로인걸 
	알수 있습니다.

	소소한 팁으로 capacity도 깔끔하게 없애버리고 싶다! 라면
	vector<int>() 로 임시 벡터를 만듭니다.
	vector<int>().swap(v); 임시벡터와 우리가 사용하던 벡터를 스왑하면 우리가 사용하던 벡터는 방금만든 아무데이터도 없는
	벡터가 되는것이고 capacity가 늘어나 있던 벡터는 임시벡터가 가져간다음 이 코드 실행이 끝나자 마자 삭제되어서 메모리 해제가 됩니다. 

	이외에도 여러 기능들이있습니다.
	v.front(); : 맨앞에 있는 값을 보기
	v.back();  : 맨뒤의 값을 보기
	v.pop_back : push_back과 반대로 맨 마지막의 값을 뽑아내기

	벡터를 만들때 바로 resize를 해줄 수도 있습니다.
	vector<int> v(1000);   : 벡터를 만듬과 동시에 resize(1000)을 해준것과 동일합니다.
	vector<int> v(1000, 0) : 두번째인자로 만들어놓은 배열의 초기값들을 설정해줄 수 있습니다. (내용물이 전부 0으로 초기화)
	
	vector<int> v2 = v;    : 새로만드는 벡터에 이미 있던 벡터의 상태들을 복사합니다.
*/



int main()
{
	// 배열
	//const int MAX_SIZE = 10;
	//int arr[MAX_SIZE] = {};

	//for (int i = 0; i < MAX_SIZE; i++)
	//	arr[i] = i;

	//for (int i = 0; i < MAX_SIZE; i++)
	//	cout << arr[i] << endl;


	// vector

	vector<int> v;
	//v.resize(1000);
	v.reserve(1000);
	for (int i = 0; i < 1000; i++)
	{
		//v[i] = 100;
		 v.push_back(100);
		cout << v.size() << " " << v.capacity() << endl;
	}
	// size(실제 사용 데이터 개수)
	// 1 2 3 4 5 6 ...
	// capacity(여유분을 포함한 용량 개수)
	// 1 2 3 4 6 9 13 19 28 42 ...

	v.clear();
	vector<int>().swap(v);
	cout << v.size() << " " << v.capacity() << endl;


	return 0;
}