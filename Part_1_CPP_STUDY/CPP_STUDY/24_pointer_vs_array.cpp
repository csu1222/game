#include <iostream>
using namespace std;

// 오늘의 주제 : 포인터 vs 배열

// 배열은 같은 타입의 묶음이라고 했습니다.


// 배열을 인자로 받는 함수 
void Test(char a[])
{
	a[0] = 'x';
}

int main()
{
	// 첫 시간에 꼭 배우는 Hello World 의 정체가 무었이었을까요?
	cout << "Hello World" << endl;
	char msg[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
	cout << msg << endl;

	// 문자열 = 문자의 배열
	// C 스타일에서는 문자로 이루어진 배열에 끝에 \0(널 종단 문자)가 와야합니다.

	// 포인터로 문자열을 받아 보겠습니다.
	const char* test1 = "Hello World";

	// 배열로 문자열을 받아 보겠습니다.
	char test2[] = "Hello World";

	// 둘다 통과되는걸 보니 포인터와 배열은 같은게 아닌가? 하는 생각

	// 포인터의 경우
	// test1[ 주소 ] << 8바이트
	// .data 영역 주소[H][e][l][l][o][ ][W][o][r][l][d][\0]  맨 앞의 H의 주소를 test1 이라는 포인터에 넣어줌

	// 배열의 경우
	// 어셈블리 단계에서 살펴 봤을 때 
	// .data 영역 주소[H][e][l][l][o][ ][W][o][r][l][d][\0] 
	// 에서 4바이트씩 복사해 test2에 넣었습니다.

	// 포인터는 [주소를 담는 바구니]
	// 배열은 [닭장] 즉, 그 자체로 같은 데이터끼리 붙어있는 데이터 모음
	// - 다만 [배열 이름]은 '바구니 모음'의 [시작 주소]

	// 다시 말하자면
	// 포인터는 그저 문자열의 첫 주소를 담고있습니다. (고정 8바이트)
	// 배열은 문자열의 첫 주소와, 문자열 자체를 복사해 가지고 있습니다(문자열 크기만큼 크기증가)
	// 그래서 포인터는 읽기 전용 데이터인 문자열을 수정 할 수 없고
	// 배열은 자신이 문자열을 가지고 있으니 인덱스를 사용해 수정 할 수 있습니다. 

	// -----------------------------------

	// 배열을 함수의 인자로 넘기게 된다면?

	// test2 가 바뀔까? 안 바뀔까?  -> 바뀜
	// 배열은 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환한다.(char[] -> char*)
	Test(test2);
	cout << test2 << endl;


	return 0;
}