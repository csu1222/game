#include <iostream>
using namespace std;
#include <vector>
#include <list>
#include <deque>
#include <set>
#include <map>
#include <algorithm>

// 오늘의 주제 : 전달 참조 (forwarding reference)

/*

	* 요약 
	* 1) auto, template 같은 형식 연역에서 &&을 사용하면 전달 참조(forwarding reference)
	* 2) 전달 참조는 들어온 인자에 따라 왼값 참조, 오른값 참조 각각으로 기능
	* 3) 전달 참조는 반복되는 코드를 줄여줌
	* 4) 오른값 자체와 오른값 참조는 다른다 (오른값 참조는 왼값으로 기능함)
	* 5) 전달 참조로 받은 매개변수를 std::forward()에 넣어서 사용하면 왼값, 오른값을 구분해서 캐스팅 해줌

	원래		보편 참조 (universal reference) 라는 용어 였다가
	C++17 부터	전달 참조 (forwarding reference) 라고 바뀌었습니다.

	&&		-> & 을 두번하면... 오른값 참조?


	&&이 붙었다고 꼭 오른값 참조라는 보장이 없는게 오늘의 주제 전달 참조 때문입니다.
	전달 참조는 auto나 template 문법, 형식 연역(type deduction : 컴파일러가 타입을 추리해서 맞춰주는 기능)이 일어날때 발생합니다.
	템플릿 타입네임 T를 사용해서 매개변수를 T&& param으로 받아주는 함수가 있다고 했을때 
	이 함수는 매개변수로 모든 타입의 오른값을 받아주는 함수이겠구나 생각 할 수 있습니다. 그래서 
	인자로 std::move(인자)를 주고 커서를 가져다 대서 보면 실제로 오른값 참조로 받아주고 있습니다.
	근데 그냥 move를 하지 않은 인자를 줘도 잘 빌드가 됩니다. 살펴보면 이번에는 같은 함수인데 인자를 왼값 참조로 받고있습니다.
	이 현상을 템플릿 뿐만 아니라 auto에서도 마찬가지입니다. 

	전달 참조는 인자가 왼값, 오른값 어떤게 오는지에 따라 알아서 처리를 해줍니다. 
	만약 매개변수가 템플릿&& 이대로가 아닌 앞에 const같은 문법이 붙게 된다면 그때는 전달참조가 아닌 템플릿 오른값 참조가 됩니다.
	auto도 마찬가지로 순수 auto&&일때만 전달 참조로 기능합니다.

	
	지금까지 결론 : &&이 무조건 오른값 참조를 뜻하는것은 아니다!. 형식 연역에서 &&은 전달 참조로 인자에 따라 알아서 처리해준다!
	 전달 참조를 구별하는 방법
	-----------------------------------------

	전달 참조가 왜 필요할까요?
	전달 참조로 왼값, 오른값 모두 대응가능한 기능이 없다면 왼값 참조방식의 함수, 오른값 참조 방식의 함수 두개를 만들어야 합니다.
	매개변수가 하나뿐이면 두개밖에 안되는데 그냥 만들면 안될까? 할 수 있지만 
	템플릿은 여러개의 typename을 사용할수 있었습니다. 매개변수가 2개로 늘어난다고 하면 전달 참조가 없을때 각각 만들어야 하는 
	함수의 수가 4개로 늘어납니다. 매개변수 갯수가 늘수록 제곱으로 늘어날 것입니다.

	그런데 생각할 부분이 있습니다. 왼값 참조와 오른값 참조의 데이터 취급이 달랐습니다.
	어떤 객체를 복사하는 함수가 전달참조 함수 구현부에 포함 되어있다고 할때 왼값으로 인자를 받으면 복사생성자가 실행되어 깊은 복사를 
	하게 될것이고, 오른값으로 인자를 받으면 이동 생성자가 실행되어서 얕은 복사를 해도 될것 입니다. 이때 이동 생성자는 받은 인자가 
	훼손되어도 괜찮다는 의미고 복사생성자는 원본을 훼손할수 없을것입니다. 
	그래서 왼값이냐 오른값이냐에 따라 적절하게 기능하도록 만들어야 겠습니다.

	* 
	한가지 다시 집고 넘어가야 할 점 오른값 참조 타입 변수는 오른값인가?
	말이 어렵지만 용어를 집고 넘어가자면
	// 오른값 : 왼값이 아니다 = 단일식에서 벗어나면 사용불가
	// 오른값 참조 : 오른값만 참조할수 있는 참조 타입
	오른값을 참조 받아 만든 오른값 참조 타입 변수는 그 단일식을 넘어가서도 다시 사용할수 있습니다. 즉, 왼값입니다.
	햇갈리는것은 std::move(k1)은 Knight&& 타입으로 캐스팅 한다고 하였는데 오른값 참조 타입과 같은 형태입니다.

	타입의 형태는 같지만 오른값 참조 타입으로 만든 변수는 왼값이고, sto::move(k1)이라는 이 데이터는 이름을 지어줄 수도 없고
	이 식을 벗어나면 사용할 수 없는 오른값이라는 차이가 있습니다.

	다시 말하자면 오른값 참조는 인자로 받은 원본은 오른값으로 취급해서 손상되어도 되게끔 취급하지만 자신 자체는 왼값으로써 
	취급합니다.
	*

	다시 전달 참조로 돌아와서 밑의 예시로 사용하는 Test_ForwardingRef(T&& param) 함수에서 param은 인자로 오른값을 주게되면 오른값 참조로 
	기능한다고 했습니다.
	위의 오른값 자체와 오른값 참조의 차이점에서 말했듯이 param은 오른값을 받았지만 param자체는 왼값입니다. 
	그래서 함수내에서 오른값으로써 취급하려면 다시 std::move를 해주고 사용해야합니다.
	하지만 이러면 다시 문제가 생기는데 만약 인자가 왼값으로 들어왔다면 이 원본을 멋대로 std::move를 해서는 안될것입니다.

	그래서 이런 조건이 필요합니다.
	만약 매개변수가 왼값 참조라면 그대로 사용
	만약 매개변수가 오른값 참조라면 std::move를 해서 사용

	이 조건을 if문으로 만들게 되면 결국 전달 참조를 사용하지 않을 때처럼 여러 경우의 수를 다 대비해야합니다.

	이 문제를 해결하는 문법인 std::forward<T>() 이 forward문법은 전달 참조기능과 한 세트라고 보면 되겠습니다. 
	forward안에 매개변수를 넣으면 알아서 조건에 맞게 캐스팅을 해줍니다.



*/

class Knight
{
public:
	Knight() { cout << "기본 생성자" << endl; }
	Knight(const Knight& k) { cout << "복사 생성자" << endl; }
	Knight(Knight&& k) noexcept { cout << "이동 생성자" << endl; }
};

// 복습
void Test_RValueRef(Knight&& k)		// 오른값 참조
{

}

void Test_Copy(Knight k)
{
	
}


// 전달 참조 : 템플릿,auto 같은 형식 연역(type deduction)이 일어날때 발생
template<typename T>
void Test_ForwardingRef(T&& param)
{
	// TODO
	// 만약 왼값 참조라면 그대로
	// 만약 오른값 참조라면 move
	Test_Copy(std::forward<T>(param));
}

int main() 
{
	Knight k1;

	//Test_RValueRef(std::move(k1));  // rvalue_cast
	// 이렇게 저번에 배운 오른값 참조를 복습하였습니다. 
	// && 이 등장하면 무조건 오른값 참조인가? 가 오늘의 주제 인데요


	Test_ForwardingRef(k1);
	Test_ForwardingRef(std::move(k1));

	auto&& k2 = k1;
	auto&& k3 = std::move(k1);


	// 오른값 과 오른값 참조
	Knight& k4 = k1;   // 왼값 참조
	Knight&& k5 = std::move(k1);   // 오른값 참조

	// 오른값 : 왼값이 아니다 = 단일식에서 벗어나면 사용불가
	// 오른값 참조 : 오른값만 참조할수 있는 참조 타입
	Test_RValueRef(std::move(k5));


	return 0;
}