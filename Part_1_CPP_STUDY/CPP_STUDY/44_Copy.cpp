#include <iostream>
using namespace std;

// 오늘의 주제 : 얕은 복사 vs 깊은 복사  (면접에 단골로 나온답니다)

/*
예시로 Knight 클래스를 만들었습니다.
메인 함수에 기사 객체를 만들었습니다. ( 기본생성자 ) 이 후 기사 객체의 체력 속성을 200으로 수정했습니다.
이 기사 객체를 복사하려고 합니다. 두가지 정도 복사하는 방법이 생각 나는데요.
1. 기사2 객체를 기사를 복사 하면서 생성하기 (Knight knight2 = knight; 와  Knight knight2(kinght); 는 같은 의미라고 합니다.)
2. 기사3 객체를 일단 생성하고 후에 기사객체를 복사하기 ( Knigth knight3; 이후 knight3 = knight; 하기)
-두 방법이 언뜻 보기에 비슷해보입니다. 하지만 두 방법이 객체를 복사하는것은 조금 차이가 있습니다.
    1번 방법의 경우는 처음 객체를 생성할때 기본 생성자가 아닌 복사 생성자를 불러옵니다.
    2번 방법의 경우 객체 생성은 일반 생성자를 사용하지만 이후 복사 대입 연산자 함수로 기사객체의 속성을 복사합니다.
두 방법이 어떤 차이인지는 알았습니다. 하지만 조금 이상한것이 기사 클래스를 만들었을때 복사 생성자 함수와 복사 대입 연산자 함수를 
만든 적이 없는데도 실행이 잘 되었습니다.
- 이유는 [복사 생성자], [복사 대입 연산자]는 컴파일러가 '암시적'으로 만들어서 실행해 주었습니다.

중간 결론 ) 컴파일러가 알아서 잘 만들어준다?
수고하세요~ 다음 주제로 넘어갑시다! << NO!

컴파일러가 암시적으로 만들어준 복사 생성자, 복사 대입 생성자가 왜 문제가 되느냐?
- 객체가 들고 있는 정보를 그대로 넘겨주는 것 밖에 못하는게 문제라고 합니다.
-- ? 정보를 그대로 주는게 무슨문제인가 싶습니다.
-- 일반 데이터는 별 문제없을 수 있지만, 객체가 참조값이나 포인터를 들고 있을 경우 문제가 될수 있다고 합니다.


* 멤버 변수로 클래스가 올때 클래스 포인터로 가지고 있어야 하는 이유:
새로운 사양으로 펫이 생겼다고 가정하였습니다. 기사클래스에 펫을 쥐어줄때 포인터 형태로 주는것이 좋다고 합니다. 
그냥 클래스 형태로 Pet pet; 만들어 주게 되면 기사 객체를 생성/소멸 할때 펫도 함께 생성/소멸하게 되고 만약 펫이 데이터를 많이 차지하면 
각 기사 객체마다 펫의 데이터를 전부 들고 있어야 합니다. 
더 더욱 중요한 문제로 펫을 상속한 자식클래스로 토끼, 거북이 가 있다고 할때 들고있던 펫을 다른 종류로 변경 할 수 없다고 합니다.
(사실 이부분은 잘 이해하지 못했습니다.)
아무튼 클래스를 멤버변수로 가질때는 포인터 타입으로 가지고 있어야 좋다고 합니다. 그래야 이전 시간에 배운 타입 변환을 이용해 
수정 할 수 있다고 합니다.

아무튼 펫을 가지고 있는 기사4 를 컴파일러가 암시적으로 기사5(복사 생성자), 기사6(복사 대입 연산자)에 복사 해주게 되면,
기사4가 가지고 있던 펫의 포인터를 복사 받았으니 하나의 펫을 세 객체가 공유하는것이 되어 버립니다.

    [얕은 복사 Shallow Copy]
    멤버 데이터를 비트열 단위로 '똑같이' 복사 (원본 메모리 영역 값을 그대로 복사)
    포인터는 주소값 바구니 -> 주소값을 똑같이 복사 -> 동일한 객체를 가리키는 상태가 됨
    생성자에서 Pet객체를 만들어주고 소멸자에서 delete해준다고 하면 Knight1이 소멸한뒤 Knight2,3 의 소멸자로 이미 
    없어진 Pet를 다시 delete하게 하는 셈 입니다.
    Stack : Knight1 [ hp, 0x1000  ] -> Heap 0x1000 Pet[  ]
    Stack : Knight2 [ hp, 0x1000  ]  ↗
    Stack : Knight3 [ hp, 0x1000  ]  ↗
        
    [깊은 복사 Deep Copy]
    멤버 데이터가 참조(주소)값이라면, 데이터를 새로 만들어준다 (원본 객체가 참조하는 대상까지 새로 만들어서 복사)
    포인터는 주소값 바구니 -> 새로운 객체를 생성 -> 각각의 객체를 가리키는 상태가 됨
    Stack : Knight1 [ hp, 0x1000  ] -> Heap 0x1000 Pet[  ]
    Stack : Knight2 [ hp, 0x2000  ] -> Heap 0x2000 Pet[  ]
    Stack : Knight3 [ hp, 0x3000  ] -> Heap 0x3000 Pet[  ]

얕은 복사, 깊은 복사 둘 다 숙지하고 필요에 따라서 사용합시다


실험)
- 암시적 복사 생성자 Steps
    1) 부모 클래스의 복사 생성자 호출 
    2) 멤버 클래스의 복사 생성자 호출
    3) 멤버가 기본 타입일 경우 메모리 복사(얕은 복사 Shallow Copy)
- 명시적 복사 생성자 Steps
    1) 부모 클래스의 기본 생성자 호출
    2) 멤버 클래스의 기본 생성자 호출
    - 원본 클래스가 명시적으로 복사 생성자를 만든 순간 컴파일러는 부모 클래스와 멤버 클래스의 기본 생성자만 호출해주고 
    스스로 알아서 하라고 하는것 입니다. 부모클래스의 멤버 변수를 원본 클래스가 값을 바꾸고나서 복사를 하게 되면 복사된 
    클래스의 부모클래스의 변수 값은 부모 클래스의 기본 생성자의 값을 따라가는것입니다. (멤버 클래스도 마찬가지) 
    제대로 복사하려면 원본 복사 생성자에서 부모 클래스 복사 생성자와 멤버 클래스 복사 생성자를 직접 호출해야 하겠습니다.
    (명시적으로 복사 생성자를 사용한 순간 모든 복사에 대한 관리는 나 자신에게 생기는 것이기 때문에 일일히 챙겨줘야 하겠습니다.)

- 암시적 복사 대입 연산자 Steps
    1) 부모 클래스의 복사 대입 연산자 호출 
    2) 멤버 클래스의 복사 대입 연산자 호출
    3) 멤버가 기본 타입일 경우 메모리 복사(얕은 복사 Shallow Copy)
- 명시적 복사 대입 연산자 Steps
    1) 알아서 해주는 것 없음
    - 복사 대입 연산자도 마찬가지로 직접 부모 클래스의 복사 대입 연산자를 추개해야하고 ([부모클래스] :: operator(매개변수)) 
    멤버 클래스도 매개변수로 받은 값을 직접 넣어줍니다.([멤버클래스] = 매개변수.멤버클래스)

왜 이렇게 혼란스러울까?
객체를 '복사'한다는 것은 두 객체의 값들을 일치시키려는 것
따라서 기본적으로 얕은 복사(Shallow Copy) 방식으로 동작

명시적 복사 -> [모든 책임]을 프로그래머에게 위임하겠다는 의미
*/

class Pet
{
public:
    Pet()
    {
        cout << "Pet()" << endl;
    }

    ~Pet()
    {
        cout << "~Pet()" << endl;
    }

    Pet(const Pet& pet)
    {
        cout << "Pet(const Pet&" << endl;
    }
};

class Knight
{
public:
    Knight()
    {
        _pet = new Pet();
    }

    Knight(const Knight& knight)    // 직접 만든 복사 생성자
    {
        _hp = knight._hp;
        _pet = new Pet(*(knight._pet));
    }

    Knight& operator= (const Knight& knight)// 직접 만든 복사 대입 연산자
    {
        _hp = knight._hp;
        _pet = new Pet(*(knight._pet));

        return *this;
    }

    ~Knight()
    {
        delete _pet;
    }

public:
    int _hp = 100;
    Pet* _pet;
};


int main()
{
    Knight knight;   // 기본 생성자
    knight._hp = 200;

    Knight knight2 = knight;    // 복사 생성자
    //Knight knight3(knight);  // 위와 같은의미

    Knight knight3;             
    knight3 = knight;           // 복사 대입 연산자

    // [복사 생성자] , [복사 대입 연산자]
    // 둘 다 직접 만들지 않아도 컴파일러가 '암시적'으로 만들어준다.

    // 중간 결론 : 컴파일러가 알아서 잘 만들어준다? NO


    // 포인터형 멤버 변수까지 컴파일러가 복사 해주었습니다.
   
    Knight knight4;
    knight4._hp = 200;

    Knight knight5 = knight4;

    Knight knight6;
    knight6 = knight4;

    return 0;
}