

        오른손 법칙


이제 맵과 플레이어를 만들었으니 길찾기를 구현해볼겁니다. 

그런데 본격적인 길찾기 알고리즘은 그래프나 우선순위 큐 ? 라는 선수지식이 필요하다고 합니다. 

이번시간은 아주 간단한 우수법을 구현하면서 코딩 연습을 해볼겁니다. 우수법은 항상 어떤 미로던지 통하는 방법은 아니고 미로가 출구까지 
확실히 연결되어있고 뺑뺑이를 도는 순환구조가 없다면 적용가능한 길찾기 방법입니다. 

우수법이 무엇이냐면 플레이어가 바라보는 방향이 있을건데 플레이어가 다음 통로를 보고있다고 했을때 오른손을 뻗어서 벽을 만지면서 쭉 따라 걷는 방법입니다. 

이 우수법 기능을 이제 Player 클래스에서 관리할 것인지 Board 클래스에서 관리할 것인지 고민이 되는데 길찾기는 플레이어의 인공지능과 관련된 부분이기 때문에 
기왕이면 Player 클래스에서 관리하도록 해주겠습니다.


-> Player 클래스
    플레이어 클래스에는 현재 Init 메소드와 Update 메소드가 있습니다. 
    어떻게 우수법을 구현할것이냐면 먼저 Init 메소드 안에서 한번에 우수법에 따른 플레이어의 이동 정보를 계산한다음 그 정보를 
    Update 메소드에서 하나씩 처리하면서 플레이어가 길을 찾아 걸어가는걸 처리해줄겁니다. 
    이 방법은 프로그램이 실행되면서 미리 플레이어의 경로를 계산해주는 방법인데 
    물론 경로 계산을 실시간으로 해주는 방법도 있습니다. 하지만 이번 시간에는 좀더 쉽게 구현하기 위해서 한번에 경로계산을 하는 식으로 구현해보겠습니다. 

    가장먼저 이 로직은 플레이어가 목적지에 도착하기전까지 계속 실행되어야 합니다. 그리고 이동할때의 위치도 기록해야합니다. 
    이동경로를 Player 의 멤버 변수 _pos 를 가지고 계산하면 안되는게 _pos 는 플레이어의 실제 위치이기 때문에 계산에 사용되는 임시 위치를 따로 만들어서 사용할겁니다.

    이제 우수법을 의사 코드로 표현해보겠습니다.
    1 - 현재 바라보는 방향을 기준으로 오른쪽으로 갈 수 있는지 체크
        OK. 플레이어의 방향을 오른쪽으로 90도 회전 후 앞으로 한 보 전진
        No. 2번 조건으로 
    2 - 현재 바라보는 방향으로 갈 수 있는지 체크
        OK. 현재 바라보는 방향으로 한 보 전진
    3 - 플레이어의 방향을 왼쪽으로 90도 회전 후 처음 조건으로 루프 

    이 로직을 이제 코드로 표현해주면 될것입니다. 

    길찾기 코딩 문제에 자주 사용되는 테크닉이 있다고 합니다. Player 의 방향이라는 의미에서 _dir 이라는 멤버 변수를 들고 있었는데 
    이걸 switch case 문으로 표현하면 아래와 같습니다. 
    // 방향을 왼쪽으로 틀 경우 
        switch (_dir)
        {
        case DIR_UP:
            _dir = DIR_LEFT;
            break;
        case DIR_LEFT:
            _dir = DIR_DOWN;
            break;
        case DIR_DOWN:
            _dir = DIR_RIGHT;
            break;
        case DIR_RIGHT:
            _dir = DIR_UP;
            break;
        }}
    // 허나 이러면 코드가 너무 장황해짐

    // 이럴때를 위해서 환경설정때 Dir 을 Up 부터 반시계 방향으로 차례대로 지정,
    // 그리고 총 갯수도 들고 있게 했음 
    // 위의 switch case 문을 간단하게 표현하면 

        _dir = (_dir + 1) % DIR_COUNT; 

    이런 속성을 활용해서 플레이어의 오른쪽을 체크하는 방법을 생각해 보면 좋겠습니다. 

    int32 rightDir = (_dir + 3) % DIR_COUNT; 
    이렇게 3을 더해주거나 아니면 1을 빼주는 방법입니다. 

    int32 rightDir = (_dir - 1 + DIR_COUNT) % DIR_COUNT;
    1을 빼주는 방법으로 구현할때는 _dir 값이 음수로 가지 않게 다시 방향의 총갯수를 더해서 양수로 변환한다음 나머지를 구해줍니다. 

    이제 현재 플레이어의 방향을 기준으로 좌, 우, 뒤 의 방향을 구할 수 있게되었습니다. 
    여기에 더해 또 필요한 정보는 해당 방향으로 이동 할 수 있는지를 알아야 합니다. 

    이동 할 수 있는지를 물어보는것은 많이 사용하게될겁니다. 그래서 별도의 함수로 빼줄겁니다. 
        
    bool Player::CanGo(Pos pos)
    {
        TileType tileType = _board->GetTileType(pos);

        return tileType == TileType::EMPTY;
    }

    Pos 를 인자로 주면 그 타일을 갈수 있는지 즉 그 타일이 EMPTY 타일인지를 체크하는 함수입니다. 

    이제 갈수 있는지를 체크할 함수를 얻었습니다. 이제 의사코드의 첫번째 if 문 의 조건으로 CanGo(플레이어의 오른쪽 타일 Pos) 를 체크해주면 될겁니다. 

    다음 타일의 좌표를 구하는 방법은 역시 방향값을 switch 로 4가지 case 를 걸어서 Pos[y][x] 의 좌표중 하나에 + 1 을 해주면 될것입니다. 
    하지만 이 방법 외에 좀 더 간편한 방법이 있습니다. 

    이 방법은 우리가 방향을 0, 1, 2, 3 이라는 int32 으로 관리해서 할 수 있는 방법인데 다음 Pos 의 배열을 방향의 갯수크기로 만드는 방법입니다. 

	Pos front[DIR_COUNT] =
	{
		Pos { -1 , 0 },		// Up
		Pos { 0 , -1 },		// Left
		Pos { 1 , 0 },		// Down
		Pos { 0 , 1 },		// Right
	};

    이 front 배열은 방향의 값들을 인덱스로 써서 상하좌우로 한칸씩 움직이는 Pos 를 가져올 수 있습니다. 그럼 이걸 _pos 에 더해주면 그것이 해당 방향으로 한걸음 걸어 간것 입니다.

    즉 CanGo(_pos + front[rightDir]) 이 코드가 현재 위치의 오른쪽으로 갈 수 있는가? 를 bool 값으로 알려주는 코드입니다. 

    앞으로 가는 코드가 꼭 이것만 있는것은 아니고 수많은 방법이 있다고 합니다. 그래서 지금 이 방법을 배웠다고 해서 달달 외우지 않아도 됩니다. 
    컨텐츠 코드는 사람마다 다 생각하는 방법이 다를 수 있습니다. 자신이 생각한 방법이 있으면 그걸 사용해도 됩니다. 단, 결과는 똑같이 나와야 할겁니다.

    의사 코드를 코드로 작성해보겠습니다. 
    1 - 현재 바라보는 방향을 기준으로 오른쪽으로 갈 수 있는지 체크  
    //	OK.플레이어의 방향을 오른쪽으로 90도 회전 후 앞으로 한 보 전진
    if (CanGo(_pos + front[rightDir]))
		{
			//	OK.플레이어의 방향을 오른쪽으로 90도 회전 후 앞으로 한 보 전진
			_dir = rightDir;
			pos += front[_dir];
			//	No. 2번 조건으로
		}
    
    여기서 우리는 플레이어의 초기화 함수에서 미리 출구 까지의 길을 다 구해주는 방식으로 구현할 것이라고 했습니다. 
    미리 구해두려면 가는 길 , path 를 저장해두어야 합니다. 

    멤버 변수로 추가해주겠습니다. 

    vector<Pos>     _path; 

    좌표의 벡터를 만들어서 계산한 결과물을 넣어줄겁니다. 
    위의 내용들을 종합하면 path 를 구하는 최종 코드는 이렇게 될겁니다. 

    void Player::Init(Board* board)
    {
        _pos = board->GetEnterPos();
        _board = board;

        Pos pos = _pos;

        Pos dest = _board->GetExitPos();

        _path.clear();
        _path.push_back(pos);

        Pos front[DIR_COUNT] =
        {
            Pos { -1 , 0 },		// Up
            Pos { 0 , -1 },		// Left
            Pos { 1 , 0 },		// Down
            Pos { 0 , 1 },		// Right
        };
        
        while (pos != dest)
        {
            int32 rightDir = (_dir + 3) % DIR_COUNT;

            int32 leftDir = (_dir + 1) % DIR_COUNT;
            if (CanGo(_pos + front[rightDir]))
            {
                _dir = rightDir;
                pos += front[_dir];

                _path.push_back(pos);
            }
            else if (CanGo(pos + front[_dir]))
            {
                pos += front[_dir];
                _path.push_back(pos);
            }
            else
            {
                _dir = leftDir;
            }
        }
    }
    이 루프가 완료되는 시점이 현재 pos 가 출구 dest와 같으면 루프를 빠져나오게 됩니다. 
    그러면 _path에는 출구까지의 vector<Pos> 가 담겨 있습니다. 

    while 문 안으로 들어가기전에 _paht.clear() 와 _path.push_back(pos) 를 해주는이유는 일단 혹시 모를 _paht 의 데이터의 쓰레기값이 있으면 
    clear 하고 처음 플레이어가 출발하는 입구 pos 를 처음에 push_back 해주는 코드입니다.

    이렇게 플레이어가 갈 루트를 다 구해줬으면 그 데이터를 가지고 Update 함수에서 플레이어를 움직여줘야 합니다. 
    이때 필요한 데이터가 무엇이 있을지 생각해 봤습니다. 
    먼저 _path를 차례대로 쭉 읽어 나갈건데 그 인덱스를 관리할 변수가 있어야 할 것 같고 Update 의 연산이 컴퓨터의 속도 만큼 진행시키면 
    사람눈에 보이지 않을것 같기 때문에 0.1 초에 한칸씩 움직이도록 할 내용도 있어야 합니다. 

    // Player.h 추가된 멤버 변수 
	enum
	{
		MOVE_TICK = 100,
	};
	uint32			_pathIndex = 0;

	uint32			_sumTick = 0;

    // Player.cpp Update 함수 
        
    void Player::Update(int32 deltaTick)
    {
        if (_pathIndex >= _path.size())
            return;

        _sumTick += deltaTick;

        if (_sumTick >= MOVE_TICK)
        {
            _sumTick = 0;
            
            _pos = _path[_pathIndex];

            _pathIndex++;
        }
    }

    업데이트 함수를 해석해보면 먼저 _pathIndex 가 _path 의 크기보다 크면 바로 리턴하고 있습니다. _path 를 모두 순회 했다는 의미일겁니다.

    다음으로 _sumTick 에 현재 프레임에서 걸리 시간인 deltaTick 을 더해줍니다. 그러고 나서 _sumTick 이 위에서 설정한 MOVE_TICK 보다 크다면 
    플레이어를 움직이는 로직을 실행합니다. 
    MOVE_TICK 의 값이 100 인것은 100ms 라는뜻인데 이 시간은 0.1초를 말합니다. 
    플레이어를 움직이는 로직은 플레이어의 실제 좌표인 _pos 에 Init 에서 미리 계산했던 좌표를 0번 부터 차례대로 넣어줍니다. 그러면 Update가 루프 될때 마다 
    경로를 따라 한칸씩 움직일겁니다. 

이제 프로젝트를 빌드 실행하면 플레이어가 우수법에 따라 출구까지 이동하는걸 볼 수 있습니다. 

사실 우수법은 길찾기 알고리즘이라고 하기 뭣 한게 출구까지 가기까지 불필요한 곳을 너무 많이 들립니다. 
하지만 이번 파트에서 가장 간단한 출구찾기 방식을 사용해 봤습니다. 


정리 - 
우수법을 구현하기 위해서 여러 방법이 있는데 이번 강의에서는 Player::Init 때 미리 출구 까지의 루트를 다 구해놓고 Update 에서 하나씩 까먹으면서 
전진하는 방법으로 구현하였습니다. 
플레이어가 바라보는 방향을 회전하는 방법을 DIR_COUNT 를 가지고 구할 수 있습니다. 
바라보는 방향을 바꿀 수 있다면 그 방향으로 전진을 할 수도 있어야 하는데 방향 값들을 0 ~ 3 의 값으로 만들어서 배열의 인덱스 값으로 활용해서 
Pos 원소들을 상황에 맞춰 한걸음씩 나가도록 합니다. 
그리고 이렇게 구해준 한걸음 나간 플레이어의 Pos 를 벡터로 저장합니다. 

플레이어의 경로를 인덱스 로 하나씩 실제로 움직여주고 렌더링을 하면서 한걸음씩 나가는걸 표현합니다. 
이때 deltaTick 을 활용해서 얼마나 텀을 두고 한걸음을 갈 지 정해줍니다. 
