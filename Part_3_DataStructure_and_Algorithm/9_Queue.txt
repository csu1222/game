

    큐 (Queue)


오늘은 이전에 배운 스택의 짝궁인 큐 Queue 에 대해 알아보겠습니다. 

큐는 특성이 FIFO First-In-First-Out 선업선출 이 특성입니다. 

    front << [1][2][3][4] << rear(back)

큐가 활용되는 경우는 스택보다 더 범용적으로 사용됩니다.
대기열 구현이 주요한 활용처입니다. 은행, 커피점, 게임 랭크 등에서 많이 사용됩니다.   

대부분의 상황에서는 명령들이 들어오면 먼저 들어온 순서대로 처리하는 경우가 많다보니까 큐가 더 자주 사용됩니다.

그러면 바로 실습에 들어가보겠습니다. 위에서 말한 특성들을 알아볼 테스트 코드는 아래와 같습니다. 

	queue<int> q;

	for (int i = 0; i < 100; i++)
		q.push(i);

	while (q.empty() == false)
	{
		int value = q.front();
		q.pop();

		cout << value << endl;
	}

	int size = q.size();

queue<int> q 를 만들었습니다. 그리고 0 부터 99 까지의 정수를 push 하고 q 가 empty 빌때 까지 루프를 돌겁니다. 
루프안에서는 q.front 맨 앞에 있는 데이터를 value 라는 변수에 가져오고 그걸 다음 코드 pop 에서 삭제해줍니다. 그리고 value 를 출력합니다.
queue 에서도 사이즈가 적용되는지 확인하는 size() 를 해봅니다. 

위의 코드를 실행 해보면 0 부터 99 까지의 정수들이 출력됩니다. 

이제 직접 큐를 구현해보면서 알아가 보겠습니다. 

-> vecotr 기반 Queue (1)
    일단 스택에서도 그랬듯이 벡터 기반으로 큐를 구현해보았습니다. 
    template<typename T>
    class Queue
    {
    public:
        void push(const T& value)
        {
            _container.push_back(value);
        }

        void pop()  // 스택에서는 이 부분이 비효율적
        {
            _container.erase(_container.begin());
        }

        T& front()
        {
            return _container.front();
        }

        bool empty() { return _container.empty(); }
        int size() { return _container.size(); }

    private:
        vector<T>	_container;
    };
    벡터로 큐를 구현해보면 다른 기능들은 STL 식으로 간편하게 만들 수 있는데 pop() 이 비효율적입니다. 
    벡터는 본래 pop_front 가 비효율적이라서 지원하지 않았습니다. 동적배열의 특성상 맨앞의 데이터를 지우면 그 뒤의 모든 원소들을 한칸씩 
    앞으로 복사 이동 해야하기 때문입니다. 
    위에서 pop 은 일단 pop_front 대신에 이터레이터를 사용한 erase 를 가지고 구현은 했습니다. 이때 pop 의 시간복잡도는 O(N) 일겁니다.

-> list 기반 Queue
    반면에 vector 말고 list 를 사용한다면 위의 문제점을 해결할 수 있을겁니다. 
    template<typename T>
    class Queue
    {
    public:
        void push(const T& value)
        {
            _container.push_back(value);
        }

        void pop()
        {
            _container.pop_front();
        }

        T& front()
        {
            return _container.front();
        }

        bool empty() { return _container.empty(); }
        int size() { return _container.size(); }

    private:
        list<T>	_container;
    };
    list 는 중간 삽입/삭제 자체의 이점이 있는 컨테이너 였습니다. 유의점으로 어떤 원소를 수정할지를 찾는것 자체는 느렸지만 
    큐에서는 그런 탐색 과정없이 가장 앞의 원소만 삭제 하면 되기 때문에 문제가 되지 않습니다. 

    그러니까 연결리스트를 활용해 큐를 구현하는게 '일단은' 더 좋아 보입니다. 

-> deque 기반 Queue
    이번에는 deque 를 활용하면 어떨지 생각해보겠습니다. 
    deque 는 part 1 에서 배웠던 STL 컨테이너인데 어떤 식으로 동작했었는지 간략하게 살펴보면 
    일종의 동적 배열? 연결리스트? 의 중간쯤에 있는 컨테이너였습니다. 일정 크기의 배열을 일단 할당 받은 다음 데이터를 push 하다가 저장 공간이 꽉 차면 
    모든 배열을 이사하는게 아니라 처음 할당 받았던 크기만큼 다른 메모리에 다시 할당 받고 두 배열을 포인터로 연결합니다. 
    이러면 몇개의 배열을 할당 받았는지, 그 배열안에서의 인덱스가 몇번인지를 알게 되면 중간 중간 포인터로 연결 되었음에도 임의 접근 비슷하게 작동할 수 있고 
    데이터가 늘어날때 모든 원소들을 이사해야하는 성능 낭비도 일어 나지 않습니다. 거기다가 push_back 뿐만 아니라 push_front 도 가능한데 
    앞에 밀어넣을 데이터를 새로운 배열로 만들고 이 배열을 기존 deque 의 첫번째 배열 앞에 연결합니다. 새로 만든 배열이 맨 앞에 붙는겁니다. 

    그래서 큐도 deque 를 활용해서 구현 할 수 있습니다. 그런데 스택과 큐의 원본 라이브러리를 따라 들어가 보면 둘 다 deque 를 가지고 구현이 되고 있는걸 알수 있습니다. 


-> vector 기반 Queue (2) - 순환구조
    그러면 일반배열, vector 를 이용해서 큐를 제대로 만들 수 있는 방법은 없는지 궁금해집니다. 
    배열기반 큐를 구현하는 방법을 알아보는게 공부할 가치가 있기 때문에 한번 알아보겠습니다.
    위의 list 기반 큐를 ListQueue 라고 하고 지금 만들어볼 배열 기반 큐는 ArrayQueue 라고 하겠습니다. 

    ArrayQueue 가 들고있을 멤버 변수는 기존과 좀 다릅니다. 

    private:
        vector<T>	_container;
        
        int			_front = 0;
        int			_back = 0;
        int			_size = 0;

    벡터 기반으로 만들었고 _front, _back, _size 라는 int 형 변수를 추가로 들고 있을 겁니다. 

    아까 벡터기반 큐가 비효율적이었던 부분은 pop 에서 벡터는 _front 를 꺼내는게 느리기 때문이었습니다. 

    이걸 극복하기 위한 방법은 벡터가 처음부터 넉넉하게 배열을 할당 받습니다. 그리고 _front, _back 이 시작 인덱스와 끝 인덱스의 역할을 합니다. 
    무슨 말이냐면 맨처음 아무런 데이터를 넣지 않은 큐에서 _front 와 _back 은 둘다 0번 인덱스 값을 가집니다. 
    그리고 큐에 push 로 1 이라는 데이터가 들어 왔다고 하면 _front 는 0번 인덱스 그대로인로 _container의 0번에 1이라는값이 들어간 다음 _back에 1을 더해서 
    _front = 0, _back = 1 이 됩니다. 

    이 push 를 몇번 반복해서 _container 안에 1,2,3,4,5 라는 데이터 들이 들어있다고 해보겠습니다. 
    이때 _front = 0, _back = 5 가 되고 _front 부터 _back 의 이전 까지를 _size 라고 인식하면 됩니다.
    이번에는 pop 을 하게 되면 _container 에는 1,2,3,4,5 값이 그대로 있지만 _front 값이 1 증가해서 
    _front = 1, _back = 5 가 됩니다. _front 와 _back 사이의 값만을 인정하게 되면 _container 에서는 실질적으로 맨앞 데이터를 삭제 하지 않아도 
    큐에서 pop 을 한게 됩니다. 

    이렇게 벡터 기반 큐를 구현하게 되면 굳이 진짜로 벡터의 맨 앞의 데이터를 erase 로 삭제하고 뒤의 원소들을 한칸씩 땡기지 않아도 어느정도 구현이 될겁니다. 

    이걸 순환 방식으로 큐를 구현했다고 하는데 이 순환 방식은 재미있는 발상입니다. 그리고 나중에 버퍼를 만들 때 도 순환버퍼를 만든다거나 할 때도 사용되는 
    기초 테크닉이라고 할 수 있습니다. 

    그런데 만약에 처음에 할당 받았던 벡터가 꽉 찼다면 어떻게 될까요? 아까 부터 순환 이라고 말하고 있었는데 순환이라는 단어에 맞게 
    벡터의 끝과 시작점이 연결 되었다고 가정하고 _back 이 0번으로 돌아갑니다. 그러니까 _back 이 _front 보다 앞에 있다면 
    _front 부터 벡터의 끝까지 그리고 벡터의 처음부터 _back 까지를 이어서 큐에 들어있는 데이터라고 인식하는겁니다.

    이제 실제로 구현해보겠습니다. 
    일단은 처음 만드니까 큐 가 다 찼는지, 비었는지 같은 예외 체크는 생략하고 기능만 먼저 만들어 보겠습니다. 

    template<typename T>
    class ArrayQueue
    {
    public:
        ArrayQueue()
        {
            _container.resize(100);
        }

        void push(const T& value)
        {
            // TODO: 다 찼는지 체크 

            _container[_back] = value;
            _back = (_back + 1) % _container.size();
            _size++;
        }

        void pop()
        {
            _front = (_front + 1) % _container.size();
            _size--;
        }

        T& front()
        {
            return _container[_front];
        }

        bool empty() { return _size == 0; }
        int size() { return _size; }

    private:
        vector<T>	_container;
        
        int			_front = 0;
        int			_back = 0;
        int			_size = 0;
    };

    먼저 생성자에서 _container 를 resize로 할당을 받아 주고 있습니다. 

    push 에서는 _back 을 인덱스로 사용해서 _container 에서 값을 넣어줍니다. 값을 넣었으면 _back 과 _size 를 1씩 증가합니다. 
    이때 _back 의 값이 _container.size() 보다 커지면 안되기 때문에 % 로 나머지 연산을 해줍니다. 

    pop은 그냥 _front 를 1증가 시키고 _size 를 1 감소시킵니다. 이때도 % _container.size() 를 해줍니다. 

    front 함수도 그냥 _front 의 인덱스에 있는 값을 리턴하는데 

    empty 와 size 가 좀 달라졌습니다. 기존의 _container.empty() 나 _container.size() 는 말 그대로 _container의 속성이었고 
    지금 구현하고 있는 큐의 속성이 아니었습니다. 


    다음은 이제 _container 의 데이터가 꽉 찼을 때 어떻게 증설을 하는지 알아보겠습니다. 

            // TODO: 다 찼는지 체크 
            if (_size == _container.size())
            {
                // 증설 작업 
                int newSize = max(1, _size * 2);
                vector<T> newData;
                newData.resize(newSize);

                // 데이터 복사 
                for (int i = 0; i < _size; i++)
                {
                    int idx = (_front + i) % _container.size();
                    newData[i] = _container[idx];
                }

                // 데이터 스왑
                _container.swap(newData);
                _front = 0;
                _back = _size;
            }

    push 안에서 체크할 코드입니다. 
    _size는 실제 사용하는 데이터의 개수를 말하고 _container.size() 는 컨테이너 자체의 크기를 말하는데 이 둘이 같다면 데이터가 꽉 찼다고 볼 수 있을겁니다. 

    그러면 증설작업에 들어가야 하는데 새로 할당 받을 컨테이너의 크기는 기존 _size 의 두배로 늘리겠습니다. 
        int newSize = max(1, _size * 2);
    이 코드에서 max 부분은 두 인자중에 큰 값을 리턴하는 함수인데 만약 어떤 이유로 _size * 2 가 0 이라면 사이즈가 계속 0인 상태일겁니다. 
    그걸 방지 하기 위해서 최소 1 의 값은 가지도록 하였습니다. 

    이제 새로 정한 컨테이터 크기로 새로운 벡터 newData 를 만들고 resize 를 합니다. 이때 새로 vector 를 만드는것은 기존 _container 의 크기를 그냥 늘리는 것은 
    생각보다 복잡하고 만약 _back 인덱스가 한바뀌 돌아서 _front 보다 앞에 있을때 데이터가 꼬일 수도 있기 때문에 
    새로운 벡터에 잘 정리해서 담아줍니다. 

    그리고 나서 데이터 복사를 진행합니다. _size 만큼 반복해주면 _container 안의 데이터를 모두 긁어올겁니다. 
    데이터를 가져올때 _front 부터 한바퀴 돌도록 가져오면 새로운 벡터에는 먼저 가지고 있던 데이터들을 0번 인덱스 부터 차곡 차곡 정리하면서 복사 할 수 있습니다. 

    다 복사 했으면 _container에 newData 를 스왑 해줍니다. 그리고 이제는 0번 인덱스 부터 데이터가 시작하니까 _front 와 _back 의 값을 정리 해줍니다. 

    코드를 여기까지 구현했으면 먼저 생성자에서 100 으로 resize 해줬던 부분이 필요 없을것 같습니다. 

    이렇게 배열기반의 큐를 구현해보면서 배열에서 pop_front 가 부담이 된다고 하면 순환 구조를 활용해서 구현 하면 된다는 점을 기억하면 되겠습니다. 



이렇게 해서 여러가지 방법으로 Queue 를 구현하는 실습을 해봤습니다. 
erase로 pop 을 구현한 vector 버전, 노드기반 연결리스트를 사용한 버전, 순환구조로 구현한 vector 버전

그러나 실제로 Queue 의 코드에서는 deque 를 활용한 버전을 사용하고 있다는것도 알았습니다. 