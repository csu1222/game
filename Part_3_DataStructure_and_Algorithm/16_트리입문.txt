

        트리 입문 


이번시간부터 우선순위 큐를 공부하기 위한 선수지식을 배워볼것입니다. 

우선순위 큐가 힙 트리구조로 만들어져 있어서 트리도 조금은 공부 해야 합니다. 

트리 자체도 깊게 공부하려면 공부량이 많지만 일단은 당장 미로 프로젝트를 진행하기위한 필요 최소한의 내용만 알아보고 
비교적 면접에 자주 나온다거나 하는 중요 트리는 part 후반에 다시 다루도록 하겠습니다.

트리란 무엇이냐?
- 계층적 구조를 갖는 데이터를 표현하기 위한 자료구조
- 구성개념
-- 노드 (Node) : 데이터를 표현
-- 간선(Edge) : 노드의 계층 구조를 표현하기 위해 사용

여기까지만 보면 이미 배웠던 그래프와 똑같아 보입니다. 그래프도 정점과 간선으로 이루어졌습니다. 

트리의 예시로 회사의 부서 구조 같은 것입니다. 
어떤 게임 프로젝트의 가장위에 개발실이 있고 이 개발실 아래에는 디자인팀, 프로그래밍팀, 아트팀으로 또 나뉘어져 있고 
각 팀에서 다시각각 세부적인 부분으로 또 나뉠겁니다. 

이런 식으로 계층구조를 가질때 트리를 사용하고 이것 말고도 트리는 생각보다 더 많은 곳에 사용됩니다. 
윈도우즈의 폴더도 상위폴더가 있고 그 아래 하위 폴더들이 있는데 이것도 계층구조를 가진 트리를 이용하는겁니다.

여기까지 알아봐도 아직 그래프와 트리의 차이가 잘 와닿지 않을 수 있습니다. 트리가 그냥 그래프의 하위 개념아닌가 싶기도 하고 

하지만 그래프같은 경우는 정점들 사이가 계층 구조라기 보다는 동등한 높이의 구조라고 한다면
트리는 위에서 아래로 내려가는 계층적인 구조가 있다는것이 핵심적인 내용입니다.

트리에서 사용되는 용어들이 여럿 있는데 대강 알아보면 일단 한 트리의 가장 위에 있는 노드를 루트(root) 노드라고 하고 반대 개념으로 트리의 가장 하위노드를 리프(leaf)로드, 
계층 구조에 놓인 두 노드중 위쪽 노드를 부모 노드, 아랫 노드를 자식노드라고 합니다. 그리고 깊이, 높이 라는 것이 있는데 깊이는 루트노드 부터 해서 몇층을 가리키는지를 말합니다.
높이는 이 트리 전체가 모두 몇층인지를 말합니다.
이 외에도 많지만 모든 용어를 외우기 보다는 트리의 구조를 이미지로 
알고 있다가 대강 이용어가 이런 의미구나 하고 알아 들을 수 있으면 될것입니다.

그리고 트리는 재미있는 속성이 있습니다. 재귀적인 속성, 서브트리(subtree) 라고 하는데 
루트노드 아래로 이어져 있는 자식노드도 자신을 루트노드로 하는 별도의 트리라고 볼 수도 있습니다.
그래서 트리는 서브 트리들이 모여서 만들어 져있다고 볼 수도 있고 트리를 실제로 구현을 하고 탐색을 한다고 할때 재귀함수가 애용이 될겁니다.

재귀함수가 프로그래밍에서 자주 활용이 되는것은 아니지만 트리의 탐색에서는 자주 사용되고 있습니다.
트리와 재귀함수가 잘 맞는 이유는 트리의 재귀적 속성 때문입니다.

이렇게 트리의 개념과 용어에 대해 알아봤습니다.


- 코드 

이제 알아본 트리를 직접 코드로 구현해보겠습니다. 
프로젝트는 Algorithm 입니다. 

먼저 노드라는 이름의 구조체를 만들어 줄것인데 이 노드를 이미 한번 다뤄 봤었습니다. 선형적 자료구조중 연결리스트도 노드를 사용했었습니다.
그런데 트리의 노드는 연결리스트와 다르게 앞과 뒤의 노드만 가리킬수 있는게 아니라 여러개의 노드를 가리킬 수 있다는 점이 다릅니다.

struct Node
{
    string          data;
    vector<Node*>   children;
};

데이터 타입을 템플릿문법으로 관리해줄 수도 있지만 지금은 그냥 간편하게 string 으로 만들었습니다. 
그리고 연결리스트에서는 prev, next 노드로 관리하던것과 다르게 얼마든지 다른 노드를 연결 할 수 있게 vector<Node*> 로 만들었습니다. 

다른 노드들을 포인터로 만들면 메모리 관리를 직접 해줘야 하는데 이것이 싫다면 스마트 포인터를 사용해도 됩니다. 
사용법은 이렇습니다. 

using NodeRef = shared_ptr<struct Node>;

struct Node
{
	string				data;
	vector<NodeRef>		children;
};

이렇게 shared_ptr 를 전역으로 선언하고 선언하면서 전방선언도 같이 해줍니다. 

그리고 Node 의 생성자를 만들어 줄건데 기본 생성자 하나와 인자로 문자열을 받으면 data 에 인자를 넣어주는 생성자를 만들어 주겠습니다.

struct Node
{
	Node() { }
	Node(const string& _data) : data(_data) { }

	string				data;
	vector<NodeRef>		children;
};

이제 트리를 만들어 보겠습니다. 루트노드를 만들고 그 아래로 디자인팀, 프로그래밍팀, 아트팀 그리고 각 팀 아래로 다시 세부 직무가 있습니다. 

NodeRef CreateTree()
{
	NodeRef root = make_shared<Node>("R1 개발팀");
	{
		NodeRef node = make_shared<Node>("디자인팀");
		root->children.push_back(node);
		{
			NodeRef leaf = make_shared<Node>("전투");
			node->children.push_back(leaf);
		}
		{
			NodeRef leaf = make_shared<Node>("경제");
			node->children.push_back(leaf);
		}
		{
			NodeRef leaf = make_shared<Node>("스토리");
			node->children.push_back(leaf);
		}
	} 
	{
		NodeRef node = make_shared<Node>("프로그래밍팀");
		root->children.push_back(node);
		{
			NodeRef leaf = make_shared<Node>("서버");
			node->children.push_back(leaf);
		}
		{
			NodeRef leaf = make_shared<Node>("클라");
			node->children.push_back(leaf);
		}
		{
			NodeRef leaf = make_shared<Node>("엔진");
			node->children.push_back(leaf);
		}
	}
	{
		NodeRef node = make_shared<Node>("아트팀");
		root->children.push_back(node);
		{
			NodeRef leaf = make_shared<Node>("배경");
			node->children.push_back(leaf);
		}
		{
			NodeRef leaf = make_shared<Node>("캐릭터");
			node->children.push_back(leaf);
		}
	}

    return root;
}

각 구조들을 만들어 주고 마지막에 root 를 반환하면이제 root 하나를 가지고 순회를 하면서 전체 구조를 알 수 있게 될겁니다.

이제 다음으로 만들 함수는 위에서 만든 트리를 콘솔에 출력해주는 함수를 만들겠습니다.
이것을 어떻게 구현을 하느냐? 개론시간에서 말했듯이 트리의 재귀 구조를 활용해서 재귀함수를 사용하면 잘 맞는다고 합니다.

void PrintTree(NodeRef root)
{
	cout << root->data << endl;

	for (NodeRef& child : root->children)
		PrintTree(child);
}

이 함수에서는 먼저 인자로 받은 노드의 데이터(노드의 이름)를 프린트 하고 노드에 연결된 child 들을 순회하면서 자기 자신을 다시 호출합니다. 

이제 프로그램을 실행하면 다음과 같이 출력됩니다. 

R1 개발팀
디자인팀
전투
경제
스토리
프로그래밍팀
서버
클라
엔진
아트팀
배경
캐릭터

의도대로 잘 출력되긴 했지만 아쉬운점이 있습니다. 각 트리의 계층구조의 표현이 잘 안되서 출력된다는게 문제입니다. 
이걸 극복하냐면 깊이depth 를 넣어주면 된다고 합니다.

void PrintTree(NodeRef& root, int depth)
{
	for (int i = 0; i < depth; i++)
		cout << "-";
	cout << root->data << endl;

	for (NodeRef& child : root->children)
	{
		PrintTree(child, depth + 1);
	}
}

	PrintTree(root, 0);

두번째 인자로 depth 를 추가해주고 받은 depth 의 크기 만큼 "-" 를 출력해주는 코드를 추가 했습니다. 간단한 코드지만 
재귀를 들어갈때 마다 depth 에 + 1 을 해주면 트리의 깊이를 추적할 수 있었습니다.

하는김에 한가지 더 테스트를 해보겠습니다.
트리를 처음 배울때 기본적으로 하는 실습중 하나가 트리의 높이를 출력해보는 겁니다. 
다시 용어정리를 하자면 비슷하게 느껴지는 용어가 두개 있습니다. 
깊이(depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수 (ex. 몇층입니까?)
높이(height) : 가장 깊숙히 있는 노드의 깊이(max(depth))

 
int GetHeight(NodeRef root)
{
	int height = 1;

	for (NodeRef& child : root->children)
	{
		height = max(height, GetHeight(child) + 1);
	}
	return height;
}

높이를 구하는것 역시 재귀적으로 구할 수 있습니다. 이 함수가 어떻게 구현이 되냐면 기본적으로 자신이 1 이라는 높이를 가지고 있을것이기 때문에 
기본 높이 1 을 가집니다. 그리고 나서 재귀함수로 height 를 갱신해주는데
height = max(height, GetHeight(child) + 1);
이렇게 높이를 갱신해주는 이유는 더 낮은 계층의 깊이보다 자신의 깊이가 더 클 수도 있습니다. 그래서 다음 계층 노드의 깊이와 현재 깊이중 큰것을 높이로 삼습니다.
하여튼 이렇게 재귀함수안으로 들어가면 두번째 계층의 노드도 일단은 높이가 1로 설정이 됩니다. 그리고 나서 다시 다음 계층... 
해서 가장 하위의 계층에 도달하면 자식 노드가 없기때문에 for 문 안의 재귀함수까지 실행이 되지 않고 기본 높이인 1이 리턴이 됩니다. 가장 하층의 노드가 실행이 끝났으니 
바로 위 의 노드는 이제 max(height, 1 + 1) 로 갱신이 됩니다.여기서는 height 는 기본 1로 설정되어 있기 때문에 밑에서 두번째 노드는 2라는 값을 리턴하게 되고 
이게 쭉연결되서 루트 노드까지 오면 실제 높이 값이 리턴됩니다. 

- 정리 
트리는 재귀함수에 익숙하다면 쉽게 이해할 수 있습니다. 물론 이번 시간은 트리의 기초이기 때문이기도 합니다. 
핵심은 재귀함수를 제대로 이해하는것입니다.