

        오른손 법칙 개선


이제 선형 자료구조를 어느정도 순회를 했습니다. 

지금까진 배운 선형 자료구조를 활용해서 맨 처음 만들었던 오른손 법칙이라는 알고리즘? 을 개선해보겠습니다. 

그 전에 잠시 선형 자료구조에 대해 얘기해보면 

// 동적배열
// 연결리스트
// 스택
// 큐 

여기서 사실 스택과 큐는 동적배열과 연결리스트를 활용해서 구현할 수 있었으니까 가장 기초가 되는 내용은 
동적배열과 연결리스트라고 할 수 있습니다.
게다가 면접에서 자주 물어보는 내용이기도 합니다.

신입이 시간 복잡도에 대한 개념과 동적배열, 연결리스트에 대한 특성을 잘 알고 있는지를 알수 있는 질문입니다.
그렇다고 시간복잡도에 대해 달달 외워갈 필요는 없고 각각의 특성을 잘 이해할 수 있으면 그냥 대답 할 수 있는 질문입니다. 


- 본 내용 
이번시간에는 Maze 프로젝트로 가서 작업을 해볼겁니다. 시작 프로젝트로 설정해주고 시작합니다. 

좀 오랫만에 오다 보니까 기억이 가물가물합니다. 한번 실행해보면 25 * 25 크기의 맵에 미로를 이진 트리 알고리즘으로 만들어 주었고 
그 위에서 (1,1) 에서 시작하는 플레이어 타일이 출구 까지 오른쪽 벽을 쭉 따라가면서 움직입니다. 

이제 선형 자료구조를 도입해서 개선할 점을 찾아보겠습니다. 
가장먼저 거슬리는것이 오른손 법칙으로 길을 찾다 보니까 미로의 막다른 길도 오른벽이 이어져있으면 한번씩 꼭 들어갔다가 나오는 부분을 
개선하고 싶습니다. 

최단거리까지는 아니더라도 불필요한 막다른길을 가는 것을 개선 하려면 어떤 방법이 있을지 생각해보니 
스택을 응용해서 개선 해보려고합니다. 
플레이어의 이동경로를 플레이어 초기화 하는 함수에서 미리 쫙 만들고 그 경로를 따라 걷는 부분을 플레이어 업데이트 함수에서 포함하고 있었습니다. 

이때 플레이엉의 경로 path를 스택으로 관리해주면서 한걸음 갈때 마다 다음번에 갈 타일이 스택의 top 과 같은지를 체크하려고 합니다. 
무슨 효과가 있냐면 다음 갈 곳과 top 이 같다면 왔던 길을 돌아 간다는 의미입니다. 그럴때 스택의 최상위 데이터를 pop 해줍니다. 
그리고 나서 다시 그 다음 타일과 top 이 같은지 체크 하면 아직 돌아가는 중이라면 또 같을것이고 이거 반복하면 
남은 경로는 기존의 막다른길까지 모두 갔던 경로에서 막다를 길은 모두 pop 해버린 경로가 남습니다. 

글로 설명하는 것 보다 코드로 구현해가면서 알아보겠습니다. 

코드 위치는 Player::Init 입니다. 

-> Player 클래스 
    현재 Init 에서 _path 를 만들어 주는 반복문이 끝나면 바로 다음으로 넘어가서 렌더링에 들어갔습니다. 
    반복문이 끝나는 부분에서 다시 _path 를 돌면서 막다른 길을 개선해주는 방법으로 해보겠습니다. 
    첫 반복문에서 같이 개선을 할 수도 있지만 코드가 섞이면서 괜히 복잡해 질 수 있기 때문입니다. 
    
    #include <stack>

	stack<Pos> s;

	for (int i = 0; i < _path.size() - 1; i++)
	{
		if (s.empty() == false && s.top() == _path[i + 1])
			s.pop();
		else
			s.push(_path[i]);
	}
	// 목적지 도착 
	if (_path.empty() == false)
		s.push(_path.back());

    출구까지의 경로를 다시 담을 stack<Pos> s 를 생성하고 _path.size() - 1 번 만큼 순회를 돌아줄겁니다. (마지막은 출구일것이기 때문)
    s 가 비어있지 않고 s의 top 과 다음에 갈 곳의 Pos 가 같다면 s 의 pop 을 해줍니다. 아니라면 s 에 push 해주고 있습니다. 
    마지막으로 목적지는 따로 담아주고 있습니다. 
    천천히 읽어보면 이해가 가고 이해가 가면 간단한 로직입니다. 

    그런데 이제 스택을 멤버 변수 _path 로 다시 옮겨 줄겁니다. _path 는 vector 타입이었습니다. 
    이때 스택이 특성상 top(), pop() 을 하면 출구부터 입구까지 가는 경로로 뒤집혀서 나올겁니다. 이걸 뒤집어주는 함수를 호출해줘야 합니다. 
    
	// 스택에서 벡터로 꺼내기
	vector<Pos> path;

	while (s.empty() == false)
	{
		path.push_back(s.top());
		s.pop();
		// 스택 특성상 경로가 뒤집혀서 나옵니다.
	}
	
	// 다시 뒤집어 주기 
	std::reverse(path.begin(), path.end());

	_path = path;


여기까지만 코드를 수정해주고 실행해보면 신기하게도 이제 플레이어가 막다른길은 들르지 않고 출구까지 뛰어갑니다. 
하지만 나중에 미로생성 알고리즘이 달라져서 길이 여러개가 생긴다면 이 경로가 최단거리일것이라는 보장은 없습니다. 

이렇게 이번강의에서는 스택, 큐를 배운 김에 한번 응용하는 기회를 가져보았습니다. 

다음 강의 부터는 좀 더 고급 알고리즘, 자료구조를 가지고 미로 생성과 길찾기 를 개선할것입니다. 
그러기 위해서는 그래프나 우선순위 큐 라는 좀 더 고급 자료구조를 알아야할것입니다.