


        동적 계획법 DYNAMIC PROGRAMMING (DP)



이번시간부터 단원을 넘어서 동적 계획법에 대해 알아보겠습니다. 

강사님의 말씀으로는 동적 계획법을 게임 개발에서 사용했던 적은 한번도 없다고 하십니다. 
그러면 왜 배우나? 

반면 자료구조 공부나 프로그래밍 대회에서는 반대로 대부분 이 동적 계획법을 통해 문제해결을 한다고도 하십니다.

그러면 왜 현업에서는 사용할 일이 없냐면 DP 는 사실 로우하게들어가야 사용할 일이 생깁니다. 
만약 AI 같은걸 만든다면 많이 사용하겠지만 컨탠츠를 만드는 단계에서는 사용할 일이 없습니다. 그래도 이 개념을 이해 하는게 좋은이유는
가끔씩 코딩테스트에 나오기 때문입니다.

이제 동적계획법이 어떤 개념인지 예시를 통해 알아보겠습니다.

- COMBINATION (이항 계수)
지금 이 예시인 이항 계수가 곧 동적 계획법이다 이런 의미는 아니고 동적 계획법을 잘 사용하는 예시중 하나입니다.

문제는 이렇습니다.  
Q) 상자 안에 공 5개가 있다. 공 2개를 뽑는 경우의 수는? 

  각 공에 숫자를 붙힘  1 , 2 , 3 , 4 , 5  

이 문제를 수학적으로 푸는 공식은 Combination 이나 C 등 여러 표기 법이 있습니다. 
n 이 선택할수 있는 공의 총 갯수, k 를 한번에 고를 공의 개수 라고 했을 때 

    n!/k!(n-k)! 

이런 공식이 성립합니다. ! 기호는 펙토리얼을 뜻합니다.

위의 문제를 이 식으로 풀어보면 

    5!/2!(5-2)! = 5*4*3*2*1 /  2*1 * 3*2*1 = 10 

이렇게 풀립니다.

또 다른 공식도 있습니다. 

C(n, k) = C(n-1, k) + C(n-1, k-1) 

이 공식이 왜 이렇게 나오는지 딱 이해가 가지 않습니다. 

1,2,3,4,5 의 공들 중에 3번 공을 하나 정했다고 하겠습니다.
그러면 공을 두개르 뽑아야 할때 뽑히는 공들 중에 3번 공이 포함이 될수도 있고 안될 수도 있습니다.

우선 3번이 포함되지 않는 경우를 보면 1,2,4,5 중 두개의 공을 뽑는경우이고 
반대로 3번이 하나 포함되어 있는경우에는 1,2,4,5 중 한개의 공을 뽑으면 됩니다.
그래서 이런식이 될겁니다. 

    C(5,2) = C(4,2) + C(4,1) = 4*3/2 + 4 = 10 

하여튼 이런 수학 공식을 이항계수라고 할텐데 이중에 두번째로 배웠던 식을 코드로 표현해 볼겁니다.


 int combination(int n, int r)
 {
    // 기저 사례
    if (r == 0 || n == r)
        return 1;
    
    return combination(n-1, r-1) + combination(n-1, r);
 }

기저 사례가 무슨 의미냐면 코드가 아니라 말로 풀어서 생각해보면 당연합니다. n개의 공중에 r개의 공을 뽑는 함수인데 뽑는 공의 수가 0 개 라면 
아무 공도 뽑지 않는 케이스 한 가지 뿐일것이고 반대로 n 과 r 이 같다 즉 모든 공을 뽑는 경우의 수도 1가지일겁니다. 그래서 retrun 1 인겁니다.
두 경우가 아니라면 위에서 알아 봤던 식을 따라 진행합니다.

여기 까지 알아보면 그냥 재귀함수아닌가? 동적계획법이라고 새로운 개면을 배우는 줄 알았는데? 라고 생각이 들 수 있습니다. 

그래서 무엇이 다른지 시간을 한번 재보겠습니다. 


int main()
{
    __int64 start = GetTickCount64();

    int lotto = combination(45, 6);

    __int64 end = GetTickCount64();

    cout << end - start << "ms" << endl;
}

여기서 GetTickCount64 함수는 windows.h 라는 윈도우 API 라이브러리에 있는 함수입니다. 시스템이 시작된 후 경과된 시간 (밀리초)를 가져오는 함수입니다. 
이 프로그램을 시스템 시작하고 얼마나 지난다음 시작했던지 일단 end - start 의 값은 그 사이에 있는 combination 함수가 실행된 시간일겁니다. 

이 값은 저의 환경에서는 70 ms 언저리 의 값이 나옵니다. 0.07 초 라는 이야기인데 이 시간은 사람 입장에서는 되게 빠르게 느껴지지만 컴퓨터 입장에서는 
꽤 늦은 시간입니다. 
그러면 왜 이렇게 느린건지 함수가 잘못되었나? 하는 생각이 듭니다. 
하지만 이 것은 재귀 함수의 한계입니다. 45 개의 숫자중 6개의 번호를 뽑을 때 combination(n-1, r-1) + combination(n-1, r) 을 반복하면서 
결국 r 이 0이 되거나 n == r 인 상태가 될때 까지 내려가서 거기서 부터 1씩 더해 가면서 세는 겁니다. 그렇게 해서 8145060 이라는 경우의 수를 찾은것이니 
생각 보다 늦을 수 밖에 없습니다.

그런데 C(4,2) 로 예시를 들어보면 아래와 같습니다. 

C(4,2) - C(3,1) - C(2,0)
                  C(2,1) - C(1,0)
                           C(1,1)
         C(3,2) - C(2,1) - C(1,0) 
                  C(2,2)   C(1,1)

이런 경우의 수가 있을텐데 이중에 C(2,1) 이라는 경우가 두번 곂쳐서 등장하는 걸 볼 수 있습니다. 지금은 범위가 작아서 한번 밖에 나타 나지 않았지만 
연산 범위가 넓어질 수록 이런 경우가 많아 질텐데 한번 계산했던 값을 굳이 또 계산할 필요는 없을것 같습니다. 

int g_count = 0;

int combination(int n, int r)
{
    // 기저 사례
    if (r == 0 || n == r)
        return 1;

    if (n == 2 && r == 1)
        g_count++;

    return combination(n - 1, r - 1) + combination(n - 1, r);
}

그래서 C(2,1) 인경우가 C(45,6) 안에서는 몇번 겹칠지를 세봤습니다. 결과는 962598 번 이었습니다 

여기서 생각할 수 있는것이 만약 한번 값을 구한 경우라면 그 값을 기억한다면 중복해서 계산하지 않아도 되지 않을까 라는 생각입니다. 

이미 한번 계산한 값을 기억해두는걸 캐시 cache 라고 하는데 이걸 이용한다는 아이디어 입니다. 

- 동적 계획법 개념 정리
결국 동적 계획법 Dynamic Programming 에서 중요한 컨샙은 쪼개서 연산을 한다 입니다. 그 와중에 이미 구한 값이 있으면 그걸 캐싱해서 
사용한다가 핵심적인 개념이라고 할 수 있습니다. 


- 코드 
지금 알아본 개념을 코드로 다시 실습해보면서 알아 보겠습니다. 

동적 계획법은 딱 정해진 코드 형식이 있는것은 아니고 동적 계획법이라는 개념에 맞도록 동작하면 되는 것인데 
그래서 나 스스로의 동적 계획법 스타일을 하나 정해서 그걸 쭉 밀고 나가는 것이 익숙해지기 쉬울겁니다. 

강사님의 스타일로 이 위에서 했던 Combination함수를 동적 계획법으로 만들어 보면 이렇습니다. 

// 메모이제이션 (memoization)
// n이 최대 50 인 경우를 상정할겁니다. cache 의 범위는 [n의 범위][r의 범위] 를 뜻합니다. 
// cache에 이미 구한 답이 있는지를 알아 보기위해 같은 크기의 bool 이차 배열을 만드는것은 메모리 낭비입니다.
// 그래서 초기 값으로 절대 오지 못할 값을 넣어 두고 그걸로 판단합니다. 
int cache[50][50];

int combination(int n, int r)
{
    // 기저 사례
    if (r == 0 || n == r)
        return 1;

    // 이미 답을 구한 적이 있으면 바로 반환 
    int& ret = cache[n][r];
    if (ret != -1)
        return ret;

    // 새로 답을 구해서 캐시에 저장

    return ret = combination(n - 1, r - 1) + combination(n - 1, r);
}

int main()
{
    // cache를 -1로 초기화 
    ::memset(cache, -1, sizeof(cache));

    __int64 start = GetTickCount64();

    int lotto = combination(45, 6);

    __int64 end = GetTickCount64();

    cout << end - start << "ms" << endl;

}

코드를 하나씩 다시 해석해보면 먼저 cache 를 만드는데 int cache[50][50] 이라는 크기로 만들어 주었습니다. 
이 크기가 뜻하는 바는 먼저 숫자를 고를 최대 범위(n)를 50 이라고 가정하는겁니다. 그러면 그 중에 몇개를 뽑을지(r)도 최대 50 개 일겁니다. 
그러니까 지금 이 cache 의 크기는 현재 예제에 맞게 만든 크기이고 정해진것이 아닙니다. 

그리고 cache 에 한번 값이 저장되었는지를 체크하기 위해 같은 크기의 bool 배열을 만들어 줄 수도 있을겁니다. 
bool visited[50][50]; 이렇게 
하지만 지금은 범위가 작기 때문에 괜찮지만 프로그램이 커질수록 비슷한 크기의 배열을 두개씩 만들어야 한다는것은 메모리에 부담이 될 수 있습니다. 

그래서 cache에 프로그램 안에서 절대 올 수 없을 만한 값으로 초기화를 해두면 그 값을 조건삼아 체크할 수 있을겁니다. 
main 함수 의 첫부분에 있는데 ::memset("초기화할 컨테이너", "초기값", "컨테이너의 크기") 이런 기본 메소드를 활용해서 cache를 초기화 해 줄 수도 
있고 아니면 배웠던 대로 2중 for 문을 돌면서 초기화를 해줄 수도 있습니다. 

이제 cache를 만들었고 combination 함수를 볼 차례인데 총 3단계로 이루어 집니다. 
1. 기저사례 : r 이 0이거나 n 과 r 이 같다면 1을 리턴합니다. 이 조건은 이미 위에서 설명했습니다. 
2. cache에 이미 값이 있을 경우 : 이미 한번 연산을 한 값이면 그 값을 바로 반환 
3. 연산한 값을 cache 에 저장 : 처음으로 연산하는 경우는 cache 에 저장하고 그대로 반환 

이 순서대로 코드들이 진행됩니다. 
이때 반환값을 cache에서 미리 int& ret 이라고 받아오는데 여기서 ret을 참조값으로 받아오는게 좋은게 2번 단계에서 반환 될때는 상관 없지만 
3번 단게 까지 갔다면 ret의 원본데이터 위치에 연산값을 저장해줘야 하기 때문에 값을 복사한 변수는 조금 번거롭습니다. 

이제 작성한 프로그램을 실행해서 걸린 시간을 확인해보면 놀랍게도 0 ms 로 획기적으로 줄었습니다.
속도가 줄은 만큼 반복연산이 많았다라는걸 알수 있습니다. 
동적 계획법이 마냥 좋기만한것은 아니고 데이터의 범위가 넓어 질 수록, 한 번 저장될 데이터가 클 수록 cache의 용량을 점점 더 커지게 됩니다. 
이것은 해시 테이블에서도 알아 봤듯이 살을 내주고 뼈를 깍는 듯한 방법입니다.