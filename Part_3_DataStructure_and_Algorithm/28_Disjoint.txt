

            Disjoint 



여기까지 정렬 알고리즘, 선형 자료구조, 트리, 이진 트리, 이진 검색 트리, 레드 블랙 트리, 그래프, DFS, BFS,
다익스트라 알고리즘, A* 알고리즘, 해시 테이블 등을 배우면서 게임프로그래머로서의 정말 기초는 배웠다고 할 수 있다고 합니다. 

그러면 이제 자료구조 알고리즘을 더 이상 하지 않아도 되는가? 
어떤 사람들은 자료구조 알고리즘은 기초만 알면 더이상 하지 않아도 된다고도 하지만 
강사님의 의견은 자료구조 알고리즘은 운동선수의 웨이트 트레이닝에 해당한다고 봅니다.

실무를 뛸때는 거의 대부분의 상황에서 vector 와 map 으로 해결을 할 수 있을텐데 그럼에도 더욱 고급 자료구조 알고리즘을 배우면 
어떤 효과가 있는가 하면 문제 해결의 시야가 넓어진다고 할 수 있습니다. 

서론이었는데 이번 시간이후로는 완전 필수적이진 않지만 알아볼만한 내용들을 다뤄보겠습니다. 

주제는 이렇습니다. 최소 스패닝 트리 (Minimum Spanning Tree)
대략 어디에 속하는 내용이냐면 그래프/트리 응용 이라고 할 수 있습니다.

최소 스패닝 트리는 이 단원의 주제이고 

이번시간의 주제는 선수 지식인 상호 배타적 집합(Disjoint Set) 입니다.

이전에 A* 알고리즘을 배우면서 경로까지의 최선의 노드를 꺼내기 위한 우선순위 큐 라는 자료구조를 사용하면 아주 찰떡처럼 어울렸던 경험이 있습니다. 
마치 A* 알고리즘을 위해 만든 자료구조 였습니다.
 
그렇듯이 단원 주제인 최소 스패닝 트리에 아주 잘맞는 개념인 상호 배타적 집합을 먼저 알아보는것입니다. 


- 상호 배타적 집합 Disjoint Set

이 자료구조를 다른 이름으로는 유니온-파인드 Union-Find 라고 합니다. 고유명사처럼 사용이 되는데 이름 처럼 합치고 찾는데에 특화가 되어 있습니다. 

예시를 들면서 설명해보겠습니다. 
- 게임회사를 다니고 있는데 이런 기획이 들어왔습니다. 리니지라는 게임이 인기가 많고, 배틀그라운드라는 게임도 인기가 많으니 
  리니지 배틀그라운드 라는 게임을 만들도록 하겠다! (혼종) 
  혈맹전 + 서바이벌 이라는 컨텐츠를 만들겁니다. 
  
  사양은 
  1인 팀 1000명 까지 참가가능 (팀ID 0 ~ 999) 
  동맹 (1번팀 + 2번팀 = 새로운 팀) 가능 

  대략 이런 사양서를 보고 코딩을 해야하는데 만약 자료구조 알고리즘을 모르는 상황에서 이걸 구현하려면 이런식일겁니다.
  
void LineageBattleground()
{
	struct User
	{
		int teamId;
		// TODO
	};

	// TODO : UserManager
	vector<User> users;
	for (int i = 0; i < 1000; i++)
	{
		users.push_back(User{ i });
	}

	// 팀 동맹 
	// user 1번 + user 5번 동맹
	users[5].teamId = users[1].teamId;

	// 초반 동맹은 인원이 적으니 단순해 보임 

	// 하지만 후반에 결국 동맹이 커진다면?

	// [1][2][3][4] .... [999]
	// [1][1][1][1]...[2][2][2][2][2] ... [999]
	
	// 세력대 세력의 합병은?
	for (User& user : users)
	{
		if (user.teamId == 1)
			user.teamId = 2;
	}

	// 찾기 연산	O(1)
	// 합치기 연산  O(N)
}

일단 User 데이터는 ID 만들고 있다고 치고 벡터로 유저들을 관리합니다. 사양에서 1000명 의 1인 팀이 가능 하다고 했으니까 for 문으로 만들어 줬고 

게임 초반에는 개인끼리의 동맹을 맺을테니 그냥 어느 한 팀 ID 로 병합되면 되었습니다. 

하지만 진행이 될수록 점점 세력 대 세력의 병합이 되는데 users 라는 벡터에서 어떤 팀들을 병합시키려면 결국 for 문으로 각각 유저의 팀ID 를 체크해서 
병합을 시켜줘야 합니다. 

그래서 시간복잡도는 이렇게 됩니다. 
	// 찾기 연산	O(1)
	// 합치기 연산  O(N)

이런 상황에서 좀 더 효율적으로 개선하고 싶다고 한다면 오늘의 주제인 상호 배타적 집합을 배워야 합니다.

상호 배타적 집합의 특징은 
- 트리구조를 이용한 상호 배타적 집합의 표현을 한다.

트리 구조이므로 각각의 유저들이 노드로 만들어져 있습니다. 

[0] [1] [2] [3] [4] [5]

struct Node
{
    Node* leader;
}
노드들은 자신이 따르는 리더를 포인터로 들고 있을겁니다. 맨 처음에는 자신을 가리킬겁니다. 

다음으로 서로 팀을 맺는다고 하겠습니다.
 [1]    [3]
 [2]   [4][5]

여기에 0번 노드가 5번의 밑으로 들어간다면 또 이렇게 됩니다. 
 [1]    [3]
 [2]   [4][5]
          [0]

이걸 코드로 한번 만들어 보겠습니다. 


class NaiveDisjointSet
{
public:
	NaiveDisjointSet(int n) : _parent(n)
	{
		for (int i = 0; i < n; i++)
			_parent[i] = i;
	}

	// 니 대장이 누구니?
	int Find(int u)
	{
		if (u == _parent[u])
			return u;

		return Find(_parent[u]);
	}

	// u와 v를 합친다 (일단 u가 v 밑으로)
	void Merge(int u, int v)
	{
		// 일단 대장을 찾는다 
		u = Find(u);
		v = Find(v);

		if (u == v)
			return;

		_parent[u] = v;
	}

private:
	vector<int> _parent;
};

노드 구조로 만든다고는 했지만 꼭 노드 구조체를 만들어서 관리할 필요는 없습니다. 우선순위 큐 도 실제 데이터는 벡터로 관리하면서 각 상하 관계만 추적하면 되었듯이 

_parent 라는 벡터의 인덱스가 노드의 ID 라고 하고 그 값이 따르는 대장이라고 하겠습니다. 
맨처음에는 자기 자신이 대장일테니까 생성자에서 인자로 총 노드의 갯수를 받고 각자 자신이 대장이 되도록 생성했습니다. 

찾기와 합치기 기능을 만들어 볼건데 

먼저 Find 에서는 자신의 _parent 를 반환합니다. 인자는 어떤 노드인지를 가리킬거니까 인덱스로 사용합니다. 
인자 u 가 _parent[u] 와 같다면 자기자신이 대장인 상황 즉 최상위 노드입니다. 그러면 대장을 찾은것이니 u를 리턴합니다. 
아니라면 이제 부하노드인 상태일겁니다. 재귀적으로 Find(_parent[u]) 를 리턴하게 되면 결국 최상위 두목을 찾게 될겁니다.

다음은 Merge 는 합칠 두 노드를 받습니다. 일단은 u가 v 밑으로 들어간다고 하면 
u와 v가 부하노드라면 부하끼리는 합칠수가 없습니다. 일단 두목 노드 까지 거슬러 올라가야합니다. 
다 거슬러 올라간 결과 u 와 v 가 같다면 처음부터 한식구였으니까 그냥 return 합니다. 
아니라면 이제 다른 식구끼리 합칠것이니까 u 의 부모를 v 라고 해줍니다.

일단 NaiveDisjointSet 를 만들어 봤는데 이게 딱히 성능이 더 좋다고 한적은 없습니다. 시간 복잡도를 계산해보겠습니다.
그런데 사실 시간복잡도를 구하기 조금 난감한게 Find 에서 부모의 부모를 쭉 타고 올라가는 방식이다 보니까 트리의 높이에 비례한 시간이 걸립니다. 

트리의 높이는 상황에 따라 다른데 운이 좋게 두목 밑으로 평평하게 부하들이 모일수도 있고 
아니면 운 나쁘게 수직적으로 길어질 수도 있습니다.

나쁜경우에는 결국 배열을 사용할때와 같은 성능이 나옵니다. 

이런 경우를 이전에도 본적이 있습니다. 이진 검색 트리를 만들면서 균형이 깨져서 한쪽으로 만 쏠리게 되면 
결국 연결리스트와 같아진다고 했습니다. 그래서 레드 블랙 트리라는 복잡한 알고리즘을 사용해서 균형을 맞춰줬었는데 

이 NaiveDisjointSet 도 균형을 맞춰줘야 합니다.

최대한 균형을 맞추기 위해서는?
- 높이가 낮은 트리를 높이가 높은 트리 밑으로 합병

 [1]    [3]
 [2]   [4][5]
          [0]

이런 상황에서는 [1]의 트리를 [3] 밑으로 합병한다는 말입니다.
이 방법을 Unino-By-Rank 랭크에 의한 합치기 최적화 라고 합니다. 

class DisjointSet
{
public:
	DisjointSet(int n) : _parent(n), _rank(n, 1)
	{
		for (int i = 0; i < n; i++)
			_parent[i] = i;
	}

	// 니 대장이 누구니?
	int Find(int u)
	{
		if (u == _parent[u])
			return u;

		return Find(_parent[u]);
	}

	// u와 v를 합친다 
	void Merge(int u, int v)
	{
		// 일단 대장을 찾는다 
		u = Find(u);
		v = Find(v);

		if (u == v)
			return;
		
		if (_rank[u] > _rank[v])
			swap(u, v);

		// _rank[u] <= _rank[v] 가 보장됨

		_parent[u] = v;

		if (_rank[u] == _rank[v])
			_rank[v]++;
	}

private:
	vector<int> _parent;
	vector<int> _rank;
};

NaiveDisjointSet 에서 몇가지 추가가 됩니다. 먼저 rank 를 추적하기 위해서 vector<int> _rank 멤버 변수가 추가되고 
생성자에서 모든 노드의 높이를 1로 초기화 합니다. 

높이를 사용하는곳은 Merge 함수에서인데 병합할 각 두목을 찾는 데 까지는 동일합니다. 이전에는 다음에 바로 u가 v밑으로 들어갔지만 
이제는 _rank 값을 비교해서 더 낮은 두목이 아래로 들어갈겁니다. 
		if (_rank[u] > _rank[v])
			swap(u, v);
이 코드로 인해서 _rank[u] <= _rank[v] 가 보장이 됩니다. 

병합을 하고 나서 다음 코드가 생각해 볼만합니다. 
		if (_rank[u] == _rank[v])
			_rank[v]++;
병합한 두목노드의 랭크를 더하는 코드인거 같은데 조건이 _rank[u] 와 _rank[v] 가 같을때 입니다. 
왜 이런 조건이 적용되냐면 위에서 u와 v를 스왑하는 코드를 통과한다면 무조건 v 트리의 높이가 u트리의 높이보다 높아집니다. 
 [1]    [3]
 [2]   [4][5]
          [0]
이때 3 트리가 v이고 1 트리가 u 가 되는겁니다. 이게 병합이 된다면 
  [3]
[4][5][1]
   [0][2]
이렇게 되는겁니다. u 트리가 v 트리보다 높이가 낮으니 v 트리의 높이는 변동이 없었습니다. 그러면 이제 u 높이와 v 높이가 같을 때 입니다. 

 [1]    [3]             [3]
 [2]   [4][5]   ->   [4][5][1]
 [6]      [0]           [0][2]
                           [6]
병합되는 u 와 v 의 높이가 같으니 병합후 v의 높이가 1 높아 졌습니다. 

다음으로 Find 도 개선을 해줄수 있습니다. 

	// 니 대장이 누구니?
	int Find(int u)
	{
		if (u == _parent[u])
			return u;

		return _parent[u] = Find(_parent[u]);
	}

이 코드가 무슨 의미이냐면 부하 노드들에서 두목을 찾는 방법이 Find를 호출할때마다 부모의 부모를 쭉 타고 올라가는 방법이었습니다. 
그런데 매번 재귀를 반복하기 보다 한번 두목을 찾았다면 그 노드의 부모를 두목이라고 기억하도록 하는겁니다. 
  [3]                  [3]
 [4][5]       ->     [4][5][0]
    [0]    Find(0) 

한번 Find를 하면 두목의 바로 아래로 가는겁니다. 


이제 이 Find 와 Merge 두가지 기능을 개선한다면 처음 NaiveDisjointSet 보다 성능이 훨씬 좋아집니다. 

개선된 DisjointSet 의 시간 복잡도는 역시 계산하기가 어렵습니다. 
Find를 어느 노드에 했는지, 어떻게 합병되었는지 매 케이스마다 달라지기 때문인데 
그냥 증명은 빼고 결과만 보자면 DisjointSet 의 시간복잡도는 이렇습니다. 

O(Ackermann(n)) ≒ O(1)  (대략적으로 상수의 시간 복잡도)


이번에 배운 DisjointSet 라는 자료구조, 개념을 사용하면 LineageBattleground 같이 데이터 들이 서로 합쳐지고 찾는 상황에서 유용하게 사용할 수 있습니다. 