


            최소 신장 트리 Minimum Spanning Tree



이번 주제인 최소 신장 트리 Minimum Spanning Tree 는 어떻게 보면 그래프의 응용이라고 볼 수 있습니다.

그래프를 간단하게 복습하자면 정점과 간선으로 이루어진 
현실 세계의 사물이나 추상적인 개념 간의 연결 관계를 표현 하는 자료구조 
- 정점 Vertex : 데이터를 표현 (사물, 개념 등)
- 간선 Edge : 정점들을 연결하는데 사용 

그래프는 트리와 비슷하다고 볼 수도 있는데 트리같은경우는 부모-자식 같이 상하 관계로 되어 있는것에 비해 그래프는 상하관계가 없이 
그냥 수평적인 구조를 하고 있습니다.

이전에 그래프를 배우면서 DFS, BFS, 다익스트라, A* 처럼 길찾기 알고리즘들을 공부 했었습니다. 

그리고 그때는 이미 정점들과 간선들이 있는 모델을 가지고 길찾기를 했었는데 

최소 신장 트리는 간선을 만드는것부터 생각합니다. 

그래프 예제)
         ↱[2]
 [0] ↔ [1]       [5]
     ↘ ↓        ↙
       [3] → [4]

위의 모델에서 화살표들을 이제 연결 후보군, 연결 할 수도 있고 안 할 수도 있는 것들이라고 생각해보겠습니다. 

일단 스패닝 트리의 의미는 간선의 수를 최소화 해서, 모든 정점을 연결하는 것을 말합니다.
간선의 수를 최소화 한다는 것도 중요하고, 모든 정점들을 연결한다는것도 중요합니다. 

위의 모델에서 0 -> 3 으로 가는 간선을 뺀다면 간선의 수도 최소화 하고 모든 정점도 연결이 될겁니다. 
         ↱[2]
 [0] ↔ [1]       [5]
        ↓        ↙
       [3] → [4]

간선을 최소화 한다는 말은 사이클이 생기면 안된다는 말입니다. 이전 그래프에서 0, 1, 3 정점들이 서로 간선으로 연결되어 있는거 사이클이라고 합니다. 
이런 경우에는 이 그래프를 스패닝 트리라고 인정할 수 없습니다. 

그런데 지금 든 예시만 스패닝 트리인것은 아닙니다.
         ↱[2]
 [0] ↔ [1]       [5]
     ↘          ↙
       [3] → [4]
이 경우도 역시 스패닝 트리가 됩니다. 아니면 0 ,1 사이의 간선을 끊는 것도 마찬가지로 스패닝 트리입니다. 

그래서 어떤 구조에 대해서 스패닝 트리는 여러가지 존재 할 수 있다는것을 의미합니다. 

스패닝 트리를 만족하는 조건을 정리해서 다시 말해보면
- N개의 정점을 N-1 개의 간선으로 연결하고 사이클을 포함하면 안 된다 조건입니다. 


스패닝 트리의 소개를 하였으니까 이번에는 사용 예를 한번 보겠습니다. 

사용 예시) 통신 네트워크 구축
- 여러 집이 서로 통신 네트워크를 갖출때 집집 마다 모두 연결할 경우의 수를 연결할 필요는 없을 겁니다. 최소한의 비용으로 연결해야 하니까 
  이럴때 스패닝 트리를 사용할 수 있을 겁니다. 


- 최소 스패닝 트리 
스패닝 트리에서 간선의 가중치까지 고려하는것이 최소 스패닝 트리 입니다. 
실전에서 모든 간선의 비용이 같을수는 없을 겁니다. 그래서 그런 조건까지 고려하는 최소 스패닝 트리를 배워 보겠습니다.

위에서 들은 예시 통신 네트워크 구축을 보면 
         5
     15  ↱[2]
 [0] ↔ [1]       [5]
     ↘ ↓ 10     ↙ 5
    35 [3] → [4]
           5
이 여섯가구사이의 간선들과 그 코스트라고 하겠습니다. 

그냥 스패닝 트리에서는 가중치 상관없이 한 모델에서 가능한 스패닝 트리의 가지 수가 많았는데 
최소 스패닝 트리는 각 경로의 코스트 합이 가장 작은 스패닝 트리를 말합니다.


이것이 스패닝 트리, 최소 스패닝 트리의 의미입니다. 
그래프때와 비슷해 보이는데 다른점은 사이클이 없어야 한다는것이고 길 찾기가 아니라 길 뚫기같은 것이라는 점입니다. 



- 크루스칼 (KRUSKAL) MST 알고리즘 

최소 스패닝 트리를 만들기 위한 알고리즘들은 여러가지가 있는데 그 중에 대표적으로 크루스칼 알고리즘이 있습니다.

특징) 탐욕적인 (greedy) 방법을 이용 - 지금 이 순간에 최적인 답을 선택하여 결과를 도출하자 
       이 말이 무슨 말이냐면 어떤 모델이 있는데 정점들과 간선, 간선에는 가중치들이 있다고 하겠습니다. 각 가중치가 다를텐데 
       전체 간선중 가중치가 가장 낮은 간선들 부터 연결해 나가자라는 방법입니다. 
         5
     15  ↱[2]
 [0] ↔ [1]       [5]
     ↘ ↓ 10     ↙ 5
    35 [3] → [4]
           5
       여기서는 가장 가중치가 낮은것이 5짜리 간선 1->2 , 5->4, 3->4 간선입니다. 그래서 이 것들 부터 연결하고 
       다음으로 가중치가 낮은 1->3 간선, 다음은 0<->1 을 연결하게 되면 이제 최소 스패닝 트리를 완성했습니다. 
       이런식으로 한바퀴를 돌아서 최소 스패닝 트리를 완성 시키긴했는데 
       어딘가 엉성해보입니다. 

물론 이 알고리즘이 모든 케이스에 다 적용시킬수는없다고 합니다. 단순히 코스트가 좋은 간선들 부터 연결하다 보면 사이클 구조가 생길 수도 있는데
그러면 스패닝 트리의 기본조건부터 만족시키지 못하게 됩니다. 그래서 체크를 통해 이런 경우는 걸러줘야 하겠습니다.

사이클을 체크하는 방법을 또 생각해봐야 하는데 여러 방법이 있겠지만 간선을 연결시킨 정점들 끼리를 그룹으로 묶는 방법이 있습니다. 
이 방법은 처음에 정점들을 자신 하나만의 그룹을 가지게 되는데 한번 간선을 연결시키면 연결된 두 정점들을 그룹으로 묶습니다. 
이때 같은 그룹안에서 간선이 연결되면 사이클이 만들어지게 되므로 간선을 연결할때는 다른 그룹들을 대상으로만 연결시킬수 있습니다.

여기서 좋은 생각이 떠오를겁니다. 각각을 그룹으로 관리하고 서로 병합하는 것? 바로 이전 시간에 배운 상호 배타적 집합 (Disjoint Set)이 생각납니다. 
물론 그냥 각각의 정점들을 순회하면서 그룹을 세팅해도 되겠지만 데이터 량이 늘어날 수록 점점 속도가 느려질겁니다. 


-- 코드 

이제 위에서 알아본 내용들을 가지고 코드로 실습을 해보겠습니다.

먼저 그래프를 그릴겁니다. 많이 해보았던건데 복습하는겸 만들겠습니다. 

struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent; // 인접 행렬

void CreateGraph()
{
	vertices.resize(6);
	adjacent = vector<vector<int>>(6, vector<int>(6, -1));	// 초기값인 -1 짜리 간선은 연결되지 않은 간선

	adjacent[0][1] = adjacent[1][0] = 15;
	adjacent[0][3] = adjacent[3][0] = 35;
	adjacent[1][2] = adjacent[2][1] = 5;
	adjacent[1][3] = adjacent[3][1] = 10;
	adjacent[3][4] = adjacent[4][3] = 5;
	adjacent[3][5] = adjacent[5][3] = 10;
	adjacent[5][4] = adjacent[4][5] = 5;
}

정점에는 실습이기 때문에 역시 아무런 데이터가 없습니다. 정점들을 관리하는 vertices 와 adjacent 도 그냥 전역 변수로 만들었습니다. 
CreateGraph 에서는 익히 알던 내용의 모델을 만들고 있습니다. 이전과 다른점은 모든 간선들이 서로를 가리키고 있다는점입니다. 

이제 크루스칼을 구현하기 위한 준비을하겠습니다.

u와 v가 연결되고 그 간선의 코스트가 얼마인지를 묶어서 보여주게끔 구조체를 만듭니다.

// u 에서 v로 가고 그 코스트를 나타낼 구조체
struct CostEdge
{
	int cost;
	int u;
	int v;

	bool operator<(CostEdge& other)
	{
		return cost < other.cost;
	}
};

// 쿠르스칼 알고리즘 반환하는것은 완성된 최소 스패닝 트리의 코스트 합
int Kruskal(vector<CostEdge>& selected)
{
	int ret = 0;

	selected.clear();

	// edges 에 그래프의 간선들을 긁어오고 코스트가 좋은 순서대로 정렬
	vector<CostEdge> edges;

	for (int u = 0; u < adjacent.size(); u++)
	{
		for (int v = 0; v < adjacent[u].size(); v++)
		{
			// 간선이 중복되지않도록 체크 
			if (u > v)
				continue;

			int cost = adjacent[u][v];
			if (cost == -1)
				continue;

			edges.push_back(CostEdge{ cost, u, v });
		}
	}

	std::sort(edges.begin(), edges.end());
	

	// 다음은 크루스칼 알고리즘대로 코스트가 좋은 간선들을 연결하기 시작하는데 
	// 거기에 Disjoint Set 을 활용한 그룹 관리추가 

	DisjointSet sets(vertices.size());

	for (CostEdge& edge : edges)
	{
		// 같은 그룹이면 스킵 (안 그러면 사이클 발생)
		if (sets.Find(edge.u) == sets.Find(edge.v))
			continue;

		// 두 그룹을 합친다  
		sets.Merge(edge.u, edge.v);
		selected.push_back(edge);
		ret += edge.cost;
	}

	return ret;
}

시그니처부터 해석하자면 인자로는 vector<CostEdge> 의 인자를 받는데 받는 벡터에는 CreateGraph 에서 만든 그래프를 크루스칼 알고리즘에 맞게 
MST를 구한 간선들을 담아 줄겁니다. 근데 이 vector 를 반환하는게 아니라 int 를 반환하고 있는데 구한 MST 의 모든 코스트 합을 반환하겠습니다. 

코드 내용을 보면 우선 인자의 selected 를 깨끗이 밀어주었습니다. 그리고 ret 라는 int 변수를 만들었는데 여기에는 나중에 MST 를 구성하는 모든 간선
들의 코스트 합을 담을겁니다. 

다음은 CreateGraph 에서 만든 adjacent 의 내용들을 긁어와서 vector<CostEdge> 에 담아줘야 합니다. 그래야 순회를 돌면서 간선들을 연결합니다. 

vector<CostEdge> edges 에 담아줄건데 adjacent의 1차 2차 인덱스 번호를 정점번호로 사용하고있습니다. 즉 2차 벡터입니다. 
이걸 긁어오기 위해서는 이중 for 문을 사용해야합니다. 이중 for 문으로 순회를 돌면서 값이 -1 이거나 u 가 v 보다 크면 continue 를 해주고 있는데 
우선 값이 -1 이면 그래프에서 간선이 없는 경우입니다. 당연히 스킵을 해줘야 하고 u 가 v 보다 클때 스킵하는 이유는 adjacent 를 만들때 
[1][0] = [0][1] = 15 이런식으로 양쪽으로 통하도록 값을 담아 줬습니다. 그냥 edges 에 담으면 두개씩 중복되게 담아지는데 그걸 방지 하기 위해 
대칭되는 데이터들을 스킵해주고 있습니다. 

스킵을 모두 통과했다면 edges 에 push_back 해주는데 CostEdge 의 데이터 순서에 맞게 cost, u, v 순으로 값을 담습니다. 

이중 for 문을 통과하면 코스트의 크기와 상관없이 정점 번호 순으로 담겨있을겁니다. 

크루스칼에서는 탐욕적인 greedy 방법을 사용하는데 실행 당시 가장 코스트가 좋은 순으로 처리를 한다고 했습니다. 그러므로 edges 를 정렬해줍니다. 

정렬된 edges 에는 모든 간선들이 코스트 크기를 기준으로 정렬이 되어있습니다. 여기서 최소 스패닝 트리를 찾기 위해 가장 가장 코스트가 작은 간선들을 먼저 
연결하면서 사이클이 발생하지 않게 했어야 합니다. 

사이클이 생기지 않도록 하는 방법으로 Disjoint Set 을 사용한다고 했었습니다. 이전 시간에 만들어 뒀던 DisjointSet 클래스를 활용하겠습니다. 
sets 라는 이름의 클래스를 만들고 크기는 정점들의 크기만큼으로 초기화 했습니다. 
초기화 했을때는 각 정점들의 두목은 자기 자신들입니다. 

이 상태에서 순회를 도는데 for (CostEdge& edge : edges) 이렇게 돕니다. 
같은 그룹인지를 체크하는 조건문이 if (sets.Find(edge.u) == sets.Find(edge.v)) 인데 이게 왜 같은 그룹인지를 체크 하냐면 
먼저 edge 의 내용물을 다시 알아야 합니다. int u , int v, int cost 로 이루어져 있는데 여기서 u 와 v 는 간선에 연결된 정점의 번호입니다. 
즉 edge.u or edge.v 는 정점의 번호입니다. 이걸 sets.Find 의 인자로 넘겨주면 정점이 소속되어있는 두목으로 타고 올라가는데 이 두목이 같으면 같은 소속인겁니다. 

통과한다면 Merge 로 합쳐줍니다. 이때도 간선인 edge.u, edge.v 를 인자로 주는데 이건 보기에는 간선두개를 합치는것같지만 sets 안에 있는 정점 번호를 말하는겁니다. 

Merge를 했다면 이 두 정점은 같은 그룹이다. 그러니까 간선이 연결되었다는 의미이고 연결된 간선은 selected 에 push_back 해줍니다. 모든 간선을 돌면서 
MST 를 이루는 간선들은 모두 이 selected 에 담길겁니다. 그리고 간선들의 코스트 합인 ret에도 cost값을 더해주고 끝냅니다. 

