


            최소 신장 트리 Minimum Spanning Tree



이번 주제인 최소 신장 트리 Minimum Spanning Tree 는 어떻게 보면 그래프의 응용이라고 볼 수 있습니다.

그래프를 간단하게 복습하자면 정점과 간선으로 이루어진 
현실 세계의 사물이나 추상적인 개념 간의 연결 관계를 표현 하는 자료구조 
- 정점 Vertex : 데이터를 표현 (사물, 개념 등)
- 간선 Edge : 정점들을 연결하는데 사용 

그래프는 트리와 비슷하다고 볼 수도 있는데 트리같은경우는 부모-자식 같이 상하 관계로 되어 있는것에 비해 그래프는 상하관계가 없이 
그냥 수평적인 구조를 하고 있습니다.

이전에 그래프를 배우면서 DFS, BFS, 다익스트라, A* 처럼 길찾기 알고리즘들을 공부 했었습니다. 

그리고 그때는 이미 정점들과 간선들이 있는 모델을 가지고 길찾기를 했었는데 

최소 신장 트리는 간선을 만드는것부터 생각합니다. 

그래프 예제)
         ↱[2]
 [0] ↔ [1]       [5]
     ↘ ↓        ↙
       [3] → [4]

위의 모델에서 화살표들을 이제 연결 후보군, 연결 할 수도 있고 안 할 수도 있는 것들이라고 생각해보겠습니다. 

일단 스패닝 트리의 의미는 간선의 수를 최소화 해서, 모든 정점을 연결하는 것을 말합니다.
간선의 수를 최소화 한다는 것도 중요하고, 모든 정점들을 연결한다는것도 중요합니다. 

위의 모델에서 0 -> 3 으로 가는 간선을 뺀다면 간선의 수도 최소화 하고 모든 정점도 연결이 될겁니다. 
         ↱[2]
 [0] ↔ [1]       [5]
        ↓        ↙
       [3] → [4]

간선을 최소화 한다는 말은 사이클이 생기면 안된다는 말입니다. 이전 그래프에서 0, 1, 3 정점들이 서로 간선으로 연결되어 있는거 사이클이라고 합니다. 
이런 경우에는 이 그래프를 스패닝 트리라고 인정할 수 없습니다. 

그런데 지금 든 예시만 스패닝 트리인것은 아닙니다.
         ↱[2]
 [0] ↔ [1]       [5]
     ↘          ↙
       [3] → [4]
이 경우도 역시 스패닝 트리가 됩니다. 아니면 0 ,1 사이의 간선을 끊는 것도 마찬가지로 스패닝 트리입니다. 

그래서 어떤 구조에 대해서 스패닝 트리는 여러가지 존재 할 수 있다는것을 의미합니다. 

스패닝 트리를 만족하는 조건을 정리해서 다시 말해보면
- N개의 정점을 N-1 개의 간선으로 연결하고 사이클을 포함하면 안 된다 조건입니다. 


스패닝 트리의 소개를 하였으니까 이번에는 사용 예를 한번 보겠습니다. 

사용 예시) 통신 네트워크 구축
- 여러 집이 서로 통신 네트워크를 갖출때 집집 마다 모두 연결할 경우의 수를 연결할 필요는 없을 겁니다. 최소한의 비용으로 연결해야 하니까 
  이럴때 스패닝 트리를 사용할 수 있을 겁니다. 


- 최소 스패닝 트리 
스패닝 트리에서 간선의 가중치까지 고려하는것이 최소 스패닝 트리 입니다. 
실전에서 모든 간선의 비용이 같을수는 없을 겁니다. 그래서 그런 조건까지 고려하는 최소 스패닝 트리를 배워 보겠습니다.

위에서 들은 예시 통신 네트워크 구축을 보면 
         5
     15  ↱[2]
 [0] ↔ [1]       [5]
     ↘ ↓ 10     ↙ 5
    35 [3] → [4]
           5
이 여섯가구사이의 간선들과 그 코스트라고 하겠습니다. 

그냥 스패닝 트리에서는 가중치 상관없이 한 모델에서 가능한 스패닝 트리의 가지 수가 많았는데 
최소 스패닝 트리는 각 경로의 코스트 합이 가장 작은 스패닝 트리를 말합니다.


이것이 스패닝 트리, 최소 스패닝 트리의 의미입니다. 
그래프때와 비슷해 보이는데 다른점은 사이클이 없어야 한다는것이고 길 찾기가 아니라 길 뚫기같은 것이라는 점입니다. 



- 크루스칼 (KRUSKAL) MST 알고리즘 

최소 스패닝 트리를 만들기 위한 알고리즘들은 여러가지가 있는데 그 중에 대표적으로 크루스칼 알고리즘이 있습니다.

특징) 탐욕적인 (greedy) 방법을 이용 - 지금 이 순간에 최적인 답을 선택하여 결과를 도출하자 
       이 말이 무슨 말이냐면 어떤 모델이 있는데 정점들과 간선, 간선에는 가중치들이 있다고 하겠습니다. 각 가중치가 다를텐데 
       전체 간선중 가중치가 가장 낮은 간선들 부터 연결해 나가자라는 방법입니다. 
         5
     15  ↱[2]
 [0] ↔ [1]       [5]
     ↘ ↓ 10     ↙ 5
    35 [3] → [4]
           5
       여기서는 가장 가중치가 낮은것이 5짜리 간선 1->2 , 5->4, 3->4 간선입니다. 그래서 이 것들 부터 연결하고 
       다음으로 가중치가 낮은 1->3 간선, 다음은 0<->1 을 연결하게 되면 이제 최소 스패닝 트리를 완성했습니다. 
       이런식으로 한바퀴를 돌아서 최소 스패닝 트리를 완성 시키긴했는데 
       어딘가 엉성해보입니다. 

물론 이 알고리즘이 모든 케이스에 다 적용시킬수는없다고 합니다. 단순히 코스트가 좋은 간선들 부터 연결하다 보면 사이클 구조가 생길 수도 있는데
그러면 스패닝 트리의 기본조건부터 만족시키지 못하게 됩니다. 그래서 체크를 통해 이런 경우는 걸러줘야 하겠습니다.

사이클을 체크하는 방법을 또 생각해봐야 하는데 여러 방법이 있겠지만 간선을 연결시킨 정점들 끼리를 그룹으로 묶는 방법이 있습니다. 
이 방법은 처음에 정점들을 자신 하나만의 그룹을 가지게 되는데 한번 간선을 연결시키면 연결된 두 정점들을 그룹으로 묶습니다. 
이때 같은 그룹안에서 간선이 연결되면 사이클이 만들어지게 되므로 간선을 연결할때는 다른 그룹들을 대상으로만 연결시킬수 있습니다.

여기서 좋은 생각이 떠오를겁니다. 각각을 그룹으로 관리하고 서로 병합하는 것? 바로 이전 시간에 배운 상호 배타적 집합 (Disjoint Set)이 생각납니다. 
물론 그냥 각각의 정점들을 순회하면서 그룹을 세팅해도 되겠지만 데이터 량이 늘어날 수록 점점 속도가 느려질겁니다. 


-- 코드 

이제 위에서 알아본 내용들을 가지고 코드로 실습을 해보겠습니다.

먼저 그래프를 그릴겁니다. 많이 해보았던건데 복습하는겸 만들겠습니다. 

struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent; // 인접 행렬

void CreateGraph()
{
	vertices.resize(6);
	adjacent = vector<vector<int>>(6, vector<int>(6, -1));	// 초기값인 -1 짜리 간선은 연결되지 않은 간선

	adjacent[0][1] = adjacent[1][0] = 15;
	adjacent[0][3] = adjacent[3][0] = 35;
	adjacent[1][2] = adjacent[2][1] = 5;
	adjacent[1][3] = adjacent[3][1] = 10;
	adjacent[3][4] = adjacent[4][3] = 5;
	adjacent[3][5] = adjacent[5][3] = 10;
	adjacent[5][4] = adjacent[4][5] = 5;
}

정점에는 실습이기 때문에 역시 아무런 데이터가 없습니다. 정점들을 관리하는 vertices 와 adjacent 도 그냥 전역 변수로 만들었습니다. 
CreateGraph 에서는 익히 알던 내용의 모델을 만들고 있습니다. 이전과 다른점은 모든 간선들이 서로를 가리키고 있다는점입니다. 

이제 크루스칼을 구현하기 위한 준비을하겠습니다.

u와 v가 연결되고 그 간선의 코스트가 얼마인지를 묶어서 보여주게끔 구조체를 만듭니다.

// u 에서 v로 가고 그 코스트를 나타낼 구조체
struct CostEdge
{
	int cost;
	int u;
	int v;

	bool operator<(CostEdge& other)
	{
		return cost < other.cost;
	}
};

// 쿠르스칼 알고리즘 반환하는것은 완성된 최소 스패닝 트리의 코스트 합
int Kruskal(vector<CostEdge>& selected)
{
	int ret = 0;

	selected.clear();

	// edges 에 그래프의 간선들을 긁어오고 코스트가 좋은 순서대로 정렬
	vector<CostEdge> edges;

	for (int u = 0; u < adjacent.size(); u++)
	{
		for (int v = 0; v < adjacent[u].size(); v++)
		{
			// 간선이 중복되지않도록 체크 
			if (u > v)
				continue;

			int cost = adjacent[u][v];
			if (cost == -1)
				continue;

			edges.push_back(CostEdge{ cost, u, v });
		}
	}

	std::sort(edges.begin(), edges.end());
	

	// 다음은 크루스칼 알고리즘대로 코스트가 좋은 간선들을 연결하기 시작하는데 
	// 거기에 Disjoint Set 을 활용한 그룹 관리추가 

	DisjointSet sets(vertices.size());

	for (CostEdge& edge : edges)
	{
		// 같은 그룹이면 스킵 (안 그러면 사이클 발생)
		if (sets.Find(edge.u) == sets.Find(edge.v))
			continue;

		// 두 그룹을 합친다  
		sets.Merge(edge.u, edge.v);
		selected.push_back(edge);
		ret += edge.cost;
	}

	return ret;
}

시그니처부터 해석하자면 인자로는 vector<CostEdge> 의 인자를 받는데 받는 벡터에는 CreateGraph 에서 만든 그래프를 크루스칼 알고리즘에 맞게 
MST를 구한 간선들을 담아 줄겁니다. 근데 이 vector 를 반환하는게 아니라 int 를 반환하고 있는데 구한 MST 의 모든 코스트 합을 반환하겠습니다. 

코드 내용을 보면 우선 인자의 selected 를 깨끗이 밀어주었습니다. 그리고 ret 라는 int 변수를 만들었는데 여기에는 나중에 MST 를 구성하는 모든 간선
들의 코스트 합을 담을겁니다. 

다음은 CreateGraph 에서 만든 adjacent 의 내용들을 긁어와서 vector<CostEdge> 에 담아줘야 합니다. 그래야 순회를 돌면서 간선들을 연결합니다. 

vector<CostEdge> edges 에 담아줄건데 adjacent의 1차 2차 인덱스 번호를 정점번호로 사용하고있습니다. 즉 2차 벡터입니다. 
이걸 긁어오기 위해서는 이중 for 문을 사용해야합니다. 이중 for 문으로 순회를 돌면서 값이 -1 이거나 u 가 v 보다 크면 continue 를 해주고 있는데 
우선 값이 -1 이면 그래프에서 간선이 없는 경우입니다. 당연히 스킵을 해줘야 하고 u 가 v 보다 클때 스킵하는 이유는 adjacent 를 만들때 
[1][0] = [0][1] = 15 이런식으로 양쪽으로 통하도록 값을 담아 줬습니다. 그냥 edges 에 담으면 두개씩 중복되게 담아지는데 그걸 방지 하기 위해 
대칭되는 데이터들을 스킵해주고 있습니다. 

스킵을 모두 통과했다면 edges 에 push_back 해주는데 CostEdge 의 데이터 순서에 맞게 cost, u, v 순으로 값을 담습니다. 

이중 for 문을 통과하면 코스트의 크기와 상관없이 정점 번호 순으로 담겨있을겁니다. 

크루스칼에서는 탐욕적인 greedy 방법을 사용하는데 실행 당시 가장 코스트가 좋은 순으로 처리를 한다고 했습니다. 그러므로 edges 를 정렬해줍니다. 

정렬된 edges 에는 모든 간선들이 코스트 크기를 기준으로 정렬이 되어있습니다. 여기서 최소 스패닝 트리를 찾기 위해 가장 가장 코스트가 작은 간선들을 먼저 
연결하면서 사이클이 발생하지 않게 했어야 합니다. 

사이클이 생기지 않도록 하는 방법으로 Disjoint Set 을 사용한다고 했었습니다. 이전 시간에 만들어 뒀던 DisjointSet 클래스를 활용하겠습니다. 
sets 라는 이름의 클래스를 만들고 크기는 정점들의 크기만큼으로 초기화 했습니다. 
초기화 했을때는 각 정점들의 두목은 자기 자신들입니다. 

이 상태에서 순회를 도는데 for (CostEdge& edge : edges) 이렇게 돕니다. 
같은 그룹인지를 체크하는 조건문이 if (sets.Find(edge.u) == sets.Find(edge.v)) 인데 이게 왜 같은 그룹인지를 체크 하냐면 
먼저 edge 의 내용물을 다시 알아야 합니다. int u , int v, int cost 로 이루어져 있는데 여기서 u 와 v 는 간선에 연결된 정점의 번호입니다. 
즉 edge.u or edge.v 는 정점의 번호입니다. 이걸 sets.Find 의 인자로 넘겨주면 정점이 소속되어있는 두목으로 타고 올라가는데 이 두목이 같으면 같은 소속인겁니다. 

통과한다면 Merge 로 합쳐줍니다. 이때도 간선인 edge.u, edge.v 를 인자로 주는데 이건 보기에는 간선두개를 합치는것같지만 sets 안에 있는 정점 번호를 말하는겁니다. 

Merge를 했다면 이 두 정점은 같은 그룹이다. 그러니까 간선이 연결되었다는 의미이고 연결된 간선은 selected 에 push_back 해줍니다. 모든 간선을 돌면서 
MST 를 이루는 간선들은 모두 이 selected 에 담길겁니다. 그리고 간선들의 코스트 합인 ret에도 cost값을 더해주고 끝냅니다. 



------------------------------------------------------------------------------------------------

	Kruskal 알고리즘을 이용한 맵 생성

위에서는 최소 스패닝 트리를 생성하기 위한 알고리즘중 하나인 크루스칼 알고리즘을 알아 봤습니다. 크루스칼 알고리즘은 greedy 방식으로 
가장 코스트가 작은 간선들 부터 연결해 나가는 알고리즘이었고 주의 할 것은 무조건 코스트가 작다고 연결할 것이 아니라 사이클이 발생하지 않도록 
해야하는데 이부분은 DisjointSet 을 이용해서 해결 했었습니다. 

이 알고리즘을 간단하게 실습해보았는데 이전 Part 3 에서 만들었던 Maze 프로젝트에 적용해서 좀 더 근사한 미로를 만드는데 
크루스칼 알고리즘이 사용된다고 합니다. 


Maze 프로젝트를 시작 프로젝트로 설정하고 시작하겠습니다. 맵에 적용하려니까 Board 클래스의 GenerateMap 함수를 보면 될것 같습니다. 

이 GenerateMap 함수는 이번 Part 의 시작부분에서 간단하게 이진 트리 맵 생성 알고리즘을 사용했었습니다. 
이진 트리 맵 생성 알고리즘은 약간 아쉬운점이 있습니다. 결과물에서 맵의 오른쪽 끝 통로와 아래 끝 통로들이 전부 뚫려 있습니다. 

이런 부분을 개선하기 위해서 크루스칼알고리즘을 적용해볼겁니다. 

그전에 이진 트리로 만든 맵을 어떻게 만들었었는지 떠올려 보겠습니다. 

	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)
				_tile[y][x] = TileType::WALL;
			else
				_tile[y][x] = TileType::EMPTY;
		}
	}
가장 처음에 이런 코드로 맵의 기본 작업을 했습니다. 이코드에서는 이중 for 문을 돌면서 x , y 좌표 둘중 하나가 2의 배수이면 WALL 로 지정하고 
아니라면 EMPTY 길로 지정했습니다. 이러면 빨간색 타일과 초록색 타일이 격자무늬로 출력됩니다. 그리고 다시 각 타일을 순회 하면서 초록색 타일끼리를 
오른쪽이나 아래중 랜덤하게 연결하도록 만들었습니다.

그런데 여기서 크루스칼을 적용시키기 위해 격자 무늬 맵에서 초록색 타일을 정점이라고 봐보겠습니다. 그리고 초록색 타일에 인접해 있는 오른쪽과 아래쪽 빨간색 
타일을 간선이라고 생각해보겠습니다. 이때 이 간선들의 코스트를 랜덤으로 지정해줄겁니다. 이제 갈수 있는 모든 간선들이 후보군에 들어가겠지만 
각각의 코스트가 달라지기 때문에 우선순위기 달라질겁니다. 이때 크루스칼 알고리즘을 적용시킨다면 최소 스패닝 트리를 만들게 될겁니다. 

계획은 이렇고 코드로 만들어 보자면 우선 크루스칼을 사용하기 위해 상호 배타적 집합 Disjoint Set 이 필요합니다. 이미 Algorithm 프로젝트에 만들어 봤었지만 
그대로 가져오기 보다는 Maze 프로젝트에 새로 클래스를 파서 사용하겠습니다. 

// DisjointSet 클래스 
	Algorithm 에서 만들었던 DisjointSet 클래스를 그냥 헤더에 복사했습니다. 따로 선언부와 정의부를 나누지 않고 헤더에 몰빵했습니다. 


다시 Board 클래스로 돌아와서 크루스칼에서 사용했던 간선을 표현하는 구조체 CostEdge 를 만들어 줬습니다. 

struct CostEdge
{
	int cost;
	Pos u;
	Pos v;

	bool operator<(CostEdge& other)
	{
		return cost < other.cost;
	}
};
cost 는 말 그대로 이 간선의 코스트 입니다. u 와 v 는 이 간선으로 연결될 정점들입니다. 맵이 이차배열이다 보니 Pos 라는 좌표로 표현됩니다. 
< 연산자 오버로딩은 cost 비교를 하기 위해 만들었습니다. 

이 CostEdge를 vector 로 담아줄 edges 가 필요합니다. 여기에는 맵에 존재하는 모든 간선들을 일단 담습니다. 

// GenerateMap 
	vector<CostEdge> edges;

	// edges 후보를 랜덤 cost로 등록하는 코드 
	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			// 벽인곳은 스킵 
			if (x % 2 == 0 || y % 2 == 0)
				continue;

			// 우측 연결하는 간선 후보 
			if (x < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				edges.push_back(CostEdge{ randValue, Pos{ y, x}, Pos{ y, x + 2} });
			}
			// 아래로 연결하는 간선 후보 
			if (y < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				edges.push_back(CostEdge{ randValue, Pos{ y, x}, Pos{ y + 2, x} });
			}
		}
	}
	
	// 일단 모두 담은 edges 를 sort 합니다. 
	std::sort(edges.begin(), edges.end());

모든 간선을 담기 위해 이중 for 문을 돕니다. 이 코드 위에서 만든 벽인 부분은 스킵을 합니다. 그러면 남은 좌표들은 EMPTY 인 타일들입니다. 
이 상태에서 우측을 연결하는 간선 후보들을 먼저 edges 에 담는데 x 가 _size - 2 보다 작을 조건을 걸어서 최 외각 벽 이전의 x 좌표까지만 범위로 제한합니다 .
랜덤 값을 코스트에 담아주고 u와 v에 는 for 문을 돌고 있는 현재 좌표와 오른쪽으로 다음 칸인 y, x+2 좌표를 담습니다. 

아래로 연결하는 간선후보도 마찬가지로 만들어 줍니다. 

이 이중 for 문을 빠져 나왔다면 모든 간선 후보들이 담깁니다. 여기서 끝이 아니고 이 간선후보들을 cost 를 기준으로 정렬해줍니다. 

간선후보들은 이제 DisjointSet 을 사용해서 연결시켜줄겁니다. 

	DisjointSet sets(_size * _size);

	for (CostEdge& edge : edges)
	{
		// edge의 u v 가 Pos 이다 보니 sets에서 사용할 수 있도록 인덱스 값으로 변환 
		// 이 공식은 2차원 배열을 1차원으로 관리하고 싶을때 사용하는 공식
		int u = edge.u.y * _size + edge.u.x;
		int v = edge.v.y * _size + edge.v.x;

		// 같은 그룹이면 스킵 
		if (sets.Find(u) == sets.Find(v))
			continue;

		// 두 그룹을 합친다 
		sets.Merge(u, v);

		// 맵에 적용  

		// 타일의 좌표는 u 와 v의 사이 타일일겁니다. 이때 edge가 아래쪽 간선인지 오른쪽 간선인지 
		// 모르니 그냥 중간값을 구합니다. 
		int32 y = (edge.u.y + edge.v.y) / 2;
		int32 x = (edge.u.x + edge.v.x) / 2;
		_tile[y][x] = TileType::EMPTY;
	}

DisjointSet sets 의 크기를 _size * _size 로 크게 만들었는데 이유는 DisjointSet 에서 관리하는 데이터는 정점, 노드의 수만큼 크기의 int 벡터입니다. 
인덱스 번호가 자신의 아이디이고 그 인덱스안에 있는 값이 자신의 두목 노드의 아이디인데 즉 우리가 만드는 맵에서는 가로 세로 _size 만큼의 2차 배열입니다. 
vector 로 2차 배열을 표현하기 위해서는 가로 크기만큼씩을 나눠서 해석하면 몇번째 줄에 몇번째 노드 인지를 알 수 있습니다. 

다음으로 edges 의 내용물을 순서대로 하나씩 순회를 도는데 가장 먼저 edge에 담긴 u, v 가 같은 그룹인지를 체크해야합니다. 
그런데 u, v 가 (y,x) 좌표의 Pos 타입이고 sets 도 vector로 2차 벡터를 표현한것이기 때문에 
		int u = edge.u.y * _size + edge.u.x;
		int v = edge.v.y * _size + edge.v.x;
이렇게 u 와 v 를 구해주었습니다. 

같은 그룹이 아니라면 Merge를해줍니다. Merge 된 u v 는 이제 연결되었다고 볼 수 있습니다. 
이전 Disjoint Set 을 실습할때는 연결된 간선을 selected 라는 벡터에 담아주었는데 지금 GenerateMap에서는 그냥 바로 맵에 연결된 간선이 통로로 바뀌도록 
적용해주겠습니다. 

간선의 위치의 타일을 TileType::EMPTY 로 바꿔 줘야 하는데 CostEdge 구조체에서는 간선의 위치는 없고 그 양옆 정점의 위치만 있었습니다. 
게다가 간선은 이 코드 위에서 오른쪽으로 가는 간선, 아래쪽으로 가는 간선 두가지가 있었습니다. 
이 조건들을 만족하는 간선의 위치를 특정하기 위해서 u 와 v의 사이에 있는 좌표를 간선의 위치라고 생각하면 됩니다. 
그 위치의 좌표를 y, x 로 받아주고 실제 맵을 그려주는 멤버 변수인 _tile 에 적용합니다. 

