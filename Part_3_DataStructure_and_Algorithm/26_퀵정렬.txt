


        퀵 정렬 Quick Sort


이번엔 어찌보면 가장 유명한 정렬인 퀵정렬에 대해 알아보겠습니다. 

- 퀵 정렬 

퀵정렬은 이전 시간에 알아본 병합 정렬처럼 분할 정복을 하는것 까지는 비슷한데 
병합 정렬에서는 항상 데이터의 절반씩 나누는 로직인데 비해 
퀵 정렬은 조금 다른게 무엇이냐면 처음부터 일단 데이터를 나누는게 아니라 어떠한 과정을 거친다음에 왼쪽 오른쪽을 나눈다는것이 다릅니다. 

말로하면 그냥 어떠한 과정 이라고 해서 정확한 의미를 알기 어려운것 같습니다. 
예시를 들면서 이해해보겠습니다. 

      left↘                           ↙right 
    arr     [5][1][3][7][9][2][4][6][8]
      pivot↗   ↑low                  ↑high

이런 모델을 예로 들겠습니다. 
데이터는 arr 타입으로 무작위의 숫자가 들어있고 그 배열의 시작과 끝을 left 와 right 로 찝어주고 있습니다. 
거기에 새로 추가된 개념인 pivot, low, high 가 있습니다. 

pivot 은 어떤 기준점이라고 보면 됩니다. 농구의 기술중에 한쪽 축발을 두고 방향 전환을 하는걸 피벗이라고 하는데 그것과 비슷하다고 보면 되겠습니다. 
그리고 피벗을 제외한 첫번째 위치를 low 인덱스 라고 하고 마지막 위치를 high 인덱스라고 합니다.
low 인덱스는 오른쪽으로 이동할것이고 high 인덱스는 왼쪽으로 올것입니다. 

1 단계 
- pivot >= arr[low] 일 동안 low 를 오른쪽으로 이동
- pivot <= arr[high] 일 동안 high 를 왼쪽으로 이동 
    
      left↘                           ↙right 
    arr     [5][1][3][7][9][2][4][6][8]
      pivot↗         ↑        ↑
                     low     high
low 는 1->3->7 까지 갔다가 pivot 보다 7이 크기 때문에 low 가 거기서 멈추었고 high 도 8->6->4 까지 갔다가 5 보다 작아져서 4에서 멈추었습니다. 

2 단계 
- low < high 라면 arr[low]와 arr[high] 데이터 교체 

      left↘                           ↙right 
    arr     [5][1][3][4][9][2][7][6][8]
      pivot↗         ↑        ↑
                     low     high

low < high 라는 조건은 보기에는 당연한것 같지만 한 데이터를 모두 훑으면 low 와 high 가 같아지거나 지나치게 됩니다. 
데이터 교체라는것은 위의 예시에서 보듯이 7 과 4 를 서로 바꿉니다.

이제 2단계 까지 왔다면 다시 1 단계 2 단계를 반복합니다. 

1 단계 

      left↘                           ↙right 
    arr     [5][1][3][4][9][2][7][6][8]
      pivot↗            ↑  ↑
                       low  high

2 단계 

      left↘                           ↙right 
    arr     [5][1][3][4][2][9][7][6][8]
      pivot↗            ↑  ↑
                       low  high

이렇게 쭈욱 진행하면 됩니다. 

그런데 진행을 하다보면 필연적으로 low 와 high 가 곂치거나 엇갈리는 상황이 옵니다.

      left↘                           ↙right 
    arr     [5][1][3][4][2][9][7][6][8]
      pivot↗            ↑  ↑
                     high   low

그러면 여기서는 더이상 진행하지 않고 1,2 단계를 빠져나옵니다. 그리고 나서 3 단계를 진행할건데 


3 단계 
- high <= low 면 빠져나오고, pivot과 arr[high] 교체 

      left↘                           ↙right 
    arr     [2][1][3][4][5][9][7][6][8]
      pivot↗            ↑  ↑
                     high   low

피벗이었던 5와 arr[high] 인 2를 교체했습니다. 

그러면 이게 사살상 끝이라고 보면 된다고 합니다. 
하지만 이게 끝이라는게 뭐가 끝인지 모르겠습니다. 
끝이라고 한 이유를 설명하면 처음의 배열에서 피벗으로 잡은 5 라는 데이터가 정렬된 위치에 가게되었고 5 왼쪽으로는 5보다 작은 값들, 
오른쪽에는 5보다 큰 값들이 밀집해 있게 되었습니다.

그러면 이제 5는 딱 위치를 잡고 5의 왼쪽에 있는 
[2][1][3][4]   와    [9][7][6][8] 
두 배열을 대상으로 아까 한 그 1,2,3 단계를 진행해주면 되겠습니다. 

그러면 매번 할때 마다 pivot 의 위치를 찾아갈것이고 재귀적으로 계속 파고 들어가서 실행하다보면 결국은 모든 원소들이 정렬된 위치를 찾아 가게 
됩니다.

이론적으로 보면 이런 알고리즘입니다. 코드로 보면 또 다른느낌이 나니까 코드로 실습해보겠습니다. 


- 코드 

먼저 Quick Sort 에서 인자로는 배열을 받고 그 시작 인덱스 left 와 끝 인덱스 right 를 받을 겁니다. left 와 right 를 따로 받아야 나중에 재귀적으로 
배열을 나눠 가면서 정렬할 수 있습니다. 

void QuickSort(vector<int>& v, int left, int right)
{
	if (left > right)
		return;
	
	int pivot = Partition(v, left, right);

	QuickSort(v, left, pivot - 1);
	QuickSort(v, pivot + 1, right);
}

left 와 right가 겹치거나 엇갈리면 이제 모든 원소들에 정렬이 끝난상태일겁니다.
그게 아니고 정렬을 진행중이라면 실제 퀵 정렬의 로직들을 Partition 이라는 함수에 담아서 관리합니다. Partition 의 반환 타입은 퀵 정렬 1,2,3 단계를 거치고 
처음 pivot 이었던 데이터가 high 의 자리로 바뀌고 난 다음의 위치 즉, 공정이 끝난 다음의 high 인덱스를 반환합니다. 

그 값을 pivot 이라는 변수에 담고 정렬하려던 배열의 pivot 왼쪽 부분과 오른쪽 부분을 다시 재귀함수로 호출합니다. 

이제 실제 퀵 정렬의 로직이 담긴 Partition 함수를 보겠습니다. 

int Partition(vector<int>& v, int left, int right)
{
	// 피벗 , 로우, 하이 
	int pivot = v[left];
	int low = left + 1;
	int high = right;

	// low 와 high 가 교차되는 때 까지 반복 
	while (low <= high)
	{
		// 1 단계
		// - pivot >= arr[low] 일 동안 low 를 오른쪽으로 이동
		while (low <= right && pivot >= v[low])
			low++;

		// - pivot <= arr[high] 일 동안 high 를 왼쪽으로 이동
		while (high >= left + 1 && pivot <= v[high])
			high--;

		// 2 단계
		// - low < high 라면 arr[low]와 arr[high] 데이터 교체
		if (low < high)
			swap(v[low], v[high]);
	}

	// 3 단계
	// - high <= low 면 빠져나오고, pivot과 arr[high] 교체
	swap(v[left], v[high]);

	return high;
}

Partition은 이론에서 배운걸 그대로 하고 있습니다. 주의해야할점은 1 단계의 while 조건을 정할때 low >= right 나 high >= left + 1 
같은 조건을 && 앞에 두는것인데 코드를 실행할때 && 으로 묶여있어도 앞의 코드부터 진행하다 보니 배열의 범위를 벗어난 데이터에 먼저 접근한 다음 
low 와 high 의 범위를 체크하는것보다 먼저 범위 체크 후 배열에 접근하는것이 좋겠습니다. 

- 시간 복잡도 
이제 시간복잡도를 알아보겠습니다. 
조금 복잡하긴한데 먼저 Partition 함수부터 보겠습니다.
데이터가 N개 있다고 했을때 Partition에서 처음에 보이는것이 이중 while 문입니다. 왠지 N² 일것같아 불안한데 띠지고 보면 그렇지 않습니다. 
이중 반복문은 N개의 데이터를 순회하느걸 N번 하게 되면 N² 이 되지만 지금 여기서는 low 나 high 가 왼쪽으로 가거나 오른쪽으로만 가고 끝납니다. 
즉 N 의 시간 복잡도입니다. 이 다음 코드들은 상수범위 이기 때문에 넘어가겠습니다. 

그러면 이제 문제는 Partition을 QuickSort 함수에서 몇번 호출하는가가 문제입니다.

다시 퀵 정렬을 설명했던 모델을 다시 떠올려보면 피벗이라는 배열의 가장 첫 인덱스에있는 원소를 제 자리에 위치하는 동작을 반복하는 것이었습니다. 
그러니까 피벗에 해당하는 원소가 배열의 중앙에 올만한 값들이라면 절반씩 나눠지면서 정렬이 될텐데 항상 그럴리는 없습니다. 

최악의 경우에는 매번 피벗의 원소가 최소값이라고 한다면 결국은 배열 순으로 쭉 나열하는 N 의 시간복잡도를 가지고 아니면 적절하게 
절반씩 나눠지는 경우에는 logN 의 시간 복잡도를 가지게 됩니다.

최악의 경우 O(N²)
평균적으로는 O(NlogN)

실제로 다른 정렬 알고리즘과 비교를해보면 퀵 정렬이 더 빠릅니다. 
병합 정렬도 똑같이 O(NlogN) 의 시간복잡도이긴 하지만 사실은 함수내에서 임시 벡터를 만들고 데이터를 복사하는 비용을 고려하지 않았습니다. 

퀵 정렬에서는 불필요하게 이것 저것 복사하는 부분은 없었습니다.