


            힙 정렬과 병합 정렬 



저번에 알아본 기초 정렬 세가지 버블 정렬, 선택 정렬, 삽입 정렬 보다 조금 어렵지만 성능이 좋은 두가지 정렬 방법에 대해 알아보겠습니다. 


- 힙 정렬 Heap Sort
    힙 이라는 개념을 여기서 처음 들어 본것이 아니죠 우선순위 큐의 기본이 되는 힙 트리를 배운적이 있습니다. 담겨지는 데이터들을 작거나 큰 순서로 
    원하는 대로 정리하면서 담는 컨테이너 였습니다.
    우선순위 큐 Priority Queue 를 힙 구조로 만든다고 했고 표준 Priority Queue 도 코드를 따라가 보면 make_heap 으로 되어 있습니다. 
    물론 표준이 그렇다고 Priority Queue 를 힙 구조로만 만들수 있다는 말은 아닙니다. Queue 는 Queue 인데 사용자가 지정한 우선순위에 따라 
    값을 추출 할 수 있는 큐를 Priority Queue 라고 하는것이지 힙구조로 만든 Queue 를 Priority Queue 라고 하는것이 아닙니다. 
    굳이 우선순위 큐를 만들때 힙 트리를 사용하지 못하는 경우가 없고 힙 구조가 우선순위 큐와 궁합이 잘 맞기 때문에 사용하는것입니다. 

    그래서 결국 힙 정렬이란 우선순위 큐를 사용해서 하는 정렬입니다. 
    
    void HeapSort(vector<int>& v)
    {
        priority_queue<int, vector<int>, greater<int>> pq;

        for (int num : v)
            pq.push(num);

        v.clear();

        while (pq.empty() == false)
        {
            v.push_back(pq.top());
            pq.pop();
        }
    }
    힙 구조를 직접 다시 만들어서 구현 할 수도 있지만 간편하게 이미 표준인 priority_queue 를 사용해서 만들었습니다.

    그러면 힙 정렬을 사용했을때 시간복잡도는 어떨까요?
    먼저 pq.push() 를 할때의 시간 복잡도는 O(logN) 이었습니다. 하지만 push 를 한번만 하는게 아니라 정렬할 데이터의 양 만큼 반복하기 때문에 
    O(NlogN) 이라고 할 수 있습니다. 
    여기까지 pq.push 하는 부분이었고 다음은 pq 에서 v로 데이터를 넘겨주는 부분입니다. 
    pq.pop 도 마찬가지로 O(logN) 의 시간복잡도를 가지고 있는데 이것을 또 pq 의 size 만큼 반복할것이니까 마찬가지로 O(NlogN) 의 시간복잡도를 가집니다. 
    즉 결국 O(2NlogN) 인데 상수를 곱하는것은 무시 할 수 있다고 했으니까 시간복잡도는 O(NlogN) 입니다. 

    이전에 기초 정렬 방법들의 시간 복잡도인 O(N²) 보다는 훨씬 나은 성능입니다. 
    힙 정렬이란것 자체가 이렇게 간단하게 알아봤습니다. 


- 병합 정렬 
    다음은 병합 정렬입니다. 이 개념이 좀더 생소하고 어려운 개념입니다. 
    병합정렬을 이해하기 위해서는 분할 정복 (Divide and Conquer) 라는 개념을 알아야합니다. 

    분할 정복 Divide and Conquer 
    - 어떤 문제를 해결할때 어렵다면 더 쉬운 문제로 쪼개서 해결할 수 있다는 말이 있습니다. 
    - 분할 (Divide)     문제를 더 단순하게 분할한다
    - 정복 (Conquer)    분할된 문제를 해결
    - 결합 (Combine)    결과를 취합하여 마무리

    이 세단계를 거칠겁니다. 

    그러면 이 분할 정복이 이번 단원의 주제인 정렬과 무슨 상관이 있는지 다시 예시를 들어보겠습니다. 
    또 상황은 트럼프 카드를 예로 들겠습니다. 
    [3][K][7][2][J][4][8][9]    이렇게 8장의 카드가 있습니다. 
    이 8장의 카드가 너무 많아서 손에 들기 어렵다고 해보겠습니다 그래서 절반씩 나눠서 들었습니다. 

    [3][K][7][2] | [J][4][8][9]
    이중 왼쪽을 내가 정렬하고 오른쪽은 동생을 불러 정렬해달라고 맡긴다고 하겠습니다. 
    
    [2][3][7][K] | [4][8][9][J] 
    이제 이렇게 정렬된 두 뭉치의 카드를 합쳐줘야합니다. 이미 정렬되어있는 두 뭉치를 합쳐서 다시 정렬하는것은 비교적 쉬울겁니다. 
    각 뭉치의 앞부분을 비교해서 작은 부터 배치 해주면 될겁니다. 

    이런 과정을 거치는것이 분할정복입니다. 

    병합 정렬은 지금 배운 분할정복을 재귀적으로 사용하는 알고리즘입니다.
    분할 정복을 재귀적으로 사용한다는것은 8개의 카드를 4개, 4개 로 쪼개서 정복하던것을 다시 쪼개서 2개씩 4개의 묶음으로 나눌수 있고 거기에 더해서 
    1개씩 8묶음으로까지 나눌수 있을겁니다. 항상 이렇게 쪼개야한다는것은 아니고 문제를 해결할 수 있을 때 까지 쪼개서 문제해결을 하는것이 중요합니다.
    카드를 1개 단위로 쪼개면 문제 해결이 너무 쉽습니다. 그냥 자기 자신을 반환하면 되니까 1개 단위를 그렇게 해결한 다음은 이제 거슬러 올라가면서 
    결합을 해야합니다. 결합하는 방법은 아까 위에서 알아봤던대로 결합할 각 카드를 비교하면서 합칩니다.

    [3][K][7][2][J][4][8][9]                        8개 * 1
    [3][K][7][2] | [J][4][8][9]                     4개 * 2
    [3][K] | [7][2] | [J][4] | [8][9]               2개 * 4
    [3] | [K] | [7] | [2] | [J] | [4] | [8] | [9]   1개 * 8
    결합
    [3][K] | [2][7] | [4][J] | [8][9]               2개 * 4
    [2][3][7][K] | [4][8][9][J]                     4개 * 2
    [2][3][4][7][8][9][J][K]                        8개 * 1

    이런 과정으로 진행이 되긴 할건데 이걸 어떻게 코드로 구현할지 궁금한데 아까 재귀함수를 사용한다고 들었습니다.

    재귀함수로 벡터를 둘씩 나눈다면 이런 형식이 될까요?

    void MergeSort(vector<int> v)
    {
        MergeSort(v);
        MergeSort(v);
    } 
    이렇게 진행이 된다면 인자인 v 의 앞과 뒤를 어떻게 나눌지 생각해봐야 합니다. 매번 함수 스택 메모리에 v 의 앞부분과 뒷부분을 새로 vector 를 파서 넣어 
    주는 방법은 메모리를 너무 많이 사용하게 될겁니다. 우리 케이스에서는 데이터가 많지 않으니 별 상관이 없을 수 있으나 
    가정으로는 극한의 상황을 가정해야 하기 때문에 그렇게 재귀를 한번 할때 마다 vector 를 만들어 주면 안될것 같습니다. 
    
    그러면 어떻게 v를 둘씩 나눌 수 있을까 생각 해보니 이전에 Queue 를 배울때 vector 를 순환구조로 만들면서 Queue 를 구현해 봤었습니다. 
    그때 vector 의 범위를 조절하기위해 left, right 라는 개념을 가지고 읽을 인덱스를 조절하였는데 그 아이디어를 차용해서 
    v 하나만 인자로 받고 범위를 나누는것을 left, right 로 조절 해보겠습니다. 
    
    void MergeSort(vector<int>& v, int left, int right)
    {

    }

    처음에는 v 의 모든 범위가 유효하다는 의미에서 0 과 7을 넘겨줄것이지만 다음부터는 반으로 잘라서 넘겨줄겁니다.  
    void MergeSort(vector<int>& v, int left, int right)
    {
        if (left >= right)
            return;

        int mid = (left + right) / 2;

        MergeSort(v, left, mid);
        MergeSort(v, mid + 1, right);
    }

    먼저 left 가 right 와 같거나 커지면 재귀가 끝까지 일어났다는 말이 되니까 리턴을 때려줍니다. 이것을 탈출조건이라고도 하고 기저사항이라고도 합니다.
    그리고 중간지점을 만들어 줍니다. 인자로 받은 left 와 right 의 중간 값인데 int 타입이다 보니 어중간한 소수점은 반내림이 됩니다. 
    이제 재귀함수로 mid 를 활용해 절반씩을 다시 인자로 받습니다.
    이때 재귀함수이기 때문에 탈출조건에 걸릴때 까지 절반씩을 줄여 나갈겁니다. 

    이렇게 분할 Divide 까지는 구현했습니다. 

    최종적으로 Divide 를 마치게 되면 원소가 1개인 벡터들이 8개가 될겁니다 이것은 자체로 정렬된 벡터들입니다. 그러면 정복 Conquer 단계를 스킵하고 
    결합 Combine 을 하면될것입니다. 
    결합을 외부에 별도 함수를 만들어 줄겁니다. 시그니처는 이렇습니다. 

    void MergeResult(vector<int>& v, int left, int mid, int right)
    {

    }

    MergeSort 함수 안에서 구했던 mid 값도 인자로 받습니다. 이 MergeResult 함수에서는 left 에서 mid 까지 를 알수 있고 mid + 1 부터 right 까지를 알수 있습니다. 
    위에 예시중 가장 쉬운 케이스인 [3] 과 [K] 를 합치는 경우를 보면 [3][K] 이렇게 합치면 되겠는데 
    조금 더 복잡한 경우를 보면 
    [2][3][7][K] | [4][8][9][J]
    이 두 덩어리를 결합 한다고 했을때 분할에서 결합을 해 올라오면서 각 덩어리 안에서는 정렬이 되어 있다고 했습니다. 
    이제 인자의 left 에서 mid 까지가 2,3,7,K 의 영역이고 mid+1 부터 right 까지가 4,8,9,J 의 영역입니다.
    이 두 덩어리를 합치는 코드는 여러가지 버전이 있겠는데 지금은 간단한 방법을 사용해 보겠습니다. 

    임시적인 벡터를 만들어서 값을 담아 놓는 방법입니다.
        
    void MergeResult(vector<int>& v, int left, int mid, int right)
    {
        int leftIdx = left;
        int rightIdx = mid + 1;

        vector<int> temp;

        while (leftIdx <= mid && rightIdx <= right)
        {
            if (v[leftIdx] <= v[rightIdx])
            {
                temp.push_back(v[leftIdx]);
                leftIdx++;
            }
            else
            {
                temp.push_back(v[rightIdx]);
                rightIdx++;
            }
        }
        
        // 위의 while 문을 빠져 나왔다고 끝난게 아니라 두 덩어리중 한 덩어리가 먼저 끝났다는 이야기

        // 남은 데이터들을 다 push 합니다. 

        // 왼쪽이 먼저 끝났으면, 오른쪽의 나머지 데이터 복사
        if (leftIdx > mid)
        {
            while (rightIdx <= right)
            {
                temp.push_back(v[rightIdx]);
                rightIdx++;
            }
        }
        // 오른쪽이 먼저 끝났으면, 왼쪽의 나머지 데이터 복사
        else
        {
            while (leftIdx <= mid)
            {
                temp.push_back(v[leftIdx]);
                leftIdx++;
            }
        }

        // v 에 temp 를 하나씩 복사합니다. 그런데 v의 모든 영역을 항상 사용할 수 있는건아니고 
        // 인자로 받은 left 의 위치 부터 복사해나가야 하는데 그 이유는 
        // 현재 재귀 함수로 영역을 찝어서 진행하고 있기 때문입니다. 
        for (int i = 0; i < temp.size(); i++)
            v[left + i] = temp[i];
    }

    인자로 받은 left 와 mid 를 사용해서 왼쪽 뭉치의 시작 인덱스와 오른쪽 뭉치의 시작 인덱스를 leftIdx, rightIdx 로 구하고 있습니다. 
    그리고 임시 벡터인 temp 도 만들었습니다. 

    이제 왼쪽 뭉치, 오른쪽 뭉치를 인덱스 순서대로 서로 비교하면서 temp 에 push_back 해줍니다. 
    조건을 leftIdx 가 mid 보다 작거나 같을동안 && rightIdx 가 right 보다 작거나 같을 동안 이라고 했습니다. 이 이야기는 
    항상 두 뭉치가 딱 맞춰서 동시에 push_back 이 끝나는경우는 드물겁니다. 그렇다고 이 while 문 안에서 두 뭉치를 다 처리하기 보다는 
    일단 어느 쪽이든 모두 push_back 먼저 끝날때 까지 만 반복합니다. 

    그리고 다음 코드에서 나머지 데이터들을 처리합니다. 
    먼저 leftIdx 가 mid 보다 작다면 아직 왼쪽 뭉치의 데이터를 모두 push_back 하지 않고 오른쪽 뭉치가 먼저 끝난 상황입니다. 
    그러면 다시 leftIdx 가 mid 보다 같거나 커질때 까지 반복해서 데이터를 push 합니다. 
    반대 경우도 마찬가지입니다. 

    여기까지 오면 v 안에서 left, right 까지 범위의 데이터들을 temp에 정렬된 순서로 담았습니다. 
    이제 이 temp 를 v에 옮겨 복사해줘야 하는데 이때 그냥 temp의 데이터를 v[0] 부터 복사하면 안됩니다. 왜냐면 인자로 받은 left 가 
    항상 v의 0번인것은 아닐수 있기 때문입니다. 

    이렇게 재귀 함수를 사용한 MerghSort 를 배워 봤습니다. 

    그렇지만 재귀함수는 원래 프로그래밍을 배우기 시작할때는 많이 접하지 않은 개념이다 보니까 확 와닿지 않을 수 있습니다. 그래서 
    익숙해 질때까지 차근 차근 짚어보면서 학습하면 좋을것 같습니다.

    코드를 잘 살펴보면 MergeSort 에서 재귀적으로 실행되는 것은 MergeResult에 left 와 mid 와 right 라는 범위를 전달해주기 위한것으로 보입니다. 
    그리고 실제적으로 정렬을 해서 v에 복사하는 것은 MergeResult 인것 처럼 보입니다. 


이렇게 기초 정렬보다 좀 더 어렵지만 성능에서 이점이 있는 두가지 정렬 방법 힙 정렬과 병합 정렬을 알아 보았는데 
힙 정렬은 힙 트리 구조를 사용하는 정렬이었고 병합 정렬은 분할정복이라는 컨샙을 재귀적으로 사용하는 정렬이었습니다. 

그 중 병합 정렬은 그 자체로도 신기한 정렬 알고리즘이지만 기초가 되는 분할정복이라는 컨샙이 진짜 중요한 것입니다. 분할 정복이라는 것은 
병합 정렬뿐만아니라 다른 상황에서도 많이 쓰이기 때문에 꼭 알아야 합니다. 

분할 정복은 일감을 나눠서 처리하는것이기 때문에 멀티 쓰레드 환경에 사용하기 적합하다는 특징도 있습니다. 우선 Part2 에서 배웠던 
Compute 셰이더가 단순한 계산은 GPU에서 작고 많은 연산 장치에 일감을 배정하는 것도 쓰레드를 사용한다고 했었습니다.


- 추가 

이번 정렬 단원을 시작하면서 정렬이 코딩 면접에서 자주 등장한다고 했엇는데 
만약 코딩 면접에서 병합 정렬을 5분이내에 구현 해보라고 한다면 대부분 못하는게 당연할겁니다. 오랜만에 보면 굉장히 햇갈리는 개념이기 때문인데 
프로그래밍이 왠만한 테크닉, 알고리즘을 머리속에서 달달 외워서 사용해야만 하는것이 아닐겁니다 오히려 큰 그림과 어떤 개념이 이 작업과 어울리겠다 
떠올리는 능력이 중요할것이고 실제 자세한 코드는 그때 그때 빨리 배워서 사용하면 될겁니다.

강사님이 코딩 면접에서 받은 문제 중 

vector<int> Merge(vector<int> a, vector<int> b)
{
    vector<int> temp;
    // 이미 정렬된 벡터 a, b 두개를 받아서 두 벡터를 정렬된 또 하나의 벡터로 만들어 반환해라
    return temp;
}

이런 문제를 받으신적이 있다고 합니다. 이런 문제는 지금 배운 병합 정렬에서 MergeResult 의 코드를 활용하면 되는 문제 인데 

이런식으로 병합정렬의 개념을 알고 있고 떠올릴 수 있어야 한다는 말입니다. 