

        동적 배열 구현 연습 


동적 배열, Dinamic Array, Vector 를 코드로 구현해보는 연습입니다. 

사실 Part.1 에서 vector 를 구현 해봤기 때문에 이미 해본 내용이라고 할 수 있는데 동적배열, 연결리스트 구현은 이후의 자료구조들을 
구현하느 가장 기본기이므로 복습하는 의미에서 다시 해보겠습니다.


우리 솔루션을 실행하고 Algorithm 프로젝트를 시작 프로젝트로 설정하면서 시작하겠습니다. 

기본적으로 vector 를 추가하고 std 를 네임스페이스로 사용하겠습니다. 

벡터의 사용법은 간단했었습니다. 벡터안에 담아줄 데이터의 타입을 정하면서 만듭니다. 
그리고 데이터를 넣을때는 벡터.push_back(넣을 데이터) 이렇게 넣어줄 수 있었습니다. 

그리고 또 벡터의 특징이 벡터의 size 와 capacity 라는 것이 있었습니다. 

이 내용들을 간단하게 알아보는 코드를 작성해보았습니다. 
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> V;

	for (int i = 0; i < 100; i++)
	{
		V.push_back(i);

		cout << V[i] << " " << V.size() << " " << V.capacity() << endl;

	}

	V.clear();
	cout << V.size() << " " << V.capacity() << endl;
}
int 를 담는 벡터 V 에 0 부터 99 까지의 정수를 담고 V의 내용, V의 사이즈, V의 capacity 를 출력하고 
마지막으로 V.clear 한 후에 V의 사이즈와 capacity 를 출력하는 코드입니다. 

출력된 결과물중에서 사실 첫번재 V[i] 는 별 의미 없고 V.size() 의 값과 V.capacity() 의 값을 유심히 봐야합니다. 
V.size() 는 V 의 원소가 늘 때마다 비례해서 증가하는데 V.capacity() 의 증가 정도가 특이합니다. 

1, 2, 3, 4, 6, 6, 9, 9, 9, 13 ... 141, 141 
이런식입니다. 게다가 반복문을 빠져나와서 V.clear() 를 한다음 V[i] 와 V.size() 둘 다 0 으로 밀린 것에 비해서 
V.capacity 는 마지막 값인 141 그대로 입니다. 

벡터, 동적배열은 이렇게 size 와 capacity 를 확실하게 이해하고 넘어가는게 중요합니다.

이전 개론시간에서 알아봤던 내용에서 실제 사용하는 방의 개수가 size라고 할 수 있고 미리 예약한 여유공간까지의 개수가 capacity 라고 할 수 있겠습니다. 
이사를 최소화 하기 위해 여유공간을 둔다는 특징을 여기서 알 수 있습니다. 

clear를 해도 capacity 가 유지되는것도 특징입니다. 
이 특징을 보면 동적배열에서 사용하는 데이터가 줄어도 capacity 가 줄 지 않는다면 메모리가 낭비되지 않을까 생각이 되는데 
낭비는 맞긴 하지만 동적배열은 이사 횟수를 최소화하고 연속적으로 데이터를 관리하는것에 목적이 있기 때문에 어느정도 메모리의 낭비가 생겨도 괜찮다고 할 수 있습니다.

그래서 오늘은 간단하게 위의 코드를 우리가 직접 구현해보겠습니다. 
우리가 만들 벡터의 기본 골자는 아래와 같습니다. 
template<typename T>
class Vector
{
public:
	Vector()
	{

	}
	~Vector()
	{

	}

	void push_back()
	{

	}

	void reserve()
	{

	}

	T& operator[](const int pos) { return _data[pos]; }

	int size() { return _size; }

	int capacity() { return _capacity; }

	void clear()
	{

	}

private:
	T*		_data = nullptr;
	int		_size = 0;
	int		_capacity = 0;
};

먼저 템플릿 문법으로 원하는 타입으로 사용할수 있게끔 해주었고 
들고 있을 데이터로는 데이터 그 자체인 _data, 그리고 _size 와 _capacity 입니다. 

[] 연산자, size, capacity 함수는 그대로 그 값을 리턴합니다. 

먼저 push_back 부터 구현해보겠습니다. 
푸시 백에서는 데이터를 밀어넣는 일을 할텐데 그 보다 먼저 이 벡터의 용량이 다 찼는지를 체크해야합니다. 그리고 새로운 여유공간을 만들어서 
현재 여유공간의 1.5배를 곱한값을 담아줄겁니다. 이 때 처음에 0부터 시작할때는 1.5 를 곱해도 값이 커지지 않기 때문에 예외 처리도 해주겠습니다.

		// 현재 사이즈와 여유공간이 같은지 체크 
		if (_size == _capacity)
		{
			// 증설 작업 
			int NewCapatity = static_cast<int>(_capacity * 1.5f);
			if (NewCapatity == _capacity)	// 처음에 사이즈가 작을때 
				NewCapatity++;

			reserve(NewCapatity);
		}

증설 작업때 마지막으로 reserve 함수를 호출하고있는데 이 함수에서 capacity 를 관리해줍니다. 

reserve 에서 할 일은 인자로 받은 capacity 가 기존 _capacity 보다 작다면 그냥 바로 리턴합니다. 
아니라면 _capacity를 새 값으로 교체합니다. 교체된 _capacity 의 크기로 새로운 배열을 할당받습니다. 
그리고 기존 데이터의 내용을 새 데이터에 복사합니다. 기존의 데이터는 필요없으니까 삭제를 해줍니다. 그 다음에는 새 데이터를 멤버 변수로 교체해줍니다. 

여기에 추가로 만약 현제 벡터가 소멸할때도 들고 있는 데이터를 삭제해주는 부분도 잊기전에 추가 해줍니다. 

	~Vector()
	{
		if (_data)
			delete[] _data;
	}
	void reserve(int capacity)
	{
		if (_capacity >= capacity)
			return;

		_capacity = capacity;

		// 새로 할당
		T* NewData = new T[_capacity];

		// 데이터 복사
		for (int i = 0; i < _size; i++)
			NewData[i] = _data[i];

		// 기존 데이터 삭제
		if (_data)
			delete[] _data;

		// 새 동적 배열을 교체
		_data = NewData;
	}

이제 reserve 함수는 메모리를 증설해주는 역할을 맞게될겁니다. 

다시 push_back으로 돌아가서 이어서 만들어 주겠습니다. 
먼저 만든 부분은 벡터가 꽉찼을때의 조건이니까 이걸 빠져 나왔다면 여유공간이 생겼을겁니다. 
이후에는 데이터에 인자로 받은 값을 넣어주겠습니다. 
		// 데이터 저장
		_data[_size] = value;

		// 데이터 개수 증가 
		_size++;


다음으로 clear 함수를 만들어 보겠습니다. 여기서 할 일은 _size 를 0으로 초기화 하고 _data가 들고 있던 데이터를 삭제해줘야합니다. 

	void clear()
	{
		if (_data)
		{
			delete[] _data;
			_data = new T[_capacity];
		}

		_size = 0;
	}

_data 를 삭제하고 다시 할당받는 부분은 간단하게 구현하기 위한 코드입니다. 
실제 vector 라이브러리의 코드에서는 new delete 짝을 이용하지 않고 할당자 alloc 을 이용해서 사용하는 식으로 만들어 져있다고 합니다. 
이 내용은 다른 파트에서 다루기 때문에 이번 파트에서는 다루지 않을것이고 
지금 중요한것은 벡터의 사이즈와 여유공간이 동작하는 방법에 대한 것입니다. 

벡터의 기능중 pop_back 이라고 push_back 의 반대로 맨 뒤의 데이터를 삭제하는 기능이 있는데 이 기능도 원래는 맨 뒤의 데이터의 소멸자만 실행하는 식으로 
구현해야 하지만 지금 우리가 사용하는 new delete 짝을 사용하는 버전에서는 맨뒤의 데이터만 지우는게 아니라 맨뒤를 제외한 모든 데이터를 옮겨 복사하고 
이전 데이터를 전부 삭제하는 식으로 구현해야 합니다. 

이렇게 해서 간단하게 우리만의 벡터를 만들어 봤습니다. 

여기서 알수 있는 재밌는 사실이 있습니다.
동적배열에서는 데이터를 밀어 넣을때 size 와 capacity 같다면 capacity를 증설하고 나서 데이터를 밀어넣고 이때 size는 1씩 증가하고 capacity는 1.5 배씩 증가한다는 
점이 중요합니다. capacity 가 증가하는 배수가 2 인지 1.5 인지는 중요하지 않습니다. 여유공간으로 인해서 데이터 이전이 최소화 된다는 점이 중요합니다. 

이제 우리가 만든 벡터 버전을 실제로 테스트 해보면 기존의 벡터와 같은 결과가 출력됩니다. 

물론 지금 만든 벡터가 기존 벡터와 같다는 의미가 아니고 동적배열의 구조를 이해하기 위해서 직접 만들어본 정도의 의미가 있다고 할 수 있겠습니다. 

그리고 이제 벡터의 작동원리를 조금 알게 되었는데 데이터를 밀어넣는 초반에 capacity 의 증설작업이 여러번 이뤄지면서 새로 배열의 할당이 같이 일어나는걸 알 수 있습니다. 
여기서 우리는 벡터를 사용할 때 관리할 데이터의 크기를 대략적으로 안다면 미리 reserve로 capacity 를 늘려 놓는다면 
데이터 복사 작업을 최소화 할수 있다는걸 알 수 있습니다. 이 강의의 테스트를 예로든다면 
V.reserve(100); 
을 미리 호출하고 나서 데이터들을 쭉 밀어 넣었다면 맨처음에 한번 증설하고 나서 또 데이터 복사가 일어 나지 않을겁니다. 

사용할 데이터의 갯수를 예측할 수 있다면 미리 reserve 를 때리는걸로 성능 향상을 얻을 수 있다는 말입니다. 

여기에 더해서 reserve 말고 resize 라는 메소드도 있습니다. 
reserve 는 capacity를 조절하는 메소드 였다면 resize는 size 를 조절하는 메소드입니다. size를 늘릴때 capacity 가 size 보다 작으면 안되기 때문에 capacity 도 
같이 늘어납니다. 
예시로 
V.reserve(10);  // 결과  size = 0, capacity = 10;
V.resize(10);   // 결과  size = 10, capacity = 10;

그런데 이미 capacity 가 충분하다면 resize 를 실행하면 size만 변하고 capacity 는 더 큰 값 그대로 유지가 됩니다. 
예시
V.reserve(100); 
V.resize(10);
// 결과 size = 10, capacity = 100

마지막으로 이미 100 개의 데이터가 있는 벡터를 resize 하면 어떻게 될까요 
capacity 는 유지되고 resize 한 크기 까지의 데이터도 살아있지만 그 이후의 데이터는 날라갑니다. 
예시 
V.reserve(100);
for (int i = 0; i < 100; i++)
{
    V.push_back[i];
}
V.resize(10);

// 결과 size = 10 , capacity = 100, V 안의 데이터는 0 ~ 9 까지들어있음


참고로 면접을 볼 때 벡터 구현은 은근히 자주 나오는 문제중 하나라고 합니다. 
기초적인 코딩 문법에 대해 숙지 하고 있는지 사이즈와 케퍼시티에 대해 숙지하고 있는지 등을 알고 있는지를 테스트 할 수 있기 때문입니다. 