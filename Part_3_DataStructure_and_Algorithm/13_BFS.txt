

        BFS - 너비 우선 탐색 Breadth First Search


이전 시간에 배운 깊이 우선 탐색 의 짝궁 너비 우선 탐색입니다. 

- 복습 
먼저 이전 내용이었던 DFS 에 대해 조금만 얘기해보겠습니다. 
DFS 는 계속 깊게 파고 들어가면서 탐색하는 알고리즘이었습니다. 
이 방법의 장점은 데이터의 전체 구조가 어떻게 되어있는지를 좀 더 빠르게 알 수 있다는 점이 있습니다.
그리고 구조를 탐색하면서 이 데이터에 순환구조가 있는가를 알 수 있을것입니다. 

이렇게 활용범위가 넓은 BFS 의 다양한 응용, 활용 법에 대해 알아보는것은 개인적으로 또는 나중에 알아보는것이 좋겠습니다. 

일단 기초 개념들 부터 훑고 지나가려고합니다. 


- 본문 
BFS 는 DFS에 비해 사용되는 범위가 좁다고 합니다. 대표적으로 길찾기에서 사용이 되는데 
지금 게임 프로그래밍 알고리즘으로 길찾기를 공부하는 저 입장에서는 BFS 가 더 유용하게 느껴질것입니다. 

BFS 의 개념을 다시 떠올려보면 
시작 정점을 0 으로 설정하고 탐색을 시작한다고 해보겠습니다. 다시 이 탐색을 전사 예시로 들어보겠습니다. 

BFS 라는 신중한 전사는 던전을 탐사함에 있어 신중하게 입구에서 가까운 방부터 하나씩 클리어하는 방식을 따르려고 합니다. 

그러면 이걸 어떻게 구현해야 할지 막막한데 DFS 에서 재귀방식을 사용해서 생각보다 쉽게 구현 했던것 처럼 
BFS 도 어떤 개념을 도입하면 구현이 생각보다 쉬워집니다. 

바로 큐 (Queue) 를 사용해서 어느 방부터 탐색할것인지 목록을 만들어 주는 것입니다. 

말로만 들어서는 잘 와닿지 않는데 직접 코드로 테스트 해보겠습니다. 


- 코드 

실습을 진행할때 이전 시간에 만들었던 그래프를 다시 사용할겁니다. 
먼저 이전에 visited 라고 다음방 there 를 방문 했었는지를 기록하는 전역 변수가 있었습니다. 
vector<bool> visited;
이걸 BFS 에서는 이름을 조금 변경할겁니다. discovered 발견했는지를 의미하는 이름으로 바꿔 줬습니다. 
visited 와 의미가 다르기 때문에 그렇습니다.

그리고 main 에서 discovered 를 시작할때 6개 모두 false 값으로 초기화를 하면서 시작하겠습니다. 


그런데 만들었던 버전이 두가지 있었는데 인접 리스트 버전과 인접 행렬 버전이 있었습니다. 
둘 중 인접 리스트 버전부터 시작해보겠습니다. 

-> 인접 리스트 
    아까 위의 개론때 설명 했던것 처럼 큐에 발견한 방의 목록들을 기록해줄겁니다. 기록을 했다면 발견한 것이니까 그 방의 
    discovered 를 true 로 설정해줄겁니다. 
    
    void Bfs(int here)
    {
        // 발견한 목록을 기록할 큐 
        queue<int> q;
        q.push(here);
        discovered[here] = true;

        while (q.empty() == false)
        {
            here = q.front();
            q.pop();

            cout << "Visited : " << here << endl;

            for (int there : adjacent[here])
            {
                if (discovered[there])
                    continue;

                q.push(there);
                discovered[there] = true;
            }
        }
    }
    
    BFS는 재귀대신 while 을 사용한 방식으로 되어 있습니다. 
    하지만 처음 위의 코드를 보면 DFS 때와 비슷하게 코드가 잘 이해 되지않습니다. 
    그래서 한번 코드를 따라가보면서 이해해보겠습니다. 

    먼저 Bfs(0) 을 해준다는 가정입니다. 
    함수 안으로 들어가면 큐에 현재 방의 번호를 넣어줍니다. 동시에 발견했다고 설정해줍니다. 이 부분은 탐색의 시작부분을 위한 부분입니다. 

    그리고 큐가 비었을 때 까지 반복을 해줄건데 현재는 바로 위에서 here 를 push 해줬으니까 반복문 안으로 들어옵니다. 
    이 안에서는 here 에 큐의 front 맨 처음 푸시 해준 값을 꺼내오고 있습니다. 첫 반복에서는 인자와 front 값이 같으니 그대로 진행합니다. 
    front 값을 가져왔으면 큐에서 지워줍니다. 현재 큐는 비었습니다. 

    하지만 다음에 다시 for 문을 돌건데 here 라는 방번호를 가진 방이 어떤 방과 이어져 있는지를 there 에 받아주면서 반복합니다. 
    이 반복에서 가장 처음 할 일은 there 를 발견했었는지 즉 큐에 push 를 했었는지 입니다. 
    발견햇다면 다음 there 로 넘어가고 발견하지 않았다면 q에 push 하고 발견했다는 기록을 합니다. 

    이제 while 문이 끝났습니다. 현재 큐에는 0번방에 이어져 있던 방의 번호들이 push 되어 있습니다. 그렇다면 다시 while 문 안으로 들어갑니다. 
    그리고 현재 큐의 front 를 here 에 담아주는데 이때 0번방과 이어진 방이 1, 3 번 방이 있었다고 하겠습니다. 순서대로 here에는 1번이 담기고
    pop 됩니다. 현재 큐에는 3만 남았습니다. 
    here에 담기고 pop 되면 이때 방을 방문 했다고 간주합니다. 중요한점은 방의 번호를 큐에 push 할때 방문한게 아니라 발견만 먼저 하고 다음 반복때 방문을 하는겁니다. 
    1번 방에 방문을 한 상태에서 다시 연결된 방을 발견하는 for 문안으로 들어갑니다. 
    1번방과 연결된 방이 2 , 3 번이 있다고 하겠습니다. 그러면 there 가 2 일때 큐에 push 됩니다. 현재 큐는 3, 2 가 담겨있습니다. 담겼으면 발견했다고 기록 
    다음 there 인 3 번은 아까 0번 방의 이어진 방을 push 할때 있었습니다. 그래서 이미 discovered[there] 가 true 입니다. 그러면 push를 다시 하지않고 다음으로 넘어갑니다. 

    이제 1번방과 이어진 방이 더 이상 없기때문에 while 문 시작으로 돌아갑니다. here 에는 3 이 담깁니다. 이후 반복 
    
    이부분이 DFS 와 다른 부분인데 DFS 에서는 연결된 방을 찾으면 바로 그 방을 방문 했지만 BFS 에서는 방을 발견했으면 발견만 하고 그 방의 번호를 큐에 담아서 넘어갑니다. 
    이러면 탐색 시작 지점과 가까운 방 부터 빠지지 않고 탐색을 할 수 있게 됩니다. 

    그런데 여기서 멈추면 다른 방들과 연결되어 있지 않은 방 은 탐색하지 않고 넘어가게됩니다. 이것은 DFS 에서도 마찬가지였는데
    이것도 처리해주겠습니다.
    void BfsAll()
    {
        for (int i = 0; i < 6; i++)
        {
            if (discovered[i] == false)
                Bfs(i);
        }
    }

이런 느낌으로 인접 리스트 방식의 그래프를 BFS 로 탐색 해봤습니다. 
이전에도 말했지만 BFS 만의 재밌는 특성이 있는데 시작점을 기준으로 가까운것부터 탐색을 한다는 점 때문에 
길찾기에서 방들을 탐색해 나갈때 다른 정보를 추가적으로 수집한다고 해보겠습니다. 

예를 들면 내가 어떤 점에 의해 발견이 되었는지, 시작위치에서 몇칸이나 이동햇는지를 추가로 추적해보겠습니다. 

-> BFS 의 특성의 활용 

    void Bfs(int here)
    {
        // 나를 발견한 부모를 추적 
        vector<int> parent = vector<int>(6, -1);
        // 시작점으로 부터의 거리
        vector<int> distance = vector<int>(6, -1);

        // 발견한 목록을 기록할 큐 
        queue<int> q;
        q.push(here);
        discovered[here] = true;

        parent[here] = here;
        distance[here] = 0;

        while (q.empty() == false)
        {
            here = q.front();
            q.pop();

            cout << "Visited : " << here << endl;

            for (int there : adjacent[here])
            {
                if (discovered[there])
                    continue;

                q.push(there);
                discovered[there] = true;
                parent[there] = here;
                distance[there] = distance[here] + 1;
            }
        }
    }

    parent 라는 벡터로 자신을 찾은 방의 번호를 알 추적하고 distance 를 활용해서 시작점으로 부터 몇번의 이동을 통해 도착했는지를 추적하고 있습니다. 
    
    처음 시작 장소에서는 자신의 부모가 없으니 자신을 부모 값으로 해주고 거리도 시작점이니까 0 부터 시작합니다. -1 이라는 값을 가지고 있다면 시작점으로 부터 
    단절 되어 있다는 뜻이 됩니다. 

    그리고 탐색이 진행 되면서 다음 방들을 발견하면서 자신의 부모와 거리를 추적합니다. 

    이런 응용을 가지고 우리가 하던 길찾기에 사용이 됩니다. 시작 장소로 부터 거리가 가장 짧은 루트를 고르면 최단거리 길찾기가 되는겁니다. 

    parent 정보를 말단 부터 타고 들어가면 현재 방까지 도달한 경로도 추적할 수 있습니다. 