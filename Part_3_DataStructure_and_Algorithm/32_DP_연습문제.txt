


            동적 계획법 연습 문제 


동적 계획법의 개념을 알아 봤고 Combination 이라는 예시도 들어 봤습니다. 
하지만 좀 더 능숙하게 사용하려면 몇가지 예제들을 다뤄가면서 좀 더 연습해야 합니다. 


    1. LIS 

LIS (Longest Increasing Sequence) 가장 긴 순 증가 부분 수열 의 길이를 구하는 문제입니다. 

모르는 용어가 여러가지 나왔는데 용어 정리 부터 하면 

수열 (Sequence) : 수의 나열된 것   ex) 1 9 2 5 7
부분 수열 : 일부 (0개 이상) 숫자를 지우고 남은 수열 ex1) 1 2 5   , ex2) 1 9 5 7
순 증가 부분 수열 : 수열의 원소들이 증가만 하는 수열 ex) 1 2 5 

이 용어들을 활용하면 LIS 를 예시 수열에서 구하면  1 2 5 7 = 길이 4 입니다. 

문제를 직접 생각해보는 것도 좋고 아니면 바로 풀이를 보면서 이런 식으로 사용할 수 있구나 하고 배울 수도 있습니다. 

저는 일단 풀이를 보면서 배우도록 하겠습니다. 


vector<int> seq;

int LIS()
{

}

아주 기본되는 틀은 이럴겁니다 당연히 LIS 함수가 뱉어 주는 int 값이 무엇일까요? 가장 먼저 생각해야 할것은 문제 자체에서 요구하는 
값을 반환한다고 생각하는게 좋습니다. 
이번 문제에서는 '가장 긴 순 증가 부분 수열의 길이'를 요구했습니다. 

아직 LIS 에서 매개변수로 뭘 받을지도 정하지 않았습니다. seq 에는 수열이 담길것인데 이 수열의 몇번째 인덱스 부터 읽어 갈 것인지를 구하는 
매개변수를 추가해 봤습니다. 

int LIS(int pos)
{

}
그냥 seq의 모든 값에 대해 LIS 를 실행한다면 pos 를 0번 인덱스라고 넣어주면 될겁니다.

이전 시간의 DP의 기본 틀을 배웠었습니다. 기저사항, 캐시확인, 구하기 3단계로 나뉠겁니다. 

int LIS(int pos)
{
	// 기저사항 

	// 캐시 확인

	// 구하기 
}

먼저 기저사항을 생각해 보겠습니다. (사실 기저사항은 문제에 따라 없을 수도 있습니다.)
이번에는 왠지 LIS 가 실행될 수열의 위치 pos 가 seq 의 범위를 나갔을 경우를 기저사항으로 두겠습니다. 
	//if (pos == seq.size() - 1)
	//	return 1; 
일단은 적어 두었지만 나중에 알아서 챙겨질 수도 있습니다. 

다음은 캐시 확인입니다. 
지금 우리가 구하고 있는게 LIS 의 pos 입니다. (pos 를 그냥 시작위치라고 했었는데 반환에도 사용되는것 같습니다.)
캐시를 바로 만들어 보면 간단하게 
int cache[100];
문제에서 최대길이를 100 이라고 놨다고 가정하고 전역변수로 이렇게 만들었습니다. 
(cache를 동적배열로 만들어서 사용할때마다 resize해서 사용해도 되지만 코딩 문제같은데서는 코드 구조같은건 중요하지 않기 때문에 하드코딩으로 배열을 만들어도 
별 상관 없다고 합니다.)
캐시를 만들었는데 LIS 에서는 길이를 구하는 문제 였습니다. 그러니 캐시도 길이값으로 절대 오지 않을 값으로 밀어줍니다.

	::memset(cache, -1, sizeof(cache));

그리고 캐시확인하는 코드는 이전 시간과 비슷합니다.

	// 캐시 확인
	int& ret = cache[pos];
	if (ret != -1)
		return ret;

다음으로 캐시에 값이 저장 되어 있지 않은 경우 값 구하는 코드입니다. 
예를들어 pos 가 0 부터 시작하고 수열은 위에서 예시를 들었던 수열을 사용한다고 해보겠습니다. 

// Seq ; 1 9 2 5 7
1부터 시작한다고 하면 우선 최소한 1은 LIS 에 들어 있을것이니까 최소 길이가 1은 될겁니다. 
	// 구하기 

	// Seq : 1 9 2 5 7

	// 최소 seq[pos]은 있으니 1부터 시작 
	ret = 1;
여기서 DP 에서는 진행하면서 재귀적으로 처리할 만한 건덕지가 없는지 찾아야 합니다. 

지금 pos 가 0 부터 시작한 상태이면 이제 다음으로 올 수 있는 원소들은 9, 2, 5, 7 이 올 수 있습니다. 이 네가지 수는 모두 0번 인덱스인 1 보다 크기 때문입니다.

만약 다음에 올 수가 9 였다면 
LIS(0) 을 실행하고 있는 중에 재귀적으로 LIS(1) 을 호출하게 될겁니다. LIS(1) 안에서 seq[1] 의 값인 9 는 다음으로 올 수 있는 값중 가장 크기 때문에 
바로 1을 리턴하게 되고 
LIS(1) + 1 이 될것입니다. 잘 이해가 가지 으니 일단 완성된 코드를 한번 보고 이해해보겠습니다.

	for (int next = pos + 1; next < seq.size(); next++)
	{
		if (seq[pos] < seq[next])	// 순 증가 수열의 조건
			ret = max(ret, 1 + LIS(next));
	}
이 코드로 ret 의 최대 값을 구하고 있습니다. 이 코드가 뭘 말하는지 이해해보겠습니다. 

먼저 for 문을 도는데 next = pos + 1 부터 시작합니다. next 가 seq의 사이즈보다 작을때 까지만 반복합니다 next 는 1씩 증가합니다. 
이 for 문이 뜻하는 바는 0번 인덱스였던 1 이 있으니 기본 LIS의 길이가 1이되고 다음으로 뭐가 올 수 있는지 9, 2, 5, 7 을 한번씩 들려보는겁니다. 

for문 안에서는 만약 seq[pos] < sep[next] 인 경우를 조건으로 다시 거르고 있습니다. 이 조건은 pos 가 현재 인덱스이고 다음 인덱스인 next 를 가지고 
seq 에 담긴 원소의 크기를 비교하고 있습니다. 현재 인덱스의 원소가 다음 인덱스의 원소의 크기보다 작을 경우 진행한다. 이것은 순 증가 부분 수열의 조건이었습니다. 

그 안에서 ret = max(ret, 1 + LIS(next)); 라는 코드가 진행 되고 있는데 이 코드가 처음에는 잘 이해되지 않았습니다. 
그래서 예시의 수열을 직접 시뮬레이션을 해보았습니다. 
    
    LIS(0) 에서 이 코드에 도달할때 까지 ret 는 1입니다. 이 코드를 진행하면 첫번째 next 인 1 로 진행됩니다.
    먼저 seq[pos] = 1 이고 seq[next] = 9 이므로 조건은 통과
    그리고 ret  = max(ret, 1 + LIS(1)); 이 실행됩니다. 
    - LIS(1) 에서 for 문 전에도 ret 는 1입니다. for 문 안에 if 문의 조건으로 가보면 seq[1] = 9, seq[2] = 2 입니다. 조건문에 걸러져서 그냥 통과합니다. 
      이렇게 LIS(1) 은 ret값이 1 인 상태로 끝납니다. 
    이제 식은 이렇게 볼 수 있습니다. 
    ret = max(ret, 1 + 1); 이 코드가 실행되는 함수는 LIS(0) 이고 현재 ret는 1로 세팅되어 있기 때문에 1과 2중 큰값 즉, next가 1 인 경우에는 ret는 2 입니다. 

    next는 다음으로 넘어가서 2 가 됩니다. 그리고 이전 next 에서 ret 는 2로 갱신되었습니다. 
    if (seq[0] < seq[2]) 는 if (1 < 2) 이므로 통과 
    ret = max(ret, 1 + LIS(next)) 는  ret = max(2, 1 + LIS(2)) 입니다. 
    그러면 LIS(2) 는 어떤지 보면 LIS 에서도 처음 ret는 1 이고 next 들을 돌면서 진행 됩니다 pos=2, next=3 인경우도 true 이기 때문에 ret가 2로 증가하고 
    poa=3, next=4 인 경우에는 LIS(4) 는 next가 seq 의 범위를 넘어가기 때문에 ret는 1로 리턴될겁니다. (이 부분에서 기저사항이었던 코드를 대체합니다.)
    그러면 LIS(3)에서는 ret = max(1, 1+1), ret = 2 다시 빠져나와서 LIS(2) 일때는 ret = max(1, 1 + 2) 입니다.
    즉 LIS(2) 의 ret 값은 3 입니다. 

    여기서 알 수 있는 것은 max를 사용하면서 next의 경우들중 가장 큰값을 구할 수 있는 겁니다. 
    가장 큰값, 즉 Longest Increasing Sequence 의 길이를 구합니다. 

마지막으로 ret 을 반환해주면 일단 이 값이 LIS 의 길이이긴합니다. 

하지만 더 생각해볼 내용이 있습니다. 
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 1, 9, 2, 5, 7 };

	int ret = LIS(0);
}
이런 코드를 실행하면 0번 인덱스가 우연히 가장 작은 수이기 때문에 제대로된 값이 나옵니다. 

하지만 만약 0번 인덱스의 수가 가장 작은수가 아니라면?
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 10, 1, 9, 2, 5, 7 };

	int ret = LIS(0);
}
이렇게 되면 pos 가 0 이라고 시작하면 값이 1로만 반환됩니다. seq 안에 10 보다 큰숫자가 없기 때문인데 
{ 10, 1, 9, 2, 5, 7 } 의 수열에서도 사실 LIS의 길이는 4여야만 합니다. 10 , 9 를 제외한 부분 수열이 나올수 있기 때문인데 

이 문제를 해결하기 위해서는 결국 seq의 모든 인덱스를 pos 로 삼아서 LIS를 실행해보고 그 max 값을 반환해야합니다.
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 1, 9, 2, 5, 7 };

	int ret = 0;
	for (int pos = 0; pos < seq.size(); pos++)
		ret = max(ret, LIS(pos));
}

이렇게 하면 seq의 모든 인덱스에 대해 한번씩 LIS를 실행해서 가장 긴 ret을 구할 수 있게됩니다. 

원하는 값이 제대로 나오게 되었습니다.

- 추가 
강의는 여기서 끝났는데 저의 의문은 cache의 값을 따로 업데이트 해주는 부분이 없는데 그래도 되는건가 싶었습니다. 
그래서 디버깅을 해보니 이 코드 만으로 cache의 업데이트가 이미 이뤄지고 있었는데 
왜 그런지 다시 곰곰히 생각 해보니 

ret 를 정의 할 때 이미 

int& ret = cache[pos]; 로 정의 했었습니다. 

이 코드를 다시 생각 해보니 ret 를 이리저리 바꾸고 있었는데 그것 자체가 cache안에 있는 값을 참도로 가져온 ret를 건드리고 있던것이어서 
자동으로 업데이트 되었던겁니다. 