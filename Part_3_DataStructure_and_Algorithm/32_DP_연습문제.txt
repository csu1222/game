


            동적 계획법 연습 문제 


동적 계획법의 개념을 알아 봤고 Combination 이라는 예시도 들어 봤습니다. 
하지만 좀 더 능숙하게 사용하려면 몇가지 예제들을 다뤄가면서 좀 더 연습해야 합니다. 


    1. LIS 

LIS (Longest Increasing Sequence) 가장 긴 순 증가 부분 수열 의 길이를 구하는 문제입니다. 

모르는 용어가 여러가지 나왔는데 용어 정리 부터 하면 

수열 (Sequence) : 수의 나열된 것   ex) 1 9 2 5 7
부분 수열 : 일부 (0개 이상) 숫자를 지우고 남은 수열 ex1) 1 2 5   , ex2) 1 9 5 7
순 증가 부분 수열 : 수열의 원소들이 증가만 하는 수열 ex) 1 2 5 

이 용어들을 활용하면 LIS 를 예시 수열에서 구하면  1 2 5 7 = 길이 4 입니다. 

문제를 직접 생각해보는 것도 좋고 아니면 바로 풀이를 보면서 이런 식으로 사용할 수 있구나 하고 배울 수도 있습니다. 

저는 일단 풀이를 보면서 배우도록 하겠습니다. 


vector<int> seq;

int LIS()
{

}

아주 기본되는 틀은 이럴겁니다 당연히 LIS 함수가 뱉어 주는 int 값이 무엇일까요? 가장 먼저 생각해야 할것은 문제 자체에서 요구하는 
값을 반환한다고 생각하는게 좋습니다. 
이번 문제에서는 '가장 긴 순 증가 부분 수열의 길이'를 요구했습니다. 

아직 LIS 에서 매개변수로 뭘 받을지도 정하지 않았습니다. seq 에는 수열이 담길것인데 이 수열의 몇번째 인덱스 부터 읽어 갈 것인지를 구하는 
매개변수를 추가해 봤습니다. 

int LIS(int pos)
{

}
그냥 seq의 모든 값에 대해 LIS 를 실행한다면 pos 를 0번 인덱스라고 넣어주면 될겁니다.

이전 시간의 DP의 기본 틀을 배웠었습니다. 기저사항, 캐시확인, 구하기 3단계로 나뉠겁니다. 

int LIS(int pos)
{
	// 기저사항 

	// 캐시 확인

	// 구하기 
}

먼저 기저사항을 생각해 보겠습니다. (사실 기저사항은 문제에 따라 없을 수도 있습니다.)
이번에는 왠지 LIS 가 실행될 수열의 위치 pos 가 seq 의 범위를 나갔을 경우를 기저사항으로 두겠습니다. 
	//if (pos == seq.size() - 1)
	//	return 1; 
일단은 적어 두었지만 나중에 알아서 챙겨질 수도 있습니다. 

다음은 캐시 확인입니다. 
지금 우리가 구하고 있는게 LIS 의 pos 입니다. (pos 를 그냥 시작위치라고 했었는데 반환에도 사용되는것 같습니다.)
캐시를 바로 만들어 보면 간단하게 
int cache[100];
문제에서 최대길이를 100 이라고 놨다고 가정하고 전역변수로 이렇게 만들었습니다. 
(cache를 동적배열로 만들어서 사용할때마다 resize해서 사용해도 되지만 코딩 문제같은데서는 코드 구조같은건 중요하지 않기 때문에 하드코딩으로 배열을 만들어도 
별 상관 없다고 합니다.)
캐시를 만들었는데 LIS 에서는 길이를 구하는 문제 였습니다. 그러니 캐시도 길이값으로 절대 오지 않을 값으로 밀어줍니다.

	::memset(cache, -1, sizeof(cache));

그리고 캐시확인하는 코드는 이전 시간과 비슷합니다.

	// 캐시 확인
	int& ret = cache[pos];
	if (ret != -1)
		return ret;

다음으로 캐시에 값이 저장 되어 있지 않은 경우 값 구하는 코드입니다. 
예를들어 pos 가 0 부터 시작하고 수열은 위에서 예시를 들었던 수열을 사용한다고 해보겠습니다. 

// Seq ; 1 9 2 5 7
1부터 시작한다고 하면 우선 최소한 1은 LIS 에 들어 있을것이니까 최소 길이가 1은 될겁니다. 
	// 구하기 

	// Seq : 1 9 2 5 7

	// 최소 seq[pos]은 있으니 1부터 시작 
	ret = 1;
여기서 DP 에서는 진행하면서 재귀적으로 처리할 만한 건덕지가 없는지 찾아야 합니다. 

지금 pos 가 0 부터 시작한 상태이면 이제 다음으로 올 수 있는 원소들은 9, 2, 5, 7 이 올 수 있습니다. 이 네가지 수는 모두 0번 인덱스인 1 보다 크기 때문입니다.

만약 다음에 올 수가 9 였다면 
LIS(0) 을 실행하고 있는 중에 재귀적으로 LIS(1) 을 호출하게 될겁니다. LIS(1) 안에서 seq[1] 의 값인 9 는 다음으로 올 수 있는 값중 가장 크기 때문에 
바로 1을 리턴하게 되고 
LIS(1) + 1 이 될것입니다. 잘 이해가 가지 으니 일단 완성된 코드를 한번 보고 이해해보겠습니다.

	for (int next = pos + 1; next < seq.size(); next++)
	{
		if (seq[pos] < seq[next])	// 순 증가 수열의 조건
			ret = max(ret, 1 + LIS(next));
	}
이 코드로 ret 의 최대 값을 구하고 있습니다. 이 코드가 뭘 말하는지 이해해보겠습니다. 

먼저 for 문을 도는데 next = pos + 1 부터 시작합니다. next 가 seq의 사이즈보다 작을때 까지만 반복합니다 next 는 1씩 증가합니다. 
이 for 문이 뜻하는 바는 0번 인덱스였던 1 이 있으니 기본 LIS의 길이가 1이되고 다음으로 뭐가 올 수 있는지 9, 2, 5, 7 을 한번씩 들려보는겁니다. 

for문 안에서는 만약 seq[pos] < sep[next] 인 경우를 조건으로 다시 거르고 있습니다. 이 조건은 pos 가 현재 인덱스이고 다음 인덱스인 next 를 가지고 
seq 에 담긴 원소의 크기를 비교하고 있습니다. 현재 인덱스의 원소가 다음 인덱스의 원소의 크기보다 작을 경우 진행한다. 이것은 순 증가 부분 수열의 조건이었습니다. 

그 안에서 ret = max(ret, 1 + LIS(next)); 라는 코드가 진행 되고 있는데 이 코드가 처음에는 잘 이해되지 않았습니다. 
그래서 예시의 수열을 직접 시뮬레이션을 해보았습니다. 
    
    LIS(0) 에서 이 코드에 도달할때 까지 ret 는 1입니다. 이 코드를 진행하면 첫번째 next 인 1 로 진행됩니다.
    먼저 seq[pos] = 1 이고 seq[next] = 9 이므로 조건은 통과
    그리고 ret  = max(ret, 1 + LIS(1)); 이 실행됩니다. 
    - LIS(1) 에서 for 문 전에도 ret 는 1입니다. for 문 안에 if 문의 조건으로 가보면 seq[1] = 9, seq[2] = 2 입니다. 조건문에 걸러져서 그냥 통과합니다. 
      이렇게 LIS(1) 은 ret값이 1 인 상태로 끝납니다. 
    이제 식은 이렇게 볼 수 있습니다. 
    ret = max(ret, 1 + 1); 이 코드가 실행되는 함수는 LIS(0) 이고 현재 ret는 1로 세팅되어 있기 때문에 1과 2중 큰값 즉, next가 1 인 경우에는 ret는 2 입니다. 

    next는 다음으로 넘어가서 2 가 됩니다. 그리고 이전 next 에서 ret 는 2로 갱신되었습니다. 
    if (seq[0] < seq[2]) 는 if (1 < 2) 이므로 통과 
    ret = max(ret, 1 + LIS(next)) 는  ret = max(2, 1 + LIS(2)) 입니다. 
    그러면 LIS(2) 는 어떤지 보면 LIS 에서도 처음 ret는 1 이고 next 들을 돌면서 진행 됩니다 pos=2, next=3 인경우도 true 이기 때문에 ret가 2로 증가하고 
    poa=3, next=4 인 경우에는 LIS(4) 는 next가 seq 의 범위를 넘어가기 때문에 ret는 1로 리턴될겁니다. (이 부분에서 기저사항이었던 코드를 대체합니다.)
    그러면 LIS(3)에서는 ret = max(1, 1+1), ret = 2 다시 빠져나와서 LIS(2) 일때는 ret = max(1, 1 + 2) 입니다.
    즉 LIS(2) 의 ret 값은 3 입니다. 

    여기서 알 수 있는 것은 max를 사용하면서 next의 경우들중 가장 큰값을 구할 수 있는 겁니다. 
    가장 큰값, 즉 Longest Increasing Sequence 의 길이를 구합니다. 

마지막으로 ret 을 반환해주면 일단 이 값이 LIS 의 길이이긴합니다. 

하지만 더 생각해볼 내용이 있습니다. 
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 1, 9, 2, 5, 7 };

	int ret = LIS(0);
}
이런 코드를 실행하면 0번 인덱스가 우연히 가장 작은 수이기 때문에 제대로된 값이 나옵니다. 

하지만 만약 0번 인덱스의 수가 가장 작은수가 아니라면?
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 10, 1, 9, 2, 5, 7 };

	int ret = LIS(0);
}
이렇게 되면 pos 가 0 이라고 시작하면 값이 1로만 반환됩니다. seq 안에 10 보다 큰숫자가 없기 때문인데 
{ 10, 1, 9, 2, 5, 7 } 의 수열에서도 사실 LIS의 길이는 4여야만 합니다. 10 , 9 를 제외한 부분 수열이 나올수 있기 때문인데 

이 문제를 해결하기 위해서는 결국 seq의 모든 인덱스를 pos 로 삼아서 LIS를 실행해보고 그 max 값을 반환해야합니다.
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 1, 9, 2, 5, 7 };

	int ret = 0;
	for (int pos = 0; pos < seq.size(); pos++)
		ret = max(ret, LIS(pos));
}

이렇게 하면 seq의 모든 인덱스에 대해 한번씩 LIS를 실행해서 가장 긴 ret을 구할 수 있게됩니다. 

원하는 값이 제대로 나오게 되었습니다.

- 추가 
강의는 여기서 끝났는데 저의 의문은 cache의 값을 따로 업데이트 해주는 부분이 없는데 그래도 되는건가 싶었습니다. 
그래서 디버깅을 해보니 이 코드 만으로 cache의 업데이트가 이미 이뤄지고 있었는데 
왜 그런지 다시 곰곰히 생각 해보니 

ret 를 정의 할 때 이미 

int& ret = cache[pos]; 로 정의 했었습니다. 

이 코드를 다시 생각 해보니 ret 를 이리저리 바꾸고 있었는데 그것 자체가 cache안에 있는 값을 참도로 가져온 ret를 건드리고 있던것이어서 
자동으로 업데이트 되었던겁니다. 



    2 . Triangle Path 

동적 계획법 두번째 연습 문제인 트라이앵글 패스 입니다. 

문제 설명부터 하겠습니다. 
먼저 삼각형이 있습니다. 

6
1 2
3 7 4
9 4 1 7
2 7 5 9 4 

이렇게 숫자들이 쌓여서 삼각형 형태를 하고 있습니다. 

- (0, 0) 위의 삼각형에서 가장 위의 6이라는 숫자부터 시작해서 아래 or 아래우측으로 이동 가능
- 만나는 숫자를 모두 더함 
- 더한 숫자가 최대가 되는 경로가 무엇인지? 혹은 숫자를 더한 값이 무엇인지? 를 물어보는 문제 입니다. 

설명한 문제를 프로젝트에 기본적인 내용을 적어 봤습니다.

// 보드의 최대크기를 N*N 으로 만들겠습니다.
int N; 
vector<vector<int>> board;

int path()
{
	
}

int main()
{
	board = vector<vector<int>>
	{
		{6},
		{1,2},
		{3,7,4},
		{9,4,1,7},
		{2,7,5,9,4},
	};

	N = board.size();
}

이제 path 라는 함수안에서 DP로 문제를 풀어 나가면 됩니다. 

path의 반환 타입을 일단 int 로 해놨지만 문제에서 요구하는것도 이동후 값을 합이 최대가 되는 루트 혹은 그 값을 요구하는데 무엇을 반환 타입으로 
정해야 할지 부터 어렵습니다.

근데 먼저 1차적으로 더한 숫자가 최대가 된 그 값을 반환해준다고 하고 시작해보겠습니다.

그런데 값들의 합이라는것 자체가 어디서 부터 시작하는것 부터 결과가 다르겠습니다.
무슨말이냐면 (0,0) 의 6 부터 시작하면 우리가 원하는 문제의 답이 나올것은 알겠습니다. 그런데 만약 (2,2) 에있는 4 부터 시작한다고 해도 

4
1 7
5 9 4 
라는 작은 삼각형안에서 트라이앵글 패스 문제를 풀 수도 있습니다. 그래서 어느 좌표 부터 시작할것인지 그 좌표를 인자로 받아 보겠습니다. 

int path(int y, int x)
{

}

이 상태에서 DP 문제를 해결할때는 재귀 함수를 사용하는것이 좋다고 했었습니다. 그렇기 때문에 이 문제를 어떻게 재귀 함수를 적용할지를 생각해보아야 합니다. 
문제에서 주어진 좌표의 아래방향 또는 아래 우측 방향으로 이동할 수 있다고 했는데 그러면 이 이동은 결국 좌표가 바뀌는 것이니까 아래와 아래우측을 뜻하는 
좌표를 줘가면서 재귀적으로 풀수 있지 않을까요? 
이 발상이 처음에 생각나지 않는다고 해서 이상한게 아닙니다. 이런 발상은 DP 문제를 많이 풀어봐서 훈련이 되어야 자연스럽게 떠오를수 있습니다. 

path 의 코드를 진행하면서 DP에서의 3단계를 일단 생각해야합니다. 

int path(int y, int x)
{
	// 기저 사항 둘 중 하나 선택
	//if (y == N - 1)
	//	return board[y][x];
	if (y == N)
		return 0;

	// 캐시 확인


	// 문제 적용 
}

먼저 기저사항을 보았습니다. 두가지 방법이 있는데 N 이라는 int형 변수에 우리 문제의 예시가 들어있는 board 의 size를 담았었습니다. 
y == N - 1 이라는 조건은 y 좌표가 board의 맨 아래에 닿았는지를 체크하는 조건입니다. 맨 아래에 닿았으면 그 위치의 값을 바로 반환하기위해
return board[y][x]; 를 합니다. 

또 다른 방법인 y == N 이라는 조건은 N이 인덱스가 아닌 사이즈 이기 때문에 y 가 board의 범위를 넘어갔다는 말입니다. 범위를 넘어가면 값이 없을 것이기 때문에
0 을 리턴합니다. 

다음은 캐시 확인입니다. 아직 캐시를 만들지 않았는데 board와 똑같은 형태로 만들어 보겠습니다.

vector<vector<int>> cache;

	cache = vector<vector<int>>{ N, (vector<int>{N, -1}) };

전역메모리에 cache라는 이중 벡터 변수를 만들고 main 함수안에서 cache의 내용물이 N*N의 크기에다가 -1 이라는 값들로 되어있다고 만들었습니다. 
그리고 path 함수안에서는 이렇게 캐시 체크를 해야겠습니다. 

int path(int y, int x)
{
	// 기저 사항 둘 중 하나 선택
	//if (y == N - 1)
	//	return board[y][x];
	if (y == N)
		return 0;

	// 캐시 확인
	int& ret = cache[y][x];
	if (ret != -1)
		return ret;

	// 문제 적용 
}

// 이때 따로 언급하지는 않았지만 캐시에 -1 을 준건은 문제의 조건에서 board의 오는 숫자들은 양수일것이라는 조건이 있어야합니다.

cache[y][x] 의 값을 참조로 받아온 ret 의 값을 체크해서 -1 이 아니면 (y,x) 좌표를 한번 계산했다는 말이 됩니다. 그러므로 바로 리턴합니다. 

다음으로 문제 적용의 단계입니다. 
(y,x) 좌표에서 아래 또는 아래우측으로 가는 방법은 재귀적으로 표현하면 이럴겁니다. 
path(y+1, x);
path(y+1, x+1);
여기에 이동하면서 자신의 값을 더해주면서 가니까 그것 까지 표현해보겠습니다.
	// board[y][x] + path(y + 1, x);
	// board[y][x] + path(y + 1, x + 1);

여기서 이 두 값중에 더 큰값을 찾는 것이고 거기에 cache에도 기록을 해야합니다. 

	return ret = board[y][x] + max(path(y + 1, x), path(y + 1, x + 1));

이렇게 일단 트라이앵글 패스 문제가 요구하는것중에 총 합의 값을 구하는것 까지는 해보았습니다. 


int main()
{
	board = vector<vector<int>>
	{
		{6},
		{1,2},
		{3,7,4},
		{9,4,1,7},
		{2,7,5,9,4},
	};

	N = (int)board.size();
	cache = vector<vector<int>>( N, (vector<int>(N, -1)));

	int ret = path(0, 0);

	std::cout << ret << endl;
}
이렇게 한번 실행 해보면 콘솔에 28 이라는 값이 뜹니다. 어떤경로로 갔는지 예상해보면 6->2->4->7->9 의 경로로 이동한것 같습니다. 

눈으로 대강 예상할 수 있는 이 경로를 코드로도 표현할 수 있어야 합니다.

경로를 추적하는것은 길찾기 알고리즘에서 많이 해봤었습니다.
좌표를 이동하면서 y 좌표는 항상 증가하고 x 좌표는 큰값을 따라 우측으로 이동하던지 아니면 그대로 아래로 내려오던지 할 수 있습니다. 

이걸 추적하기위해 전역 변수하나를 추가합니다. 
vector<vector<int>> nextX;

main 함수안에 초기화도 해줍니다. 
nextX = vector<vector<int>(N, vector<int>(N));

이제 path 함수에서 살펴보면

경로를 추적하는 코드를 넣어주면 될것 같습니다.

	// 경로 기록
	{
		int nextBottom = path(y + 1, x);
		int nextBottomRight = path(y + 1, x + 1);
		
		if (nextBottom < nextBottomRight)
			nextX[y][x] = x + 1;
		else
			nextX[y][x] = x;
	}