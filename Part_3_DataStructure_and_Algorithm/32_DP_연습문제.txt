


            동적 계획법 연습 문제 


동적 계획법의 개념을 알아 봤고 Combination 이라는 예시도 들어 봤습니다. 
하지만 좀 더 능숙하게 사용하려면 몇가지 예제들을 다뤄가면서 좀 더 연습해야 합니다. 


    1. LIS 

LIS (Longest Increasing Sequence) 가장 긴 순 증가 부분 수열 의 길이를 구하는 문제입니다. 

모르는 용어가 여러가지 나왔는데 용어 정리 부터 하면 

수열 (Sequence) : 수의 나열된 것   ex) 1 9 2 5 7
부분 수열 : 일부 (0개 이상) 숫자를 지우고 남은 수열 ex1) 1 2 5   , ex2) 1 9 5 7
순 증가 부분 수열 : 수열의 원소들이 증가만 하는 수열 ex) 1 2 5 

이 용어들을 활용하면 LIS 를 예시 수열에서 구하면  1 2 5 7 = 길이 4 입니다. 

문제를 직접 생각해보는 것도 좋고 아니면 바로 풀이를 보면서 이런 식으로 사용할 수 있구나 하고 배울 수도 있습니다. 

저는 일단 풀이를 보면서 배우도록 하겠습니다. 


vector<int> seq;

int LIS()
{

}

아주 기본되는 틀은 이럴겁니다 당연히 LIS 함수가 뱉어 주는 int 값이 무엇일까요? 가장 먼저 생각해야 할것은 문제 자체에서 요구하는 
값을 반환한다고 생각하는게 좋습니다. 
이번 문제에서는 '가장 긴 순 증가 부분 수열의 길이'를 요구했습니다. 

아직 LIS 에서 매개변수로 뭘 받을지도 정하지 않았습니다. seq 에는 수열이 담길것인데 이 수열의 몇번째 인덱스 부터 읽어 갈 것인지를 구하는 
매개변수를 추가해 봤습니다. 

int LIS(int pos)
{

}
그냥 seq의 모든 값에 대해 LIS 를 실행한다면 pos 를 0번 인덱스라고 넣어주면 될겁니다.

이전 시간의 DP의 기본 틀을 배웠었습니다. 기저사항, 캐시확인, 구하기 3단계로 나뉠겁니다. 

int LIS(int pos)
{
	// 기저사항 

	// 캐시 확인

	// 구하기 
}

먼저 기저사항을 생각해 보겠습니다. (사실 기저사항은 문제에 따라 없을 수도 있습니다.)
이번에는 왠지 LIS 가 실행될 수열의 위치 pos 가 seq 의 범위를 나갔을 경우를 기저사항으로 두겠습니다. 
	//if (pos == seq.size() - 1)
	//	return 1; 
일단은 적어 두었지만 나중에 알아서 챙겨질 수도 있습니다. 

다음은 캐시 확인입니다. 
지금 우리가 구하고 있는게 LIS 의 pos 입니다. (pos 를 그냥 시작위치라고 했었는데 반환에도 사용되는것 같습니다.)
캐시를 바로 만들어 보면 간단하게 
int cache[100];
문제에서 최대길이를 100 이라고 놨다고 가정하고 전역변수로 이렇게 만들었습니다. 
(cache를 동적배열로 만들어서 사용할때마다 resize해서 사용해도 되지만 코딩 문제같은데서는 코드 구조같은건 중요하지 않기 때문에 하드코딩으로 배열을 만들어도 
별 상관 없다고 합니다.)
캐시를 만들었는데 LIS 에서는 길이를 구하는 문제 였습니다. 그러니 캐시도 길이값으로 절대 오지 않을 값으로 밀어줍니다.

	::memset(cache, -1, sizeof(cache));

그리고 캐시확인하는 코드는 이전 시간과 비슷합니다.

	// 캐시 확인
	int& ret = cache[pos];
	if (ret != -1)
		return ret;

다음으로 캐시에 값이 저장 되어 있지 않은 경우 값 구하는 코드입니다. 
예를들어 pos 가 0 부터 시작하고 수열은 위에서 예시를 들었던 수열을 사용한다고 해보겠습니다. 

// Seq ; 1 9 2 5 7
1부터 시작한다고 하면 우선 최소한 1은 LIS 에 들어 있을것이니까 최소 길이가 1은 될겁니다. 
	// 구하기 

	// Seq : 1 9 2 5 7

	// 최소 seq[pos]은 있으니 1부터 시작 
	ret = 1;
여기서 DP 에서는 진행하면서 재귀적으로 처리할 만한 건덕지가 없는지 찾아야 합니다. 

지금 pos 가 0 부터 시작한 상태이면 이제 다음으로 올 수 있는 원소들은 9, 2, 5, 7 이 올 수 있습니다. 이 네가지 수는 모두 0번 인덱스인 1 보다 크기 때문입니다.

만약 다음에 올 수가 9 였다면 
LIS(0) 을 실행하고 있는 중에 재귀적으로 LIS(1) 을 호출하게 될겁니다. LIS(1) 안에서 seq[1] 의 값인 9 는 다음으로 올 수 있는 값중 가장 크기 때문에 
바로 1을 리턴하게 되고 
LIS(1) + 1 이 될것입니다. 잘 이해가 가지 으니 일단 완성된 코드를 한번 보고 이해해보겠습니다.

	for (int next = pos + 1; next < seq.size(); next++)
	{
		if (seq[pos] < seq[next])	// 순 증가 수열의 조건
			ret = max(ret, 1 + LIS(next));
	}
이 코드로 ret 의 최대 값을 구하고 있습니다. 이 코드가 뭘 말하는지 이해해보겠습니다. 

먼저 for 문을 도는데 next = pos + 1 부터 시작합니다. next 가 seq의 사이즈보다 작을때 까지만 반복합니다 next 는 1씩 증가합니다. 
이 for 문이 뜻하는 바는 0번 인덱스였던 1 이 있으니 기본 LIS의 길이가 1이되고 다음으로 뭐가 올 수 있는지 9, 2, 5, 7 을 한번씩 들려보는겁니다. 

for문 안에서는 만약 seq[pos] < sep[next] 인 경우를 조건으로 다시 거르고 있습니다. 이 조건은 pos 가 현재 인덱스이고 다음 인덱스인 next 를 가지고 
seq 에 담긴 원소의 크기를 비교하고 있습니다. 현재 인덱스의 원소가 다음 인덱스의 원소의 크기보다 작을 경우 진행한다. 이것은 순 증가 부분 수열의 조건이었습니다. 

그 안에서 ret = max(ret, 1 + LIS(next)); 라는 코드가 진행 되고 있는데 이 코드가 처음에는 잘 이해되지 않았습니다. 
그래서 예시의 수열을 직접 시뮬레이션을 해보았습니다. 
    
    LIS(0) 에서 이 코드에 도달할때 까지 ret 는 1입니다. 이 코드를 진행하면 첫번째 next 인 1 로 진행됩니다.
    먼저 seq[pos] = 1 이고 seq[next] = 9 이므로 조건은 통과
    그리고 ret  = max(ret, 1 + LIS(1)); 이 실행됩니다. 
    - LIS(1) 에서 for 문 전에도 ret 는 1입니다. for 문 안에 if 문의 조건으로 가보면 seq[1] = 9, seq[2] = 2 입니다. 조건문에 걸러져서 그냥 통과합니다. 
      이렇게 LIS(1) 은 ret값이 1 인 상태로 끝납니다. 
    이제 식은 이렇게 볼 수 있습니다. 
    ret = max(ret, 1 + 1); 이 코드가 실행되는 함수는 LIS(0) 이고 현재 ret는 1로 세팅되어 있기 때문에 1과 2중 큰값 즉, next가 1 인 경우에는 ret는 2 입니다. 

    next는 다음으로 넘어가서 2 가 됩니다. 그리고 이전 next 에서 ret 는 2로 갱신되었습니다. 
    if (seq[0] < seq[2]) 는 if (1 < 2) 이므로 통과 
    ret = max(ret, 1 + LIS(next)) 는  ret = max(2, 1 + LIS(2)) 입니다. 
    그러면 LIS(2) 는 어떤지 보면 LIS 에서도 처음 ret는 1 이고 next 들을 돌면서 진행 됩니다 pos=2, next=3 인경우도 true 이기 때문에 ret가 2로 증가하고 
    poa=3, next=4 인 경우에는 LIS(4) 는 next가 seq 의 범위를 넘어가기 때문에 ret는 1로 리턴될겁니다. (이 부분에서 기저사항이었던 코드를 대체합니다.)
    그러면 LIS(3)에서는 ret = max(1, 1+1), ret = 2 다시 빠져나와서 LIS(2) 일때는 ret = max(1, 1 + 2) 입니다.
    즉 LIS(2) 의 ret 값은 3 입니다. 

    여기서 알 수 있는 것은 max를 사용하면서 next의 경우들중 가장 큰값을 구할 수 있는 겁니다. 
    가장 큰값, 즉 Longest Increasing Sequence 의 길이를 구합니다. 

마지막으로 ret 을 반환해주면 일단 이 값이 LIS 의 길이이긴합니다. 

하지만 더 생각해볼 내용이 있습니다. 
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 1, 9, 2, 5, 7 };

	int ret = LIS(0);
}
이런 코드를 실행하면 0번 인덱스가 우연히 가장 작은 수이기 때문에 제대로된 값이 나옵니다. 

하지만 만약 0번 인덱스의 수가 가장 작은수가 아니라면?
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 10, 1, 9, 2, 5, 7 };

	int ret = LIS(0);
}
이렇게 되면 pos 가 0 이라고 시작하면 값이 1로만 반환됩니다. seq 안에 10 보다 큰숫자가 없기 때문인데 
{ 10, 1, 9, 2, 5, 7 } 의 수열에서도 사실 LIS의 길이는 4여야만 합니다. 10 , 9 를 제외한 부분 수열이 나올수 있기 때문인데 

이 문제를 해결하기 위해서는 결국 seq의 모든 인덱스를 pos 로 삼아서 LIS를 실행해보고 그 max 값을 반환해야합니다.
int main()
{
	::memset(cache, -1, sizeof(cache));

	seq = vector<int>{ 1, 9, 2, 5, 7 };

	int ret = 0;
	for (int pos = 0; pos < seq.size(); pos++)
		ret = max(ret, LIS(pos));
}

이렇게 하면 seq의 모든 인덱스에 대해 한번씩 LIS를 실행해서 가장 긴 ret을 구할 수 있게됩니다. 

원하는 값이 제대로 나오게 되었습니다.

- 추가 
강의는 여기서 끝났는데 저의 의문은 cache의 값을 따로 업데이트 해주는 부분이 없는데 그래도 되는건가 싶었습니다. 
그래서 디버깅을 해보니 이 코드 만으로 cache의 업데이트가 이미 이뤄지고 있었는데 
왜 그런지 다시 곰곰히 생각 해보니 

ret 를 정의 할 때 이미 

int& ret = cache[pos]; 로 정의 했었습니다. 

이 코드를 다시 생각 해보니 ret 를 이리저리 바꾸고 있었는데 그것 자체가 cache안에 있는 값을 참도로 가져온 ret를 건드리고 있던것이어서 
자동으로 업데이트 되었던겁니다. 



    2 . Triangle Path 

동적 계획법 두번째 연습 문제인 트라이앵글 패스 입니다. 

문제 설명부터 하겠습니다. 
먼저 삼각형이 있습니다. 

6
1 2
3 7 4
9 4 1 7
2 7 5 9 4 

이렇게 숫자들이 쌓여서 삼각형 형태를 하고 있습니다. 

- (0, 0) 위의 삼각형에서 가장 위의 6이라는 숫자부터 시작해서 아래 or 아래우측으로 이동 가능
- 만나는 숫자를 모두 더함 
- 더한 숫자가 최대가 되는 경로가 무엇인지? 혹은 숫자를 더한 값이 무엇인지? 를 물어보는 문제 입니다. 

설명한 문제를 프로젝트에 기본적인 내용을 적어 봤습니다.

// 보드의 최대크기를 N*N 으로 만들겠습니다.
int N; 
vector<vector<int>> board;

int path()
{
	
}

int main()
{
	board = vector<vector<int>>
	{
		{6},
		{1,2},
		{3,7,4},
		{9,4,1,7},
		{2,7,5,9,4},
	};

	N = board.size();
}

이제 path 라는 함수안에서 DP로 문제를 풀어 나가면 됩니다. 

path의 반환 타입을 일단 int 로 해놨지만 문제에서 요구하는것도 이동후 값을 합이 최대가 되는 루트 혹은 그 값을 요구하는데 무엇을 반환 타입으로 
정해야 할지 부터 어렵습니다.

근데 먼저 1차적으로 더한 숫자가 최대가 된 그 값을 반환해준다고 하고 시작해보겠습니다.

그런데 값들의 합이라는것 자체가 어디서 부터 시작하는것 부터 결과가 다르겠습니다.
무슨말이냐면 (0,0) 의 6 부터 시작하면 우리가 원하는 문제의 답이 나올것은 알겠습니다. 그런데 만약 (2,2) 에있는 4 부터 시작한다고 해도 

4
1 7
5 9 4 
라는 작은 삼각형안에서 트라이앵글 패스 문제를 풀 수도 있습니다. 그래서 어느 좌표 부터 시작할것인지 그 좌표를 인자로 받아 보겠습니다. 

int path(int y, int x)
{

}

이 상태에서 DP 문제를 해결할때는 재귀 함수를 사용하는것이 좋다고 했었습니다. 그렇기 때문에 이 문제를 어떻게 재귀 함수를 적용할지를 생각해보아야 합니다. 
문제에서 주어진 좌표의 아래방향 또는 아래 우측 방향으로 이동할 수 있다고 했는데 그러면 이 이동은 결국 좌표가 바뀌는 것이니까 아래와 아래우측을 뜻하는 
좌표를 줘가면서 재귀적으로 풀수 있지 않을까요? 
이 발상이 처음에 생각나지 않는다고 해서 이상한게 아닙니다. 이런 발상은 DP 문제를 많이 풀어봐서 훈련이 되어야 자연스럽게 떠오를수 있습니다. 

path 의 코드를 진행하면서 DP에서의 3단계를 일단 생각해야합니다. 

int path(int y, int x)
{
	// 기저 사항 둘 중 하나 선택
	//if (y == N - 1)
	//	return board[y][x];
	if (y == N)
		return 0;

	// 캐시 확인


	// 문제 적용 
}

먼저 기저사항을 보았습니다. 두가지 방법이 있는데 N 이라는 int형 변수에 우리 문제의 예시가 들어있는 board 의 size를 담았었습니다. 
y == N - 1 이라는 조건은 y 좌표가 board의 맨 아래에 닿았는지를 체크하는 조건입니다. 맨 아래에 닿았으면 그 위치의 값을 바로 반환하기위해
return board[y][x]; 를 합니다. 

또 다른 방법인 y == N 이라는 조건은 N이 인덱스가 아닌 사이즈 이기 때문에 y 가 board의 범위를 넘어갔다는 말입니다. 범위를 넘어가면 값이 없을 것이기 때문에
0 을 리턴합니다. 

다음은 캐시 확인입니다. 아직 캐시를 만들지 않았는데 board와 똑같은 형태로 만들어 보겠습니다.

vector<vector<int>> cache;

	cache = vector<vector<int>>{ N, (vector<int>{N, -1}) };

전역메모리에 cache라는 이중 벡터 변수를 만들고 main 함수안에서 cache의 내용물이 N*N의 크기에다가 -1 이라는 값들로 되어있다고 만들었습니다. 
그리고 path 함수안에서는 이렇게 캐시 체크를 해야겠습니다. 

int path(int y, int x)
{
	// 기저 사항 둘 중 하나 선택
	//if (y == N - 1)
	//	return board[y][x];
	if (y == N)
		return 0;

	// 캐시 확인
	int& ret = cache[y][x];
	if (ret != -1)
		return ret;

	// 문제 적용 
}

// 이때 따로 언급하지는 않았지만 캐시에 -1 을 준건은 문제의 조건에서 board의 오는 숫자들은 양수일것이라는 조건이 있어야합니다.

cache[y][x] 의 값을 참조로 받아온 ret 의 값을 체크해서 -1 이 아니면 (y,x) 좌표를 한번 계산했다는 말이 됩니다. 그러므로 바로 리턴합니다. 

다음으로 문제 적용의 단계입니다. 
(y,x) 좌표에서 아래 또는 아래우측으로 가는 방법은 재귀적으로 표현하면 이럴겁니다. 
path(y+1, x);
path(y+1, x+1);
여기에 이동하면서 자신의 값을 더해주면서 가니까 그것 까지 표현해보겠습니다.
	// board[y][x] + path(y + 1, x);
	// board[y][x] + path(y + 1, x + 1);

여기서 이 두 값중에 더 큰값을 찾는 것이고 거기에 cache에도 기록을 해야합니다. 

	return ret = board[y][x] + max(path(y + 1, x), path(y + 1, x + 1));

이렇게 일단 트라이앵글 패스 문제가 요구하는것중에 총 합의 값을 구하는것 까지는 해보았습니다. 


int main()
{
	board = vector<vector<int>>
	{
		{6},
		{1,2},
		{3,7,4},
		{9,4,1,7},
		{2,7,5,9,4},
	};

	N = (int)board.size();
	cache = vector<vector<int>>( N, (vector<int>(N, -1)));

	int ret = path(0, 0);

	std::cout << ret << endl;
}
이렇게 한번 실행 해보면 콘솔에 28 이라는 값이 뜹니다. 어떤경로로 갔는지 예상해보면 6->2->4->7->9 의 경로로 이동한것 같습니다. 

눈으로 대강 예상할 수 있는 이 경로를 코드로도 표현할 수 있어야 합니다.

경로를 추적하는것은 길찾기 알고리즘에서 많이 해봤었습니다.
좌표를 이동하면서 y 좌표는 항상 증가하고 x 좌표는 큰값을 따라 우측으로 이동하던지 아니면 그대로 아래로 내려오던지 할 수 있습니다. 

이걸 추적하기위해 전역 변수하나를 추가합니다. 
vector<vector<int>> nextX;

main 함수안에 초기화도 해줍니다. 
nextX = vector<vector<int>(N, vector<int>(N));

이제 path 함수에서 살펴보면

경로를 추적하는 코드를 넣어주면 될것 같습니다.

	// 경로 기록
	{
		int nextBottom = path(y + 1, x);
		int nextBottomRight = path(y + 1, x + 1);
		
		if (nextBottom < nextBottomRight)
			nextX[y][x] = x + 1;
		else
			nextX[y][x] = x;
	}
아래방향과 아래우측의 값을 비교해서 그 인덱스를 nextX에 저장하고 있습니다. 

이번 DP 연습문제인 트라이앵글 패스를 풀어보니까 기본적인 DP 양식에서 문제가 요구하는 답에 따라 문제 적용 부분이 조금씩 달라지는걸 알 수 있습니다. 
DP 문제를 많이 연습해보는것이 중요하고 또 문제에서 어떻게 재귀적인 요소를 찾을것인지가 중요합니다.




	3. TIC-TAC-TOE

다음 연습문제로 틱택토 게임을 만들어 보겠습니다. 

틱택토는 서양의 테이블 게임 비슷한 겁니다. 3*3 의 격자에서 플레이어 두명이 번갈아 가면서 O, X 를 두는데 둘 중 한사람이 먼저 3개의 마크를 대각선이나 
일렬로 세우면 이기는 게임입니다. 오목과 비슷한 삼목? 같은거라고 보면됩니다. 

왜 틱택토를 연습문제로 삼았냐면 실무에서는 DP가 거의 사용되지 않는다고도 했지만 사실 면접이나 코딩테스트에서는 자주 나오는 내용이라고 말했었습니다.
그리고 실무에서도 가끔 컨텐츠 중 깊은 내용을 만들때도 사용되는 경우도 있다고도 했습니다.

오목이나 바둑, 체스 같은 걸 구현할때 (ex.알파고) 이런 게임들은 각수의 경우의 수가 너무나 많기 때문에 최적화 기법이 필요합니다. 
하지만 오목, 바둑, 체스는 지금 단계에서는 너무 복잡한 게임이기 때문에 훨씬 간단한 틱택토 게임을 연습문제로 가져온겁니다. 

그래도 실제 틱택토게임 전체를 만드는것 조차도 너무 오랙 걸리기 때문에 오늘의 연습문제에는 제한적인 상황이 주어질겁니다.

// [.][.][.]
// [.][o][x]
// [.][.][o]

이런 상황의 틱택토 보드가 있다고 하겠습니다. 이때 x 마크의 플레이어가 이 판을 이길 수 있는지 아니면 최선을 다해도 비기는지 아니면 지는지를 
판별할수 있는 함수를 만드는것이 목적입니다. 

이런 함수를 만든다면 이제 사람과 컴퓨터가 번갈아 말을 둘 수 있도록만하면 틱택토 AI 를 만든다고 볼 수 있습니다.
체스같은 경우는 이것만으로는 안되고 좀 더 복잡해지긴 하겠지만 기초적인 내용은 같다고 볼 수 있습니다.

문제풀이를 한번따라가 보겠습니다. 

기본 상황입니다.

vector<vector<char>> board;

int main()
{
	board = vector<vector<char>>
	{
		{'.', '.', '.'},
		{'.', '.', '.'},
		{'.', '.', '.'},
	};
}

이번에는 char 타입의 이중 벡터를 사용했고 3*3 크기에 ',' 문자를 넣어놨습니다. 지금은 모두 ',' 이지만 나중에는 위의 문제처럼 임의로 o 와 x 를 
채워서 함수를 실행해 볼겁니다.


enum
{
	DEFAULT = 2,
	WIN = 1, 
	DRAW = 0,
	LOSE = -1,
};

int CanWin(vector<vector<char>>& board, char turn)
{

}

문제를 풀 함수이름을 CanWin 이라고 지었습니다. 그리고 반환 타입은 int 인데 이것은 CanWin 함수 위에 정의된 enum의 내용을 반환할것이기 때문입니다. 
또 인자로는 아까 만든 board 를 참조 타입으로 받고, 또 문자 하나를 turn 이라는 이름으로 받습니다..
이 중에 turn 은 지금 누구의 차례인지를 인자로 받고 있는것입니다. 사실은 틱텍토는 인자로 받지 않아도 게임 판을 보면 누구의 차례인지 알수 있지만 
그것까지 구현하면 좀 더 길어지기 때문에 그냥 인자로 받는 버전으로 만들겠습니다. 

CanWin의 내용은 지금껏 풀었던 DP 문제의 순서대로 기저 사항, 캐시 체크, 문제 해결 순으로 진행됩니다. 

먼저 기저 사항입니다. 
틱택토 문제의 기저사항은 다른 문제 보다 복잡합니다. 누군가가 말을 연달아 3개를 놓아서 게임이 끝났을때 가 기저사항입니다. 

게임이 끝났다는걸 알기위한 내용을 CanWin 안에 모두 만드는것은 너무 복잡해지기 때문에 외부로 함수를 하나 만들어 주겠습니다.

bool IsFinished(const vector<vector<char>>& board, char turn)
{
	// 좌우 
	for (int i = 0; i < 3; i++)
		if (board[i][0] == turn && board[i][1] == turn && board[i][2] == turn)
			return true;
	// 상하
	for (int i = 0; i < 3; i++)
		if (board[0][i] == turn && board[1][i] == turn && board[2][i] == turn)
			return true;
	// 대각선
	if (board[0][0] == turn && board[1][1] == turn && board[2][2] == turn)
		return true;
	if (board[0][2] == turn && board[1][1] == turn && board[2][0] == turn)
		return true;

	return false;
}

게임이 끝난경우는 가로로 마크 3개가 늘어서거나 세로로 늘어서거나 대각선 으로 늘어설때입니다. 그걸 코드로 표현하면 위와 같습니다. 

다시 기저사례로 돌아가면 
내가 이기거나 비기는 경우에는 아래의 캐시 확인 단계나 문제 해결 단계에서 리턴해줄겁니다. 
기저사례에서는 상대방이 이겼을때를 체크해줄건데요 

turn 을 인자로 받았는데 이 turn 은 char 타입이고 어떤마크 차례인지를 말합니다. 문제에서는 x 마크가 놓을 차례이고 플레이어의 턴입니다. 
즉 인자로 올 마크의 반대 마크가 이기는 상황을 체크해줘야합니다. 
turn의 반대 마크를 구하는 방법은 쉽게 상각하면 
char cpuTurn;
if (turn == 'o')
	cpuTurn = 'x';
else
	cpuTurn = 'o'; 

처럼 if else 문으로 처리해도 되지만 좀 더 간지나는 방법이 있습니다. 

문자형 데이터는 ASCII 코드나 유니코드의 테이블을 사용해서 각 문자에 번호를 부여받아서 사용하는것이었습니다. 
'o' 나 'x' 나 사실 컴퓨터가 보기에는 숫자로 보인다는겁니다. 
이걸 응용한 방법입니다. 

	// 기저 사례
	if (IsFinished(board, 'o' + 'x' - turn))
		return LOSE;

'o' + 'x' 를 하고 turn 을 빼주면 turn 의 반대편 마크가 됩니다. 그리고 반대편 마크가 true 라는것은 컴퓨터가 이겼다는 뜻입니다. 
플레이어에게는 LOSE 겠죠

이제 다음은 캐시 확인입니다. 
여태껏 배웠던 LIS 문제나 Triangle Path 문제에서는 결과를 도출하기위한 cache는 배열, Triangle Path에서는 cache를 이차 벡터로 
사용했었는데 
이번 문제 틱택토에서는 board 자체가 결과에 영향을 주는 요인입니다. 
char 타입의 board를 cache로 들고 있는것은 복잡해 보이지만 사실 이 board 가 무한정 늘어나는게 아니었습니다. 

가로 세로 3칸씩인 보드에서 각 칸이 아직 마크가 놓이지 않은상태, x 마크가 놓인 상태, o 마크가 놓인 상태 로 표현할 수 있습니다. 
즉, 3(세가지 마크)가 아홉번 나열될 수 있는 의 경우의 수로 표현할 수 있다고 할 수 있습니다. 
 3*3(3*3)(3*3)... = 3^9 입니다. 계산해보면 19683 의 경우의 수가 나옵니다. 
그래서 0 에서 19683 사이의 수로 저장 할 수 있다면 이중 캐릭터 벡터의 형태로 cache를 저장하지 않아도 됩니다.


int HashKey(const vector<vector<char>>& board)
{
	int ret = 0;

	for (int y = 0; y < 3; y++)
	{
		for (int x = 0; x < 3; x++)
		{
			ret = ret * 3;

			if (board[y][x] == 'o')
				ret += 1;
			else if (board[y][x] == 'x')
				ret += 2;
		}
	}

	return ret;
}
이런 해시 함수를 하나 만들어서 board의 상태를 저장할겁니다. 
내용을 보면 3*3 이중 for 문을 돌고 있습니다. board의 좌표들을 돌면서 그 내용이 o 면 ret 에 1을 더하고 x 면 2를 더해주고 있습니다. 
자동으로 . 일때는 0으로 둡니다. 그리고 두번째 반복부터 ret 를 3씩 곱하고 있는데 그 이유는 이전 반복에서 마크에 따라 0,1,2 중 하나의 
숫자를 저장해주고 있었는데 이걸 3진법 처럼 한칸마다 무슨 마크였는지를 알기 위해 곱해주고 있는겁니다. 
[0,1,2][0,1,2][0,1,2][0,1,2][0,1,2][0,1,2][0,1,2][0,1,2][0,1,2]
	...   ...   ...    ... 			  27 	 9		 3		0

약간 이해하기 어렵지만 2차배열을 1차배열로 저장하는 방법 비슷하다고 생각하면 될것 같습니다. 

꼭 이방법을 써야 하는것은 아니고 다른 방법으로 char 이차 벡터를 추적할수 있으면 됩니다. 아예 처음부터 9 구역을 각각 담당하는 방식으로 
만들어도 되겠죠 

일단 위의 HashKey 함수를 통해서 board를 정수로 바꿔서 반환하게 될겁니다. 이제 이 HashKey를 가지고 cache 를 들고 있으면 됩니다.

cache를 만들겠습니다. 

int cache[19683];	// 전역 변수 

캐시를 의외로 큰크기의 배열로 만들었습니다. 이 캐시를 초기화 해줘야 하는데 CanWin의 결과물로는 안담길 값으로 초기화 한다고 했습니다. 
아까 만들었던 enum 중에 DEFAULT 라는 열거형을 만들었던게 이때 사용하기 위해서입니다. 

int main()
{
	board = vector<vector<char>>
	{
		{'.', '.', '.'},
		{'.', '.', '.'},
		{'.', '.', '.'},
	};

	for (int i = 0; i < 19683; i++)
		cache[i] = DEFAULT;
}

이렇게 cache를 DEFAULT 로 전부 초기화 하고 시작합니다.
  *이전에는 캐시 초기화를 memset 으로 했는데 이것도 for 문이 아니라 memset 으로 초기화 하면되지 않을까 생각이 들었습니다. 
  하지만 memset이라는 함수는 컨테이너를 1byte 단위로 초기화 해주는 함수인데 이전에는 0 과 -1 로는 초기화 가 되었습니다. 
  int 형은 4byte 의 크기의 데이터 형인데 0 은 모든 비트가 0인 상태이고 -1 은 모든 비트가 1인 상태입니다. 
  그렇기 때문에 1byte 단위로 초기화를 해도 괜찮았던겁니다. 지금은 DEFAULT 가 정수 2 이기 때문에 memset 으로는 초기화가 안됩니다.

이제 캐시 확인하는 코드를 보겠습니다. 
	// 캐시 확인
	int key = HashKey(board);
	int& ret = cache[key];
	if (ret != DEFAULT)
		return ret;

이 코드에서 HashKey라는 함수로 board를 변환한 이유가 나옵니다. 현재 board 의 상태에 따라 HashKey의 값이 달라지는데 
그 값의 범위가 0 에서 19683 까지인겁니다. 이 범위를 cache의 인덱스로 삼아서 그 위치에 이전에 연산을 했다면 WIN, DRAW, LOSE 중 하나가 
들어 있을겁니다. 

이제 문제 풀기 단계입니다. 이부분이 정말 재미있다고 합니다. 
	// [.][x][.]
	// [.][o][.]
	// [.][.][.]
이런 형태의 board를 인자로 받았다고 하고 현제 o 마크의 차례라고 하겠습니다. 그러면 .으로 되어있는 칸들에는 다음 수를 둘 수 있을겁니다. 

다시 이중 for 문으로 순회를 합니다. 

	int minValue = DEFAULT;

	for (int y = 0; y < 3; y++)
	{
		for (int x = 0; x < 3; x++)
		{
			if (board[y][x] != '.')
				continue;
			
			// 착수 
			board[y][x] = turn;

			// 확인
			minValue = min(minValue, CanWin(board, 'o' + 'x' - turn));
			
			// 취소 
			board[y][x] = '.';
		}
	}

이 코드가 무슨 의미인지 생각해보겠습니다. 인자로 받은 board 를 순회하면서 값이 '.' 인 칸은 스킵합니다. 즉 마크가 놓여져 있지 않은 곳을 
찾습니다. 일단 찾았다면 그곳에 마크를 둡니다. 
이때 board를 참조값으로 받아왔기 때문에 원본 board도 수정이 됩니다. 

수를 뒀다면 결과를 확인해야합니다. 결과를 확인하기위해 minValue 라는 변수를 이중 for문 밖에 정의 했습니다. 
그리고 // 확인 이라고 주석을 해놓은곳에서 어떤 처리를 해주고 있습니다.

minValue = min(minValue, CanWin(board, 'o' + 'x' - turn));

이 코드는 무엇을 하고 있는걸까요? minValue와 CanWin(board, 'o' + 'x' - turn)) 중 작은값을 minValue 에 다시 담아주고 있습니다. 
뒤의 'o' + 'x' - turn 이 인자는 기저사례를 체크할때 상대방 차례인지를 말하고 있습니다. 
즉, 상대방이 이겼나 졌나 하는 값들중에 가장 작은값을 찾고있는건데 
이 작은 값이라는것은 
enum
{
	DEFAULT = 2,
	WIN = 1, 
	DRAW = 0,
	LOSE = -1,
};

이 열거형중에 LOSE를 말합니다. 왜 진것을 찾고 있냐면 상대방이 졌다는것은 나 플레이어는 이겼다는 말이기 때문입니다. 

그러고 나서 취소 코드 가 나옵니다. 

이 착수, 확인, 취소 3줄의 코드가 정말 중요합니다. 
**
3줄의 코드에서 사실상 틱택토 게임에서 모든 경우의 수를 보면서 결과를 산출하고 있습니다. 

일단 이중 for 문으로 board의 각 칸을 순회 한다고 했었습니다. 

1차 순회 
{
	board[y][x] 를 내 마크('o') 로 착수하면 board의 원본데이터가 수정됩니다. 
	
	다음으로 minValue를 현재 minValue와 CanWin(board, 상대방 마크('x'))중 작은걸 고릅니다. 
	{
		board가 한칸 수정된 상태에서 다시 CanWin을 돕니다. 기저사례를 체크합니다. 
		IsFinished(board, 'o') 이게 true 라면 내가 수를 둬서 이긴 상태입니다. 리턴은 LOSE로 뜨지만 minValue는 상대방 입장이니까 
		나는 승리한겁니다. 

		통과했다고 치면 캐시확인 입니다. 첫 board에서 내가 한칸 둔 상태의 board를 유니크한 정수 key로 받아와서 cache를체크하는데 
		첫 시도이니까 그냥 스킵이 될겁니다. 

		이제 다음은 또 3줄 코드 쪽으로 옵니다. 
		다시 이중 for문을 돌면서 board에 'x' 수를 둡니다. 그리고 다시 minValue 를 구하는 코드로 들어갑니다. 

		{
			이 것을 반복하다보면 결국 board를 채워 가다가 기저사항에 'o' 나 'x' 둘 중 하나가 이기는 상황이 되면 
			그때의 minValue 가 LOSE 로 반환이되고 빠져 나옵니다. 
			빠져나오면 결판이 나는 그 순간의 board[y][x] 의 칸을 다시 '.' 으로 되돌립니다. 그리고 2중 for 문을 돌텐데 
			만약 board가 꽉차서 전부 continue 를 한다면 반복문을 빠져나올겁니다. 다음은 minValue가 LOSE 일 테니 
				return ret = -minValue;
			을 리턴하게됩니다. 이때 ret는 cache중에 이때의 board 상황에 맞는 해시키를 인덱스로 한 칸일 겁니다. 

			해서 이 가장 끝의 CanWin이 종료합니다. 

		}
		이제 가장끝 바로 전 상태인 board 를 대상으로한 CanWin이 실행되고 있습니다. 바로 전 리턴값을 
		minValue = min(minValue, CanWin(board, 'o' + 'x' - turn));
		으로 처리합니다. 다시 이 칸을 '.' 으로 되돌리고 반복문을 계속 실행합니다. 
	}
}

위와 같은 과정을 처음 board의 상태를 기준으로 모든 가능한 수를 두면서 연산하게 됩니다. 그리고 그 중에 min 값을 가져오도록 했다보니까 
최대한 이길 수 있으면 이길수 있다는 minValue가 반환 될것이고 아니라면 비기던지 그것도 아니면 진다는 값이 나오게 됩니다. 

board가 항상 꽉차는 수까지 가지 않고 일찍 결론이 나버리면 그 순간부터 재귀함수들이 되돌아오게 될겁니다. 

이 많은 과정들이 간결해 보이는 3줄로 구현이 된다는게 매우 놀랍고 재밌습니다. 

**

이제 minValue로 결론을 내리는 부분입니다.

	if (minValue == DRAW || minValue == DEFAULT)
		return ret = DRAW;

	return ret = -minValue;

minValue가 DRAW나 DEFAULT 라면 ret 를 DRAW로 바꾸고 반환합니다. 

그 외에는 cache에 값이 없는 상태이고 minValue 가 LOSE 나 WIN 인상태입니다. 어느쪽이든 플레이어는 minValue 의 반대 값을 가지게 됩니다. 

실습은 이렇게 해보았습니다.

int main()
{
	board = vector<vector<char>>
	{
		{'.', '.', '.'},
		{'.', '.', '.'},
		{'.', '.', '.'},
	};

	for (int i = 0; i < 19683; i++)
		cache[i] = DEFAULT;

	int win = CanWin(board, 'x');

	switch (win)
	{
	case WIN:
		cout << "Win" << endl;
		break;
	case DRAW:
		cout << "Draw" << endl;
		break;
	case LOSE:
		cout << "Lose" << endl;
		break;
	}
}

여기서 board의 조건을 조금씩 다르게 해보면서 실습을 해보았습니다. 



		4. ENCHANT

이어서 다음 문제입니다. 이 문제는 예전에 크래프톤의 필기 시험에 나왔던 문제라고 합니다. 

문제입니다. 

최근 한국 온라인게임에서는 장비를 강화하는 방식이 많은데 

+0 집행검 	이라는 아이템이 있다고 하겠습니다. 이 아이템을 강화할때는 강화 주문서라는 소비 아이템을 사용해 
강화를 할 수 있습니다. 
강화주문서는 한번 사용할때 마다. +1/+2/+3 중 하나의 강화가 랜덤하게 적용됩니다. 

이때 +N 의 강화가 될때 까지의 경우의 수는 얼마일까요? 

	ex) +9 집행검이 뜨는 경우의 수는?
	+1 +2 +3 ... +9
	+3 +6 +9
	+1 +3 +4 ... 
	등등의 경우의 수를 구하는 문제 


먼저 기본 환경을 조성해보겠습니다. 

int N;


// [+num]에서 시작해서, [+N]까지 가는 경우의 수 
int Enchant(int num)
{
}

int main()
{
	N = 9;
}

목표로 하는 강화를 전역변수 N으로 두고 main 에서 N을 9로 값을 줬습니다. 

여기서 시작할때 항상 하는 틀이 있었습니다. 

int Enchant(int num)
{
	// 기저사례

	// 캐시 확인

	// 문제 해결 
}

먼저 기저 사례입니다. 예외적인상황이 뭐가 있을까요 인자인 num이 현재 아이템의 강화 상황이고 N이 목표로 하는 강화 레벨입니다. 
한번 강화 할 때 마다 +1/+2/+3 중 하나 만큼 강화가 된다고 했습니다. 그러면 이전 강화에서 num 에 더해지는 강화 레벨이 N 보다 
높을 수 있을겁니다. 그 때는 우리가 찾고자하는 경우에서 벗어 날 것이고 반면 딱 N과 num이 일치한다면 우리가 찾고있는 경우의 수입니다. 

	// 기저사항
	if (num > N)
		return 0;
	if (num == N)
		return 1;

캐시 확인을 해보겠습니다.

// 전역
vector<int> cache;	

	// main 함수 안 
	cache = vector<int>(N, -1);

	// Enchant 함수 안 
	int& ret = cache[num];
	if (ret != -1)
		return ret;

cache를 벡터로 만들어도 되고 그냥 배열로 만들어도 상관없습니다. 
그리고 cache의 num 에 해당하는 인덱스에 이미 값이 있다면 반환하고 아니면 문제 해결 단계로 넘어가서 값을 구해줄겁니다. 

	// 문제 해결 
	return ret = Enchant(num + 1) + Enchant(num + 2) + Enchant(num + 3);

1,2,3 강을 한다는 것을 num 에 더하는 방식으로 구현이 되었습니다. 
재귀함수들은 이후로 num이 9에 도달할때 까지 혹은 9를 초과 할 때까지 반복되는데 9에 도달했다면 1만 리턴을 하지만 그 값을 
cache[num] 에 더해서 담아줄것입니다. 


	5. KART-RIDER

대망의 마지막 DP 문제입니다. 예전 NC에서의 문제입니다. 이 문제는 실전 면접에서 하루라는 시간을 줬습니다. 

문제는 이렇습니다. 

- 카트는 게임이 시작하면 달리기 시작하면, 주어진 시간(T)동안 달린다.
- 카트는 처음에는 기본 속조 (초속 1)로 달린다.
- 게임이 시작하고 특정 시간(a)가 되면 바닥에 신발 아이템이 생성된다.
- 카트는 신발을 신거나 지나칠 수 있다. 지나간 신발은 영영 다시 주을 수 없다.
- 신발을 착용하려면 (b)의 시간이 필요하다. 즉 (b)초 동안 제자리에서 멈추고 나서야 움직일 수 있다.
- 신발을 착용하면 일정시간(c) 동안 신발 속도(d)로 달릴 수 있다.
- 신발은 하나만 착용할 수 있고, 가장 최근에 작용한 신발의 속도만 적용된다.
- 신발을 벗거나 다른 신발로 바꿔 장착할 때 추가시간이 들지 않는다. (새로운 신발을 신는 시간만 소요 된다.)
- 신발 효과가 끝나면 다시 기본 속도 (초속 1)로 달린다. 

Q) 생성되는 모든 신발 정보가 주어졌을 때, (T)초 동안 갈 수 있는 최대 거리를 구하라.


그리고 이 문제가 출제 될 때 필요한 데이터를 텍스트 파일로 줬다고 합니다. 

input.txt
20
4
3 4 10 3
4 1 4 2
10 2 5 5
15 1 3 7

이 숫자들이 뭘 뜻했냐면 맨위 의 20 이 T 달릴 수 있는 총 시간, 그 밑의 4는 총 신발이 몇개가 있을지, 
다음으로 4개의 숫자로 되어있는 행들은 각 신발의 a, b, c, d 정보라고 합니다. 

문제를 풀어보겠습니다. 
먼저 신발이라는 개념을 구조체로 만들어 주겠습니다. 

struct Shoe
{
	Shoe(int a, int b, int c, int d)
	{
		time = a;
		start = a + b;
		end = a + b + c;
		speed = d;
	}

	int time;	// a	신발 스폰 시간
	int start;	// a+b	신발 효과 시작 시간
	int end;	// a+b+c 신발 효과 끝나는 시간
	int speed;	// d 신발 속도 
};

a,b,c,d 도 알아보기 쉽게 바꿔 놨습니다. 

input.txt 로 주어졌던 조건들도 여기서는 그냥 코드로 받아 주겠습니다. 

int T;

vector<Shoe> shoes;
vector<int> cache;
 
총 시간인 T와 신발들을 뜻하는 shoes, 나중에 어차피 만들 cache 를 전역으로 만들었습니다. 

그리고 shoes의 내용들을 main 함수 안에서 채워주겠습니다.

int main()
{
	// 총 이동 시간
	T = 20;

	// 시간별로 생성되는 신발 등록
	shoes.push_back(Shoe(3, 4, 10, 3));
	shoes.push_back(Shoe(4, 1, 4, 2));
	shoes.push_back(Shoe(10, 2, 5, 5));
	shoes.push_back(Shoe(15, 1, 3, 7));
	std::sort(shoes.begin(), shoes.end(), [=](Shoe& left, Shoe& right) { return left.time < right.time; });
}
마지막의 sort 코드는 만약 shoes에 채워준 신발들이 등장시간 순으로 정렬 되어 있지 않았다면 정렬해주는 코드입니다. 

문제를 어떻게 DP로 풀어야 할 지 막막합니다. 
풀이를 따라가 보겠습니다. 

문제를 푸는 함수를 Solve라고 만들겠습니다.
// now번 신발으 신고 갈 수 있는 최대 거리를 반환.
int Solve(int now)
{

}

인자 now 번째의 신발을 신었을때 최대거리를 반환하는 함수로 만들것입니다. 

T라는 시간동안 신발들이 등장할 텐데 이 신발 들 중에서 어떤 신발을 신었다고 치면 신은 시점의 이후의 갈 수 있는 거리는 고정이 됩니다. 
이게 무슨말인지 곰곰히 생각해봐야 합니다.
shoes 중 네번째 신발을 예시로 들어보면 가장 마지막에 나타나는 신발입니다. 15 초에 등장해서 1초 정지 후 3초동안 7이라는 속도로 이동합니다. 
즉 16 초 시점부터 3 * 7 = 21 의 거리를 이동하고 남은 1초는 1의 속도로 가니깐 4번째 신발을 신은 시점에서 22의 거리를 가는것은 확정입니다. 

이번에는 Solve의 now를 3번째 신발로 줘보겠습니다. 
10초에 등장해서 2초동안 정지 5초동안 5의 속도로 이동합니다. 등장과 동시에 신발을 신는 시간을 더하면 12초 부터 시작해서 17초 까지 25의 거리를 가고 
남은 3초동안 마저 28 의 거리를 가게됩니다.

그런데 여기서 재밌는 점은 3번째 신발을 신고 가는 도중에 4번째 신발이 생성되는데 이 신발을 신을수도 있고 안 신을 수도 있습니다.
아까 계산한 3번신발을 신었을때의 갈 수 있는거리는 중간에 4번신발을 신지 않았을 때의 거리이고 
만약 4번 신발을 신었을 때의 경우를 계산해보면 12 초 부터 4번 신발이 등장하는 15초 까지 5의 속도로 갑니다. 즉 15의 거리를 간 다음에는 
4번 신발을 신은 거리를 더해주면 됩니다. 3->4 신발의 경우는 37의 거리라고 할 수 있습니다.

이렇게 4번신발, 3번신발을 신었을때의 최대거리를 계산해 봤는데 이 값을 계산할 수 있다는 것 부터 어떤 신발을 신은 순간에 그 이전의 경우를 제쳐두고
이후에 갈 수 있는 최대 거리는 정해진다는 겁니다. 
ex) 4번 신발 : 22 만큼의 거리
	3번 신발 : 28 만큼의 거리
	3번 + 4번 신발 : 37 만큼의 거리

결국은 재귀적으로 이전에 계산했던 값을 적용시킬수 있고 이 구조는 이번단원의 주제인 DP를 적용할 수 있다는 말입니다. 

다시 Solve 함수를 만들어 나가보겠습니다. 

// now번 신발으 신고 갈 수 있는 최대 거리를 반환.
int Solve(int now)
{
	// 기저사례
	if (now >= shoes.size())
		return 0;

	// 캐시
	int& ret = cache[now];
	if (ret != -1)
		return ret;

	// 적용 
}

DP 문제를 풀면서 항상하던 3단계로 나눠 주겠습니다. 기저사례로 왠지 모르겠지만 now 라는 신발의 번호가 shoes에 담겨있는 신발 개수보다 
크다면 0을 리턴해줍니다.

그리고 캐시확인은 매번 하던 방식대로 참조 값 변수로 가져오고 값이 들어 있으면 바로 반환하는 코드입니다. 

다음으로 주된 코드를 만들어 보겠습니다.

	// 적용 
	Shoe& shoe = shoes[now];

먼저 인자인 now 가 신발의 번호인 만큼 그 번호에 맞는 신발을 shoes에서 참조로 꺼내옵니다. 
그렇게 꺼내온 shoe에서 필요한 데이터를 꺼내 써야겠죠 

일단 이 신발을 신는다고 치면 그 순간 T에 다다를때까지의 거리를 구해봅니다. 

	// 신발 신고 이동한 거리 + 걸어서 이동한 거리

	int dist = (shoe.end - shoe.start) * shoe.speed + (T - shoe.end) * 1;
	ret = max(ret, dist);

dist를 계산하는 식은 상식적으로 구할 수 있습니다. 이 거리를 cache에 저장해주고 있는데 그냥 저장하고 있는게 아니라 
원래 들고 있던값과 비교해서 큰값을 저장하고 있습니다. 

dist는 now 번 신발하나만 신고 T시간까지 이동한 거리인것인데 최대거리를 위해 최선의 신발들을 신은 상태가 아닌 딱 신발 하나만 신었을때 
이동한 거리라는게 중요합니다.

	// 다른 신발도 하나씩 신어본다
	for (int next = now + 1; next < shoes.size(); next++)
	{
		Shoe& nextShoe = shoes[next];
		if (nextShoe.time < shoe.start)
			continue;

		//다음 신발까지 이동 거리
		int moveDist = 0;

		// 현재 신발 효과가 끝나기 전에 다음 신발이 스폰 됩
		if (nextShoe.time <= shoe.end)
		{
			moveDist = (nextShoe.time - shoe.start) * shoe.speed; // 신발 신고 이동
		}
		else
		{
			moveDist = (shoe.end - shoe.start) * shoe.speed;  // 신발 신고 이동
			moveDist += (nextShoe.time - shoe.end) * 1;   // 나머지 걸어서 이동
		}

		ret = max(ret, moveDist + Solve(next));
	}

	return ret;
	}

기본 거리인 dist를 일단 ret에 저장한 다음으로 현재 신발이후로 다음 신발을 신는게 멀리 갈 수 있는지 안 신는게 나은지 
알아보는 코드입니다. 현재 신발인 now 번 신발 다음번인 int next = now + 1 부터 for문을 돕니다. 

nextShoe 를 shoes[next] 로 가져오고 이 다음 신발이 현재 신발의 신발 신는 시간 동안 생성되는지를 체크합니다. 
왜 이걸 체크하냐면 먼저 신발을 신는 도중에 생성되는 신발을 신을 거라면 아예 먼저번 신발을 신지 말고 그 동안 1의 속도로 라도 
걷는게 더 멀리 갈 수 있을것이기 때문에 상식적으로 제외합니다. 

다음으로 신발을 추가로 신을때의 경우가 두가지 있을겁니다. 이전 신발의 지속시간이 유지 되는 도중에 다음 신발을 신는 경우,
그리고 이전 신발의 지속시간을 모두 사용하고 1의 속도로 걷다가 다음 신발을 신는 경우가 있을겁니다. 

여기서 이전 신발을 신은 후에 걸은 거리를 moveDist라고 하겠습니다. 

if else 로 체크를 해줄 텐데 
신발 효과 도중에 갈아 신을 경우에 moveDist는 현재 신발의 효과가 시작되는 시간과 다음 신발이 생성되는 시간동안 현재 신발의 속도로 이동합니다.
신발 효과가 끝난 다음 다음 신발을 신을 경우 
먼저 일단 현재 신발의 효과 시간동안 간 거리를 구하고 += 현재 신발의 효과가 끝난시간부터 다음 신발이 생성되는 동안 1의 속도로 걸어간 거리를 
더합니다. 

이렇게 moveDist를 구했습니다. 
다음은 실제로 다음 신발을 신었을 경우를 더해주면 되는데 신발을 신었을 경우는 지금 만들고 있는 함수 자체입니다. 
그래서 재귀적으로 next를 넘겨주고 현재 ret 과 비교해서 큰값을 구하면 가장 멀리 가는 경우가 구해질겁니다. 


이제 프로그램을 실습해보겠습니다. 

아까 직접 계산한 4번 신발과 3번 신발을 now로 넣어줘서 실제 그 값이 나오는지 확인해 본결과 
Solve(3) = 22;
Solve(2) = 37;
로 위에서 계산한 대로의 값이 나왔습니다. 

그러면 이제 현재 상황에서 최대거리를 구하려면 신발을 하나씩 줘봐서 그 중 최대 거리인 값을 주면 될것입니다.



	// 시간별로 생성되는 신발 등록
	shoes.push_back(Shoe(0, 0, T, 1));
	shoes.push_back(Shoe(3, 4, 10, 3));
	shoes.push_back(Shoe(4, 1, 4, 2));
	shoes.push_back(Shoe(10, 2, 5, 5));
	shoes.push_back(Shoe(15, 1, 3, 7));

이렇게 맨 처음에 아무것도 안신고 달리는 것과 같은 신발을 하나 추가합니다.

그리고 
int ret = Solve(0);

을 실행해보면 50이라는 값이 나옵니다. 

중단점을 걸고 살펴보면 
cache = [50, 46, 46, 37, 22]
라는 값들이 들어있습니다. 1번신발을 신어도 46의거리를 가고 2번 신발을 신어도 46의 거리를 갑니다. 
그러면 2번 신발을 신는게 더 이득일겁니다 왜냐면 Solve해서 나온값은 신발을 신은 시점에서 T까지의 거리를 구해주는데 
0초 부터 2번 신발을 신는 4초까지의 이동거리는 포함되어 있지 않습니다.