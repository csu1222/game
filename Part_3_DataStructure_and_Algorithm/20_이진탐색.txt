

        이진탐색

// 면접 

이번 시간 주제는 이진 탐색 트리 입니다. 

이진 탐색트리는 이전에 힙 트리 를 배울때 잠시 알아봤던 내용이었습니다. 

그리고 사실 굳이 모른다고 해도 당장 개발을 하는데 지장이 생기지는 않는다고 합니다. 왜냐면 각 언어마다 이미 
이진트리를 쉽게 사용할수 있는 컨테이너가 준비되어 있다고 합니다. 

C++ 로 치면 std::map 이 이진 탐색 트리에 해당합니다.
그럼에도 불구하고 이번에 배우고 직접 구현해보는것은 처음에는 이 구조를 이해하는데 많은 도움이 되기 때문입니다. 
또한 면접에서도 자주 나오는 질문이라고 합니다.

- 이진 탐색 Binary Search
이진 탐색 트리 이전에 이진 탐색 자체에 대해 좀 다뤄보겠습니다. 

상황과 질문을 통해 이해해보겠습니다. 

// 상황) 배열에 데이터가 정렬되어 있다.

// 준비된 데이터 
// [1][8][15][23][39][47][56][61][81][91]

// Q) 82 라는 숫자가 배열에 있습니까?

// A1) 0번 인덱스부터 하나씩 순회해서 탐색 - 시간 복잡도 = O(N)

이런 질문을 받았을 때 가장먼저 떠오르는 방법은 0번 인덱스 부터 모든 원소를 하나씩 스캔하면서 82 라는 값을 가진 원소가 있는지를 체크하는겁니다.
하지만 이런 방법으로 값을 찾을때는 이 컨테이너의 개수에 비례할것입니다. 지금은 원소가 열개 밖에 없지만 이 데이터가 만약 주민등록에 사용되어서 
한 명을 찾기 위해 몇천만의 인구를 매번 순회를 하는 경우도 있을겁니다.
시간복잡도 = O(N) 

하나하나씩 순회하는 방법은 구현과 발상이 쉽지만 효율적으로 보이지는 않습니다. 그러면 어떻게 탐색을 하는게 좋을까요?
이때 중요한것은 데이터가 정렬이 되어 있다는 점입니다. 
이전시간중에 업다운 게임을 예시로들었던 적이 있습니다. 어떤 값을 찾을때 업, 다운 을 물을때 마다 거의 절반의 경우씩을 날려버리면서 탐색을 할 수 있습니다. 
마찬가지로 예시에서 82라는 값을 찾을때도 적용할수 있습니다. 

// A2) 절반씩 나누어서 찾고자 하는 값을 탐색 - 시간 복잡도 = O(logN)
준비된 데이터에서 대략 가운데의 원소를 골라야 하는데 39 를 기준으로 시작해보겠습니다.
32 와 82를 비교하면 찾고자 하는 82가 더 크다는걸 알 수 있습니다. 그러면 이제 32 보다 뒤쪽의 원소들중에서 탐색을 계속 하면 됩니다. 
다음 시도에서 61 보다 크니까 다시 경우의 수를 반으로 나누고 하는식으로 탐색을 해 나갈겁니다. 

지금은 3~4 번 만에 원하는 결과를 얻었습니다. 순회 탐색을 10번의 연산에 얻은것에 비해 그렇게 대단히 효율적으로 느껴지지 않을 수 있는데 
저장된 데이터의 양이 많으면 많을수록 절반씩 경우의 수를 날리는 방법은 효율적입니다. 

- 실습 
우선 이번이 이진 탐색 트리 강의들 중 첫 강의 니까 이진 탐색을 함수로 구현해보는것 까지 해보겠습니다. 
이진 탐색 트리가 아니라 이진 탐색 까지만 구현하는겁니다. 


vector<int> numbers;

void BinarySearch(int n)
{
	// TODO 
	// 인자로 받은 숫자가 numbers 안에 있는지를 탐색 후 있다면 로그로 출력

	int left = 0;
	int right = (int)numbers.size() - 1;

	while (left <= right)
	{
		cout << "탐색범위: " << left << " 에서 " << right << endl;
		int mid = (left + right) / 2;
		
		if (n < numbers[mid])
		{
			cout << n << " < " << numbers[mid] << endl;
			right = mid - 1;
		}
		else if (n > numbers[mid])
		{
			cout << n << " > " << numbers[mid] << endl;
			left = mid + 1;
		}
		else 
		{
			cout << n << " = " << numbers[mid] << endl;
			cout << "찾음!" << endl;
			break;
		}
	}
}

int main()
{
	numbers = vector<int>{ 1,8,15,23,39,47,56,61,81,91 };

	BinarySearch(82);
}

이론때 예시로 들었던 상황을 코드로 구현했습니다. 

BinarySearch 함수의 내용을 읽어보면 left 와 right 라는 변수를 만들었는데 배열에서 탐색할 범위를 정해줍니다. 첫번째 시도의 값은 당연히 
0 번 인덱스 부터 끝까지를 탐색할것입니다. 

다음은 while 을 돌건데 조건을 left <= right 라고 했습니다. 이것은 반복을 할 때 마다 left 와 right 사이의 거리가 절반씩 줄어들것인데 
최종적으로 left 와 right 가 같을때는 마지막 남은 하나의 원소를 체크하는 순간이고 그 다음 부터는 left 와 right 가 엇갈릴것입니다. 
그럴때는 이미 배열안에 찾는 값이 없는것이기 때문에 while 의 탈출 조건으로 left <= right 를 건겁니다. 

while 문 안에서는 먼저 배열을 절반씩 나눌 때 그 '절반' 의 인덱스를 mid 에 담아주고 있습니다. C++ 에서 int 의 성질상 홀수를 2로 나눠서 소수점이 생기면 
소수점은 생략하고 정수 부분만 가져다 사용할겁니다. 

이제 numbers[mid] 의 값과 n을 비교하는데 중간값보다 n이 작다면 right 를 mid -1 로 해서 mid의 왼쪽 범위로 줄이고 
중간값이 n보다 크다면 left 를 mid + 1 로 해서 mid 의 오른쪽 범위로 줄입니다. 
둘 다 아니라면 중간 값과 n이 같다는 말입니다. 

여기까지 이진 탐색 자체도 면접에 꼭 나오는 질문이기 때문에 숙지를 하는것이 좋겠습니다.

- 추가 : 이진 탐색만으로도 효율이 좋은데 굳이 이진 탐색 트리 까지 배워야 하는이유?

이진 탐색을 할 수 있었던 이유가 있었습니다. 바로 '정렬'이 되어있는 데이터였기 때문이었습니다. 
정렬이 되어있고 vector 에서 임의 접근이 가능했기 때문에 numbers[mid] 로 바로바로 중간값에 접근이 되었습니다. 

그런데 배열, 동적배열에는 임의접근이 된다는 장점말고도 단점이 있었는데 데이터를 중간 삽입/삭제가 어렵다는 점이었습니다. 
이 말은 한번 만든 데이터를 이후에 수정하려면 많은 시간과 비용이 든다는 겁니다. 

그러면 중간 삽입/삭제에 메리트가 있는 자료구조였던 연결 리스트를 사용하면 어떨까요?
연결리스트는 중간 삽입/삭제에 유리하지만 임의접근은 불가능 했습니다. 임의 접근이 불가능 하다면 중간 값을 찾을때 마다 연결리스트의 사이즈 절반만큼 
순회를 하면서 중간값에 접근해야하는데 이러면 이진 탐색을 하는의미가 없습니다.

즉 지금 실습한것처럼 vector 로 데이터를 관리하려면 한번 만든 데이터는 뒤쪽으로 추가만되고 중간 원소들을 수정/삭제 하지 않을 경우에만 
유용합니다. 

대부분의 경우에는 데이터들을 이리저리 수정도 해야 하기 때문에 이진 탐색 '트리' 까지 가야 원하는대로 탐색도 용이하고 데이터 수정도 용이하겠습니다. 
