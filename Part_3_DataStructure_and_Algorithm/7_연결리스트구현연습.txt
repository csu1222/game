

        연결 리스트 구현 


이번 시간에는 연결리스트를 구현하면서 이해해보겠습니다. C++ 에서 연결리스트는 list 라는 이름으로 사용됩니다. 

내용에 들어가기에 앞서 실제 프로그래밍에서 벡터와 연결리스트중에 어떤 걸 사용할지 고르면 십중팔구는 벡터를 고르게 된다고 힙니다. 
그 만큼 벡터의 장점이 더 큰것인데 연결리스트의 장점인 중간 삽입/삭제가 용이하다는 장점이 생각보다 크게 와닿는 경우가 잘 없는것 같습니다. 
그리고 데이터가 연속적이다 라는 특징때문에 원하는 데이터에 접근하기가 쉬운것이 또 큰 장점입니다. 나중에 cache 의 덕도 볼 수 있다고 합니다.

그럼에도 불구하고 연결리스트가 중요한 이유가 앞으로 공부할 자료구조들의 기초가 되는 내용이기 때문입니다. 

실습에 들어가보겠습니다. 
먼저 list 를 추가합니다. 

list 객체를 만들어서 0 부터 9 까지의 정수를 push_back 해주겠습니다. 그런데 list에는 push_back 뿐만아니라 push_front 도 지원한다는걸 알 수 있습니다. 
(지원하는 함수에 떠서)
벡터에는 지원하지 않는 함수였는데 그러면 벡터는 push_front 를 구현할수 없는가? 그것은 아닙니다. 
그러나 벡터에도 push_front 를 지원하면 막 사용해도 되는가 보다 하는 오해를 일으킬 수 있어서 기본 지원하지 않는겁니다. 
벡터의 구조를 다시 생각해보면 배열의 앞에 데이터를 넣으려면 먼저 capacity가 꽉찼는지를 체크하고 
통과하면 새로운 배열을 만들어서 앞에 넣으려는 데이터를 추가하고 이어서 기존의 데이터들을 전부 복사하는 과정이 필요합니다. 
	// vector 
	// - push_back	O(1)
	// - push_front O(n)

반면 list 에서는 개론시간에도 말했듯이 V[n] 이런 문법이 지원하지 않습니다. 
list는 첫번째 원소부터 하나하나씩 들리면서 원하는 데이터를 찾아야 합니다.

그리고 list 에는 push_back 말고도 insert 라는 메소드로 원소를 넣어줄 수 있습니다. insert 메소드는 인자를 두개를 받습니다. 
첫번째는 원소를 삽입 해줄 위치의 다음순서 이터레이터, 두번째는 넣어줄 원소 입니다. 이터레이터란 연결리스트에서 사용하는 일종의 인덱스 같은 겁니다. 
insert 메소드는 그 자체로 기능을 하기도 하지만 반환하는 값으로 추가된 원소의 이터레이터를 반환 하기도 합니다.

list의 원소를 꺼내는 것은 인덱스로 접근 할 수 없기 때문에 이터레이터를 가지고 하나씩 꺼내 사용할 수 있는데 for 문으로 순회를 도는것도 이터레이터를 활용해야 합니다. 

또 pop_back 이나 erase 같은 기능도 있는데 위에서 말한 기능들을 구현해보는것이 이번 강의의 목적입니다. 

// 테스트할 내용들 
	list<int> li;

	list<int>::iterator eraseIt;	// 이터레이터 변수
	for (int i = 0; i < 10; i++)
	{
		if (i == 5)	// insert 는 이터레이터를 주면 그 앞에 데이터를 넣습니다. 
		{
			eraseIt = li.insert(li.end(), i);
		}
		else
		{
			li.push_back(i);	
		}
		// list 에는 특이하게 push_front 도 있습니다. 

	}
	li.pop_back();

	li.erase(eraseIt);	// 제거할 이터레이터를 줍니다. 

	for (list<int>::iterator it = li.begin(); it != li.end(); it++)
	{
		cout << (*it) << endl;
	}


- Node
list 는 노드 기반의 자료구조입니다. 여기서 노드가 무엇인지 부터 시작해보겠습니다. 

노드는 list 가 들고 있을 하나의 데이터 단위입니다. 일단 데이터이다 보니까 말그대로 데이터를 들고 있을겁니다. 
그리고 노드는 단방향 노드와 양방향 노드가 있습니다. 둘의 차이는 이름대로 한쪽으로만 갈수 있는지 양 쪽으로 갈 수 있는지의 차이입니다. 
이 내용을 멤버변수로 표현해보겠습니다. 

template<typename T>
class Node
{
public:

private:
	Node*	_prev;
	Node*	_next;
	T		_data;
};

이 코드를 처음 보면 맨붕이 올 수도 있습니다. 클래스가 Node 인데 멤버 변수로 Node를 또 들고 있습니다. 노드를 정의 하기위해서 그 안의 멤버변수를 정의해야하는데 
그 멤버변수가 노드니까 또 그걸 정의하기위해 ... 같이 재귀함수처럼 무한 반복이 될것 같아 보입니다. 
이 말은 _prev 와 _next 가 포인터가 아니라 Node 그 자체였으면 맞는 말입니다. 

포인터는 주소라고 했습니다. 포인터가 가리키면 * 앞에 오는 타입의 데이터가 있다 라는 의미였으니까 _prev, _next 는 그냥 주소타입의 변수인것입니다. 
주소를 타고가서 거기있는 데이터를 Node 타입으로 해석하라는 의미입니다. 

개론시간에 호텔에서 서로 다음 이전의 방번호를 기억하고 있다고 했는데 그것을 코드로 표현하면 포인터가 되는겁니다. 

이제 노드의 멤버 함수, 생성자를 이어서 만들어 보겠습니다. 노드의 기본생성자에서는 먼저 _prev 와 _next 를 nullptr 로 초기화 해주고 _data는 _data(T()) 이렇게 초기화를 해줍니다. 
노드를 만들때 인자가 있는경우는 _data 를 해당 인자로 채워줍니다. 

template<typename T>
class Node
{
public:
	Node() : _prev(nullptr), _next(nullptr), _data(T())
	{

	}

	Node(const T value) : _prev(nullptr), _next(nullptr), _data(value)
	{

	}

private:
	Node*	_prev;
	Node*	_next;
	T		_data;
};

이제 이 노드를 하나의 단위로 사용해서 연결리스트를 만들면 되겠습니다.


- List

우리가 만들 list의 이름은 앞을 대문자로 해서 List 라는 이름으로 만들어 줄겁니다. 역시 템플릿 문법을 적용할것입니다. 

List 가 기본적으로 가지고 있어야할 데이터가 무엇일지 생각해보겠습니다. 아무 원소도 추가하지 않아도 기본적으로 두개의 노드를 들고 있게 하고 싶습니다. 
이름은 _head, _tail 이라는 이름으로 만들겠습니다. 그리고 List의 크기를 나타내는 _size 라는 정수 타입 변수도 들고 있을겁니다. 

_head, _tail 이라는 노드를 왜 들고 있을것이냐면 List 의 시작과 끝을 의미합니다. Begin, end 같은 메소드에서 사용될 노드들입니다. 

_head, _tail 둘 다 노드의 포인터 타입인데 그 내용물을 일단 들고 있을겁니다. _head, _tail 이 만약 nullptr 일 수도 있다면 코드에서 계속 null 체크를 해줘야 합니다. 
이런 귀찮은 짓을 안하도록 확실하게 생성자에서 만들어 주겠습니다.  
template<typename T>
class List
{
public:
	List() : _size(0)
	{	
		// [head] <-> ... <-> [tail]
		_head = new Node<T>();
		_tail = new Node<T>();

		_head->_next = _tail;
		_tail->_prev = _head;
	}

	~List()
	{
		delete _head;
		delete _tail;
	}

private:
	Node<T>*	_head;
	Node<T>*	_tail;
	int			_size;
};

_head 와 _tail 은 서로를 _next , _prev 로 가리키는 상태로 세팅했습니다. 나중에 원소가 추가되면 저 사이에 넣어줄겁니다. 

기본 틀은 여기서 시작되고 이제 오늘 테스트할 기본 기능들을 추가해줄겁니다. 
push_back, insert, pop_back, erase, iterator, * 연산자 까지 구현할건데 중간에 더 추가 될 수도 있습니다. 

먼저 push_back, pop_back 을 구현해보겠습니다. 이 두 메소드 모두 _tail 의 앞쪽에 노드를 추가하거나 삭제하는 메소드입니다. 

push_back 을 구현하려니 이 안에 노드를 추가하는 코드를 바로 넣는것 말고 따로 기능을 빼서 함수로 만들어 주는게 좋을것 같습니다. 
push_back 말고도 insert 같은 경우도 위치를 지정해서 노드를 추가하는 함수다 보니까 공용으로 사용할 수 있게 해주겠습니다. 

추가할 함수의 이름은 AddNode 라는 이름으로 만들겠습니다. 반환타입은 노드의 포인터를 반환 할 것이고 인자는 두개를 받을건데 첫번째 인자로 
노드의 포인터입니다. 이 첫번째 인자는 노드를 추가할 위치의 다음번 노드를 넘겨줄겁니다. 두번째 인자로 템플릿 타입 T&  인 값을 받을건데 
이 값을 가지고 노드를 만들어서 첫번째 인자 앞쪽에 추가해주겠습니다. 

함수 안에서 해줄 기능은 두번째 인자를 들고 있는 newNode 를 만들고 첫번째 노드의 _prev 값을 가진 pervNode 를 만듭니다. 
그리고 newNode 와 pervNode 가 서로를 가리키도록 해주고 before 노드와 newNode 도 서로를 가리키게 해줍니다. 이제 List 의 원소가 하나 늘었으니까 
_size++ 를 해줍니다. 마지막으로 newNode 를 리턴해줍니다. 
	// [head] <-> [1] <-> [prevNode] <-> [before] <-> [tail]
	// [head] <-> [1] <-> [prevNode] <-> [NewNode] <-> [before] <-> [tail]
	Node<T>* AddNode(Node<T>* before, const T& value)
	{
		Node<T>* newNode = new Node<T>(value);
		Node<T>* prevNode = before->_prev;

		prevNode->_next = newNode;
		newNode->_prev = prevNode;

		newNode->_next = before;
		before->_prev = newNode;

		_size++;

		return newNode;
	}
여기서 before->_prev 를 가져오는 부분이 있는데 List 가 맨처음에는 원소가 하나도 없을텐데 어떻게 _prev 를 가져오는가 의문이 들 수 있는데 
이미 생성자에서 더미 노드 _head, _tail 을 만들어 뒀기때문에 실질 원소가 하나도 없어도 _prev, _next 는 항상 있을겁니다. 
더미노드를 먼저 만들지 않았다면 매번 AddNode 를 호출 할 때 마다 bofore 의 _prev가 nullptr 인지 아닌지를 체크해야 할겁니다. 

이제 노드를 추가하는 함수를 만들었으니까 노드를 삭제하는 함수도 만들어 주겠습니다. 
함수 이름은 RemoveNode 라고 하겠습니다. 반환 타입은 Node<T>* 입니다. 인자는 삭제할 노드를 하나 받습니다. 
여기서 해줄 내용은 인자의 삭제할 노드의 _next, _prev 노드들을 가져와서 이 둘이 서로의 주소를 들고 있게 하면 삭제할 노드는 혼자 붕 떠버립니다. 
이때 그 노드를 delete 하는 로직입니다. 
	// [head] <-> [prevNode] <-> [node] <-> [nextNode] <-> [tail]
	// [head] <-> [prevNode] <-> [nextNode] <-> [tail]
	Node<T>* RemoveNode(Node<T>* node)
	{
		Node<T>* nextNode = node->_next;
		Node<T>* prevNode = node->_prev;

		nextNode->_prev = prevNode;
		prevNode->_next = nextNode;

		delete node;

		_size--;

		return nextNode;	
	}


push_back, pop_back 을 도와줄 함수들을 만들었으니 다시 push_back 부터 만들어보겠습니다. 

push_back 이 하는 일이 무엇일까요? 노드를 추가하는데 _tail 앞에 추가하는겁니다. 

	void push_back(const T& value)
	{
		AddNode(_tail, value);
	}

그리고 pop_back 을 보면 tail의 앞 노드를 삭제하는 기능입니다. 

	void pop_back()
	{
		RemoveNode(_tail->_prev);
	}

이렇게 AddNode, RemoveNode 를 미리 만들어 놨더니 push_back, pop_back 이 아주 간단하게 구현이됩니다.

여기에 더해서 List 가 소멸될때 원소를 들고 있다면 모든 원소를 날려주고 소멸해야 메모리 누수가 안 일어날겁니다. 
	~List()
	{
		while (_size > 0)
			pop_back();

		delete _head;
		delete _tail;
	}


다음으로 추가할 기능은 erase 나 begin, end 같은 iterator 에 관한 기능들입니다. 
List가 임의 접근이 안되다 보니까 이런 이터레이터가 필요합니다. 

이터레이터 부터 만들겠습니다. 
이터레이터는 변수로 노드의 포인터를 들고 있을겁니다. 
그리고 이터레이터에서 적용되는 연산자들도 정의를 해줄겁니다. it++, ++it, it--, --it, *it, ==, != 같은 연산자입니다. 
template<typename T>
class Iterator
{
public:
	Iterator() : _node(nullptr)
	{

	}

	Iterator(Node<T>& node) : _node(node)
	{

	}

	// it++
	Iterator operator++(int)
	{
		Iterator temp = *this;
		_node = _node->_next;

		return temp;
	}
	// ++it
	Iterator& operator++()
	{
		_node = _node->_next;

		return *this;
	}
	// it--
	Iterator operator--(int)
	{
		Iterator temp = *this;
		_node = _node->_prev;

		return temp;
	}
	// --it
	Iterator& operator--()
	{
		_node = _node->_prev;

		return *this;
	}

	// *it
	T& operator*()
	{
		return _node->_data;
	}

	// == 
	bool operator==(const Iterator& other)
	{
		return _node == other._node;
	}
	
	// !=
	bool operator!=(const Iterator& other)
	{
		return _node != other._node;
	}

public:
	Node<T>* _node;
};


이터레이터는 여러 연산자를 지원하고 노드들 사이를 돌아다니는 포인터 같은겁니다. 
이제 List 에서 방금 만든 이터레이터를 지원하도록 해주겠습니다. 

public:
	using iterator = Iterator<T>;

이 코드를 List 클래스 내부에 추가하면 'List<int>::iterator'  이런 형태로 이터레이터를 호출할 수 있습니다. 

그리고 begin, end 를 구현해줄건데 begin은 리스트의 시작원소를 말하는겁니다. 리스트가 기본적으로 들고 있는 더미 노드중에 
_head 가 있습니다. _head 를 그냥 넘겨주기에는 _head 자체는 데이터가 없는 더미 노드이므로 _head->_next 를 넘겨주겠습니다. 
end는 리스트에서 원소의 끝을 말하는건데 이 건 _tail을 그대로 넘겨주겠습니다. _tail->_prev 를 넘겨주기에는 이 노드가 끝이라는 증거가 필요합니다. 
_tail은 데이터가 없는 더미 노드이니까 데이터가 없다면 end라고 인식 가능하도록 _tail을 넘겨줍니다. 

또 이터레이터로 노드를 추가하거나 삭제하는 기능인 insert, erase 도 추가하겠습니다. 
이 두 함수의 반환타입은 iterator 이고 

insert의 경우 인자가 두가지를 받는데 노드를 추가할 위치의 이터레이터와 추가할 데이터 입니다.
내용은 아까 만든 AddNode 의 인자로 이터레이터가 들고 있는 노드와 데이터를 넘겨주고 반환되는 노드를 임시저장해 뒀다가 
리턴하면서 iterate(node) 를 리턴합니다. 

erase 는 지울 위치의 이터레이터를 인자로 받는데 이것도 역시 RemoveNode를 활용해서 노드를 지워주고 그 반환 값을 가지고 
이터레이터를 만들어서 반환합니다. 

public:
	using iterator = Iterator<T>;

	iterator begin() { return _head->_next; }
	iterator end() { return _tail; }

	// insert : 'it' 앞에 추가 
	iterator insert(iterator it, const T& value)
	{
		Node<T>* node = AddNode(it._node, value);
		return iterator(node);
	}

	iterator erase(iterator it)
	{
		Node<T>* node = RemoveNode(it._node);
		return iterator(node);
	}



이제 여기까지 만들면 오늘 테스트할 내용은 얼추 다 만든것 같습니다. 

main 함수로 돌아와서 우리가 만든 리스트인 List 로 다시 테스트를 해보겠습니다. 나와야 하는 결과물은 0부터 9까지 원소를 넣었다가 중간 5를 erase 하고 pop_back 으로 
9를 삭제한  0,1,2,3,4,6,7,8 입니다. 

바꾼다음 실행을 딱 누르면! 

짜잔 에러입니다. 에러메세지는 Node<T>::_data 가 private 멤버라서 외부에서 엑세스 할 수 없다고 합니다. 
괜히 Node 클래스 만들때 private 로 닫아 뒀습니다. public 으로 열어준 다음 다시 테스트 합니다. 

/*
저의 경우 여기서 한번더 에러가 났는데 erase 코드에서 retunr iterator(node); 가 변환이 안된다고 합니다. 
왜 안되는지 이곳 저곳 찾아보니 Iterator 의 생성자중에서 노드를 받는 타입의 생성자가 있었습니다. 
Iterator(Node<T>& node) : _node(node) { }
이렇게 만들었었는데 노드의 참조타입이 아니라 노드의 포인터를 인자로 받았어야 합니다. List 에서 AddNode, RemoveNode 의 반환 타입, 들고 있는 노드 모두
노드의 포인터 였는데 그 포인터를 Node 객체 자체로 캐스팅하려고 하고 있었습니다. 
*/


- 정리 

오늘도 part 1 에서 해봤던 내용을 복습해봤는데 list 에서 중요한 내용은 Node 라는것을 적용시켜서 Node 가 서로를 가리키도록 연결시켜서 
관리한다는 점입니다. 
이 Node를 선형적으로 관리하면 list 가 되는것이고 좀더 복잡하게 관리한다면 트리가 될 수도 있고 다양하게 응용이 될 수 있습니다. 

그리고 또 알 수 있는것은 list 는 중간 삽입/삭제가 용이하다고 했었습니다. 
RemoveNode 를 예로 들면 어떤 노드를 삭제할때 삭제할 노드의 앞 뒤 노드를 가져온 다음 서로 연결 시키고 삭제할 노드 자신을 그냥 delete 해주고 있습니다. 
이러면 사실상 노드를 삭제한겁니다. 이 과정의 시간복잡도는 O(1) 일겁니다. 
그런데 여기서 한가지 햇갈릴 수 있는데 RemoveNode 자체는 빠른데 list 에서 어떤 노드를 삭제할지 찾는 부분은 따로 생각해야 합니다. 
분명 list 는 임의 접근이 안된다고 했습니다. 그러면 list 에서 지우고 싶은 노드를 찾는것은 결국 전부 순회하면서 찾아야 합니다. 

지울데이터를 찾는 시간 복잡도는 O(n) 인데 그 노드를 지우는 시간복잡도는 O(1) 인겁니다. 
그러면 이 중간 삽입/삭제는 정말로 빠른걸까요?

중간 삽입/삭제가 정말빠르다고 말하려면 코드 내에서 어떤 데이터를 삭제할지 미리 저장해 두고 그 노드를 삭제 할 때 빠른것입니다. 

이부분도 꼬아서 면접에서 자주 나오는 부분이라고 합니다. 