


        A* 알고리즘


이번 시간에는 대망의 A* 알고리즘입니다. 다익스트라 알고리즘을 배울때 부터 우리 미로 프로젝트에 최종적으로 적용할 알고리즘은 
A* 알고리즘이라고 언급 했었습니다. 

먼저 Algorithm 프로젝트의 내요은 전부 날려주고 Maze 프로젝트를 시작프로젝트로 설정해주겠습니다.

오랜만에 Maze 프로젝트로 오니까 어디까지 했는지 가물가물합니다. 일단 한번 실행해보면 미로의 길을찾는데 BFS 알고리즘으로 길을 찾고 있는걸 알 수 있었습니다.

물론 중간에 BFS에서 가중치 개념이 추가된 다익스트라도 배웠고 우선순위 큐 도 배웠지만 Maze 에 적용하지는 않았었습니다. 


- A*
그러면 다익스트라, BFS, A* 에 어떤 상관관계가 있는데 또 무엇이 더 좋을지에 대해 얘기해봐야 합니다.

먼저 다익스트라나 BFS 에서는 시작점을 주고 길을 찾기는 했지만 뚜렷이 어느곳이 목적지라는 것은 주지 않았었습니다.
그냥 시작지점에서 가까운 지점 부터 탐색해 나가 보니 목적지에 도달하면 break 를 때리는 개념이었습니다.

이것을 왜 갑자기 얘기하는지를 예시를 들어 보겠습니다. 
- 스타크래프트를 예로 들어 보겠습니다. 왼쪽 위 지점부터 시작을할것인데 오른쪽 아래지점 까지 이동을 하려고 합니다. 
  하지만 스타크래프트 같은 실시간 전략게임에서는 아직 가보지 않은 지역은 맵에 안개가 끼어서 보이지 않습니다.
  이럴때 시작 지점과 목적지를 알고 있으면 왠만한 경우에는 시작지점으로 부터 오른쪽 아래방향으로 이동하는게 좋아 보입니다. 
  물론 맵이 악질이라서 중간에 벽이 가로 막고 있어서 밖으로 빙 돌아가는게 가장 가까운 길 일 수도 있습니다.
  하지만 일반적으로는 오른쪽 아래 방향으로 이동하는것이 조금더 확률이 높아질겁니다. 

  MMORPG 에서도 왠만하면 사방이 막혀있는 경우는 몇 없을것이고 대부분 지면을 통해 목적지 까지 지나갈 수 있는 경로가 있을겁니다.

그래서 A* 와 다익스트라의 가장 큰 차이점이 무엇이냐면 A* 에서는 시작점과 목적지라는 명확한 개념도 생기게 됩니다. 
어디부터 시작해서 어디까지 갈것이다 라는 목적이 생겼는데 
이 외에는 BFS 나 다익스트라와 그렇게 많이 다르다고 보기는 어렵습니다.

다익스트라는 시작 위치부터 발견한 노드중 가중치가 가장 낮은, 우월한 후보를 선택해서 그 노드를 방문하는 식으로 진행했었습니다. 
도중에 만약 경로상의 가중치 합이 더 작은 경로가 발견된다면 그 경로로 교체하기도 하고 
결국 가중치 합으로 가장 좋은 경로를 결정하는데 

A* 의 경우는 시작점을 기준으로 얼마나 가까운지를 뿐만아니라 출구를 기준으로 얼마나 떨어져 있는지 
두가지 요소를 고려하기 시작합니다. 이 두가지 요소를 어떤 알고리즘에 의해서 점수를 매겨줄것이고 그 점수를 통해서 가장 좋은 후보를 
골라 실행된다는 것은 다르지 않습니다.
좋은 점수의 경로를 따라 움직인다는것은 다익스트라와 다르지 않지만 그 점수라는것을 어떻게 매기는지가 달라집니다.

그래서 A*는 각 노드들의 점수를 어떻게 매기느냐에 따라 최단거리가 될 수도 안 될수도 있습니다. 랜덤성이 강한 알고리즘입니다. 
A* 에서 가중치를 매기는 방법은 출구 까지의 거리 혹은 출구 까지의 x 좌표차이, y 좌표차이 같은걸로도 매길수 있습니다.
이렇게 어느정도는 출구에 가까워지는것을 유도 하게끔 평가값을 맞춰주면 대부분의 상황에서는 최단거리로 달려가는 식으로 만들어 질겁니다.

여기까지가 이론이었고 말로하는것 보다 코드로 보면 좀 더 쉽게 이해할 수 있으니까 코드 구현으로 가보겠습니다. 


- 코드 

먼저 길찾기 알고리즘을 Player 의 Init 에서 해주고 있었는데 이전에 만들어 봤던 BFS 는 주석처리하고 오늘의 알고리즘인 AStar 를 함수로 만들어서 추가해주겠습니다.
기본적으로 플레이어가 시작하는 위치와 출구의 좌표, 보드의 사이즈, 그리고 플레이어의 상하좌우를 의미하는 front 라는 Pos 배열도 추가해주었습니다. 

책 같은데서 A*의 내용을 아래와 같이 설명한다고 합니다.

	// 점수 매기기
	// F = G + H
	// F = 최종 점수 (작을 수록 좋음, 경로에 따라 달라짐)
	// G = 시작점에서 해당 좌표까지 이동하는데 드는 비용 (작을 수록 좋음, 경로에 따라 달라짐)
	// H = 목적지에서 얼마나 가까운지 (작을 수록 좋은, 고정값)

F 가 가장 작은 경로가 현시점에서 가장 우수한 경로이기 때문에 그 경로를 따라 간다 라고 합니다. 
그러니까 이 점수를 매기는 부분만 추가되었다 뿐이지 저번에 했었던 다익스트라와 거의 비슷하다는걸 알 수 있습니다.

그리고 또 front 라는 Pos 배열로 위, 아래, 왼쪽, 오른쪽을 관리해주고 있었는데 이제 추가로 대각선으로도 움직일 수 있도록 몇가지 추가하겠습니다.	
    
    Pos front[] =
	{
		Pos { -1 , 0 },		// Up
		Pos { 0 , -1 },		// Left
		Pos { 1 , 0 },		// Down
		Pos { 0 , 1 },		// Right
		Pos {-1, -1},		// UP_LEFT
		Pos {1, -1},		// DOWN_LEFT
		Pos {1, 1},			// DOWN_RIGHT
		Pos {-1, 1},		// UP_RIGHT
	};
이렇게 8개가 만들어 지는데 항상 대각선도 포함하지는 않을것이기 때문에 거기에 대한 개수데이터도 관리 해줘야합니다.
	enum
	{
		DIR_COUNT = 4,
	};
이렇게 하면 4개까지만 사용한다. 대각선 빼고 위,왼쪽,아래,오른쪽 을 사용한다는 것이고 이 DIR_COUNT을 8로 변경하면 대각선까지 사용하겠다는 의미가 됩니다.

그리고 각 방향으로 이동하는 코스트를 또 관리해줍니다.

	int32 cost[] =
	{
		10,		// UP
		10,		// LEFT
		10,		// DOWN
		10,		// RIGHT
		14,		//	UP_LEFT
		14,		// DOWN_LEFT
		14,		// DOWN_RIGHT
		14,		// UP_RIGHT
	};
상하좌우는 10 씩 그리고 대각선은 상하좌우 에 루트 2 를 곱한 값 1.414 대략 14 로 주었습니다. 10 을 곱해서 float 가 아닌 int32 로 관리 가능하도록 해주었습니다. 
이 코스트 값은 절대적인것이 아니라 각자 원하는값으로 세팅해도 된다고 합니다.

여기까지 기본 작업이었다면 다음으로 해야 할일은 이렇습니다. 

	// 1) 예약(발견) 시스템 구현
	// 2) 뒤늦게 더 좋은 경로가 발견 될 수 있음 -> 예외 처리 필수 

먼저 예약(발견) 시스템 구현입니다. 예약을 할 때 발견한 타일의 Pos 정보 뿐만아니라 이 좌표에 얼마의 점수가 매겨졌는지도 관리해야 합니다. 
이걸 그먄 std::pair 로 어떻게 만들어서 관리 할 수도 있지만 여기서는 따로 struct 를 만들어서 관리해줄겁니다. 
이 구조체를 우선순위 큐 (priority_queue) 로 관리할것이기 때문에 PQNode 라고 이름을 지어줬습니다.
그리고 이 PQNode 끼리 평가값이 크다 아니다를 비교할때는 최종 점수 f를 서로 비교할것이기때문에 그에 대한 연산자 오버로딩도 추가해줄겁니다.

struct PQNode
{
	bool operator<(const PQNode& other) const { return f < other.f; }
	bool operator>(const PQNode& other) const { return f > other.f; }

	int32 f;	// f = h + g
	int32 g;
	Pos pos;
};

이렇게 A* 에서 사용할 기본 단위 구조체를 정의 했으니까 이것을 가지고 예약(발견) 시스템을 구현해보겠습니다. 
어떻게 구현 할것이냐면 다익스트라에서 했던것과 비슷하게 해줄겁니다. 

다익스트라에서는 discovered 말고도 best 라고 각 노드의 크기만큼의 vector<int> 를 만들었습니다. 의미는 시작점으로 부터 각 노드까지의 최적의 가중치 합입니다. 
지금 미로 프로젝트에서는 이차 벡터로 맵을 만들었으니까 best 도 그에 맞게 만들어 줍니다. 

	// best[y][x] -> 지금까지 (y,x) 에 대한 가장 좋은 비용(작을 수록 좋은 비용)
	vector<vector<int32>> best(size, vector<int32>(size, INT32_MAX));

실시간으로 찾아낸 가장 좋은 비용을 best에 기록할겁니다.

그래서 만약 혹시라도 뒤늦게 어떤 경로를 찾았을때 best 보다 나쁘다면 걔를 굳이 예약 시스템에 넣을 필요가 없을겁니다. 반면 반대로 나중에 찾은 어떤 경로가 
best 보다 좋다면 그 경로를 예약 시스템에 추가해줄겁니다.
그래서 best 의 기본값을 INT32_MAX로 말도 안되게 큰 값을 넣어주어서 첫 발견때는 모든 평가값을 넣어줄 수 있게끔 해주었습니다.

그리고 나중에 부모 추적 용도로 사용될 parent 도 만들어 주겠습니다.

	// 부모 추적 용도
	map<Pos, Pos> parent;

또 이것은 옵션이긴한데 여태껏 지나온 타일을 기록하는 ClosedList 를 만들어 주겠습니다.

	// ClosedList
	// closed[y][x] -> (y, x) 에 방문 했는지 여부 
	vector<vector<bool>> closed(size, vector<bool>(size, false));

이제 예약(발견) 시스템 자체를 만들 차례입니다. 
예약 시스템에서는 여러데이터를 밀어 넣었다가 그 안에서 가장 크거나 작은 값을 가진 데이터를 골라서 꺼내 사용할것인데 
이 내용은 바로 이전 시간에 배운 우선순위 큐의 특징과 같습니다. 

	priority_queue<PQNode, vector<PQNode>, greater<PQNode>> pq;

pq 는 템플릿 옵션으로 PQNode 타입, 컨테이너는 벡터, 작은 숫자 순으로(greater) 설정했습니다. 
그리고 이 pq의 역할 앞으로 방문할 노드의 목록을 구글에서 찾아보면 OpenList 라고 합니다. 반대개념으로 위에서 나온 CloseedList 가 있습니다.

이미 방문을 끝낸 애들을 ClosedList, 아직 방문하지 않은 애들을 OpenList 이다 라고 정리 할 수 있습니다.

다음은 초기값 설정을 해주겠습니다.

	// 초기값
	{
		int32 g = 0;
		int32 h = 10 * (abs(dest.y - start.y) + abs(dest.x - start.x));
		pq.push(PQNode{ g + h, g, start });
		best[start.y][start.x] = g + h;
		parent[start] = start;
	}

g 가 뜻하는것은 시작점으로 부터 현재 위치까지의 드는 비용이었습니다. 지금은 초기값을 설정해주는 부분이니까 움직이지 않았기 때문에 
g = 0 입니다. 
h 는 목적지 부터 출발점까지의 거리입니다. 여기서 사용하는 식은 정해진것이 아니고 각자의 정책에 따라 사용하면됩니다. 
일단 여기서는 기본 한칸 움직일때 마다의 비용을 10 으로 정했으니까 10이 곱해지고 거기에 목적지의 y 좌표값 빼기 시작점의 y 좌표값의 절대값(abs) 와 
x 좌표값들의 차이 절대값을 더해주고 있습니다. 

이렇게 시작점에서 초기값을 계산해주었으면 pq 에 push 합니다. PQNode 에서 만들었던 구조대로 f = g + h, g, Pos 를 넣어서 push하였습니다. 
잊지 말고 best와 parent 도 설정해주었습니다. 

	- 유의점 
	지금 코드에서 best 를 vector<vector<int32>> best(size, vector<int32>(size, INT32_MAX))로 만들고 있습니다. 그런데 이 형태에서는 데이터 양이 많아지면 
	용량이 부담이 될 수도 있습니다. 그럴때는 best 의 용도에 맞는 다른 컨테이너를 사용해도 됩니다. 이 강의에서 2차 벡터로 만들었다고 항상 똑같이 만들어야 
	한다는 법이 아니라는 것입니다. 구현하고자 하는 것을 잘 이해하고 그 것을 구현할 수만 있으면 됩니다. 
	best 뿐만아니라 다른 기능들도 배운대로만 외우려고 하지 말고 기능을 제대로 이해하고 그때의 상황에 적절한 자료구조를 가져다 사용하도록 하는게 좋겠습니다.

이제 초기값을 설정했으면 루프를 돌기 시작할겁니다. 


	while (pq.empty() == false)
	{

	}

이 루프 안에서 가장 먼저 할 일은 pq 노드 에서 가장 좋은 후보를 찾는것입니다. 이때 이미 priority_queue 를 사용하고 있었으니 pq의 top이 가장 좋은 후보입니다.
	
	// 제일 좋은 후보를 찾는다
	PQNode node = pq.top();
	pq.pop();

다음할 일은 이 가장좋은 후보가 동일한 좌표를 여러 경로로 찾아서 더 빠른 경로로 인해 이미 방문 했다면 스킵하도록 
체크하는부분입니다.

	// 두가지 방법이 있는데 Closed를 이용하는 방법과 best를 이용하는 방법

	// [선택]
	if (closed[node.pos.y][node.pos.x])
		continue;
	if (best[node.pos.y][node.pos.x] < node.f)
		continue;

이 다음은 바로 방문을 해줍니다.

	// 방문
	closed[node.pos.y][node.pos.x] = true;

그런데 이때 이런 의문이 생겼습니다. 
방문했는지 체크를 통과하자마자 곧 바로 방문했다고 해버리는데 만약 나중에 찾은 경로가 더욱 비용이 작다면 이 체크때문에 갱신하지 못하지 않을까?
그런데 이 의문은 수학적으로나 직접 그림을 그려가 보거나 해서 그럴일 없다고 증명 할 수 있다고 합니다.
직접 증명 해보던가 일단 받아들이고 지나갑니다.

여기까지 온 다음 이렇게 뽑은 노드가 목적지에 도달 했다면 이 while 루프를 빠져나오겠습니다. 

	// 목적지에 도달 했으면 종료
	if (node.pos == dest)
		break;

아니라면 이제 이 노드에서 갈 수 있는곳을 찾아서 pq 에 후보로 넣어줄겁니다. 

	// 갈 수 있는 모든 방향으로 체크
	for (int32 dir = 0; dir < DIR_COUNT; dir++)
	{
		// 각 방향으로 한걸음 더 갔을때의 Pos 구하기 
		Pos nextPos = node.pos + front[dir];

		// nextPos 가 갈 수 있는지 확인
		if (CanGo(nextPos) == false)
			continue;

		// [선택] 이미 방문한 곳이면 스킵
		// 여기서 체크해주던가 아니면 다음 while 루프때 체크해줄수 있음
		if (closed[nextPos.y][nextPos.x])
			continue;

		// nextPos 의 비용계산
		int32 g = node.g + cost[dir];
		int32 h = 10 * (abs(dest.y - nextPos.y) + abs(dest.x - nextPos.x));
		// 다른 경로에서 더 빠른 길을 찾았으면 스킵
		if (best[nextPos.y][nextPos.y] <= g + h)
			continue;

		// 예약 진행
		best[nextPos.y][nextPos.x] = g + h;
		pq.push(PQNode{ g + h,g,nextPos });
		parent[nextPos] = node.pos;
	}

미리 설정해 뒀던 갈수 있는 방향의 갯수만큼 체크해줄것입니다. 
각 방향으로 한걸음 나아간 노드는 nextPos 로 관리해줍니다. 그리고 그 nextPos 로 갈 수 있는지를 체크 합니다.

다음은 nextPos가 이미 방문한 곳인지를 체크하는데 이 기능을 여기서 해줘도 되고 아니면 일단 pq에 등록한 다음 이 노드가 while 문을 돌때 위에서 걸러줄 수도 있습니다. 
기왕이면 여기서 걸러서 pq 에 아예 등록되지 않도록 할 수도 있습니다. 

이제 nextPos는 갈 수도 있고 이전에 방문하지 않은 노드라는것을 알았습니다. 
nextPos의 비용을 계산해줍니다. g는 시작 지점으로 부터 현재 노드 까지의 코스트 합이었습니다. 시작지점에서 부터 cost를 계속더해오면 됩니다. 
h는 목적지에서 현재 노드 까지의 거리입니다. 

이렇게 구한 g 와 h 를 가지고 예약을 진행하기 전에 다른 경로를 통해 현재 위치까지 더 빠른 길을 찾았었다면 스킵을 합니다. 
이 부분 때문에 발견(예약)된 노드는 이전에 방문 되지 않았다면 가장 빠른 경로가 됩니다. 

예약을 진행합니다. 초기값설정때와 비슷합니다. parent 세팅때만 nextPos의 부모가 node.pos 인것을 주의 합니다. 

이제 A* 알고리즘으로 최단 경로를 구했습니다. 이제 이 정보들을 가지고 미로에 사용될 경로 _path에 담아주면 됩니다. 

이부분은 BFS 때 와 같습니다. 

	// 거꾸로 

	_path.clear();
	_pathIndex = 0;

	Pos pos = dest;

	while (true)
	{
		_path.push_back(pos);

		// 입구이면 break
		if (pos == parent[pos])
			break;

		pos = parent[pos];
	}

	// _path를 뒤집는다

	std::reverse(_path.begin(), _path.end());

경로를 추적하는것을 parent를 활용하기 때문에 거꾸로 출구부터 거슬러 올라가면서 _path에 기록하고, 다 기록했다면 거꾸로 뒤집어서 사용했습니다.

이 부분은 이전부터 반복되게 등장하기 때문에 사실은 따로 함수로 빼놓는것이 좋습니다.


- 복습겸 추가
여기까지하면 기존의 미로찾기 프로그램이 동작이 될겁니다. 
그런데 이번에는 조금 변주를 주어서 한번 미로를 다 돌면 자동적으로 새로운 미로를 만들고 다음 길찾기를 실행되도록 만들어 보겠습니다. 

Maze.cpp 를 살펴보면 

Board board;
Player player;
이 두 객체를 전역으로 만들어 주고 시작합니다. 

main 함수 코드 순서가 일단 랜덤 시드를 만들어 주고 
	board.Init(25, &player);
	player.Init(&board);

이때 board.Init 안에서 맵의 크기를 첫번째 인자로 설정하고 player 도 가지고있도록 합니다. 그 다음 GeneratorMap으로 이진 트리 미로 제작 알고리즘으로 
간단한 랜덤 미로 생성을 해줍니다. 
그리고 player.Init 에 board를 쥐어주고 보드에 맞춰서 플레이어 Init 에서 알고리즘을 통한 최단경로 를 구해줍니다. 

이제 while 문을 돌면서 프로그램을 유지시켜줄겁니다. 이때 프레임관리에 사용될 uint64 lastTick = 0; 을 while 문 밖에 미리 정의 합니다. 
한번 프로그램이 루프도는 시간을 deltaTick에 받아주면서 player.Update 에 인자로 줍니다. 
player.Update에서는 경로의 인덱스 _pathIndex가 _path의 끝에 달했으면 미로찾기를 끝내고 아니라면 일정시간이 지날 때 마다 _path 에서 한 걸음 씩을
꺼냅니다. 

그리고 꺼낸 한 걸음을 board.Render 에서 해당 위치로 플레이어를 옮기고 타일의 색을 바꾸면서 길을 찾아 나가고 있다고 표현해줍니다. 

이제 여기서 미로찾기가 멈추지 않고 계속 반복되게 하려면 미로찾기가 끝나는 지점, player::Update 에서 _pathIndex 가 _path.size()에 도달 했을때
를 수정해야합니다. 이때 그냥 return 해주는게 아니고 새로 미로를 만드는겁니다(GeneratorMap) 새로 맵을 만들었으면 이 맵에 대한 새로운 경로도 만들어야 합니다.
(player.init) 

void Player::Update(int32 deltaTick)
{
	if (_pathIndex >= _path.size())
	{
		_board->GenerateMap();
		Init(_board);
		
		return;
	}
	// ... 

/*
버그 발생 
프로그램을 실행하면 플레이어가 첫 걸음이 아래로 갈때 까지 맵을 자꾸 새로 만드는 버그가 있었는데 
원인은 AStar 함수에서 nextPos 를 구하고 그 비용을 계산해서 g ,h 에 담아준 다음 
best[nextPos.y][nextPos.x] <= g + h 를 체크할때 오타가나서 
best[nextPos.y][nextPos.y] <= g + h 를 체크하고 있었습니다. 
*/

여기서 한가지 더 신기한것을 체크해볼건데 DIR_COUNT 를 8로 설정해주는것이었습니다. 이걸 설정해주면 대각선 방향으로도 이동한다는 뜻입니다. 
대각선으로 이동하는게 더 낫다고 판단이 되야 대각선으로 움직일텐데 지금 코드에서는 대각선으로 움직이면 루트2 의 근사값인 1.4 * 10 의 비용이 든다고 
설정해놓았기 때문에 가로 세로로 이동하면 20 이 걸리는 걸 14 의 비용만 드니까 왠만하면 대각선으로 움직이려고 할겁니다. 
그러면 대각선으로 움직이는 비용을 20보다 높게 21 로 세팅하면 어떻게 될까요?
이러면 대각선으로 이동하는것 보다 가로 세로로 이동하는게 비용이 더 적어져서 대각선이동을 하지 않게 됩니다.


- 정리 
이렇게 해서 A* 알고리즘을 간단하게 구현, 실습해보았습니다. 
A* 알고리즘을 구현할때 신경써야 할 점은 예약시스템을 구현할때 그냥 list 로 구현해서 가장 코스트가 좋은 노드를 찾기까지 오랜 시간이 걸리게 하지 않고 
priority_queue 로 예약시스템을 구현해서 더 효율적으로 최선의 노드를 뽑아 사용할 수 있도록 하는게 좋겠다는걸 알았습니다.

예약시스템을 구현한 다음은 이미 더 좋은 경로를 찾았다면 스킵을 하는 부분도 처리 해놓았고 
만약에 뒤늦게 더 좋은 경로를 찾았다면 예외 처리를 해야하는데 
- OpenList 에서 찾아서 제거 한다거나 
- pq에서 pop을 한다음 무시한다거하 
하는 방법으로 예외처리를 해줘야합니다. 

이게 무슨 말이냐면 우리가 사용하고 있는 OpenList 인 pq 에서는 중간의 노드를 찾아서 제거하기 어렵기때문에 
순서대로 노드를 꺼내다가 꺼낸 노드가 이미 지나온 경로보다 비용이 많이 나간다면 이 꺼낸 노드를 그냥 무시하는 방법이 더 쉽고 유효할것입니다. 

만약 OpenList 를 priority_queue 가 아닌 다른 컨테이너를 사용했다면 애당초 OpenList에서 찾아서 제거하는 방법이 있을 수도 있습니다.

그리고 다익스트라와 다른점을 찾아보면 노드에 점수를 매기는 부분이 다릅니다. 
다익스트라에서는 이미 처음에 그래프를 만들때 부터 가중치를 같이 매기고 그 이미 매겨진 가중치를 기준으로 가장 좋은 경로를 선택해서 
길을 찾는 알고리즘이었는데 

A* 에서는 처음에는 각 노드에 가중치가 없지만 실시간으로 출발지와 목적지를 가지고 가중치를 계산해 나가면서 그 가중치로 인한 코스트가 가장
좋은 경로를 찾아 나갑니다.

이렇게 해서 우리 part.3 의 1차 프로젝트였던 Maze 프로젝트의 A* 길찾기 까지 완료되었습니다.

A*를 1차 목표로 진행해 왔던것은 A* 자체도 매우 유용하게 사용될 알고리즘이기도 하고 A* 를 이해하기 위해 선수지식으로 알아야할 
선형 자료구조라던가 그래프, DFS, BFS, 다익스트라, 트리, 이진 트리, 힙 트리, 우선순위 큐 등을 자연스럽게 이해하면서 
여기까지 올 수 있었습니다.


다음 시간부터는 앞으로 면접에서 나올만한 탐색트리같은 어렵지만 중요하게 다뤄야할 내용에 대해 배워보겠습니다.