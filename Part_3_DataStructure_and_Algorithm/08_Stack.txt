

        스택


- 복습
이전 시간에 연결리스트를 배우면서 같이 여러가지 개념에 대해 배웠습니다. 

연결리스트의 기본 단위인 노드는 템플릿 타입의 데이터와 자신의 앞 뒤 노드의 주소를 가지고 있는 자료구조 였습니다. 
그리고 이터레이터 반복자 라는 개념을 배워서 STL 코드와 똑같이 맞춰 보는 연습도 해봤습니다. 

참고로 이터레이터를 왜 사용해야 하는지 이해가 잘 안 갈 수 있습니다. 직접 만들어본 이터레이터도 구조가 그냥 노드를 감싸고 있고 몇몇 오퍼레이터 오버로드를 
한것뿐입니다. 일부러 이터레이터를 만들어서 사용하지 않아도 노드에 연산자를 붙혀서 사용할 수도 있을것 같다는 생각이 듭니다. 
물론 노드를 직접 사용하는것도 가능합니다. 
그럼에도 이터레이터를 사용하는 장점이 있는데 코드의 재사용성이 높아진다고 할 수 있습니다. 반복자 이터레이터는 데이터를 왔다 갔다 움직인다는게 중요하고 
이런 기능을 사용하도록 연산자 오버로드를 따로 빼서 해놓으면 만약 코드에서 list를 사용하고 있다고 했을때 이 list를 영원히 사용한다고 말 할 수 없습니다. 
어떤 이유가 있어서 컨테이너를 vector로 바꿔야 한다고 했을때 list 를 순회하기 위해 이터레이터를 사용하고 있었다면 그냥 타입만 바꿔주면 그대로 동작합니다. 

        ex)
        for (list<int>::iterator it = li.begin(); it != li.end(); it++)

        list 를 순회한다고 했을때 컨테이너를 vector 로 교체한다면 

        for (vector<int>::iterator it = li.begin(); it != li.end(); it++)

        이렇게 list 를 vector로 치환하기만 해도 잘 동작합니다. (li 는 list의 약자이지만 변수이름이기 때문에 굳이바꾸진 않았습니다.)

그런데 위의 예시에서 이터레이터의 타입을 지정할때 list<int>::iterator 같이 다 입력하지 않아도 part 1 에서 배웠던 auto 라는 타입을 사용하면 
컴파일러가 알아서 이터레이터라고 알아듣습니다. 

우리가 어떤 컨테이너를 사용하던지 그 안의 원소들을 반복해서 순회해야 하는 상황에서 이터레이터를 사용한다면 어떤 컨테이너인지 상관없이 동작한다는 
인터페이스 통일이라는 장점이 생깁니다. 

마찬가지로 STL 컨셉상 각 컨테이너가 지원하는 메소드들은 같은 기능은 같은 이름을 사용해서 재사용이 용이하게 해뒀습니다. 
물론 일부 기능은 list 에만 있다거나 반대로 일부는 vector 에만 있는 기능이 있기도 합니다.(ex> vector 는 임의 접근 [], list는 push_front 같은 기능)

여기까지 이전시간의 복습과 보충 이었습니다. 


- 본 강의 

오늘의 본 강의는 스택에 대한 내용입니다. 

스택을 한문장으로 설명하면 LIFO Last In First Out 후입 선출  이라고 할 수 있습니다. 

이 말이 어떤 의미인지 예시를 들어 보겠습니다. 
좁은 차로에서 자동차 4대가 가고 있다고 하겠습니다. 가던중에 어느 길에서 갑자기 사고나 공사를 하느라 더이상 앞으로 갈 수 없다고 했을때 
자동차 4대는 어쩔 수 없이 맨 뒤 차량부터 후진을 해서 왔던길을 되돌아 가야 합니다. 이런 상황을 후입선출 이라고 합니다. 

데이터를 [1][2][3][4] 순서로 밀어 넣엇다고 한다면 4번부터 꺼내써야 한다는 말입니다. 

이런 특징을 가지는 스택을 왜 알아야 하는지 궁금 할 수 있습니다. 스택은 다음 시간에 배울 큐와 같이 실생활에도 자주 쓰이는 자료구조입니다. 
예를 들어서 되돌리기 기능을 만들어야 한다고 해보겠습니다. 게임에서도 되돌리기 같은 기능도 있을겁니다. 커스터마이징 했던걸 취소한다거나 
아니면 문서나 툴에서 Ctrl + Z 기능도 되돌리기 기능입니다. 비주얼 스튜디오에서도 오타가 나거나 이전에 입력한 코드가 맘에 안들면 직전 취소 Ctrl + Z 를 하면 
최근 작업부터 하나씩 되돌아갑니다 . 이런 후입 선출이 스택의 개념입니다. 

이제 스택 코드를 보겠습니다. 스택도 기본 라이브러리가 있습니다. 그리고 스택의 메소드를 보면 개수가 아주 많지는 않은걸 알 수 있는데 
오늘 테스트해 볼 내용은 스택에 데이터를 밀어 넣는 push, 스택의 최상위 데이터를 확인하는 top, 스택의 최상위 데이터를 삭제하는 pop, 스택의 사이즈를 확인하는 size 
스택이 비었는지를 확인할 empty 이렇게 다섯가지 기능을 만들어 보면서 실습할겁니다. 

#include <iostream>
#include <vector>
#include <list>
#include <stack>
using namespace std;

// Stack (LIFO Last_In_First_Out 후입선출)

// [1][2][3][4] << 밀어넣음
// ex) 되돌리기 (Ctrl + Z)

int main()
{
	// 스택 생성 
	stack<int> s;

	// 데이터 밀어넣기
	s.push(1);
	s.push(2);
	s.push(3);

	while (s.empty() == false)	// 스택이 비었나?
	{
		// 최상위 원소가 무엇?
		int data = s.top();

		// 최상위 원소를 삭제
		s.pop();

		cout << data << endl; 
	}

	// 사이즈는?
	int size = s.size();
}

이걸 이제 우리만의 스택을 만들어서 다시 테스트 해보겠습니다. 

생각해보면 이전 시간들에 vector 와 list 를 만들어보 경험으로 응용해서 만들 수 있을것 같습니다. 
스택의 뒤부분에만 데이터를 밀어넣고 삭제하는것이 주요 기능인데 이것은 vector 나 list 의 push_back, pop_back 과 같은 기능입니다. 
그러면 동적배열이나 연결리스트 둘 중 아무거나 사용해서 구현할 수 있을것같습니다. 왜냐면 중요한건 뒤쪽 데이터를 넣고 꺼낼수 있으면 되기 때문입니다. 

이번에는 동적배열 vector 를 활용해서 스택을 구현해보겠습니다. vector의 코드 자체는 전에 실습 해봤으니 STL vector 를 가져다 사용하겠습니다. 

template<typename T>
class Stack
{
public:
	void push(const T& value)
	{
		_container.push_back(value);
	}

	void pop()
	{
		_container.pop_back();
	}

	T& top()
	{
		return _container.back();
	}

	bool empty() { return _container.empty(); }
	int size() { return _container.size(); }

private:
	vector<T> _container;
};

보면 기능 구현이 간단합니다. 그냥 벡터를 들고 있을것이고 그 벡터의 기능들을 스택에서 필요한 기능에서 호출해주고 있습니다. 
테스트 코드에 적용해서 실행해도 잘 실행됩니다. 


이렇게 vector 로 구현해 봤는데 너무 간단해서 이번엔 list 로 구현 해볼까 하는 생각이 듭니다. 
그런데 굉장히 재밌게도 멤버 변수의 타입만 list 로 교체해도 그대로 잘 돌아갑니다. 
template<typename T>
class Stack
{
public:
	void push(const T& value)
	{
		_container.push_back(value);
	}

	void pop()
	{
		_container.pop_back();
	}

	T& top()
	{
		return _container.back();
	}

	bool empty() { return _container.empty(); }
	int size() { return _container.size(); }

private:
	// vector<T> _container;                // 컨테이너만 교체
	list<T> _container;
};

이런것이 STL 의 장점입니다. STL 에서 관리되는 컨테이너들은 같은 기능을 하는 메소드는 그 안의 구현 방식은 다를 지라도 이름은 같게 
만들어서 서로 코드의 재사용이 용이하도록 만들어져 있습니다. 

한술 더 떠가지고 컨테이너도 템플릿으로 바꿔 가면서 만들수도 있습니다.

template<typename T, typename Container = vector<T>>
class Stack
{
public:
	void push(const T& value)
	{
		_container.push_back(value);
	}

	void pop()
	{
		_container.pop_back();
	}

	T& top()
	{
		return _container.back();
	}

	bool empty() { return _container.empty(); }
	int size() { return _container.size(); }

private:
	Container _container;
};
이렇게 컨테이너 타입도 템플릿으로 받으면 지금은 T의 벡터가 기본값인데 스택을 만들때 다른 컨테이너 방식으로 만들고 싶다면 생성할때 인자로 주면됩니다. 

Stack<int> S;   // 기본 컨테이너인 벡터로 구현한 스택

Stack<int, list<int>>  S2;      // 컨테이너를 list 로 지정해서 만든 list 방식의 스택 


우리가 결국에 우리가 part 1 에서 배웠던 vector, list 를 굳이 part 3 에서 다시 배웠던 이유는 vector, list 가 다른 자료구조의 기본이 되어서 사용이 되기 때문입니다. 


마지막으로 C++ 의 stack 에서는 top 과 pop 이 분리되어서 최상위 데이터를 가져오는것과 삭제하는게 따로인데 
C#에서는 pop 을 하면 최상위 데이터를 가져오는 동시에 그 최상위 데이터를 삭제 까지 해준다고 합니다. 
T pop()
{
        T ret = _data[_size - 1];
        _size--;
        return ret;
}
위와 비슷한 기능을 한다고 하는데 C++에서는 왜 top 과 pop 으로 나눠 놨냐면 단순히 성능 때문입니다. 

이번강의에서 스택 테스트를 int 형 데이터만 사용해서 그렇지 스택에 담기는 데이터가 굉장히 큰 용량을 가지고 있다면 위의 코드에서는 push 나 pop 을 할 때 
큰 용량의 데이터를 매번 ret 변수에 복사해줘야 합니다. 

그러면 복사버전이 아니라 참조타입 버전은 어떨까요?
T& pop()
{
        T ret = _data[_size - 1];
        _size--;
        return ret;
}
이러면 리턴하는 값은 ret 의 주소일겁니다. 하지만 ret은 임시 메모리, 스택 메모리 상에 있는 데이터이고 이 함수가 끝나면 바로 유효하지 않은 데이터가 됩니다. 
그렇기 때문에 어쩔수 없이 복사 버전으로 사용해야 합니다. 

그렇기 때문에 C++에서는 어쩔 수 없이 두 부분으로 나눠서 top 과 pop 으로 구현이 되어있습니다. 