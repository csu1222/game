

        기본 정렬 (버블, 선택, 삽입)


이번 시간부터 새로운 단원으로 들어와서 정렬에 대해 배우겠습니다. 

정렬 알고리즘은 컨테이너에 담긴 원소들을 번호순이나 사전순서와 같이 일정한 순서대로 열거하는 알고리즘 입니다. 

정렬이 왜 필요하냐면 우리가 Part 3 의 초반에서 선형적 자료구조 (연결리스트, 동적배열 등) 을 배웠습니다.
이런 자료구조의 기초와 같이 정렬도 기초에 해당하는 알고리즘입니다. 실전에서는 딱히 이 정렬 알고리즘을 직접 만들거나 하는 상황은 
많지 않습니다. 

강사님의 또 다른 강의 C# 강의에서 어떤 질문이 있었다고 하는데 

Q) A* 길찾기 알고리즘에서 OpenList 를 (Priority Queue) 로 사용하고 있었는데 왜 굳이 PQ 를 사용해야 하는가?
- 예를 들어 C# 에서 동적배열을 List 라는 이름으로 사용하는데 이 List 에 Sort 메소드가 있으니 이 List 에 원소들을 다 넣어 놓고 
  Sort 메소드를 활용해서 원하는대로 원소 값이 큰 순서(혹은 작은 순서) 로 정렬을 한 다음 사용하면 되는것이 아닌지? 왜 굳이 PQ를 사용해야 하는지
  라는 질문이 있었다고 합니다. 

만약에 자료구조, 알고리즘을 배우지 않는다면 PQ 를 사용하는 것과 동적배열을 정렬해서 사용하는것의 차이를 느끼지 못할 수도 있을것 같습니다. 

vector<int> v{ 1, 4, 2, 5, 3 };

std::sort(v.begin(), v.end());

이렇게 정렬해서 OpenList 로 사용하는것과 PQ 를 사용하는것의 차이를 알아보자면 

먼저 PQ 의 시간 복잡도는 O(logN) 이었습니다. 그리고 바로 전 강의에서 배웠던 레드 블랙 트리 도 마찬가지로 O(logN) 의 시간복잡도를 가집니다. 
이렇게 이진 트리의 구조로 되어 있는 자료구조는 O(logN) 의 시간복잡도를 가진다고 보면 되겠습니다. 
데이터가 아무리 많아지더라도 생각보다 트리의 높이가 생각보다 느리게 증가하기 때문에 그냥 하나씩 스캔하면서 탐색하는것과는 천차만별입니다. 

그러면 정렬 Sorting 은 얼마의 시간복잡도를 가질것인가 가 궁금합니다. 
그런데 정렬은 오래도록 연구된 분야이기 때문에 종류가 많습니다. 
또 정렬 자체를 이해하는것도 중요하긴 하지만 굳이 단원을 하나 파서 정렬만 다루는 이유는 면접에서 자주 물어보는 질문중에 하나가 정렬에 대해서 이기 때문입니다. 
이게 꼭 중요해서 라기 보다는 20~30 분 내에 면접자의 코딩실력을 판단하기 위한 경우가 많기 때문에 
우선순위 큐나 레드 블랙 트리 같은걸 코딩 면접에서 물어보는경우는 잘없다고 합니다. 시간도 오래걸리고 이걸 다 외우고 있어야 하는건 어렵기 때문인데요 
그에 비해 이번 단원의 정렬 알고리즘은 비교적 짧은시간에 풀 수 있는 적당한 난이도의 주제 여서 코딩 면접에서 자주 물어보는것 같습니다. 

서론이 조금 길었는데 본제로 들어가서 정렬 알고리즘에는 종류가 많다고 했는데 하나씩 소개해보겠습니다. 

그 중에서도 기본적이고 다소 동작 효율이 떨어지는 것들 부터 알아보겠습니다. 

1) 버블 정렬 (Bubble Sort)

2) 선택 정렬 (Selection Sort)

3) 삽입 정렬 (Insertion Sort)

이렇게 세가지에 대해 알아보겠습니다. 

- 버블 정렬 
  정렬이라는것 부터 선형적 자료구조, 예를 들어서 vector 같은 데에 담겨져 있는 데이터들을 큰 순서나 작은 순서로 나열하는것이었습니다. 
  그 중 버블 정렬은 컨테이너안의 원소들을 앞에서 부터 둘씩 비교해 정렬하는 알고리즘입니다. 

  예시로 포커카드를 다섯장을 받았다고 해보겠습니다. 

  이렇게 다섯장을 받았다고 했을 때 위에서 말한 둘씩 비교한다는 말은 이중 3 , J 부터 비교를 시작하는데 원소의 값이 작은순으로 정렬한다고 했을때 
  J가 3보다 크기 때문에 이대로 넘어갑니다. 
  [3][J][5][K][9]   // 3 과 J 비교 J가 더 크고 뒤쪽에 있기때문에 넘어감

  [3][5][J][K][9]   // 5 와 J 비교 J가 더 큰데 앞쪽에 있기 때문에 5 와 자리를 교체

  [3][5][J][K][9]   // J 와 K 비교 K가 더 크고 뒤에 있기때문에 넘어감 

  [3][5][J][9][K]   // K 와 9 비교 K가 더 큰데 앞쪽에 있기 때문에 9 와 자리를 교체 

  이렇게 해서 이 배열을 한바뀌를 쭉 돌고 나면 배열안에서 가장 크기가 큰 원소가 맨 뒤에 위치하게 되는걸 알수 있고 
  이 작업을 맨 뒤부터 한칸씩 자리를 확정해 나가는 방식입니다. 

  이것이 버블 정렬이고 왜 '버블 정렬' 이라는 이름이 붙었냐면 원소 두개씩 묶여서 비교가 일어나는게 버블같이 보인다고 해서 버블 정렬입니다. 
  
  코드로 표현하면 이렇게 됩니다.

  //1) 버블 정렬(Bubble Sort)
  void BubbleSort(vector<int>& v)
  {
    const int n = (int)v.size();

    for (int i = 0; i < n - 1; i++)
    {
      for (int j = 0; j < (n - 1 - i); j++)
      {
        if (v[j] > v[j + 1])
        {
          int temp = v[j];
          v[j] = v[j + 1];
          v[j + 1] = temp;
        }
      }
    }
  }

  이 BubbleSort 라는 함수는 인자로 정렬할 벡터를 받고 있습니다. 그리고 그 벡터의 사이즈를 가져옵니다. 
  이중 for 문을 도는데 i 는 n-1 까지 j 는 n -1 -i 까지 돕니다. 
  (버블 정렬에서는 원소 두개씩 짝지어서 확인하기 때문에 i < n - 1 만큼 돕니다.)
  j 는 n-1-i 까지 도는 이유는 j for문에서는 실질적으로 벡터의 원소들을 비교해 스왑하는 기능을합니다. j for 문이 한 바퀴를 돌면 
  하나의 원소가 제자리로 정렬되는데 그 다음 루프에서는 이미 정렬된 원소까지 굳이 비교 스왑을 할 필요가 없기 때문에 
  하나의 원소를 정렬한 다음 i 개 만큼 반복 횟수를 줄이는겁니다. 

  이어서 버블 정렬의 시간복잡도를 계산해보겠습니다. 비교 하는 부분의 코드에서는 그냥 상수이기 째문에 시간복잡도에 영향이 없고 
  for문 두개 를 인자의 갯수만큼 도는 명령어가 데이터 갯수에 영향을 받기 때문에 이 버블 정렬의 성능을 결정짓는다고 볼 수 있습니다. 
  i가 n - 1 번 만큼 연산을 할텐데 그 안에서 매번 j 가 n - 1 -i 만큼을 연산을 할겁니다.
  (n -1) + (n - 2) + ... 2 + 1 
  이런식으로 i의 for 문이 연산이 되는데 이것을 등차수열의 합 공식을 이용하면 n * (N - 1) / 2 라는 값이 나옵니다.
  이걸다시 풀어 사용하면 n²/2 - n/2 라는 결과이긴합니다. 
  하지만 시간복잡도를 계산할때는 가장 큰 값만 보기 때문에 결국 
  버블 정렬의 시간 복잡도는 O(n²) 이라고 볼 수 있습니다.

  굉장히 느라다고 볼 수 있습니다. 실전에서는 거의 사용하지 못합니다.


- 선택 정렬 

  이제 다음으로 선택정렬입니다. 
  선택정렬에서는 정렬할 원소들을 쭉 스캔을 하면서 그 중 가장 작은 원소가 뭔지 기억 했다가 한번 스캔이 끝나면 가장 작은 원소를 맨 앞으로 옮깁니다. 
  그리고 다음번 스캔에서 두번째로 작은 원소를 찾는 것을 반복합니다. 

  버블정렬과 비슷한 느낌인데 둘 둘 씩 비교하는것이 아니라 한번의 스캔에서 승자 하나만 가져다 위치하는 방법입니다. 
  //2) 선택 정렬(Selection Sort)

  void SelectionSort(vector<int>& v)
  {
    const int n = (int)v.size();

    // 승자를 찾는 루프
    for (int i = 0; i < n - 1; i++)
    {	
      // 일단 최선의 인덱스는 시작 인덱스
      int bestIdx = i;

      // 스캔을 돌면서 맨처음 원소보다 좋은 후보가 있는지 찾음
      for (int j = i + 1; j < n; j++)
      {
        if (v[j] < v[bestIdx])
          bestIdx = j;
      }

      // 찾은 최선의 후보를 앞에서부터 채워넣음
      int temp = v[i];
      v[i] = v[bestIdx];
      v[bestIdx] = temp;
    }
  }

  버블 정렬과 비슷하게 시작하고 있습니다. 다른 점은 bestIdx 라는 인덱스를 추적하고 있는점인데 i 는 n-1 까지 순회합니다. 
  순회의 횟수를 i로 관리함과 동시에 i 를 인덱스로 사용해서 순회마다 앞에서 부터 bestIdx 를 기본적으로 설정하고 있습니다. 
  j 를 i + 1 부터 n 까지 순회하는데 이유는 j 순회안에서 하는 일이 현재 bestIdx 보다 좋은 후보가 있다면 그걸 기록하는 역할이기때문에 i 이후부터 다른 후보를 찾을것입니다. 
  j 순회가 끝났으면 찾은 bestIdx 를 현재 i 번 인덱스의 원소와 스왑합니다.

  시간복잡도를 계산해보면 i 가 n -1 까지 j 는 i 가 반복될때 까지 n - i 만큼 연산을 하는데 이것은 버블 정렬때와 거의 동일하다고 할 수 있습니다. 
  즉, O(n²) 의 시간복잡도를 가집니다. 

  시간복잡도를 계산하는것은 하다보면 쉽게 할 수 있습니다. 데이터 개수에 영향을 받는 변수를 추적하면되는데 만약 for 문을 두개 쓴다면 제곱이 되는것입니다. 


- 삽입 정렬

  삽입 정렬은 이 알고리즘 자체가 중요하다기 보다는 코딩 테스트에 많이 나오는 문제이기 때문에 꼭 알아두는것이 좋겠습니다. 
  특히 문자열과 관련된 문제에서 뒷부분부터 건드려서 진행하는 부분이 있는데 이런 걸 알면 좋겠습니다. 

  삽입 정렬도 선택 정렬과 비슷한 느낌을 받습니다. 
  선택 정렬에서는 승자를 골라서 우리가 원하는 위치에 배치했다고 하면 삽입 정렬은 실시간으로 정렬된 데이터를 만들어 나가는 동작을 하게 됩니다. 
  이게 무슨 말이냐면 정렬할 컨테이너 예를 들어서 벡터가 있을때 
  정렬되지 않은 벡터를 v1 이라고 하고 또 다른 빈 벡터를 v2 라고 만듭니다. v1 에서 원소 하나를 꺼내서 v2 에 추가합니다. 
  다음 시행에서 다시 v1 에서 원소 하나를 꺼내서 v2 에 추가하는데 그냥 push_back 이 아니라 순서에 맞게 삽입을 합니다. 
  이렇게 v2 에서는 항상 정렬이 되어있는 상태가 되고 v1 에서 원소들을 하나씩 옮깁니다. 

  그러면 이걸 코드로 만들기 위해서 인자로 정렬할 벡터를 받고 원소들을 하나씩 담을 임시 벡터를 만들어야 할것 같은데 그렇지 않습니다. 
  위의 설명에서는 v2 라는 벡터를 새로 만들어서 원소를 하나씩 삽입 한다고 했는데 실제 코드에서는 v1 안에서 해결할것입니다. 
  하나의 배열안에서 정렬이 되어 있는 영역, 정렬을 할 영역을 나눠서 기억하면됩니다. 

  코드로 보면 이렇습니다. 
  //3) 삽입 정렬(Insertion Sort)

  void InsertionSort(vector<int>& v)
  {
    const int n = v.size();

    // 첫번째 원소는 딱히 연산할게 없으니까 두번째 원소부터 연산 시작 
    for (int i = 1; i < n; i++)
    {	
      // 매 반복마다 삽입할 데이터를 고릅니다.
      int insertData = v[i];

      // j 는 InsertData 의 앞 순서부터 거꾸로 순회를 돕니다.
      int j;
      for (j = i - 1; j >= 0; j--)
      {
        if (v[j] > insertData)
          v[j + 1] = v[j];
        else
          break;
      }
      v[j + 1] = insertData;
    }
  } 
  
  눈여겨 봐야 할 점들은 i 가 1부터 시작한다는 점, j 가 i - 1 부터 거꾸로 진행한다는 점 등입니다.

  그리고 int j 를 for 문안에 정의 한게 아니라 i for 문 에 정의해 사용하고 있는데 j for 문을 break 나 조건을 넘어서 빠져나온 다음 
  j + 1 에 원소를 삽입하기 위해서입니다. 
  그런데 이렇게 하지 않고 기존 처럼 for 문 안에 int j 를 정의 하는 방법도 있는데 

  for (int j = i - 1; j >= 0; j--)
  {
    if (v[j] > insertData)
      v[j + 1] = v[j];
    else
    {
      v[j + 1] = insertData;
      break;
    }
  }
  
  이렇게도 작동은 합니다.

  이 삽입 정렬도 시간 복잡도는 다른 기초 정렬 알고리즘들과 동일하게 O(n²) 입니다. 
  삽입 정렬도 느린 알고리즘 이기는 하지만 그래도 위의 두 알고리즘들 보다 나은 점은 버블 정렬이나 선택 정렬같은 경우는 이미 배열이 정렬이 되어 있건 
  안되어 있건간에 모든 경우를 돌아야 하지만 삽입 정렬은 삽입할 데이터를 체크할때 뒤에서 부터 값을 체크해서 삽입할 데이터가 더 크다면 그 위치에 
  저장하고 다음 반복으로 넘어갑니다. 이것은 이미 배열이 정렬이 되어있을 수록 좀 더 빠른 속도를 보인다는 말입니다. 
  하지만 일반적으로는 그다지 효율적이진 않습니다.

  그래도 뒤쪽 원소부터 체크하는 컨샙은 면접에서 많이 물어보니 알고 넘어가야 겠습니다.