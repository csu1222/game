

        다익스트라 알고리즘


이전 시간에는 BFS 를 우리 미로 프로젝트에 적용해보았습니다. 

하지만 현재 로직으로는 만약 길찾기를 할 때 타일을 대각선으로 간다면 상하좌우보다는 더 먼 거리를 가는데 이런 차이를 둘수 없는 것이 아쉬운 점이었습니다. 

이부분을 보완가능한게 오늘 주제인 다익스트라 알고리즘이라고 합니다. 
하지만 오늘 개념을 배우고 우리 미로 프로젝트에 바로 적용하지는 않고 알고리즘 프로젝트에서 실습 까지만 해볼겁니다. 

- BFS 의 아쉬움
먼저 다시 BFS 의 아쉬운 점이 무엇인지 정확히 집고 넘어가겠습니다. 

우리가 그래프를 배울 때 방향 그래프와 가중치 그래프라는것이 있다고 배웠었습니다. 둘은 같이 적용되는 개념인것 같은데 
이전 시간에 만들었던 미로에서의 BFS 길찾기는 말하자면 방향 그래프를 커버하는 알고리즘이었습니다.
상하좌우가 동일한 가치, 무게를 가지고 있는 상태를 커버하고 있다는겁니다.

그렇지만 가중치 그래프는 커버하지 못하는 방법이었는데 지하철 노선도 같은 경우는 지하철 역의 간선마다 거리가 모두 다른데 그냥 하나의 간선이라고 
다 같은 가중치를 두는것은 부자연스러운 일입니다.

예를들어서 0번 ,1번, 3번 역이 있다고 하겠습니다. 시작 지점은 0번 역인데 3번역에 가고 싶습니다. 0번역은 1번역, 3번역 모두 연결되어 있고 1번역에서는 
또 3번역으로도 연결되어있습니다. 이때 가중치(역사이의 거리) 가 없다면 당연히 괜히 1번역을 거쳐서 3번역을 가는것보다 곧바로 0번에서 3번역으로 가는것이 
합리적입니다. 
하지만 가중치(역사이의 거리)를 적용시켜 보겠습니다. 0번역 에서 3번역까지 35분이 걸리고, 0번역에서 1번역 까지 15분, 1번역에서 0번역까지 10분이 걸린다고 
하겠습니다. 
이렇게 가중치를 두면 0번에서 3번역은 35분 , 1번역을 거쳐서 3번역은 25분이 걸립니다. 이러면 0 -> 3 으로 바로가는 간선은 의미가 없기때문에 제외하고 생각할 수 있습니다.

이전시간의 BFS 와 차이점은 BFS 는 모든 간선들의 비용이 똑같았고 오늘의 예시인 가중치가 더해진 그래프에서는 간선마다의 비용이 다릅니다.

가중치 그래프에서 경로를 찾으려면 시작역인 0번 역에서 1번역(15분), 3번역(35분)을 일단 BFS 와 똑같이 일단 발견상태를 인지하도록 등록을 하긴 할 겁니다.
하지먼 발견등록때 가중치도 같이 기록을 할겁니다.

이제 다음 턴에서 뺑뺑이를 돌면서 체크를 할 때 기존에 발견목록 q 를 비웠던것과 마찬가지로 
가중치 그래프에서도 우리가 발견한 목록을 쭉 스캔해 볼겁니다. 그리고 그 중에서 가중치가 가장 낮은, 즉 비용이 가장 적은 간선을 선택하게 됩니다. 
아까 지하철역 예시에서는 1번역이 15분, 3번역이 35분 이므로 1번역을 선택하게 됩니다.
그 다음에 이어서 1번의 인접 정점을 다시 발견하게 될겁니다. 

1번의 인접 정점은 2번(5분), 3번(10분) 이 있다고 하겠습니다. 이때 2번정점의 비용을 게산할때는 그냥 5분이 아니라 시작 정점부터 계산해서 
1번역 비용(15분) + 2번역 비용(5분) = 20분 
이라고 계산이 됩니다. 이렇게 2번 역은 20분이라는 비용을 가지고 있는 정점이라고 발견하게됩니다.
그런데 여기서 흥미로운 사실은 1번과 연결된 또하나의 역 3번역입니다. 3번역은 0번역의 발견 목록에 이미 있었습니다. 
하지만 1번역의 발견 목록에 다시 등장하는데 이때의 3번역의 코스트는 25분 으로 발견하게됩니다.

이때 BFS 와 다르게 무조건 먼저 발견햇다고 그 경로를 따라간다는것이 아니라 이후에 더 빠른 경로를 발견하게 되면 그 경로로 갈 수 있다는 말이 됩니다.
이제 기존의 35분이라는 비용을 가진 0->3번 역 루트를 갱신한다거나 해서 0->1->3 번 역 루트를 다시 발견하게 됩니다.

그래서 이 다익스트라 알고리즘은 BFS와 거의 비슷하긴한데 차이가 생기는 점은 간선마다 동일한 코스트가 아니다 라는 점이고
단순하게 큐 하나를 만들어서 순서대로 예약하는거로는 부족하다는 말입니다. 왜냐면 내가 먼저 발견한 경로가 꼭 실제로 이동해야하는경로는 아니고 
경우에 따라 더 효율적인 경로를 발견할 수 있기 때문에 이런 부분 까지 고려를 해야한다는 말입니다. 


- 코드

이제 이 다익스트라 알고리즘을 코드로 구현하면서 실습을 해보겠습니다. 
내용이 말로 하면 어려워 보이겠는데 한번 이해하고 코드로 적어보면서 익숙해지면 그렇게 어려운 개념이 아니게 될겁니다. 

그리고 다익스트라도 잘 이해한다면 나중에 A* 길찾기 도 자연스럽게 따라온다고 합니다. A*는 우리 강의 마지막으로 개선할 길찾기 알고리즘입니다. 

결국 중요한것은 기초가 되는 BFS를 확실하게 이해하는것입니다. 

코드는 먼저 가중치 그래프를 모델링을 구현해보겠습니다.  

struct Vertex
{
	// int _data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent;	// 인접 행렬

void CreateGraph()
{
	vertices.resize(6);
	adjacent = vector<vector<int>>(6, vector<int>(6, -1));

	// -1, -1, -1, -1, -1, -1
	// -1, -1, -1, -1, -1, -1
	// -1, -1, -1, -1, -1, -1
	// -1, -1, -1, -1, -1, -1
	// -1, -1, -1, -1, -1, -1
	// -1, -1, -1, -1, -1, -1

	adjacent[0][1] = 15;
	adjacent[0][3] = 35;
	adjacent[1][0] = 15;
	adjacent[1][2] = 5;
	adjacent[1][3] = 10;
	adjacent[3][4] = 5;
	adjacent[5][4] = 5;

}

가중치 그래프를 모델링하는 작업은 그래프 처음 배울때도 해봤던 내용일겁니다. 

이제 이 모델링을 탐색할 다익스트라 알고리즘을 만들어 보겠습니다. 

BFS 에서도 처음에 만드는것은 발견목록 이었습니다. 지금까지는 queue 로 발견 목록을 만들어 줬었습니다. 
왜냐면 가중치가 없으니 발견한 순서대로 꺼내 사용하면 되었기 때문인데 

지금 다익스트라에서는 발견한 순서대로 꺼낼것이라는 보장이 없기 때문에 queue 는 사용하지 못합니다. 그래서 list를 사용해서 
발견 목록을 만들어 주겠습니다.

	struct VertexCost
	{
		int vertex;
		int cost;
	};

	list<VertexCost> discovered;	// 발견 목록 

그리고 또 한가지더 추적할 데이터가 있습니다. 현재 발견한 루트중 가장 코스트가 좋은 (여기서는 낮은게 좋습니다.) 값을 추적하는 데이터가 필요합니다. 

	vector<int> best = vector<int>(vertices.size(), INT32_MAX);

이 best 라는 데이터가 왜 필요하냐면 일단 현재 발견한 경로의 코스트를 기록하면서 나중에 발견한 경로의 코스트가 더 좋다면 그 경로와 현재 경로를 비교하기가 
쉬워지기 때문입니다. 

이 추가한 두가지 데이터를 가지고 알고리즘 구현을 시작하겠습니다. 
먼저 BFS 에서도 시작하면서 시작점의 데이터를 먼저 push 하면서 시작했습니다. 그리고 추적하기로 한 데이터가 하나 더 있었습니다. best 인데 이것도 
시작점에서의 값을 같이 넣어줍니다.

	discovered.push_back(VertexCost{here, 0});
	best[here] = 0;

이제 while 문으로 들어갈겁니다. 여기까지 과정이 BFS와 매우 흡사합니다. 그런데 while 문 안에서 가장 처음 하는 단계가 
현재 discovered 에 담긴 발견한 정점의 데이터들을 돌면서 이 중에 가장 cost 가 낮은 값과 그 정점의 이터레이터를 찾습니다. 

	while (discovered.empty() == false)
	{
		// 제일 좋은 후보를 찾는다 
		list<VertexCost>::iterator bestIt;
		int bestCost = INT32_MAX;

		// 이 for문에서는 현재 discovered 중 가장 좋은 코스트를 가진 정점의 이터레이터와 그 코스트를 가져옵니다.
		for (auto it = discovered.begin(); it != discovered.end(); it++)
		{
			const int vertex = it->vertex;
			const int cost = it->cost;

			// 현재 까지 발견한 간선중에 가장 좋은(값이 낮은) 케이스를 갱신한다.
			if (cost < bestCost)
			{
				bestCost = cost;
				bestIt = it;
			}
		}
	}
 
이 while 문에 들어온 discovered 는 반드시 하나 이상의 정점을 가지고 있을겁니다 왜냐면 while 의 조건 자체가 discovered.empty() == false 이기 때문입니다. 
즉 bestIt, bestCost 도 값이 채워져 있을것입니다. 

		// 현재 here 에서 찾은 discovered 중 베스트 코스트와 정점번호를 다시 받습니다. 
		int cost = bestCost;
		here = bestIt->vertex;
		// 왜 erase 하냐면 BFS 때 해당 정점을 방문하면서 pop 하던 부분과 비슷합니다. 
		discovered.erase(bestIt);

찾은 정점과 코스트를 for문 밖에서 다시 받아주고 찾은 최선의 정점을 erase 해주는데 이부분은 BFS 에서 다음 정점을 들르면서 q.pop() 을 하던 부분과 유사합니다.

이제 위의 말대로 erase 를 했으면 방문을 해야 하는데 개론시간에 나온 내용중에 
1번 정점으로 가는 코스트 15 와 3번정점으로 가는 코스트 35를 일단 discovered 에 담아 줬다가 나중에 0->1->3 으로 가는 루트를 발견하고 이 루트가 0->3 루트보다 코스트가 
적다는걸 알게 되면 discovered 에 들어가있는 3번 정점으로 가는 루트를 더 나은걸로 교체 해줘야 합니다. 그러면 discovered 에는 같은 정점에 대해 여러개의 데이터가 들어가 있을
것이고 그렇다면 혹시라도 이전에 이미 더 좋은 루트로 해당 정점을 방문 했을 수도 있습니다. 우리 모델에는 적용 되지 않지만 실제 서비스때에는 그럴 수도 있다는 말입니다.
이 부분을 크로스 체크를 해줘야 합니다. 

		// 방문? 지금 찾은 경로보다 이전 경로의 코스트가 더 좋다? 스킵
		if (best[here] < cost)
			continue;

		// 방문!
		for (int there = 0; there < 6; there++)
		{
			// 연결되지 않았으면 스킵.
			if (adjacent[here][there] == -1)
				continue;
			 
			// 더 좋은 경로를 과거에 찾았으면 스킵.
			int nextCost = best[here] + adjacent[here][there];
			if (nextCost >= best[there])
				continue;

			best[there] = nextCost;

			discovered.push_back(VertexCost({ there, nextCost }));
		}

먼저 한가지 체크를 또 해주고 있는데 무슨 내용이냐면 best[here] 가 cost 보다 작다면 다음으로 넘기는 코드입니다. 
이때 best[here] 는 here 라는 정점까지의 최단거리를 추적해오고 있었습니다. 그리고 cost 는 위의 for문에서 찾은 이전 루프에서 발견한 노드들의 코스트중 가장 
작은 값을 말합니다. 
그런데 best[] 값들은 위에서 아직 추적하지 않은 정점의 크기를 INT32_MAX 로 설정해 놓았기 때문에 처음 발견된 here 는 항상 이 조건을 빠져나갈겁니다. 	
이 조건을 빠져나간다는것은 지금까지 구했던 best 가 최선이었다는걸 보장해주게 됩니다. 지금 모델에서는 갑자기 2번 정점에서 3번 정점으로 이어진다고 하고 그 코스트가 1이라고 하면 
이전 0->1->3 의 경로의 코스트였던 25 보다 0->1->2->3 일때의 코스트가 21 이 되어서 더 짧은 경로가 되기 때문에 이 경로를 선택해서 방문을 하게되지만 아직 discovered 에는 0->1->3 
의 경로가 남아 있습니다. 이 경로는 discovered 중에 코스트가 적은 순서대로 체크를 들어가는데 3번으로가는 best 값보다 크게 나오게되므로 그냥 erase 만 한 상태에서 다음 discovered 
원소로 넘어가게 됩니다. 

다음은 드디어 here 를 방문합니다. here 와 연결된 정점을 adjacent[here][there] 로 찾습니다. 이 값이 -1 이라면 끊겨있다는 의미입니다. 
이어진 다음 정점을 발견했다면 그 가중치를 best[here] 까지의 값에 더해서 다음 there 의 코스트인 nextCost 로 삼습니다. 
이때 다시 체크를 하나 하는데 nextCost가 best[there] 보다 크거나 같다면 continue 가 됩니다. 이 조건에 걸리는 nextCost 는 이전에 찾았던 경로보다 않좋은 경로이기 때문에 
스킵합니다. 
통과한다면 이제는 현재까지 가장 좋은 there 까지의 가장 좋은 경로입니다. best[there] 에 담아주고 또 discovered 에 발견한 there 를 push_back 합니다. 
there 는 adjacent[here] 를 순회 할것입니다. 그래서 here 와 연결된 모든 간선을 체크, 추가 합니다.

이제 최단거리(best[])는 알았는데 그 경로는 모릅니다. 경로를 추적하는 방법은 각 정점들의 부모 parent 를 추적하는 방법이 있었습니다. 
이 코드에도 이제 parent를 추가해줘 보겠습니다. 

	vector<int> parent(6, -1);

int 의 벡터로 parent 를 만들었습니다. 
parent 를 세팅해주는 부분은 맨처음 시작 지점에서와 코드 마지막 부분에 best[there] = nextCost 를 해줄때 같이 해주면 됩니다. 
	// ... 

	discovered.push_back(VertexCost{here, 0});
	best[here] = 0;
	parent[here] = here;

	// ...

	best[there] = nextCost;
	parent[there] = here;

이렇게 해서 가중치가 있는 그래프에서의 최단거리와 최단거리의 경로를 추적할 수 있게 되었습니다. 


사실 이 다익스트라 알고리즘도 BFS 와 비슷한 성질이 있는데 이 알고리즘들이 어떤 목적지를 가지고 최단거리를 구하는게 아니고 
시작 지점부터 가까운 거리에 있는 모든 정점들을 돌아다니는데 가장 빠르게 목적지에 도달한 경우의 parent 와 best 를 가져다 사용하는겁니다. 
이점이 나중에 배울 A* 와 다른점이라고 합니다. A* 는 시작점과 어떤 지정한 목적지를 주고 최대한 그 경로를 가지고 가려고 시도하는반면 
BFS, 다익스트라 는 방향성없이 시작점부터 탐색을 시작한다고 합니다.

그런데 우리가 구현한 다익스트라 코드는 생각보다 느리게 동작할것이라고 합니다. 왜냐면 일단 discovered 가 비었는지 while 로 루프를 돌고 있고 
그 안에서 또 discovered 의 원소중 가장 코스트가 작은 원소를 찾기위해 루프를 또 돌고 있습니다. 
이런 구조일때는 지금처럼 우리가 임의로 정한 6개라는 작은 단위의 모델이 아니라 실제 게임에서사용된다고 하면 훨씬 많은 데이터를 관리하게 되는데 그럴때 동작이 매우 느려질겁니다.

우리가 하고 싶은 길찾기 알고리즘에서 원하는것은 가장 좋은 후보를 찾는것입니다. 일단 먼저 배웠던 컨테이너인 std::list 를 가지고 discovered 를 관리했었지만 
list 가 아니라 좀 더 원하는 기능을 갖춘 자료구조가 있다면 지금처럼 이터레이터로 순환해서 찾는것을 수정 할 수 있을겁니다. 

이런 문제를 해결해줄수 있는 자료구조가 우선순위 큐 라고 합니다. 이름이 우선순위 '큐' 라고 해서 그냥 큐인가? 여기 밀어넣는 순서대로 뽑아서 쓰는건가 할 수 있는데 
그렇지 않고 '우선순위' 큐 라고 우선순위가 있어서 우리가 밀어넣은 데이터 중에서 가장 베스트 케이스하나르 뽑아서 추출할 수 있는 자료구조로써 
지금 하고 있는 다익스트라 알고리즘과 굉장히 잘 맞습니다.

그래서 다음시간부터는 우선순위 큐 를 배워서 다익스트라 알고리즘도 물론이고 이후 배울 A* 에서도 사용하도록 
우선순위 큐 (priority_queue) 자체가 어떻게 동작하는지를 알아보겠습니다. 