

        DFS 깊이 우선 탐색 (Depth First Search)


지난 시간까지 간단하게 그래프에 대해 알아보고 간단하게 구현도 해보았습니다. 
하지만 여기까지만 배우면 그래서 그래프를 어떻게 활용해야 할지 감을 못잡았습니다. 그래서 이번 강의부터 그래프를 활용해서 
탐색하는것을 해보겠습니다.

탐색은 가장 기본적인것인데 어떤 알고리즘에 의해서 자료구조가 가지고 있는 데이터들을 모두 돌아가면서 찾는 것을 말합니다. 
예를 들여 for 문으로 순회를 돌거나 std::find 같은걸 말합니다.

하지만 for, find 같은건 선형 자료구조에서나 쓸만한 방법이고 그래프같은 자료구조에서는 적용하기 애매합니다. 
왜냐면 그래프의 데이터가 많아지고 연결 구조가 복잡해지면 그 모든 경우의 수를 전부 반복해야한다는것이 무겁고 
애초에 그래프의 어느 정점부터 시작해야 하는지 조차 애매합니다. 이전시간에 구현했던 그래프에서는 왠지 0번 정점부터 돌면 될것 같지만 
사실 그냥 그 정점의 인덱스가 0 번이기 때문이지 거꾸로 5번 정점부터 돌아도 전혀 상관이 없습니다. 

그래서 이런저런 이유에 따라 그래프를 탐색하기 위한 크게 두가지 방식이 있습니다. 
    DFS (Depth First Search) 깊이 우선 탐색
    BFS (Breadth First Search) 너비 우선 탐색 

이 두가지 탐색 방법은 중요한 개념들입니다. 면접에서도 자주 나온다고 합니다. 대기업의 면접을 준비한다면 꽤 오랜 시간을 준비해야할 정도로 
광범위합니다.

어쨋든 오늘의 주제인 DFS 가 어떤 방식으로 탐색을 하는지 알아보겠습니다.

- DFS
깊이 우선 탐색은 먼저 탐색하고자 하는 정점들중 어느 점부터 시작한다면 가장 깊은 곳까지 일단 들어가보는 탐색 방법입니다. 

이게 무슨말인지 예시를 들어보겠습니다. 
예를들어 어떤 그래프가 있는데 이 그래프를 던전이라고 해보겠습니다. 0번 정점부터 시작한 용감한 전사가 다음 방을 들어가서 탐색을 마쳤습니다. 
이때 신중한 전사는 다시 뒤로 돌아가서 안가본 방은 없는지 찾아 탐색할 수도 있지만, 용감한 전사는 일단 계속 던전의 안쪽으로 진행을 하는겁니다. 
만약 막다른 길이라면 다시 돌아와서 다른 깊은곳으로 이어지는 방으로 진행하는 식입니다. 

이렇게 들어보면 DFS 방식이 당연한게 아닌가 생각이 들수도 있지만 

BFS 를 예시로 들어보면 BFS 의 신중한 전사는 시작 방으로 부터 가장 가까운 방들을 먼저 탐색합니다. 시작방 부터 1번의 이동으로 갈수 있는 방을 탐색을 마친후 
2번의 이동으로 갈 수 있는 방을 탐색을 전부 마치는 식으로 진행이 됩니다. 

그래서 오늘은 DFS 길이있으면 들어가고 본다 라는 컨샙의 탐색 방법을 공부해볼겁니다. 


- 코드 

이전 시간에 배웠던 그래프를 다시 구현해보겠습니다. 

저번시간에서는 그래프를 만드는 방법에 따라 로컬 구조체를 만들어서 관리했지만 오늘은 전역으로 관리할것입니다. 

그리고 그래프를 만들때 정점들 사이의 연결 관계를 표현하는 방법이 두가지 있었다고 했습니다. 
인접 리스트를 만드는 방식, 인접 행렬을 만드는 방식 이 있었는데 이번에는 먼저 인접 리스트 방식으로 구현해보겠습니다. 

-> 인접 리스트 
    // 전역 변수
    {
    struct Vertex
    {
        // int _data;
    };

    vector<Vertex> vertices;
    vector<vector<int>> adjacent;
    vector<bool> visited;
    }

	vertices.resize(6);
	adjacent = vector<vector<int>>(6);

    adjacent[0].push_back(1);
	adjacent[0].push_back(3);
	adjacent[1].push_back(0);
	adjacent[1].push_back(2);
	adjacent[1].push_back(3);
	adjacent[3].push_back(4);
	adjacent[5].push_back(4);

이렇게 그래프를 일단 만들었으면 오늘의 주제인 DFS 함수? 알고리즘? 을 만들어 주겠습니다. 뭐라고 불러야 하는지 애매하네요 
일단 함수의 형태로 만들겁니다. 

-> DFS
    이 DFS 함수는 인자로 int here 라는 인자를 받을겁니다. 이 here 가 무슨 일을 하냐면 DFS 를 돌리긴 돌릴건데 시작하는 위치가 어디냐를 
    의미한다고 생각하면 되겠습니다. 
    현재위치 = here
    
    오늘의 DFS 는 시작위치부터 안으로 타고 타고 들어가는것이 목적입니다. 그렇다는것은 일단 내가 방문을 했는지 안했는지를 기록을 해둬야 합니다.
    왜냐면 시작점에서 두가지 갈래 노드가 있다고 했을때 한 갈래길을 들리니 한번 들어가니 막다른 길이라면 다시 돌아올겁니다. 
    그리고 방금 갔던 막다른 노드를 들렸는지를 기록하지 않으면 다시 막다른 노드를 들릴것이고 이것을 무한 반복하게 됩니다. 

    노드를 방문 했는지를 기록하기 위해서 새로운 전역 변수를 만들어 줄겁니다. 방문 했는지 않했는지를 표현하려면 bool 타입이 좋을것 같습니다. 
    vector<bool> visited; 라는 변수를 전역에 만들어 줬습니다. 
    그리고 main 함수에서 바로 초기화하는부분을 추가 해줬는데 오늘 테스트하는 그래프의 정점 갯수가 6개이니까 거기에 맞춰서 크기를 맞춰줬습니다. 
    
	visited = vector<bool>(6, false);

    시작할때는 아무곳도 들르지 않았으니까 모두 false 로 초기화 합니다. 

    다시 DFS 함수로 돌아와서 어떤 정점에서 시작 한다고 인자를 준다고 해보겠습니다. 여기서는 일단 임의로 0번 정점부터 시작하겠습니다. 
    그러면 DFS 에서 가장 처음 해야할 일은 방문 했다고 방문 도장을 찍어주는 겁니다. 
    다음은 길이 이어진 방을 타고 들어가서 방문도장 후 다시 안으로 타고 들어가다가 막혔으면 이전 방으로 돌아오는걸 구현해야 합니다. 
    이 것이 구현하기 생각보다 어려울 수 있는데 재귀 함수를 사용하면 가능하다고 합니다. 
    그래서 DFS 는 대부분 재귀를 사용한다고 합니다. 

    DFS 에서 무엇을 할지 일단 말로 적어보면 here 에 인접한 방들의 개수 만큼 반복을 하면서 각각 들러 줄겁니다. 
    그리고 방의 번호가 무엇인지 받아서 그 방을 방문 했는지 안했는지 체크를 한다음 방문 하지 않았다면 방문합니다. 
    코드로는 이렇습니다. 
    
    void Dfs(int here)
    {
        // 방문!
        visited[here] = true;
        
        // 인접 리스트 버전
        // 모든 인접 정점을 순회한다 
        for (int i = 0; i < adjacent[here].size(); i++)
        {
            // 방문할 방 there
            int there = adjacent[here][i];

            // 방문했는지 체크 후 방문하지 않았으면 방문 
            if (visited[there] == false)
                Dfs(there);
        }
    }

    재귀에 익숙하지 않아서 이 함수가 어떤 의미인지 잘 와 닿지 않는데 한번 해석해보면 
    방문하자 마자 방문도장을 쾅!

    here 의 인접한 방들 (adjacent[here]) 을 돌아 다닐겁니다. 개수(size()) 만큼 반복,
    순서대로 방문할 방의 번호를 가져옵니다. (adjacent[here][i]) 
    그 방을 방문했는지 체크 후 안했다면 방문

    이렇게 해서 우리가 만든 그래프를 이 Dfs 함수로 탐색한다면 아래와 같은 과정일겁니다. 
    - Dfs(0)
    --Dfs(1)
    ---Dfs(2)
    ---Dfs(3)
    ----Dfs(4)
    --Dfs(3) 위에서 먼저 방문 했기 때문에 방문하지 않음 

    Dfs 에 어디를 들럿는지를 확인할 수 있도록 
	cout << "Visited : " << here << endl;
    코드를 추가하고 실행 해보면 위의 예상대로 방문 한다는것을 알 수 있습니다. 

    하지만 지금 처럼 Dfs(0) 으로 실행하면 따로 동떨어진 5 번 정점은 방문 할 수 없습니다. 이런 경우 때문에 또 한겹 래핑을 해야 합니다. 

        
    void DfsAll()
    {
        for (int i = 0; i < 6; i++)
            if (visited[i] == false)
                Dfs(i);
    }

    이러면 Dfs(0) 이 탐색이 끝난다음 다른 정점들도 한번씩 들르면서 방문했는지를 체크해줄 수 있습니다.


인접 리스트로 만든 그래프를 DFS 탐색해봤는데 그래프를 만드는 방법중에 인접 행렬을 이용한 방법도 있었습니다. 
이 버전도 한번 실습 해보겠습니다. 

-> 인접 행렬 
    // 인접 행렬
	adjacent = vector<vector<int>>
	{
		{ 0, 1, 0, 1, 0, 0},
		{ 1, 0, 1, 1, 0, 0},
		{ 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 1, 0},
		{ 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 1, 0},
	};

    // 인접 행렬 버전
	for (int there = 0; there < 6; there++)
	{
		if (adjacent[here][there] == 0)
			continue;

		if (visited[there] == false)
			Dfs(there);
	}

    인접 리스트 방식과 알고리즘 자체는 동일합니다. 하지만 adjacent 에 데이터를 어떻게 읽을것인가가 차이점일겁니다. 



- 정리 
인접 리스트 방식, 인접 행렬 방식의 그래프의 구조를 이해해야하고 
깊이 우선 탐색을 실행할때 재귀적 방법이 자주 사용됨을 안다. 


