

        Big O 표기법


이번 시간은 자료구조 알고리즘에서 빈번하게 사용되는 Big O 표기법에 대한 내용입니다. 

우선 어떤 알고리즘 A, B 두가지가 있다고 해보겠습니다. 이 두 알고리즘은 같은 문제를 해결하기 위해 도입하려고 하는 알고리즘의 후보들입니다. 
그러면 A,B 어떤 알고리즘을 채택할지는 당연히 성능, 속도 일겁니다. 그런데 이 성능이라는것이 그냥 저 알고리즘 보다 '조금' 빨라요, '많이' 빨라요 
이런식으로 비교하는것은 그 기준이 애매모호 합니다. 
그러면 애매모호한 단어 말고 직접 실행해보고 더 빠른쪽을 채택하면 어떨까 해서 직접 실행해보는 방법을 써보면 알고리즘을 실행하는 컴퓨터는 
사람마다 그 상태와 성능이 다를것이기 때문에 객관적인 비교는 어려울겁니다.
또 어찌 저찌 해서 비교를 해서 A 알고리즘이 B 알고리즘보다 더 빠르거나 비슷한 효율을 보여줬습니다. 그런데 이때 넣은 인풋 데이터의 양이 아주 적은양이었었고 
다음 실험때 훨씬 많은 양의 인풋 데이터를 넣어 보니 A 알고리즘이 B 알고리즘보다 느리게 나올 수 도 있는겁니다. 그리고 이 인풋의 양은 
어느정도가 적절한 양인지도 모릅니다. 

이런 알고리즘 사이의 성능비교를 하기위해서 데이터 양에 따라 표현할수 있는 표기법이 Big O 표기법입니다. 

빅 오 표기법의 설명에 들어가겠습니다. 

  - 빅 오 표기법 1 단계 : 대략적인 계산 
  수행되는 연산 (산술, 비교, 대입 등) 의 개수를 '대략적으로' 판단 
  ex)
  
  int Add(int n)
  {
        return n + n;
  }
  이런 정말 간단한 함수 add 의 연산의 수는 1 이라는 것을 알 수 있습니다. 

  int Add2(int n)
  {
        int sum = 0;

        for(int i = 0; i < n; i++)
                sum += i;

        return sum;
  }
  이 Add2 함수는 인자 n 의 팩토리얼을 구하는 함수입니다. 이 때 0 번부터 n 의 크기까지 한번씩 연산을 하기 때문에 이때 연산의 수는 n + 1 입니다.

  int Add3(int n)
  {
        int sum = 0;

        for(int i = 0; i < n; i++)
                for(int j = 0; j < n; j++)
                        sum += 1;
        
        return sum;
  }
  이번 Add3 함수에서는 2중 for 문을 돌면서 sum 에 1 씩을 더해주고 있습니다. 이러면 n² + 1 의 연산 수 가 됩니다.


  - 빅 오 표기법 2 단계 : 대장만 남긴다 
  규칙 1 ) 영향력이 가장 큰 대표 항목만 남기고 삭제
  규칙 2 ) 상수 무시 (ex. 2N -> N)

  int Add4 (int n)
  {
        int sum = 0;

        for(int i = 0; i < n; i++)
                sum += i;
        
        for(int i = 0; i < 2 * n; i++)
                for(int j = 0; j < 2 * n; j++)
                        sum += 1;
        sum += 1234567;

        return sum;
  }
  이 함수 Add4 에서는 Add 1,2,3 의 내용이 전부 섞엿습니다. 위 함수의 연산 수를 구해보면 
  = O(N + 1 + 4*N² + 1)  //이라는 연산수를 가집니다. 여기서 규칙 1을 적용시켜보면 아래와 같습니다. 
  = O(4*N²)     // 이제 규칙 2 산수를 무시한다를 적용 시키겠습니다. 
  = O(N²)
  최종적으로 이 함수는 N² 의 시간 복잡도를 따른다 라고 표현합니다. 
  // O 를 "Big O" 라고 읽을 수도 있고 "Order Of" 라고 읽기도 합니다.

가장 영향력이 큰 부분만 보는것이냐 상수를 때고 생각하는것은 프로그램에서 데이터를 처리할때 엄청난 수의 데이터를 처리하게 되면 제곱 같은 
연산에 비해 그냥 더하기나 상수의 곱은 큰 의미를 가지지 못하기때문입니다. 
물론 같은 시간복잡도를 가지는 알고리즘 끼리 비교했을때 둘 사이의 성능이 차이가 생길 수도 있지만 
일단 거시적인 관점에서 같은 시간 복잡도를 가졌다고 표현하는것이라고 합니다. 


그러면 이렇게 나름 복잡한 빅 오 표기법을 통해 어떤 의미를 가질 수 있는지 의의를 살펴보겠습니다. 

  - Big O 표기법의 의의
  
  1) 상수 : 먼저 상수값의 시간 복잡도를 가지는 알고리즘은 인풋이 얼마나 많아지건간에 상수의 시간만 걸리기 때문에 가장 빠릅니다. 
  2) O(log n) :그 다음은 log n 의 시간 복잡도입니다. 이 경우는 완만한 곡선을 그리면서 증가 하고 있습니다.
  3) O(n) : 인풋의 양과 시간이 정비례로 늘어납니다. 
  4) O(n log n) : 시간 복잡도가 인풋이 늘 수록 가파르게 늘어나지만 제곱 보다는 완만합니다. 
  5) O(n²) : 가장 가파른 경사를 가지고 있습니다. 

  위의 내용들은 입력 N 의 크기에 따라 성능이 영향을 받는 정도를 나타냅니다.

  컴퓨터의 성능에 따라 다르겠지만 예를 들어 각 시간 복잡도와 인풋에 따라 아래와 같은 시간이 걸린다고 해보겠습니다. 

인풋    lon N     N    N log N      N²
10만  0.017ns   10ns    1.67ms     10sec

이런 그래프가 있다고 했을 때 MMORPG 에서 몬스터의 수가 10만이라거나 유저의 수가 10만일 경우도 있을겁니다. 
그럴때 우리 게임의 어떤 기능의 프로그램의 시간복잡도가 N² 이라면 어떤 기능을 실행 했을때 10 초나 기다려야 한다는 말입니다. 

그래서 실전에서 N² 의 시간 복잡도까지 가면 그 알고리즘은 현실성이 없고 사용하면 안된다는 의미입니다. 
N log N 은 그나마 어느정도 사용가능하다고 할 수 있기는 하지만 너무 자주 사용하면 안될겁니다. 대표적으로 Sorting 알고리즘들이 N log N 의 시간복잡도를 따른다고 합니다. 


/* 번외 Log 함수 
너무 오랜만에 보는 로그 함수입니다. 정말 간단히 복습하고 넘어가겠습니다. 
제곱이라는 개념을 알고 있습니다. 
2¹ = 2 = 2
2² = 2*2 = 4
2³ = 2*2*2 = 8 
이런 개념이었습니다.

이럴때 어떤 수 a 를 몇번 제곱하면 b 라는 값이 나오는지를 알고 싶습니다. 이것을 
? = loga(b)
라고 표현합니다. 

그런데 거시적인 관점에서 a 의 자리에 있는 수는 큰 영향이 없습니다. 그래서 시간 복잡도에서는 a 자리를 생략하고 사용합니다.
수학에서는 a 자리가 생략되었다면 10 이라고 생각하면됩니다.
알고리즘에서는 대부분의 경우 밑이 2 일것입니다. 
*/

log n 이라는 시간 복잡도가 왜 빠른 속도를 가지는지를 알아보겠습니다. 이진 트리라는 알고리즘같은데서 알 수 있는데 반 씩 쪼개 가면서 찾아나가는 알고리즘입니다. 

예를 들어서 업다운 게임을 한다고 해보겠습니다. 상대방이 1 에서 100 사이의 수 하나를 생각하고 있을때 그 값을 질문자가 어떤 수냐고 물으면 대답자는 그 생각한 수가 
물어본 수보다 작으면 다운, 크다면 업 이라고 말하고 생각한 수와 물어본 수가 일치 한다면 게임이 끝납니다. 

가장 단순하게 접근한다면 1 부터 100 까지 하나씩 물어보는 방법이 있을겁니다. 이러면 최악의 경우일때 100 번의 트라이가 있을겁니다. 
즉, N의 시간 복잡도를 가집니다. 

대부분은 중간에 있는 숫자를 찍어서 물어볼겁니다. 그러면 대답자가 업이나 다운 혹은 정답이라고 알려줄겁니다. 업이나 다운일 경우 첫번째 질문으로 대답의 나머지 부분의 
선택지는 전부 경우의 수에서 제외됩니다. 그리고 그 다음에도 남은 수의 중간을 찍는다면 그 안에서 또 절반의 경우의 수가 덜어집니다. 
이것을 수식으로 생각해보면 전체 범위가 N 일때 한번 물어볼때 마다 N/2 가 되는데 몇번 물어보면 결국 값이 1이 될것이냐를 구하는겁니다.

N / 2의 ? 제곱 = 1      // 이걸 다시 전개 합니다. 
N = 2 의 ? 제곱         // 이 형태는 위에서 봤던 log 함수의 식입니다.

이제부터 log n 이라는 걸 보면 뿌듯해져야 합니다. 반씩 줄여나가면서 데이터가 많아도 빨리 찾아낼 수 있겠구나 하고 

파트 2 에서 보았던 트리구조에서 무언가를 찾아가는 법에서도 적용이 되는데 루트 노드에서 어느쪽에 있는지 하나씩 골라 가면서 경우의 수를 줄여나가면 
업다운 게임과 비슷하게 시간이 걸린다고 할 수 있을겁니다.