

        환경 설정 

이번 파트에서는 콘솔에서 여러 테스트를 하면서 알고리즘과 자료구조를 알아 볼겁니다. 

VS 에서 새 프로젝트 만들기를 하고 콘솔 앱 템플릿을 선택합니다. 경로는 제 프로젝트 경로로 설정하고 프로젝트 이름은 Algorithm 이라는 이름으로 해주었습니다. 

프로젝트 생성이 되면 콘솔에 Hello World 를 출력해주는 Main 함수가 생성됩니다.
이 Algorithm 프로젝트에서는 자료구조 알고리즘을 테스트 해주는 용도로 사용할 것이고 이 프로젝트 말고 별도로 하나 더 프로젝트를 만들어줄것입니다. 

Maze 라는 이름으로 새 콘솔 앱 프로젝트를 만들어 줄건데 여기서는 배운 알고리즘 자료구조를 적용해서 미로를 통과하는 프로그램을 테스트 할 때 사용할겁니다. 
그리고 Maze 프로젝트를 '우클릭->시작 프로젝트로 설정' 을 해줘서 일단은 Maze 부터 테스트를 해주겠습니다.

첫시간에는 간단하게 미로를 만들어 보는 실습을 해볼겁니다.
필터 정리부터 할것인데 기본으로 만들어져 있느 필터들중 헤더 필터와 리소스 필터를 삭제하고 
Maze , Board 필터를 새로 만들었습니다. 그리고 Maze.cpp 는 Maze 필터에 위치하였습니다. 

처음 만들어줄 클래스의 이름은 ConsoleHelper 입니다. 우리가 미로를 콘솔에 그려줄건데 그 콘솔을 도와줄 헬퍼 클래스입니다. 

-> pch 클래스 
    그리고 Maze 에서 미리 컴파일된 헤더를 겸사 겸사 만들어 줬습니다. 미리 컴파일된 헤더는 이 프로젝트의 공용 헤더같은 느낌으로 사용됩니다. 
    'Maze 프로젝트 우클릭 -> 속성 -> C/C++ 란 화살표 -> 미리 컴파일된 헤더 란 -> 미리 컴파일된 헤더 사용으로 변경, 헤더 이름은 pch.h 로'
    이제 프로젝트에 pch 클래스를 추가 해주고 Maze 필터로 옮겨줬습니다. 

    다음은 만들어진 pch.cpp 와 pch.h 파일 중 
    'pch.cpp 를 우클릭 -> 속성 -> 미리 컴파일된 헤더 -> 만들기로 변경'
    이렇게 하면 미리 컴파일된 헤더가 적용 됩니다. 

    // pch.h 에 앞으로 사용할 기본 헤더들을 추가했습니다. 
    #pragma once

    #include <Windows.h>
    #include <iostream>
    #include <vector>
    using namespace std;

    그리고 여기에 많이 사용할 정수 타입들을 선언해 줄 수도 있습니다. 

    using int8		= __int8;
    using int16		= __int16;
    using int32		= __int32;
    using int64		= __int64;
    using uint8		= unsigned __int8;
    using uint16	= unsigned __int16;
    using uint32	= unsigned __int32;
    using uint64	= unsigned __int64;

    이런 타입 선언을 pch.h 에 선언 해주는 방법도 있고 아니면 따로 Types.h 라는 헤더 파일을 만들어서 타입 선언들을 모두 모아주는 방법도 있습니다.

    이번 파트에서는 타입 선언을 따로 빼주는 방식으로 하겠습니다. 이 타입이 필요한 클래스에서는 Types.h 를 include 하면 될겁니다. 
    그런데 이 Types.h 를 pch.h 추가해주면 왠만한 클래스들에 다 적용이 될겁니다. 
    이때 Types 헤더는 "" 큰 따옴표로 작성해야 include 됩니다. 대부분 <>은 기본 탑재 헤더, "" 는 개인적으로 추가한 헤더에 사용됩니다.

-> ConsoleHelper 클래스 
    ConsoleHelper 클래스는 실질적으로 맵을 그리는 역할을 할 것입니다. 그래서 Board 필터 아래로 이동 시켜주었습니다. 
    Board 필터에 올 클래스들이 우리의 미로의 맵을 그려줄 총체적인 역할을 할겁니다.

    맨 처음 추가해줄 코드는 Console 에서 사용될 색들을 enum class 로 관리해줄겁니다. 이때 지정하는 숫자들은 임의로 정하는것이 아니라 
    나중에 추가될 라이브러리의 정책을 따르고 있습니다. 

    #include <Windows.h>

    enum class ConsoleColor
    {
        BLACK = 0,
        RED = FOREGROUND_RED,
        GREEN = FOREGROUND_GREEN,
        BLUE = FOREGROUND_BLUE,
        YELLOW = RED | GREEN,
        WHITE = RED | GREEN | BLUE,
    };

    그리고 ConsoleHelper 클래스 안에 새로 3가지 함수를 만들어 줄겁니다. 인자로 x,y 좌표를 받아서 해당 위치에 커서가 위치하도록 하는 함수, 
    커서의 색을 세팅하는 함수, 커서를 보여줄지 안 보여줄지 플래그로 세팅하는 함수 
    
    // ConsoleHelper.h 선언부
    class ConsoleHelper
    {
    public: // static 을 붙여야 전역함수처럼 사용가능합니다. 
        static void SetCursorPosition(int x, int y);
        static void SetCursorColor(ConsoleColor color);
        static void ShowConsoleCursor(bool flag);
    };


    // ConsoleHelper.cpp 정의부 (pch.h 를 꼭 include 해줘야 합니다.)
    
    void ConsoleHelper::SetCursorPosition(int x, int y)
    {
        HANDLE output = ::GetStdHandle(STD_OUTPUT_HANDLE);
        COORD pos = { static_cast<SHORT>(x), static_cast<SHORT>(y) };
        ::SetConsoleCursorPosition(output, pos);
    }
    여기서 사용되는 타입들과 메소드들은 윈도우 API 와 관련되어있습니다. 일단은 이렇게 하면 SetCursorPosition 의 인자로 넣어준 위치에 커서가 존재하게됩니다.
    
    void ConsoleHelper::SetCursorColor(ConsoleColor color)
    {
        HANDLE output = ::GetStdHandle(STD_OUTPUT_HANDLE);
        ::SetConsoleTextAttribute(output, static_cast<int16>(color));
    }
    컬러를 세팅하는 함수에서는 아까와 같이 output 핸들을 가져와서 SetConsoleTextAttribute 라는 함수에 int16 타입으로 캐스팅한 color 인자를 같이 넘겨주면 된다고 합니다. 
    
    void ConsoleHelper::ShowConsoleCursor(bool flag)
    {
        HANDLE output = ::GetStdHandle(STD_OUTPUT_HANDLE);
        CONSOLE_CURSOR_INFO cursorInfo;
        ::GetConsoleCursorInfo(output, &cursorInfo);
        cursorInfo.bVisible = flag;
        ::SetConsoleCursorInfo(output, &cursorInfo);
    }
    커서를 보여줄지를 세팅하는 함수에서는 아웃풋 핸들을 똑같이 가져오고 콘솔 커서 인포 라는 타입의 변수에 현재 커서의 정보를 가져온다음 
    그중 bVisible 이라는 값을 인자인 flag 로 바꿔준다음 다시 Set 함수로 세팅해주고 있습니다. 

    이 위의 3가지 함수들은 생소한 윈도우즈 API 로 만들어져 있습니다. 
    생소해서 괜히 전부 외우고 가야 하나 생각이 들 수 있는데 절대 그렇지 않고 지금 한번 입력하고 대충 이런 내용이 있구나 하고 넘어가면 됩니다. 
    필요할때 이 부분만 찾아서 코드를 가져다 쓰면되는 부분입니다. 

ConsoleHelper 는 이번에는 이정도만 하고 Maze.cpp 로 돌아가서 작업 해보겠습니다.

-> Maze 클래스 
    먼저 게임이 무엇인지 한번 생각을 해보겠습니다. 대부분의 게임 (거의 100%) 은 코드에서 while(true) 의 무한 루프 안에서 돌아갑니다.
    그래서 유저가 게임을 끌 때 까지 무한 뺑뺑이를 돌면서 실행이 됩니다.
    이 뺑뺑이 안에서 크게 3가지 단계를 거치게 됩니다. 입력, 로직 ,렌더링 단계들인데 
    입력 단계에서는 말그대로 입력을 받습니다. 키보드나 마우스같은 입력 기기로 부터 입력을 받는걸 말합니다. 
    로직 단계는 게임 로직 플레이어를 움직인다거나 몬스터의 ai 를 실행한다거나 하는 부분이고 
    렌더링 단계는 그렇게 입력받고 계산된 게임세상을 모니터에 그려주는 단계입니다.

    이 3 단계가 무한 루프를 돌면서 프레임마다 업데이트 되면서 실행될겁니다.

    온라인 게임의 경우에는 일부 로직이 서버쪽에서 계산이 되면서 돌아가게 될것이지만 기본적인 게임의 구조는 이렇다고 할 수 있습니다.

    그리고 또 프로그램이 루프를 도는 시간을 가지고 초당 프레임을 관리해 줄 수도 있습니다. 
    while 문 밖에서 라스트 틱이라는 uint64 변수를 만들고 루프안에서 현재의 틱수를 가져오는 메소드를 가져옵니다.
    그리고 현재 틱에서 라스트 틱을 빼주면 한 프레임의 틱을 얻을 수 있습니다. 그리고 다음 프레임을 위해 라스트 틱을 현재틱의 값으로 업데이트합니다. 

	uint64 lastTick = 0;
	
	while (true) 
	{
    #pragma region 프레임 관리 
		uint64 currentTick = ::GetTickCount64();
		uint64 deltaTick = currentTick - lastTick;
		lastTick = currentTick;
    #pragma endregion
		// 입력

		// 로직

		// 렌더링

    이게 기본적인 프레임 관리라고 할 수 있습니다. 

    이때 이 게임을 고정프레임으로 갈지 가변프레임으로 갈지를 정해줄 수 있는데 
    프레임은 위의 while 문이 1초동안 몇번이나 루프를 돌것인지를 말하겠죠 

    요즘 게임같은 경우에는 컴퓨터의 성능에 따라 그냥 상한을 풀어줘서 200 프레임 정도까지 올라가는걸 볼 수 있는데 
    그럴 때는 별도의 제한 없이 계속 while 을 통과시켜주는겁니다.

    만약 고정프레임을 걸고 싶다면 중간에 if(deltaTick < 제한) 일때 continue 를 때려주는겁니다. 
    우리 프로젝트에서는 일단 이런 제한 없이 그냥 풀어주겠습니다.

    다음의 입력, 로직, 렌더링 단계는 프레임 제한과 상관없이 실행될겁니다. 

    이번에 테스트로 무언가 그려보겠습니다. 아까 만든 ConsoleHelper 클래스로 어떤 일을 하면될 것같습니다. 

    #include "ConsoleHelper"

    // unicode-table.com/kr/ 에서 가져왔습니다. 검색어:U+25A0
    const char* TILE = "■";

    ConsoleHelper::SetCursorPosition(0, 0);
    ConsoleHelper::ShowConsoleCursor(false);
    ConsoleHelper::SetCursorColor(ConsoleColor::RED);

    for (int32 y = 0; y < 25; y++)
    {
        for (int32 x = 0; x < 25; x++)
        {
            cout << TILE;
        }

        cout << endl;
    }

    기본 적으로 가로 25 , 세로 25 의 빨간색 타일을 콘솔창에 그려주는 코드입니다. 
    ConsoleHelper 의 메소드들 SetCursorPosition, ShowConsoleCursor, SetCursorColor 등을 static 함수로 만들어서 따로 ConsoleHelper 객체를 만들지 않아도 
    사용할 수 있게 만들었고 각 역할은 이름에서 보이듯이 SetConsolePosition에서는 커서의 위치를 0,0  콘솔 맨 왼쪽위로 위치시킨다음 
    ShowConsoleCursor 에서 값을 false 로 주어서 커서가 깜빡거리지 않게 만들었고 SetCursorColor 에서 색을 빨간색으로 설정 

    그리고 unicode-table.com 에서 가져온 TILE 을 2중 for 문으로 가로 25 개를 깔고 다음 줄로 가기 를 반복해서 
    25*25 의 빨간 타일들을 만들었습니다. 
    

