

        BFS를 활요한 길찾기 


길찾기에 활용된다던 너비 우선 탐색을 이제 우리 Maze 프로젝트에 적용해보는 실습을 해보겠습니다. 

지난번에 어디까지 만들었었는지를 복습 부터 해보겠습니다. 실컷 이론만 배우고 오니까 살짝 까먹었네요 

맵은 25 * 25 크기로 만들었고 미로 생성 알고리즘은 이진 트리 알고리즘으로 만들었었고 
맵에서 지나갈 수 없는 타일은 빨간색으로 Wall, 지나갈 수 있는 타일은 초록색으로 Empty, 길을 찾고 있는 주체 플레이어는 파란색으로 Player, 
출구는 노란색으로 별다른 타일 타입은 정하지 않고 색만 칠해 줬습니다. 

그리고 플레이어가 길을 찾는 방법은 우수법으로 길을 찾아주고 있었다가 
동적배열, 연결리스트, 스택, 큐 를 배운 다음 우수법의 단점이었던 막다른 길도 전부 들렀다 오는 것을 
스택을 가지고 수정해주었습니다. 


이번시간에는 이제 BFS 를 도입해서 출구 까지 최단 거리를 구해보는 작업을 할것입니다. 
지금 미로 특성상 길이 여러갈래로 갈리는게 아니라서 우수법으로도 최단거리로 가고 있는것이긴 합니다. 
하지만 나중에 미로를 더욱 복잡하게 만들수 있게된다면 우수법 만으로는 길을 찾더라도 최단거리라는 보장이 없고 
순환 구조를 만나면 우수법은 길을 못찾기도 합니다. 

반면 오늘의 주인공인 BFS 를 도입하면 최단거리라는것이 보장이 됩니다. 


- BFS 복습 
BFS 는 너비 우선 탐색 Breadth First Search 라는 의미로 
시작 지점부터 가까운 거리의 정점을 먼저 탐색하는 알고리즘이었습니다. 

그리고 BFS 를 실습할때 그래프를 만들면서 정점 Vertex 라는 구조체와 정점들 사이의 연결관계(adjacent)를 인접 리스트 혹은 인접 행렬의 방식으로 구현해서 
실습하였었습니다. 그리고 탐색을 했었는지를 따로 기록하기도 하였습니다. 

그런데 경우에 따라서 vertex 건 adjacent 건 아예 만들 필요도 없고 기존에 있던 정보로 유추를 할 수도 있습니다. 
이게 무슨 말이냐면 우리가 만든 맵의 크기가 있고 각각 타일의 기능이 있습니다. 
이때 각 타일들을 정점이라고 해보겠습니다. 그러면 따로 정점과 인접정보를 만들어 준 적은 없지만 맵의 데이터를 가지고 그래프로 표현할 수 있습니다. 
미로가 있고 한 타일에서 상하좌우로 연결이 되있을 수도 있게 그러니까 어떤 초록타일의 상하좌우중 위쪽은 빨간 타일이 있다고 하면 인접하지 않다, 
오른쪽으로 초록색이 이어진다면 현재 타일과 인접하다라고 표현할 수 있을겁니다. 

그러면 이 상황에서 우리가 만든 미로에서 BFS 를 돌려주면 BFS의 특성상 시작점을 기준으로 가까운 정점을 기준으로 탐색할겁니다. 
발견하는 순서에 차이는 있을 수 있겠지만 탐색하는 순서는 가까운 순서로 하게 됩니다. 그것이 큐를 활용한 특징이었죠
결과적으로 모든 통로를 들리면서 BFS 를 완료하게됩니다. 그러면 목적지를 기준으로 각 타일의 parent 를 타고가면서 경로를 그릴수 있게 될겁니다.
목적지가 가장 먼저 탐색되는 순간의 parent 정보들을 쫒아 올라가면 그것이 최단경로일것이라는걸 알 수 있습니다. 


이 내용을 가지고 이번시간의 실습을 해볼겁니다. 

- 실습 

먼저 코드에서 우리가 길찾기 알고리즘을 넣어놨던 부분이 Player 였습니다. 현재는 우수법 코드가 적혀있는데 이 코드를 그냥 날리기에는 아까우니까 
따로 함수로 빼서 보관 해두겠습니다.

-> Bfs 함수 
        BFS 탐색도 시작은 오른손 법칙과 비슷할겁니다. _pos 를 함수 로컬 변수 Pos pos로 받는 부분, 출구를 Pos dest 에 _board->GetExitPos() 를 받아주는
        부분등
	// 똑같이 가져올 부분
        Pos pos = _pos;

	// 목적지에 도착할때 까지 계속 실행 되어야 함
	Pos dest = _board->GetExitPos();

	// 앞의 방향을 방향의 크기만큼의 Pos 배열로 만듭니다.
	Pos front[DIR_COUNT] =
	{
		Pos { -1 , 0 },		// Up
		Pos { 0 , -1 },		// Left
		Pos { 1 , 0 },		// Down
		Pos { 0 , 1 },		// Right
	};

        // BFS 먼저 구현한 다음 path 를 구할것
	_path.clear();
	_path.push_back(pos);

	
	이제 본격적으로 BFS 를 구현할것인데 이때 필요했던 데이터가 무었이있었는지 생각해보면 
	각 정점들의 크기만큼 그곳을 탐색했었는지 여부를 기록하던 bool 타입 vector가 있었습니다. 

	const int32 size = _board->GetSize();	// board 클래스에 간단하게 _size를 반환하는 함수를 추가해줍니다. 
	vector<vector<bool>> discovered(size, vector<bool>(size, false));

	discovered 를 만드는 코드를보면 약간 햇갈릴 수도 있는데 이전 시간의 vector<Vertex>(6) 짜리 가 아니라 
	우리는 맵을 이차벡터로 만들었으니 discovered 도 이차벡터로 만들어야 합니다. 

	그리고 또 필요햇던게 큐(queue) 를 만들어서 거기에 탐색할 방들을 담았었습니다. 
	여기 Bfs 함수에도 큐를 만드려니 아직 헤더가 추가되지 않은것 같습니다. 
	// pch.h 
	{
	#include <queue>
	#include <map>
	맵은 나중에 필요할것 같다고 겸사겸사 추가해주었습니다.
	} 

	BFS 에 사요할 큐는 이렇게 만들었습니다. 
	
	queue<Pos> q;

	이전 실습때는 int 타입을 담도록 만들었었는데 이번에는 Pos 입니다. 이전 실습때는 각 정점을 인덱스 번호로 관리하고 구별했어서 int 로 만들었었는데 
	아무튼 각 정점들을 구별 할수 있으면 됩니다. Pos 는 각 타일의 좌표를 직접 들고 있을것이고 
	이게 아니라 int 로 인덱스로 구별하고 싶으면 board 에 각 타일에 인덱스를 붙히는 과정을 추가하고 그것을 가지고 큐에 넣어줘도 됩니다. 
	지금 실습에서는 좀 더 직관적인 좌표값을 넣어주겠습니다. 

	이다음은 BFS 시간에 실습했던 내용과 거의 같습니다. 먼저 코드를 보겠습니다. 
	
	queue<Pos> q;

	// BFS 의 시작할때 탐색 시작지점
	q.push(pos);
	discovered[pos.y][pos.x] = true;

	while (q.empty() == false)
	{
		pos = q.front();
		q.pop();

		// 방문! 
		
		// 목적지라면 break
		if (pos == dest)
			break;

		// 위,왼쪽,아래,오른쪽 의 방향각각 을 체크 
		for (int32 dir = 0; dir < 4; dir++)
		{	
			Pos nextPos = pos + front[dir];
			
			// nextPos 가 갈수 있는 타일인지?
			if (CanGo(nextPos) == false)
				continue;

			// nextPos 가 갈 수 있다면 이미 탐색했던 타일인지?
			if (discovered[nextPos.y][nextPos.x])
				continue;

			q.push(nextPos);
			discovered[nextPos.y][nextPos.x] = true;
		}

	}
	BFS 실습과 거의 똑같은 과정인데 다른점은 중간에 pos == dest 인지를 체크해서 출구에 도달했는지를 확인하는 부분과 
	adjacent 라고 정점이 어디와 연결되어 있는지를 관리하던 부분이 우리 미로 맵의 특징상 상하좌우 로 4방향을 확인해주면 되는점입니다. 
	이때 이전에 만들었던 CanGo 함수를 다시 사용해서 간편하게 구현 할 수 있었습니다. 

	여기까지는 이제 pos 가 입구 부터 출구까지 이동을 한것이고 우리의 목표는 여기서 구한 최단거리를 추출하는것입니다. 
	그러기 위해서는 또 다른 데이터를 추적해줘야 합니다. 
	타일들을 탐색해 나가면서 자신의 부모 타일을 추적한다면 출구까지 도달한 시점의 플레이어의 부모타일들을 쭉 수집해 나가면 그것이 최단 경로가 될겁니다. 

	parent 를 만드는 방법은 BFS 실습때 했던듯이 vector에 push 해주는 방법이 있을것이고 
	// vector<vector<Pos>> parent;

	아니면 아까 Pch.h 에 queue 를 추가하면서 같이 추가 했던 map 을 활용하는 방법이 있다고 합니다. 
	
	/*
	map 이 무엇이었는지 까먹은 김에 복습을 해보겠습니다. 
	map은 key 와 value가 짝지어진 데이터가 하나의 단위로 되어 있는 STL 컨테이너입니다. 
	데이터를 찾을때는 key 로 찾을 수 있고 하나의 map 안에 중복된 key가 있을 수 없습니다. 
	*/

	그러면 map 으로 만든 parent 는 이런 식입니다. 
	// parent[A] = B; A는 B로 인해 발견함
	map<Pos, Pos> parent;

	이제 이 parent 는 BFS 에서 실습 했던것 처럼 사용하면 됩니다. 

	처음 탐색을 시작하는 장소 입구의 parent 는 자기자신이라고 설정해주고 자신 위치에서 사방의 타일을 체크해서 갈 수 있는 타일을 
	q에 push 해주는 순간 그 nextPos 의 parent 를 pos 라고 설정 해주겠습니다. 

	map<Pos, Pos> parent;

	queue<Pos> q;

	q.push(pos);
	discovered[pos.y][pos.x] = true;
	parent[pos] = pos;		// 자기자신이 부모

	while (q.empty() == false)
	{
		pos = q.front();
		q.pop();

		// 방문! 
		
		// 목적지라면 break
		if (pos == dest)
			break;

		// 위,왼쪽,아래,오른쪽 의 방향각각 을 체크 
		for (int32 dir = 0; dir < 4; dir++)
		{	
			Pos nextPos = pos + front[dir];
			
			// nextPos 가 갈수 있는 타일인지?
			if (CanGo(nextPos) == false)
				continue;

			// nextPos 가 갈 수 있다면 이미 탐색했던 타일인지?
			if (discovered[nextPos.y][nextPos.x])
				continue;

			q.push(nextPos);
			discovered[nextPos.y][nextPos.x] = true;
			parent[nextPos] = pos;	// 발견한 다음 타일의 부모는 나 
		}

	}

	이 코드를 거쳐서 pos 가 dest 에 도달해 루프를 빠져나왔다면
	그때 parent 의 데이터를 가지고 경로 _path 를 재조립해주면 됩니다. 
	
	_path.clear();

	// 거꾸로 거슬러 올라간다

	pos = dest;

	while (true)
	{
		_path.push_back(pos);

		// 부모와 자신이 같다면 시작점이다
		if (pos == parent[pos])
			break;

		pos = parent[pos];
	}

	// 거꾸로 거슬러 올라간걸 다시 뒤집는다.
	std::reverse(_path.begin(), _path.end());

	혹시 잉여 데이터가 남지않도록 _path 를 clear 해주고 시작합니다. 
	우리의 전략은 출구 dest 부터 부모를 거꾸로 거슬러 올라가는겁니다. 

	출구부터 시작해서 _path 에 push_back 해준 다음 pos 자신과 부모 pos 가 같은지 체크하는데 이 조건에 해당하는 타일은 입구 밖에 없으므로 
	지금 입구 타일인지 물어보는겁니다. 입구라면 break 로 루프를 깹니다.

	아니라면 자신의 위치 pos 를 부모의 pos 로 교체해서 한칸씩 거슬러 올라갑니다. 

	이 루프가 끝나면 출구부터 입국까지의 최단경로가 _path에 담기는데 이것을 뒤집어 주기 위해 
	std::reverse 를 해줍니다. 


	일단 여기까지 하고 잘 되었는지 빌드를 해주니 에러메세지가 뜹니다.

	< 연산자가 오버로딩 되지 않아서 생기는 에러입니다. 

	bool operator<(const Pos& other) const
	{
		if (y != other.y)
			return y < other.y;
		return x < other.x;
	}

	이런 연산자 오버로드를 Pch 에서 만들었던 struct Pos 에 추가해주었습니다. 

이제 빌드후 실행 해보면 BFS 로 구한 최단경로를 따라 탈출하는 플레이어를 볼 수 있었습니다. 


- 추가적인 내용
BFS 로 최단경로를 구하는 실습을 해봤는데 이 방법에서는 탐색을 시작할때 목적지를 딱 찍고 가는것이 아닌 시작점부터 가까운 곳부터 전부 들리다 보니까 
출구에 도착했다는 컨샙입니다.
그렇다 보니까 경로를 구하는 도중의 코드에서는 미로의 막다른 길이든 뭐든 일단 가까우면 모두 들르면서 갑니다.
결과는 최단거리가 구해지지만 계산되는 과정에서는 낭비가 있을수 있다는 말입니다. 

또 한가지 아쉬운점은플레이어가 진행을 할 때 상하좌우 뿐만이 아니라 대각선 방향으로도 움직여야 한다면 문제가 생깁니다. 
상하좌우로 움직이는 비용을 1이라고 했을때 대각선은 1은 아니고 1.4 정도 의 비용이 들건데 우리가 구현한 BFS 에서는 이런 이동의 가중치를 둘 수 없다는점이 
아쉽습니다.
그래서 이 부분을 보완해주는 다익스트라 알고리즘에 대해 다음 시간에서 알아볼것입니다. 