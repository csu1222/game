

        맵 만들기


이전시간 환경설정을 하면서 맛보기로 맵을 한번 만들어 보았었습니다. 

그런데 그때는 Maze 프로젝트 Main 클래스에 직접 만들었었는데 계속 그런식으로 코드를 늘리다 보면 가독성이 심하게 떨어질겁니다. 

당연히 맵을 그려주는 코드도 별도의 클래스로 관리해주는게 합리적일겁니다. 그렇기 때문에 Board 프로젝트에 새로 클래스를 만들어 줄건데 
이름은 Board 말 그대로 우리 맵을 그려줄거라는 뜻 입니다. 

-> Pch.h
    이후로 사용하게될 구조체같은 것들을 추가해주겠습니다. 
    먼저 포지션정보를 표현할 구조체입니다.
    
    struct Pos
    {
        bool operator==(Pos& other)
        {
            return y == other.y && x == other.x;
        }

        bool operator!=(Pos& other)
        {
            return !(*this == other);
        }

        Pos operator+(Pos& other)
        {
            Pos ret;
            ret.y = y + other.y;
            ret.x = x + other.x;

            return ret;
        }

        Pos operator+=(Pos& other)
        {
            y += other.y;
            x += other.x;

            return *this;
        }

        int32 y = 0;
        int32 x = 0;
    };

    위치정보를 표현하는 Pos 객체들을 만들 수 있도록 했고 Pos 끼리 ==, !=, +, += 등의 연산이 가능하도록 오퍼레이터 오버라이드도 했습니다. 
    현재는 이정도만 추가했지만 나중에 다른 오퍼레이터가 필요해지면 그때마다 추가해주겠습니다.

    그리고 어디로 움직이는지 방향을 관리하는 enum 도 하나 만들어 줄겁니다. 
    
    enum Dir
    {
        DIR_UP = 0,
        DIR_LEFT = 1,
        DIR_DOWN = 2,
        DIR_RIGHT = 3,

        DIR_COUNT = 4,
    };

    이때 방향순서를 위 부터 반시계방향으로 정한것도 나중에 이유가 나온다고 합니다. 
    마지막에는 방향의 갯수 정보를 추가해줬는데 나중에 반복문을 사용할때 편리할것입니다. 

    지금 만든 내용들을 나중에 따로 별도의 클래스로 빼줘도 되는데 그건 나중에 내용이 많아지거나 했을때 해주는걸로 하고 지금은 일단 Pch 에 넣어주겠습니다.

이제 Board 클래스에서 맵을 만드는 부분을 이전해주겠습니다. 

-> Board 클래스
    먼저 보드의 최대 크기를 enum 으로 관리해줍니다. 그리고 타일 타입이란걸 만들어줄겁니다. 
        
    enum
    {
        BOARD_MAX_SIZE = 100,
    };

    enum class TileType
    {
        NONE = 0,
        EMPTY,
        WALL,
    };

    보드 사이즈는 최대 100 * 100 으로 제한을 한것이고 TileType 이라는 enum class 는 말 그대로 타일의 타입을 관리합니다. 
    타일 타입은 해당 타일이 플레이어가 지나갈수 있는 비어있는(empty) 타일인지, 아니면 벽(wall)이라서 지나갈 수 없는 타일인지를 나타냅니다. 
    지금은 벽과 길 밖에 없지만 제대로된 게임에서는 타일의 종류가 더 많을겁니다. 함정일수도 있고 물일수도 있고 워프포탈 일수도 있습니다. 

    본겨적으로 Board 클래스를 만들어 볼겁니다. 
    헤더의 선언부는 아래와 같습니다. 
    
    class Board
    {
    public:
        Board();
        ~Board();

        void Init(int32 size);
        void Render();

    private:
        TileType _tile[BOARD_MAX_SIZE][BOARD_MAX_SIZE];
        int32 _size = 0;
    }; 

    사용할지 않할지 모르지만 일단 생성자와 소멸자를 만들었고 다음으로 멤버 변수로 _tile 을 만들었습니다. 각 원소를 TileType 으로 들고있는 2중 배열입니다. 
    가로 세로 BOARD_MAX_SIZE 로 설정이 되었는데 항상 이 최대 크기의 보드를 사용하는것은 아니고 이 최대크기의 타일에서 필요한 만큼을 맵으로 그려줄겁니다. 

    그러면 필요한 만큼을 관리해줄 int32 _size 멤버 변수도 필요할겁니다. 

    멤버 함수는 사이즈를 인자로 받아서 초기화 해줄 Init 함수, 초기화된 데이터들을 가지고 콘솔에 맵을 그려줄 Render 함수입니다. 

    다음으로 해줄일은 이전 환경설정시간에 만들었던 임시 맵 코드들을 싹 긁어서 Board::Render 함수 안으로 옮겨줬습니다.
        
    void Board::Render()
    {
        ConsoleHelper::SetCursorPosition(0, 0);
        ConsoleHelper::ShowConsoleCursor(false);
        ConsoleHelper::SetCursorColor(ConsoleColor::RED);

        for (int32 y = 0; y < 25; y++)
        {
            for (int32 x = 0; x < 25; x++)
            {
                cout << TILE;
            }

            cout << endl;
        }
    }

    TILE 은 Board.cpp 의 전역 변수로 빼줬습니다. 

    여기까지 한 다음은 이제 Init 함수를 보겠습니다. 인자로 사이즈를 받아주고 있었는데 그 값을 멤버 변수 _size 에 담아주는게 먼저 할 일 일것입니다.
    그리고 나서 그 사이즈를 가지고 맵을 만들어 주는 부분이 추가 되야하는데 그 기능을 다른 멤버 함수 GenerateMap 으로 빼주겠습니다.

    그러면 GenerateMap 의 내용을 채워주겠습니다. 그런데 맵을 만드는것도 어떤 알고리즘을 따라서 만들어 질겁니다. 
    이번 시간은 첫시간이니 만큼 간단하게 가겠습니다. 외곽만 벽으로 치고 안의 부분은 이동할 수 있는 길로 만들어 주겠습니다. 
    
    void Board::GenerateMap()
    {
        for (int32 y = 0; y < _size; y++)
        {
            for (int32 x = 0; x < _size; x++)
            {
                if (x == 0 || x == _size - 1 || y == 0 || y == _size - 1)
                    _tile[y][x] = TileType::WALL;
                else
                    _tile[y][x] = TileType::EMPTY;
            }
        }
    }
    맵을 그릴때 2중 for 문을 도는것은 똑같습니다. 그런데 그 안에서 조건문을 추가 하였는데 x, y 좌표 둘 중 하나가 0 이거나 _size - 1(맵의 끝) 이라면 
    TileType::WALL 로 아니라면 TileType::EMPTY 로 설정을 해주었습니다. 

    간단한 2중 for문 입니다. 

    이제 이렇게 만든 맵 정보를 가지고 Render 해주면 될것 같습니다. 지금 Render 내용은 현재 타일의 타입이 무엇이던지간에 빨간색으로 그려주고 있습니다. 
    지금부터는 벽이라면 빨간색, 갈수 있는 타일이라면 초록색으로 표현해주겠습니다. 

    이런 내용을 그냥 직접 넣어줄 수도 있지만 나중에 쓰기 편하게 하기위해 역시 따로 멤버 함수로 빼주겠습니다. 

    새로 두개의 멤버 함수가 추가될건데요 좌표 Pos에 있는 타일의 타입이 무엇인지 가져오는 함수와 좌표에 있는 타일의 색을 가져오는? 설정하는 함수를 추가 하겠습니다. 

    먼저 타일의 타입을 가져오는 함수부터 보겠습니다. 
    
    TileType Board::GetTileType(Pos pos)
    {
        if (pos.x < 0 || pos.x > _size)
            return TileType::NONE;

        if (pos.y < 0 || pos.y > _size)
            return TileType::NONE;

        return _tile[pos.y][pos.x];
    }
    범위 체크부터 합니다. 입력받은 Pos 의 좌표가 0 부터 _size 까지 사이의 값인지를 체크하고 그 이내라면 Init 함수에서 만들었던 _tile 의 
    Pos 좌표 위치의 타일 타입 값을 리턴 합니다.

    그리고 타일 타입에 따라 색을 지정해주는 함수입니다.
    
    ConsoleColor Board::GetTileColor(Pos pos)
    {
        TileType tileType = GetTileType(pos);

        switch (tileType)
        {
        case TileType::EMPTY:
            return ConsoleColor::GREEN;
        case TileType::WALL:
            return ConsoleColor::RED;
        }

        return ConsoleColor::WHITE;
    }

    아까 만들었던 GetTileType 을 가지고 인자 pos의 타일 타입을 가져옵니다. 그 타입에 따라 switch case 문으로 EMPTY 라면 초록색, WALL 이라면 빨간색으로 설정합니다.
    이 두가지 경우에 안걸리고 switch case 문을 빠져나온다면 하얀색으로 설정해줍니다. 

    여기 까지 만들면 ConsoleColor 가 무엇인지 에러가 날겁니다. 헤더에서도 ConsoleColor 가 무엇인지 모르고 있을건데 
    Board.h 에 include "ConsoleHelper.h" 를 추가해 주면 됩니다.

    이제 이렇게 만든 헬퍼 함수들을 Render 에 적용해보겠습니다. 해야할 일은 2중 for 문을 돌면서 타일을 그려줄때 해당 위치의 Pos를 가지고 GetTileColor 로 
    컬러 정보를 변수에 받아서 ConsoleHelper::SetCursorColor 에 넘겨주면 됩니다. 
    그려줄 맵의 크기를 이전에는 25 라고 하드코딩했었는데 Init 에서 설정해준 _size 크기로 만들어지도록 해줬습니다.
    // 해당 부분의 코드 
    for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			ConsoleColor color = GetTileColor(Pos{ y, x });
			ConsoleHelper::SetCursorColor(color);
			cout << TILE;
		}

		cout << endl;
	}

    이러면 이전시간에 모든 타일의 색을 빨간색으로 설정해 줬던 코드를 지워줘도 되겠습니다.

렌더링 부분을 Maze안에 전부 넣지 않고 따로 Board 클래스로 빼주는 작업이었습니다. 
이제 다시 Maze 클래스에 적용시켜보겠습니다. 

-> Maze 클래스 
    Board 객체를 동적할당 해도 되지만 이번에는 그냥 Maze 안에서 전역 객체로 생성해주겠습니다. 
    #include "pch.h"
    #include <iostream>
    #include "ConsoleHelper.h"
    #include "Board.h"

    Board board;

    int main()
    {
        board.Init(25);

        uint64 lastTick = 0;
        
        while (true) 
        {
    #pragma region 프레임 관리 
            uint64 currentTick = ::GetTickCount64();
            uint64 deltaTick = currentTick - lastTick;
            lastTick = currentTick;
    #pragma endregion
            // 입력

            // 로직

            // 렌더링
            board.Render();
        }
    }


실행해보면 의도한대로 겉의 타일은 빨간색이고 안의 타일은 초록색인 맵이 출력됩니다. 

그런데 우리가 만들고 싶은 것은 미로입니다. 미로를 만드는 방법으로 우리가 손으로 일일히 타일마다 타입을 지정해주면서 만드는 방법도 있겠지만 
좀 더 스마트하게 알아서 랜덤한 미로가 만들어지도록 하고 싶습니다.

그것을 위해 새로운 알고리즘을 배워보겠습니다. 
알고리즘의 이름은 Binary Tree 미로 생성 알고리즘 이라고 합니다. 
Maze for Programers 라는 미로 만드는 방법들을 소개하는 책에서 나온 방법이라고 합니다. 그 중 맨 처음에 나오는 방법들중 하나입니다. 

첫 단계로 일단 x % 2 == 0 || y % 2 == 0 일때 타일 타입을 벽으로 인지하도록 해보겠습니다. 
그러면 격자무늬로 빨간 타일이 그려진 맵이 출력됩니다.

이 상태에서 격자 안의 초록색 타일들이 있을건데 그 초록색 타일들을 순회하면서 랜덤으로 오른쪽의 타일을 뚫어 줄건지 아래쪽 타일을 뚫어줄건지 
50% 확률로 정해줄겁니다. 매우 간단하지만 생각보다 그럴듯하게 미로가 그려진다고 합니다.

-> Maze 클래스 
    우선 랜덤값을 사용하기위해 랜덤 시드 값을 Main 함수에 만들어줬습니다. 
    
	::srand(static_cast<unsigned>(time(nullptr)));
	
-> Board::GenerateMap 메소드 
    랜덤 시드를 가지고 Binary Tree 미로 만들기를 적용했습니다. 
    void Board::GenerateMap()
    {
        // 1단계에서 해줬던 격자무늬 만들기 코드 생략 

        // 랜덤으로 초록색 점으로 부터 왼쪽 혹은 아래쪽을 뚫어주는 알고리즘
        for (int32 y = 0; y < _size; y++)
        {
            for (int32 x = 0; x < _size; x++)
            {
                if (x % 2 == 0 || y % 2 == 0)   // 격자중 빨간색인 부분의 경우 continue 로 통과 
                    continue;
                const int32 randValue = ::rand() % 2;   // 랜던 값을 2의 나머지로 받아옵니다. 

                if (randValue == 0) 
                {
                    _tile[y][x + 1] = TileType::EMPTY;  // 랜덤 값이 0이라면 오른쪽 타일을 뚫습니다. 
                }
                else
                {
                    _tile[y + 1][x] = TileType::EMPTY;  // 랜던 값이 1이라면 아래쪽 타일을 뚫습니다. 
                }
            }
        }
    }

이렇게 해서 한번 실행해보면 꽤 그럴듯한 미로가 생성이 됩니다. 
그런데 이 결과물에서 최외각 타일들이 듬성 듬성 뚫려 있습니다. 이러면 안되고 외곽은 벽으로 둘러 쌓여있어야 하기때문에 
최외각에서 바로 뒤의 타일에서는 x 축에서는 오른쪽으로만 뚫어주고 y 축으로는 아래로만 뚫어주도록 해주겠습니다. 

-> Board::GenerateMap 메소드 
    // 생략 
    if (x % 2 == 0 || y % 2 == 0)
				continue;

    if (y == _size - 2)
    {
        _tile[y][x + 1] = TileType::EMPTY;
        continue;
    }
    
    if (x == _size - 2)
    {
        _tile[y + 1][x] = TileType::EMPTY;
        continue;
    }

    const int32 randValue = ::rand() % 2;
    // 생략 

이 코드를 실행해보면 대부분의 외곽이 막혀있고 가장 왼쪽 아래에서 하나 위쪽 타일만 뚫려있습니다.

지금 배운 이진 트리 미로만들기 알고리즘의 단점? 아쉬운점은 미로의 맨 오른쪽과 아래쪽 통로가 쭉 뚫려있다는 점과 최초에 x, y 좌표가 2로 나눈 나머지가 0 인곳을 
벽으로 만드는 부분 때문에 미로의 전체 사이즈가 홀수로 되어 있어야 합니다. 
이런 점만 빼면 쉽게 미로를 랜덤하게 만들 수 있는 알고리즘 이었습니다. 

이제 마지막으로 예외 하나만 더 넣어서 맵의 구멍을 막아 주겠습니다. 
위의 조건문들중에서 
    if (x % 2 == 0 || y % 2 == 0)
				continue;
    다음에 예외를 추가해줄겁니다. 
    y 좌표와 x 좌표 모두 통로의 끝이라면 그냥 continue 를 합니다. 

    if ( y == _size - 2 && x == _size - 2)
        continue;

이제 미로의 맵에 구멍이 매워졌습니다. 

첫 미로 알고리즘을 만들었습니다. 그러면 이제 더 해볼것은 만든 미로를 대상으로 길 찾기 알고리즘을 실행해보겠습니다.


길 찾기라는 기능을 구현하기 위해서 먼저 필요한 요소들이 무엇일지 생각해 보았습니다. 길이라는것은 입구와 출구가 있어야 할겁니다. 그리고 두 점은 갈 수 있는 
통로여야 합니다. 우리가 구현한 이진 트리 미로에서는 거의 모든 타일이 통로일지 벽일지는 50 퍼센트 확률입니다. 확실히 통로일거라고 정해진 곳은 
맵의 (2, 2) 좌표의 통로 입구와 (24, 24) 의 둘러싼 벽 직전의 타일입니다. 그래서 이 두점을 입구와 출구라고 보겠습니다. 

다음은 이제 길을 찾을 주체인 플레이어라는 개념이 있어야할겁니다. 
입구, 출구, 플레이어 세가지 개념이 추가되겠습니다. 

입구 출구는 Board 클래스에서 만들어 줍니다. 

-> Board 클래스 
        
	Pos				GetEnterPos() { return Pos{ 1, 1 }; };
	Pos				GetExitPos() { return Pos{ _size - 2, _size - 2 }; };

    이런 멤버 함수를 추가 해줬습니다. 
    이것을 활용해서 출구에 해당하는 타일의 색을 바꿔서 알아보기 쉽게 해주겠습니다. 

    타일의 색을 그려주는것은 Render 였지만, 그 타일 색의 정보를 세팅해주는 함수는 GetTileColor 메소드 였습니다. 
    여기서 현재 체크하고 있는 타일의 좌표 Pos 가 GetExitPos 와 같다면 파란색으로 설정해주는 코드를 추가해주었습니다. 

다음은 미로에서 길찾기를 하는 주체인 플레이어를 새로운 클래스로 추가 해주겠습니다. 
클래스는 Board 필터 아래에 생성해주겠습니다.

-> Player 클래스 
    플레이어가 가지고 있어야 할 정보가 무엇일지 생각해보았습니다. 플레이어는 일단 자신의 위치 정보 Pos 를 들고 있어야 할겁니다. 그리고 어디로 갈것인지 
    Dir 도 가지고 있을겁니다. 또 한가지로 플레이어 자신이 위치하고 있는 보드를 포인터로 가지고 있게끔 하겠습니다. 

    먼저 보드를 들고 있을것이기 때문에 Board 클래스를 전방선언해줍니다. 
        
    private:
        Pos			_pos = {};
        int32		_dir = Dir::DIR_UP;
        Board*		_board = nullptr;

    이제 플레이어의 메소드는 무엇이 있을지 생각해보면 먼저 초기화 함수가 있어야 할건데 초기화할때 플레이어는 자신이 있을 보드를 인자로 받아서 멤버 변수
    _board 에 세팅해줄것입니다. 
    그리고 프로그램의 매 프레임마다 플레이어가 움직이도록 해줄건데 플레이어를 업데이트 해줄 메소드가 필요할것이고 인자는 매 프레임의 시간인 deltaTick 을 받아주겠습니다. 
    위의 함수들을 도와줄 헬프 함수들이 필요한데 플레이어의 포지션을 세팅해줄 함수는 인자로 Pos 를 받아서 _pos 에 세팅해줄것이고 
    반대로 플레이어의 포지션을 꺼내주는 함수도 필요합니다. 일단은 여기까지 선언부를 만들겟습니다. 
    public:
        void		Init(Board* board);
        void		Update(int32 deltaTick);

        void		SetPos(Pos pos) { _pos = pos; };
        Pos			Getpos() { return _pos; };
    
    일단 Init 함수의 정의부를 일부분 만들어 줄겁니다. 
    제일 먼저 Player.cpp 에 Board 클래스를 추가 해주고 Board::GetEnterPos 으로 플레이어의 첫 위치를 맵의 입구에 위치시켜줍니다. 
    그리고 _board 에도 연결시킨 Board 를 담아줍니다. 
    #include "Board.h"

    void Player::Init(Board* board)
    {
        _pos = board->GetEnterPos();
        _board = board;
    }

    일단은 여기까지만 하고 나서 이제 보드에서도 플레이어를 인식하고 플레이어를 맵에서 다른 색으로 표현해주는 부분을 추가해주겠습니다. 

->  Board 클래스 
    // Board.h  변경점
    
    class Player;

    class Board
    {
    public:
        void			Init(int32 size, Player* player);
    private:
        Player*			_player = nullptr;
    };

    보드에서도 플레이어를 들고 있을것이기 때문에 먼저 전방선언을 해주었고 보드의 초기화 함수에서 플레이어를 포인터로 받아서 플레이어와 보드가 서로를 
    들고 있게끔 해주었습니다. 멤버 변수로도 저장하도록 _player 도 추가 했습니다. 

    // Board.cpp 변경점
        
    #include "Player.h"
    void Board::Init(int32 size, Player* player)
    {
        _player = player;
    }
    Init의 정의부에서 인자로 받은 플레이어를 멤버 변수에 저장합니다. 이후 GenerateMap 으로 맵을 만드는 코드가 실행되고 
    그리고 Maze의 렌더링 부분에서 보드의 Render가 실행되는데 여기서 플레이어의 위치를 다른 색으로 표현하려고 합니다. 그 메소드는 GetTileColor 입니다. 
    ConsoleColor Board::GetTileColor(Pos pos)
    {
        if (_player && _player->Getpos() == pos)
            return ConsoleColor::YELLOW;

    _player 가 nullptr 이 아니고 _player 의 위치가 현재 체크하고 있는 타일의 위치와 같다면 그 타이의 색을 노란색으로 설정합니다.

플레이어 추가 마지막 단계로 실제 프로그램이 실행되는 Maze 클래스에 추가해주겠습니다. 

-> Maze 클래스 
    여기서는 먼저 Player 클래스를 추가 하고 Board 객체와 마찬가지로 그냥 전역 객체로 Player 도 만들어 준다음 
    board 객체의 Init 함수에 player 객체의 포인터를 넘겨주고 반대로 player 객체의 Init 에도 board 포인터를 넘겨주겠습니다. 
    // 변경점 
    #include "Player.h"
    Player player;
    int main()
    {
        board.Init(25, &player);
        player.Init(&board);

    그리고 이번시간에는 Player::Update 까지는 구현하지 않을 것이긴 한데 Maze의 로직 부분에 플레이어 업데이트 메소드에 델타틱을 넘겨줘서 플레이어가 
    길찾기 로직이 실행되도록 하면될겁니다. 
    // 변경점

    // 로직
    player.Update(deltaTick);

여기까지가 이번 강의에서 구현할 내용들입니다. 이제 프로그램을 실행해보면 미로를 만들었고 그 위에 벽은 빨간색, 통로는 초록색, 출구는 파란색, 플레이어는 노란색 
타일로 출력됩니다. 

이진 트리 알고리즘을 통해 랜덤 미로의 기초적인 방법을 학습했습니다. 