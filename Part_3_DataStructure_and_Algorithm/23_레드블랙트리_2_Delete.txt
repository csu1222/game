

        레드 블랙 트리 2 Delete

    
지난시간 Insert 에 이어서 Delete 를 알아보겠습니다.

삽입 Insert 는 찬찬히 내용을 따라 가다 보면 그나마 이해하기 편했었습니다. 반면 Delete 는 이전에도 말했듯이 Insert 보다 이해하기 어려운 내용입니다.

그런데 이 Delete 를 달달 외워서 면접에서 물어보면 쫙 설명 할 수 있어야 하고 그런 내용은 아니라고 합니다.
어쩌다가 한번 만들어 보는 정도라고 하는데 
그러니까 어렵더라도 겁먹지 말고 이해하려 도전해보겠습니다. 


- Binary Search Tree :: Delete 복습 
시작하기에 앞서 BST에서의 삭제를 복습해보겠습니다.
레드 블랙 트리에서 삭제를 할때도 가장 먼저 단계는 일반적인 BST 에서 삭제하는것과 똑같이 동작합니다.
그러니까 노드를 삭제하는 것 까지는 똑같은데 그 다음 레드노드, 블랙노드 와 같이 색상을 수정하는 부분에서 차이가 생깁니다. 

예를 들 모델은 아래와 같습니다. 

         [10]
    [5]        [20]
      [8]    [15] [30]

BST 에서 삭제를 할때의 케이스가 몇가지 있었습니다. 

case 1) 삭제할 노드의 자식이 아예 없는 경우
-> 위의 모델에서 [8]을 예시로 들겠습니다. 이때가 가장 쉬운 케이스 였는데 [8] 의 부모인 [5] 의 right 를 끊어 준 다음 [8] 을 날려주면 끝났습니다. 
         [10]
    [5]        [20]
             [15] [30]

case 2) 삭제할 노드가 자식이 1개 있는경우 
-> [5] 를 삭제한다고 할 때의 경우입니다. 
   아까와 달리 자식이 하나 있기 때문에 그냥 툭 잘라 버릴 수는 없고 [5] 의 자리에 [8] 이 대체를 하게 됩니다. 
         [10]
    [8]        [20]
             [15] [30]

case 3) 삭제할 노드가 양옆으로 2개 있는경우 
-> [10] 을 삭제할때의 경우입니다.
   이 경우에는 삭제할 노드의 다음 노드 Next 노드를 구해서 그 노드를 삭제할 노드에 복사하고 Next 를 삭제하는 방법을 사용했습니다. 
         [15]
    [5]        [20]
      [8]         [30]

아까 말했듯이 BST 에서의 삭제 과정이 레드 블랙 트리의 삭제 과정의 기본이 됩니다.


- 레드 블랙 트리 복습

레드 블랙 트리는 5가지 조건을 만족해야 했습니다. 

1) 노드는 레드 혹은 블랙 이라는 색상을 가진다.
2) 루트 노드는 항상 블랙 노드이다.
3) Leaf(NIL) 노드는 항상 블랙 노드이다.
4) 레드 노드의 자식은 항상 블랙 노드여야한다. (레드 노드가 연달아 나올수 없음)
5) 어떤 노드로 부터 그에 속한 하위 리프 노드까지의 경로에서 는 모두 같은 수의 블랙 노드를 거쳐야 한다. 

이중에 1,2,3,4 도 물론 중요하지만 삭제를 할때는 5번 조건이 큰 역할을 합니다. 

이제 본격적으로 레드 블랙 트리의 삭제를 알아 볼텐데 반복해서 말하지만 일반적인 BST 의 삭제 과정을 레드 블랙 트리에서도 똑같이 거칩니다.
거기에 더해서 또 케이스 들이 나뉘게 되는데 
         [10(B)]
    [5(B)]        [20(R)]
  [n]  [8(R)]  [15(B)] [30(B)]
      [n] [n]  [n] [n] [n] [n] 
이 모델에서 [8]을 삭제한다고 하겠습니다. BST 에서 [8] 은 그냥 자식이 없는 노드이기 때문에 자신만 달랑 삭제 하면 됐었습니다.
그런데 이제 레드 블랙 트리에서 는 삭제할 노드의 색상도 고려해야 합니다. 

case 1) 삭제할 노드가 Red 인 경우 
    - 이 경우가 가장 쉬운 케이스입니다. 삭제할 노드가 자식도 없고 색상도 레드라면 그냥 삭제를 하면됩니다. 
    완전히 BST 와 다를 바가 없는 케이스 입니다. 
         [10(B)]
    [5(B)]        [20(R)]
  [n]  [n]    [15(B)] [30(B)]
              [n] [n] [n] [n] 
case 2) 삭제할 노드가 Black 인 경우 
    - 그러면 이번에는 삭제할 노드가 블랙일때 입니다. 이 때 부터 복잡해 지기 시작합니다.
    아까와 같이 그냥 BST 같이 삭제해버리면 아래와 같은 모양이 될겁니다.
           [10(B)]
    [5(B)]        [20(R)]
  [n]  [8(R)]    [n]   [30(B)]
      [n] [n]          [n] [n] 
    이렇게 되면 안되는 것이 레드 블랙 트리의 5번 조건인 어떤 노드로부터 그에 속하는 하위 리프노드까지의 모든 경로에 같은 수의 블랙 노드가 있어야합니다. 
    그런데 이 상황이 되면 [20] 의 left 로 가는 경로가 블랙 노드가 하나 부족합니다. 이것은 레드 블랙 트리의 특성을 만족하지 못하게 됩니다.

    그래서 레드 블랙 트리의 삭제 기능에는 BST 의 노드 삭제까지는 그대로 따라 가지만 이 후 5번 조건을 위반하는 부분을 어떻게든 보완하는 작업이 추가 되어야 합니다.

    이 상황을 어떻게든 대처하기위해서 [20] 의 left 에 있는 _nil 노드에 블랙이 두개 붙어있다고 가정을 해보겠습니다. 
    이 상태를 더블블랙이라고 하는데 그냥 이상태에서 끝낼 수는 없습니다. 하나의 노드는 레드이든 블랙이든 둘중 하나여야지 블랙을 두개 들고 있을수는 없습니다.
    하지만 그럼에도 불구하고 20의 n이 더블블랙이라고 가정을 할것인데 이 블랙노드를 폭탄돌리기를 하듯이 어떻게든 누군가에게 떠 넘겨서 
    레드 블랙 트리의 모든 조건에 만족하는 상태로 만드는게 오늘의 최종 목표입니다. 
           [10(B)]
    [5(B)]        [20(R)]
  [n]  [8(R)]  [n(BB)] [30(B)]
      [n] [n]          [n] [n] 
    
    생각보다 복잡한 문제입니다. 만약 더블블랙인 nil 노드에서 블랙 폭탄을 일단 위쪽으로 떠넘겼다고 하겠습니다. 그러면 [20]이 블랙폭탄을 받습니다. 
    지금은 우연히도 [20] 이 레드 노드 였지만 만약 상위 노드도 블랙 노드였다면 또 더블블랙상태가 되고 그때는 다시 상위 노드로 폭탄을 돌려야합니다.
    
그래서 쉽게 쉽게 처리할 수 있는 방법은 없고 다양한 상황에 대한 공식들이 있어서 그것에 맞춰서 트리를 이동하고 회전을하고 블랙 노드 폭탄을 이동하고 
하는 작업을 해줘야 합니다. 

이때 발생하는 상황이 크게 6 가지가 있다고 합니다. 
지금부터 배울 모든 상황을 외우고 있을 필요는없고 가볍게 알아보고 혹시 나중에 이 레드 블랙 트리를 사용할일이 생겼을때 그때 다시 복습하면서 차근차근 
만들어 보는 방향으로 가야 합니다. 

이제부터 노드를 삭제해서 5번 조건을 만족하기위해 더블블랙 이 이리저리 옮겨 다니게 되는데 
그 여섯가지 케이스 중 가장 쉬운 케이스 둘 부터 보겠습니다.

case 1) 삭제할 노드가 빨간색이었다.
- 이 상황은 위에서 말했던 상황입니다. 삭제할 노드가 레드 노드 였다면 5번조건에 영향이 가지 않기 때문에 BST 처럼 그냥 노드를 삭제해주면 끝입니다. 

case 2) 더블블랙을 이리저리 옮기다 보니 루트 노드가 더블블랙이 되었다는 케이스입니다. 
- 이때는 블랙 폭탄을 그냥 제거해도 상관이 없어 집니다. 왜냐면 5번 조건이 어떤 노드에서건 리프 노드까지 가는 모든경로에 블랙 노드의 갯수가 같아야 하는데
  루트 노드가 더블블랙이다 라는것은 루트 노드부터의 모든경로에 영향을 미치기 때문에 상관이 없어집니다. 어떤 서브 트리에는 더블블랙이 영향을 미치고 
  어떤 서브 트리에서는 영향을 안미치고 하는것이 문제였지 모든 경로에 영향을 미친다는것은 모든경로에 영향이 없다는 말과 같습니다. 
  즉, Root 가 DB = 추가 Black 삭제! 끝!
  (이때 드는 생각이 그럼면 추가 블랙을 곧바로 루트로 올려보내고 삭제하면 되는것이 아닐까 생각이 드는데 당연히 그렇게는 안되고 세밀한 알고리즘을 거쳐야 한다고 합니다.)

/*
다음 케이스를 알아보기 전에 먼저 레드 블랙 트리 삭제 알고리즘에 자주 등장할 용어부터 알아보고 넘어 가겠습니다. 
형제 (Sibling) 이라고 하는데 
Insert 알고리즘에서는 삼촌 (uncle) 이라는 개념이 등장했던것과 비슷하게 삼촌은 자신의 부모와 같은 조부모를 두고 있는 노드 즉, 부모의 형제 노드를 가리켰습니다. 
여기서 알 수 있듯이 형제(Sibling) 은 자신과 같은 부모를 가지고 있는 노드를 뜻합니다. 
*/

case 3) 더블블랙(DB) 인 노드의 형제가 레드 노드인 상황 
- 이 상황에서는 총 해주는 작업이 3가지인데 먼저 형제노드(s) 와 부모노드(p) 의 색상을 서로 교환합니다.(s = black, p = red 로)
  그리고 DB 방향으로 Ratate(p) 를 합니다. 여기까지 진행되면 DB 의 s 가 블랙 노드가 되고 그러면 거기에 맞는 케이스로 가게 됩니다.
  (case 3 같은 상태에서 문제를 해결하기가 어렵기 때문에 다른 케이스로 유도하는겁니다. InsertFixup 에서도 트라이앵글 케이스 일때 리스트 케이스로 변경하기 위해 도입한 Rotate 
  함수 같은 경우)

이제 부터는 DB 의 s 가 블랙 노드인 상황인데 여기서도 s 의 자식노드들이 어떤지에 따라 나뉘게 됩니다. 

case 4) DB 의 형제가 Black && 형제의 양쪽 자식이 모두 Black
- 이런 상황에서 해야할 작업은 먼저 DB 노드가 가지고 있는 추가 블랙을 p 로 넘깁니다. 그러면 이전에 DB 였던 노드에서는 Black 의 개수는 안정이 되지만 
  형제 쪽 경로에는 Black 이 하나 늘었습니다. 그래서 형제 노드를 Red 로 바꿔줍니다. 이러면 p 로 부터의 모든 리프까지의 경로들에게 Black 의 수가 같아집니다. 
  하지만 이 케이스 에서도 예외 상황이 또 있는데 처음 DB 의 추가 블랙을 p로 넘길때 p가 Red 노드 였다면 상관없지만 Black 노드 였다면 다시 더블블랙이 되면서 
  p를 대상으로 알고리즘을 이어서 실행해야 합니다. 

case 5) DB의 형제가 Black && 형제의 near 자식 = Red && 형제의 far 자식 = black
- 이번에는 형제의 자식노드들 중 DB와 가까운 쪽 자식이 Red 이고 먼쪽은 Black 인 상황입니다.
  이럴때는 먼저 near = black, s = red (s 와 near 의 색상교환)
  far 방향으로 Rotate(s) (near 가 DB 의 형제가 되고 s 가 near의 자식으로 갑니다.) (이러면 s 였던 노드가 far 가 되면서 레드 노드가 됩니다. )
  후 case 6 으로 진행 합니다.

case 6) DB의 형제가 Black && 형제의 far 자식 = Red 
- case 5 에서 유도 했던 형태 입니다. 여기서 하는 작업을 보면 
  p 와 s 의 색상교환을 합니다. 이때 s가 블랙일것이고 p가 레드였다고 하면 둘의 색상교환을 하면 p = black, s = red, far = red 로 연달아서 레드가 두개 나옵니다. 
  이러면 4번 조건에 위배되기 때문에 far 도 black 으로 바꿉니다. 
  그 다음은 DB 방향으로 Rotate(p) 를 해줍니다. ( s 가 p의 부모가 되고 p아래로 DB 가 있습니다.)
  이렇게 되면 이제 s 였던 노드가 상위 노드인 서브 트리가 되는데 이때 이 밑쪽으로의 경로에 black 이 고루 분배됩니다. 그런데 DB 가 들고 있는 추가 블랙을 제거합니다. 


이렇게 레드 블랙 트리의 삭제 알고리즘에 대해 알아 봤습니다. 이걸 처음 만들었던 개발자는 이 내용들을 모두 이해하고 있어야 겠지만 
그 수혜를 받아 사용하는 입장에서는 이 알고리즘을 상황에 맞게 가져다 사용하는걸로 더욱 쉽게 사용할 수 있을겁니다. 
한번 본걸로 전부 이해하면 정말 좋겠지만 억지로 달달 외우거나 이해하려고 머리 싸매고있는것보다는 이미 증명된 내용을 잘 가져다 사용하는것 부터 하면 좋겠습니다. 


/*
추가 
- 삭제 알고리즘 case 1 에서 삭제할 노드가 빨간색이라면 그냥 삭제하고 끝이라고 했는데 이때 삭제할 노드가 말단 노드여서 자식이 하나도 없다면 
정말로 달랑 삭제하고 끝이겠지만 만약 삭제할 레드 노드 밑으로 자식 노드들이 달려 있다면 어떨까요?

BST 에서 자식이 있는 노드를 삭제하게되면 자식이 하나만 있다면 자식노드를 자신위치로 끌어올리고 삭제하면 되었고 
자식이 둘다 있다면 자신의 다음 값을 자신에 복사하고 다음값을 삭제한다고 했습니다.

이 중 자식이 둘 다 있는경우에서는 값을 복사한다음 다음값을 삭제한다. 즉 다음 값을 삭제하는 알고리즘을 사용해야합니다.
*/

이런 이론을 바탕으로 코드로 구현해보면서 좀 더 알아보겠습니다. 



-------- 실습 -----------

Algorithm 프로젝트를 열었습니다. 

레드 블랙 트리를 실습하기에 앞서서 먼저 콘솔에 출력되는 부분을 조금 수정해주고 시작하려고 합니다. 

지금까지 Print 함수에서는 노드를 추가할때 마다 기존 콘솔창을 밀어주고 다시 적는게 아닌 그냥 원래 있던 텍스트위에 다시 입력하는 방식이었습니다. 
그런데 이번 레드 블랙 트리 실습에서는 노드를 추가하기도 하고 삭제하기도 할것이기 때문에 매 프레임마다 콘솔을 밀어주고 다시 입력하도록 바꿔 줄것입니다. 
거기에 더해서 커서가 깜빡거리는 것도 안보이게끔 해주겠습니다. 

이 부분은 이전에 Maze 프로젝트에서 ConsoleHelper 클래스에서 한적이 있습니다.

void ShowConsoleCursor(bool flag)
{
	HANDLE output = ::GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_CURSOR_INFO cursorInfo;
	::GetConsoleCursorInfo(output, &cursorInfo);
	cursorInfo.bVisible = flag;
	::SetConsoleCursorInfo(output, &cursorInfo);
}

이 함수에서는 인자로 bool 타입을 받습니다. 이 인자에 따라 콘솔의 커서가 보이거나 안보입니다.

Print 함수도 내용을 수정했습니다. 
void BinarySearchTree::Print()
{
	::system("cls");
	ShowConsoleCursor(false);
	Print(_root, 10, 0);
}
::system("cls"); 이 코드는 콘솔을 매번 밀어주고 다시 입력해주는 코드입니다. 다음 코드들은 커서를 안보이게끔 하고 기존의 Print 내용도 넣었습니다. 

그리고 Replace 함수도 조금 수정해줄것이 있는데 별건 아니고 기존에 nullptr 를 사용하던 코드를 _nil 로 바꿔주는겁니다. 


본격적으로 Delete 를 만들어 보겠습니다.
기본적으로 BST 에서 했던 삭제 작업은 다 마친 이후 그 트리가 레드 블랙 트리의 조건에 부합하는지를 체크하고 아니라면 교정을 해주는 부분이 추가될겁니다.
InsertFixup 을 만들었던것과 비슷하게 DeleteFixup 함수를 만들어서 그 안에 삭제 알고리즘을 넣어주겠습니다.

다시 BST 의 삭제 코드를 보겠습니다.

void BinarySearchTree::Delete(Node* node)
{
	if (node == _nil)
		return;
	if (node->left == _nil)
	{
		Replace(node, node->right);
	}
	else if (node->right == _nil)
	{
		Replace(node, node->left);
	}
	else
	{
		// 다음 데이터 찾기 
		Node* next = Next(node);
		node->key = next->key;
		Delete(next);
	}
}

먼저 삭제할 노드가 _nil 이라면 return 하고 삭제할 노드의 왼쪽 자식이 비었다면 오른 자식을 Replace, 오른쪽이 비었다면 왼쪽 자식을 Replace 를 합니다. 
둘다 있다면 삭제할 노드의 다음 값 노드를 복사하고 다음값을 삭제합니다. 

BST 에서는 여기서 끝났겟지만 레드 블랙 트리에서는 이제 노드들에게 색상이라는 것이 생겨서 레드 블랙 트리 조건에 맞도록 해줘야 합니다. 

예시로 들 트리가 있습니다.
             [20]
    [10(B)]        [30]
      [15(R)]   [25]  [40]
 
이때 만약 [10(B)] 을 삭제한다고 했을 때 [15(R)] 와 Replace 를 하게 됩니다. 
             [20]
    [15(R)]        [30]
                [25]  [40]
이 상태에서는 루트에서 부터 [15(R)] 을 거치는 경로에 black 이 하나 모자라게 됩니다. 그래서 [15] 의 색을 black 으로 바꿔 준다고 생각하는 방식이 있고 

아니면 
             [20]
    [10(B)]        [30]
      [15(R)]   [25]  [40]
이 상태에서 [15] 의 key 를 [10] 에 복사하고 [15] 를 삭제 한다고 생각하는 방식이 있습니다. 

이걸 어떻게 분석할지는 자유였습니다. 

이번에는 두가지 분석 방법중에 전자로 해보겠습니다. 즉, [10] 을 실제로 삭제하고 [15] 의 색상을 바꿔주는 방법입니다. 
그러면 이것을 코드로 구현하려면 삭제하려던 노드의 색상이 무엇이었는지 그리고 삭제하려던 노드에 연결된 자식노드는 무엇이었는지를 추적해야합니다.

if (node->left == _nil)
	{
		Color color = node->color;
		Node* right = node->right;

		Replace(node, node->right);

		if (color == Color::Black)
			DeleteFixup(right);
	}
	else if (node->right == _nil)
	{
		Color color = node->color;
		Node* left = node->left;

		Replace(node, node->left);
		if (color == Color::Black)
			DeleteFixup(left);
	}
왼쪽 오른쪽을 대칭적으로 처리했습니다. 변수로 color 와 right(혹은 left) 를 Replace 전에 기록해두었고 Replace 가 끝난다음 삭제했던 노드의 색상이 
Black 인경우 DeleteFixup 을 실행했습니다. 왜 color가 레드인경우는 처리하지 않았냐면 
레드 블렉 트리의 삭제 알고리즘에서 주로 문제가 되는것은 5번째 조건인 어떤노드건 리프까지의 모든 경로에 블랙노드의 수가 동일해야 한다는 조건이 중요한데 
만약 삭제한 노드가 레드 노드였다면 5번 조건에 영향이 가지 않기 때문에 그냥 삭제하고 끝입니다.

이 다음으로 양쪽 노드가 있는경우의 코드에서는 삭제할 노드의 양쪽 모두 _nil 이 아닌경우인데 이 때는 삭제 노드의 next 값을 복사 받고 next를 다시 Delete 해주게 됩니다. 
즉, 결국은 리프까지 양쪽 모두 자식이 있어서 마지막에 Delete(_nil) 이 되어 그냥 리턴이 되거나 
아니면 어느 한쪽 자식만 있어서 위의 조건으로 들어가게 됩니다. 

그러므로 위의 둘중 하나의 자식만 있는경우에만 DeleteFixup 을 체크해주면 되겠습니다. 

이제는 삭제한 노드가 블랙이라서 DeleteFixup 에 들어섰을때 어떻게 해야 하는가가 관심사입니다.
이 내용이 아까 설명한대로 많이 복잡합니다.

DeleteFixup 의 여섯가지 케이스 중 첫번째 케이스인 삭제할 노드가 Red 인경우는 Delete 에서 처리 해줬으니 두번째 케이스 부터 처리를 시작할것인데 

이 코드를 아무리 글로 적어 보면서 코드를 만들어도 실수할 가능성이 많이 높습니다. 
그렇기 때문에 혹시나 코딩테스트에 나온다거나 하는 경우는 없다고 합니다. 이런 코드는 천천히 집에서 혼자 만들어보는 정도의 코드라고 합니다. 
너무 복잡하다 못할것 같다 라는 자괴감을 가질 필요없이 일단 쭈욱 따라서 훑어보고 필요할때 그때 마다 다시 복습하는 식으로 사용하여야 하겠습니다.

DeleteFixup 에서 먼저 Case 1 과 Case 2 를 처리하는 과정을 보겠습니다. 

void BinarySearchTree::DeleteFixup(Node* node)
{
	Node* x = node;
  
  while ( x != _root && x->color == Color::Black)
  {
    // 다른 Case 들을 처리해줄 자리 
  }

  x->Color = Color::Black;
}

while 문의 조건에 해당하지 않는다면 x 는 루트 이거나 아니면 Red 노드인것입니다. 이 두 Case 인경우 x 의 색을 Black 으로 바꿔 주면 해결이 됩니다. 

다음으로 Case 1, Case 2 를 걸러주는 while 문 안에서 처리되는 다른 Case 들입니다. 
이 안에서는 x 가 x->parent 의 왼쪽 자식인지 오른쪽 자식인지를 대칭적으로 처리해줄것입니다. 
  {
  if (x == x->parent->left)
      {
      }
      else
      {
      }
  }

이 중에서 왼쪽 자식인 경우의 코드를 예시로 들겠습니다. 먼저 Case 3 입니다. Sibling 의 색상이 Red 라면?
		
    	Node* s = x->parent->right;
			if (s->color == Color::Red)
			{
				s->color = Color::Black;
				x->parent->color = Color::Red;

				LeftRotate(x->parent);
				s = x->parent->right;
			}

Case 3 의 처리과정인 p 와 s 의 색상교환->DB방향으로 rotate(p)를 한다음 s 를 x->parent->right 로 갱신해주고 있습니다. 
갱신하는 이유는 Rotate 이후에는 트리의 구조가 달라졌기 때문에 기존에 s 의 left 였던 노드가 p의 오른쪽에 와서 붙습니다. 
      [p(B)]                                       [s(B)]
[x(B)]      [s(R)]      ---->                [p(R)]
         [sl]       (LeftRotate(p))    [x(B)]    [sl] 

이 다음은 while 문을 돌면서 DB가 해결될때 까지 루프를 돌겁니다. 
case 3 은 직접적으로 DB 가 해결되는 케이스가 아닌 다른 case 로 가는 변환 과정이기 때문에 이어서 다른 case 들을 만들어 주겠습니다. 

순서대로 다음은 Case 4 입니다. DB 의 sibling 노드가 Black && sibling의 양쪽 자식도 Black 이라면?
			
      if (s->left->color == Color::Black && s->right->color == Color::Black)
			{
				s->color = Color::Red;
				x = x->parent;
			}

이상하게도 Case 4 의 코드는 이렇게 밖에 없습니다. 글로 적었던 과정에서는 내용이 더 많았었는데 어째서 if 문안에 두줄의 코드만 들은게 끝일까요?
 // - Case 4) DB 의 sibling 노드가 Black && sibling의 양쪽 자식도 Black
// -- 추가 Black을 Parent 에 이전 
// -- p가 Red 였으면 Black 이 됨.
// -- p가 Black 이었으면 DB가 됩.
// -- s = red
// -- p를 대상으로 알고리즘 이어서 실행 (p 가 DB가 되었을 경우)
이 내용중 1~3 째 줄의 내용이 코드에 없습니다. 
왜냐면 일단 p 가 Red 였으면 Black 이 된다는 부분은 x = x->parent 이렇게 교체된다음 while 루프를 돌때 x 가 Red 라면 즉, 이전 루프의 p 가 Red 라면 
while 문을 빠져나와서 x->color = Color::Black; 를 통해 자연히 실행됩니다.
그러면 거꾸로 p가 black 이라면 DB가 된다는 부분은 다음 루프에서 x가 black 이라면 while 안으로 들어오는데 이 while 자체가 DB 를 처리하기 위한 
루프입니다. 루프를 거듭하면 p가 DB가 되고 p를 대상으로 알고리즘을 이어서 실행하는것까지 처리가 되는겁니다. 추가 Black 을 이전한다는것은 
이론시간때 이론적으로 이해하기 쉽도록 추가 Black 이라는 폭탄 개념을 만든것이고 Case 1 을 통과한것 자체가 x가 DB 라는 뜻입니다.

다음은 Case 5 입니다.
    // Case 5) DB의 silbling 노드가 Black && sibling의 near child =red , far child = black
    if (s->right->color == Color::Black)
    {
      s->left->color = Color::Black;
      s->color = Color::Red;
      RightRotate(s);
      s = x->parent->right;
    }
Case 5 의 조건이 (s->left->color == Color::Red && s->right->color == Color::Black)  
이 아닌이유는 이 위에서 Case 4 를 통과했다면 s 의 자식중 하나는 Red 라는것이기 때문에 생략해도 되었습니다.
처리 과정대로 s <-> near 의 색상교환 후 far 방향으로 rotate(s) 를 해주고 x 의 sibling을 재설정 해주었습니다.

다음은 Case 6 입니다. 
Case 6) DB의 sibling 노드가 Black && sibling의 for child = red

      // Case 6) DB의 sibling 노드가 Black && sibling의 for child = red
      s->color = x->parent->color;
      x->parent->color = Color::Black;
      s->right->color = Color::Black;
      LeftRotate(x->parent);
      x = _root;
처리 과정은 s <-> p 의 색상변환, far 를 black 으로, DB의 방향으로 rotate(p) 를 한 다음 추가 black 을 제거합니다. 
추가 black 제거라는 말은 루프를 돌필요가 없다는 뜻이기 때문에 x 를 root 로 만들어서 while 을 빠져나오도록 했습니다.

여기까지 x 가 left child 일때를 만들었으니  대칭적으로 right child 일때도 만들면 DeleteFixup 코드가 완성됩니다. 


- 정리 
이렇게 해서 레드 블랙 트리를 한바뀌 훑어 보았습니다. 처음 보고 모두 이해하고 외울 수 있는건 당연히 아닙니다. 

그래도 여기서 가져가면 좋은것은 대략적으로 어떤 로직으로 진행이 되는지를 가지고 가면 좋을것 같습니다. 
여기서 새로 등장한 개념들인 추가할때는 uncle 노드, 삭제할때는 sibling 과 near, far 노드들 이 무엇을 뜻하는지도 어렴풋이라도 알고 넘어가면 좋겠습니다.