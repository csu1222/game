


        해시 테이블


이번 시간은 해시 테이블입니다. 이 주제는 정말 면접에 자주 나오는 질문이라고 합니다. 

질문이 무엇이냐면 

Q) Map vs Hash Map  둘의 차이가 무엇인가? 라는 질문입니다.  

우선 C++ 11 표준에서 해쉬 맵에 해당하는 컨테이너는 unordered_map 이라고 합니다. 

이 질문에서 여러모로 기본기를 테스트 할 수 있습니다.

그러면 이 질문의 대답을 알아보겠습니다. 

map : Red-Black Tree
- 추가/팀색/삭제 O(logN)
  이진 검색 트리에서 균형까지 고려한 레드 블랙 트리

// C# 에서 Dictionary 라는걸 많이 쓴다고 합니다. 
    C# Dictionary = C++ map  이라고 많이 생각하는데 그렇지 않습니다. 
    C# Dictionary = C++ unordered_map 입니다. 

hash_map(unordered_map) 
- 추가/탐색/삭제 O(1) (하지만 조건이 있다)

  메모리를 내주고 속도를 취한다

  예를 들어 아파트 우편함은 각 호수 마다 우편함이 있지만 실제 각 우편함이 매번 꽉꽉 들어차지는 않습니다. 그렇다고 
  하나의 조금 더 큰 우편함에 모든 호수의 우편들을 받는다면 거기서 자신의 호수의 우편을 찾을때 더 많은 시간을 사용할것인데 
  반대로 원래 방식대로 각 호수의 우편함이 있다면 자신의 호수를 딱 찾아서 우편을 찾으면 그만입니다. 이렇게 임의 접근을 할수 있기 때문에 
  O(1) 이라는 시간복잡도를 낼 수 있습니다. 

  그렇다면 문제가 되는 상황은 가구수가 무진장 많아 지면 낭비되는 공간이 너무 많아 진다는겁니다. 
  메모리가 제한되어 있는 상황에서는 제한되겠지만 만약 무제한의 메모리를 사용해도 된다고 한다면 진짜로 각 데이터의 개수 만큼의 용량을 사용해서 
  빠르게 서칭을 할 수 있습니다. 

  이제 우편함이 아니라 코드로 다시 돌아와 보겠습니다. 
  1 ~ 999 개의 user 데이터가 있다고 하겠습니다. 그리고 각 유저는 키값 혹은 ID 를 1~999 의 숫자를 할당받는다고 하겠습니다.
  이정도 갯수의 데이터는 요즘 컴퓨터에서는 아주 작은 규모의 데이터 량입니다. 
  그래서 이걸 처리하기위해 레드 블랙 트리를 만들어서 어떻게 관리하기 보다 
  그냥 어찌보면 무식하게 1000개 짜리 배열을 그냥 만들면 됩니다. 그러면 각 ID를 가지고 임의 접근을 할 수 있습니다. 

  이렇게만 보면 이게 중요한 질문에 기본기 테스트를 한다는 자료구조가 맞나 싶기도 합니다.

  그래서 해쉬 테이블은 이전에 배운 BST, 레드 블랙 트리 같은 자료구조에 비해 개념이 단순하고 그렇기때문에 코드 구현도 비교적 단순합니다. 

  해시 테이블은 '해시' 와 '테이블' 이라는 용어로 이루어져있는데 각각이 중요한 의미가 있습니다. 

- 테이블 
먼저 테이블 이라는 개념을 코드로 예시를 들어보겠습니다. 
void TestTable()
{
	struct User
	{
		int userId = 0;		// 1 ~ 999
		string userName;
	};

	vector<User> users;
	users.resize(1000);

	// 777 번 유저 정보 세팅
	users[777] = User{ 777, "SeaBass" };

	// 777 번 유저의 이름은 무엇입니까.
	string name = users[777].userName;

	cout << name << endl; 
}

이 코드를 보면 너무나도 당연한 내용을 새로운 개념이라고 하는 느낌입니다. 하지만 테이블은 정말 이런 개념입니다. 
resize 로 1000 을 잡아 두면서 메모리를 낭비할지언정 성능적으로만 보면 바로 데이터에 접근할 수 있는 이것이 바로 O(1) 입니다.
가끔은 돌아갈 필요 없이 무식한 방법이 더 빠를 수 있다는 겁니다.

위에서 사용한 777 이라는 숫자에 해당하는것을 key 라고 합니다. 

하지만 이걸 실전에서 그대로 사용한다면 당연히 문제가 있습니다. 지금은 가정으로 999 개라는 이쁜 개수의 데이터를 상정했지만 
실제 게임 서비스에서는 동시접속자 뿐만아니라 기존의 가입한 유저의 데이터들도 가지고 있어야 할텐데 그럴때 문제가 생깁니다. 

문제가 되는 상황을 예로 들면 int32 의 최대 값 근처인 3억개의 데이터를 관리해야 한다고 했을때 위의 코드처럼 
user[300000000] 이렇게 만들면 당연히 메모리가 터질겁니다. 
용량을 희생해서 성능을 챙긴다고는 했지만 그것도 정도껏 해야합니다. 

그리고 이 문제를 해결하기 위해서 오늘의 주제중 해시 Hash 라는 개념이 등장합니다. 

- 해시
그러면 해시는 무엇일까요? 

해시는 보안 프로그램 같은데서도 들어 볼 수 있는 용어입니다. 

예를 들어서 어떤 사이트에 가입을 하겠다고 하겠습니다. ID 를 apple PW 를 juice 라고 하겠습니다. 
이렇게 가입을 한다고 하면 이 아이디와 비밀번호를 데이터 베이스에 저장해주게 됩니다. 

DB 에 [apple][juice]    이렇게 apple을 key 로 삼아서 저장을 한다고 하면 문제가 발생할 수 있는데 
만약 이 데이터베이스가 해킹을 당해서 그 안의 데이터 들이 모두 털렸다고 하겠습니다.

그런데 보통 사람들은 주로 사용하는 아이디하나를 이곳 저곳에서 사용합니다. 그렇기때문에 한 곳으 데이터가 털려도 피해는 기하 급수적으로 늘 수 있습니다. 

예전 2000 년대 초반에 보안에 별로 관심이 없을 때는 그냥 [apple] [juice] 라고 평문으로 관리를 했었지만 

요즘에는 PW 에 해시값을 줘서 처리한다고 합니다. 여기서 말하는 해쉬 함수는 어떤 규칙에 따라 인풋한 문자열을 다른 문자열로 변환하는 함수라고 합니다. 
변환된 값은 당연히 이전 문자열을 예측하기 어렵게 만들겠죠 그리고 이렇게 변환된 암호를 DB 에 저장하게 됩니다. 
변환되기 전의 값을 알면 변환된 값을 알 수는 있지만 반대로 변환된 값을 가지고 이전 값을 알수 없게 합니다. 이게 해시의 묘미라고 합니다. 

하는 김에 비밀번호에 대한 이야기를 좀 더 해보면 잊어버린 비밀번호 찾는걸 해봤을 겁니다. 

비밀번호 찾기 -> 아이디 입력 -> 휴대폰/이메일 인증 -> 새 비밀번호 입력 (옛날에는 직접 비밀번호를 반환해줬었습니다.)

요즘은 왜 비밀번호를 알려주지 않고 새 비밀번호를 입력하도록 하냐면 서버에서도 원래 비밀번호가 무엇인지를 모르는겁니다. 
무슨 말이나면 서버에서는 해시 값을 알고 있는것이지 비밀번호 자체를 알고 있는것이 아니라서 새 비밀번호를 입력하면 그걸 암호화 할 수는 있지만 암호와 
해시 값으로 원래 비밀번호를 알아 낼 수가 없습니다.  

말이 좀 많이 돌아 왔지만 해시라는 개념을 요즘에는 이런식으로 사용하고 있다는 것입니다. 

다시 해시 테이블의 예시로 돌아와서 위에서 테이블을 만들면서 만약 테이블의 내용 버켓을 INT32_MAX (약 3억)개로 만들때 의 문제점을 해결하기 위한 
개념이 해시라고 했었습니다. 

예시를 다시 들면 

void TestHash()
{
	struct User
	{
		int userId = 0;		// 1 ~ 999
		string userName;
	};

	vector<User> users;
	users.resize(1000);

	const int userId = 123456789;
	int key = (userId % 1000);  // hash < 고유번호 

	// 123456789 번 유저 정보 세팅
	users[key] = User{ userId, "SeaBass" };

	// 123456789 번 유저의 이름은 무엇입니까.
	User& user = users[key];
	if (user.userId == userId)
	{
		string name = user.userName;
		cout << name << endl;
	} 
}

이렇게 버켓 자체는 1000 개로 유지하겠습니다. 

이때 만약 123456789 번째 의 유저를 저장하려고 한다고 하겠습니다. 

하지만 버켓을 1000 개 까지 밖에 못저장하는데 이걸 아주간단한 식을 사용하는 key 로 변환했습니다. 이게 hash 라고 할 수 있습니다.

아이디를 1000 으로 나눈 나머지를 키로 가지면 이제 789 라는 키 값으로 users 에 저장을 하면 되겠습니다. 

그러니까 고유번호 ID 를 그대로 사용하는것이 아니라 어떤 알고리즘으로 변환한 key 를 추출한다음 그 key 를 사용해 정보에 접근한다는 말입니다. 


- 해시 테이블

이제 해시 테이블 이라는 용어의 의미와 왜 나왔는지를 이해하면 좋겠습니다. 
먼저 테이블은 접근에 아주 빠른 성능을 가지고 있지만 용량의 낭비라는 단점을 가지고 있고 해시는 그 테이블의 단점인 용량을 어느정도 보안해주는 역할을 합니다.  

그런데 위와 같이 사용하면 안되는 문제가 아직 있습니다. 
그 문제란 것은 key 값의 충돌입니다. 

key 값의 충돌이란 한 해시 테이블에서 동일한 key 값이 중복되는 상황입니다. 
실제 상황같은 비밀번호 해시 처리 같은 경우에는 정말 왠만해서는 키값이 중복이 되지 않지만 위에서 예시로 든 TestHash 함수의 key 값 구하는 방법은 그냥 1000 의 나머지를 
반환하는 것이어서 1000번 이후로 부터 계속 충돌이 일어나게 됩니다. 

그러면 이렇게 카값의 중복이 일어날때 어떻게 해결해야 할지 를 생각해보겠습니다. 
다양한 방법이 있을 수 있는데 
1.먼저 아이디는 많지만 그 아이디에 포함되는 데이터량이 그렇게 많지 않은 상황이라면 
- 충돌이 발생한 자리를 대신해 다른 빈자리를 찾아나서면 됩니다. 
-- 선형 조사법 (linear probing)
--- 충돌이 일어났다면 그냥 그 옆자리로 간다는 컨셉 hash(key) + 1 -> hash(key) + 2 
    아주 간단한 개념이지만 그 만큼 단점도 있습니다. 너무 데이터가 몰리게 되면 인접한 데이터끼리 겹칠확률이 높아집니다.
-- 이차 조사법 (quadratic probing)
--- 선형 조사법의 단점을 보안하기 위해 옆으로 이동하는 거리를 제곱해서 움직이는 컨샙  hash(key) + 1² -> hash(key) + 2²

이외에도 데이터를 옮겨서 키 중복, hash 충돌을 해결하기 위한 방법들이 많지만 이 방법도 사실 테이블의 사이즈가 넉넉할 때의 이야기입니다. 

2.테이블에 저장할 데이터가 확실하게 많아서 버켓에 남는 공간이 없는 상황이라면 
- 체이닝이라는 기법을 사용하면 되겠습니다.
-- 체이닝이라는 것은 한 버켓에 데이터 하나만 저장하는게 아니라 버켓 자체를 연결리스트나 동적배열로 만들어서 한 버켓에 여러 데이터를 저장할수 있게 하는것입니다.  
-- 이러면 선형 조사법이니 이차 조사법이니를 사용하지 않아도 그냥 같은 키값을 가진 데이터가 들어왔다고 해도 그 같은 키값을 가진 데이터들끼리 이어서 관리할 수 있습니다. 

void TestHashTableChaining()
{
	struct User
	{
		int userId = 0;		// 1 ~ 999
		string userName;
	};

	vector<vector<User>> users;
	users.resize(1000);

	const int userId = 123456789;
	int key = (userId % 1000);  // hash < 고유번호 

	// 123456789 번 유저 정보 세팅
	users[key].push_back(User{ userId, "SeaBass" });
	users[789].push_back(User{ 789, "Seonguk" });

	vector<User>& Bucket = users[key];

	for (User& user : Bucket)
	{
		if (user.userId == userId)
		{
			string name = user.userName;
			cout << name << endl;
		}
	} 
}

테이블 로 사용하던 users 를 vector<User> 타입에서 vector<vector<User>> 로 바꿨습니다. 이제 버켓 하나에는 또 다시 vector 가 자리할겁니다. 
그리고 123456789 를 아이디로 사용하던 데이터를 push_back 하고 또 789 를 아이디로 사용하는 데이터도 다시 push_back 하면 이전 같으면 hash 충돌이 일어날테지만 
지금은 789 번째 버켓에 0 번 1번 인덱스에 차례대로 저장이 됩니다. 

이제 시간 복잡도를 계산해보면 
만약 해시 테이블의 버켓을 컨테이너가 아닌 그냥 데이터를 저장해서 사용한다면 대단히 많은 용량을 사용하겠지만 각 버켓에 접근하는것은 상수의 시간복잡도를 따를겁니다.  
그리고 사실 해시 값을 복잡하게 준고 충분히 넓은 용량을 사용한다면 해시 충돌의 확률을 많이 낮출수 있을 겁니다. 

결국 해시 테이블은 O(1) 이라고 볼 수 있는겁니다. 이상적일때의 이야기이긴 합니다. 
레드 블랙 트리처럼 담긴 데이터를 원하는대로 정렬해서 주는 것은 아니고 그냥 담긴 데이터를 키값으로 빠르게 찾기위한 자료구조라고 보면 되겠습니다. 


- 결론 

면접에서 자주 나온다는 질문의 답을 알아보겠습니다. 

map 과 Hash_map 의 차이를 물어 본다면 

C++ 에서의 map 은 레드 블랙 트리 이고, 균형 이진 트리입니다. 이진 검색 트리에서 데이터가 한쪽으로 쏠리지 않도록 균형을 잡아주는 균형 이진 트리이고 
시간 복잡도는 O(logN) 을 따릅니다. 

hash_map 은 C++ 에서는 unordered_map 이라고 불리고 해시 테이블의 구조입니다. 레드 블랙 트리 보다도 훨씬 빠른 속도를 내지만 
많은 메모리를 차지하고 해시 충돌을 고려해야합니다. 만약 해시 충돌이 일어나지 않고 메모리도 무제한으로 사용한다면 빠른 속도를 냅니다. 

이렇게 해시 메모리의 개념을 가지고 가면 성공이라고 할 수 있겠습니다.