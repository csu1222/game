

        레드 블랙 트리 


이전 시간에서 이진 탐색 트리 Binary Search Tree 를 배웠습니다. 
이 BST 도 잘 쓰면 나쁘지는 않은데 만약 데이터가 한쪽으로 몰리게 되면 이진 탐색의 의미가 퇴색된다는 단점이 있었습니다. 
사실상 연결리스트와 다를바가 없어지는겁니다. 

그래서 어찌됐든 BST 에서 균형을 맞추는 방법이 필요합니다. 
이 주제도 굉장히 오랫동안 연구된 분야이기 때문에 다양한 알고리즘들이 있습니다. AVL또는 운빨에 기대는 트립 그리고 오늘 배우게 될 레드 블랙 트리 
라는 알고리즘등등이 있습니다.

그리고 오늘의 주제인 레드 블랙 트리의 내용이 많기 때문에 여러 강의로 쪼개서 알아볼것입니다. 
이번 강의에서는 레드 블랙 트리의 특성을 알아보고 삽입하는 부분까지만 만들어 보겠습니다. 

레드 블랙 트리도 BST 에서의 삽입과 크게 다르지 않지만 데이터를 추가 한다음 전체적인 균형을 맞춰주는 부분이 추가 됩니다. 
그래서 이전 시간에 만들어본 코드를 상당부분 재사용 할 수 있습니다.

- 레드블랙트리

레드 블랙 트리는 이름 부터 '레드' 와 '블랙' 이라는 용어가 새로 등장합니다. 이 용어들이 무엇을 뜻하는지 부터 알아보겠습니다.

위키 백과 참조(https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC)
{
레드-블랙 트리는 각각의 노드가 레드 나 블랙 인 색상 속성을 가지고 있는 이진 탐색 트리이다.
1. 노드는 레드 혹은 블랙 중의 하나이다.
2. 루트 노드는 블랙이다.
3. 모든 리프 노드들(NIL)은 블랙이다.
4. 레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다. (즉, 레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다)
5. 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.
}

레드 블랙 트리를 이루고 있는 노드들은 모두 레드 혹은 블랙 노드이고 루트노드는 무조건 블랙부터 시작합니다. 
그리고 리프노드(NIL) 은 모두 블랙이라고 간주한다고 하는데 이때 NIL은 연결리스트에서 더미노드begin, end 와 비슷한 노드들입니다. 
그런데 이전 시간에 만들었던 이진 탐색 트리에서는 그냥 NIL 노드를 만들지 않고 nullptr 로 처리했었습니다. 

레드 블랙 트리에서는 NIL 이 블랙이어야 한다는 규칙이 있어서 이번 실습때는 NIL 을 만들어 주는게 더 속이 편합니다. 

여기 3번 조건 까지는 별로 어려울게 없습니다. 진짜 중요한 조건들은 4, 5번입니다. 

4번에서 하고싶은 말은 무엇이냐면 레드 노드의 자식노드들은 무조건 블랙 노드여야한다 그러니까 트리에서 레드 노드가 부모 자식관계에서 연달아 나올 수 없다는 말입니다.
예를 들어서 루트노드(블랙) -> 레드노드 -> 블랙노드 -> NIL(블랙) 이런식이어야 한다는 말입니다. 
그런데 이때 블랙노드는 연달아 나와도 전혀 상관없습니다. 
- 이 4번 조건이 굉장히 중요한데 실질적으로 데이터를 추가 할 때 노드를 빨간색으로 만들어서 추가할건데 추가될 위치의 부모 노드가 빨간색이라면 부모 노드 밑에 연달아 
  레드 노드가 오게 되고 이렇게 조건을 충족하지 않을때 레드 블랙 트리 전체가 재배치가 일어나게 됩니다. 

이어서 5번 조건은 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.
입니다. 이것이 무슨뜻인지 잘이해가 가지 않을 수 있는데 사람마다 해석이 다를 수 있다고 합니다. 루트노드와 NIL 을 세는 사람도 있고 안세는 사람도 있는데 
루트 노드부터 NIL 까지를 본다고 했을때 
루트(블랙) -> 노드(레드) -> 노드(블랙) -> NIL(블랙) 
이런 경로가 있다고 하면 루트에서 NIL까지 블랙 노드가 총 3개 입니다. 
그런데 이 루트 말고도 다른 루트 
루트(블랙) -> 노드(레드) -> 노드 (블랙) -> 노드(레드) -> NIL(블랙) 이런 루트에서도 블랙 노드의 갯수는 총 3개입니다. 
트리가 모두 이런식으로 이루어져 있다는 것이 5번 조건입니다. 

4,5번 조건같은 경우는 우리가 이걸 배우자 마자 이걸 응용해서 다른걸 한다 라기 보다도 레드 블랙 트리의 특성이라고 만 알고 있어도 됩니다. 
앞으로 레드 블랙 트리를 실습하면서 조건에 위배되는 상황이 나올때 트리를 재배치 할것인데 그 재배치도 이미 정해진 알고리즘을 그대로 따라서 사용하면 됩니다. 

진짜 어려운것은 이 레드 블랙 트리 같은 알고리즘을 처음에 구상하고 수학적으로 증명하고 코드로 구현하는 분들이 정말 대단한 것이지 
이후에 증명된 알고리즘을 가져다 사용하는 저 같은 사람은 매우 쉬운것이라고 볼 수 있습니다.

그래서 이제 우리 프로젝트에서 이제 노드에 레드와 블랙이라는 개념을 추가 해주고 트리의 Insert 기능을 만들어 보겠습니다. 
Insert 를 구현하면서 트리 재구성이 필요할 수도 있습니다. 그것도 같이 알아보겠습니다. 


일단은 이런 5가지의 특징이 있다고 기억을 한다음 레드 블랙 트리를 실습 해보겠습니다. 


- 실습 

일당은 먼저 트리를 이루는 단위인 노드에서 새로운 개념을 추가 해주겠습니다. 

enum class Color
{
	Red = 0,
	Black = 1,
};
struct Node
{
	Node*	parent = nullptr;
	Node*	left = nullptr;
	Node*	right = nullptr;
	int		key = {};
	Color	color = Color::Black;
};

레드와 블랙이라는 것을 bool 이나 아니면 enum class 로 관리해주겠습니다. 그리고 노드의 기본 색상은 NIL 노드가 기본 블랙이어야 하니까 
일단 블랙이 기본 색상이라고 하겠습니다. 

다시 한번 레드 블랙 트리의 특성을 숙지하고 시작하겠습니다.

// Red-Black Tree
// 1) 모든 노드는 Red or Black
// 2) Root는 Black
// 3) Leaf(NIL)은 Black
// 4) Red노드의 자식은 Black(즉, 연속해서 Red는 안됨)
// 5) 각 노드 부터 Leaf 까지의 경로에서는 모두 같은 수의 Black 노드를 만난다.

이제 다음으로 만들 내용은 이전 이진 검색 트리에서 그냥 넘어가서 만들지 않았던 NIL을 만들어 주겠습니다.

class BinarySearchTree
{
public:
    BinarySearchTree();
    ~BinarySearchTree();
// ... 
private:
	Node*	_root = nullptr;
	Node*	_nil = nullptr;
};

_nil 을 nullptr로 일단 만들어 주겠습니다. 그리고 이 _nil을 하나만 만들어서 재사용할것입니다. 
생성자 소멸자 함수에서는 어떤 내용이냐면

BinarySearchTree::BinarySearchTree()
{
	_nil = new Node();

	_root = _nil;
}

BinarySearchTree::~BinarySearchTree()
{
	delete _nil;
}

이런 내용을 가지고 있습니다. Node를 기본 생성자로 생성하게되면 key 값도 없고 parent, right, left 모두 nullptr color 는 블랙인 노드가 만들어 집니다. 
그리고 맨처음 BinarySearchTree 객체를 만들때 _root 를 _nil 이라고 합니다. 
이 _nil은 앞으로 nullptr 을 대신할겁니다. 
_nil을 Leaf 노드 마다 하나씩 만드는게 아니라 하나만 만들고 Leaf 노드는 이 _nil 을 가리키도록 할것인데 어짜피 다른 데이터를 들고 있는게 아닌 nullptr 의 역할을 
할것이기 때문에 재사용이 가능합니다. 

BinarySearchTree 가 소멸할때 _nil 도 delete 합니다.

다음은 코드에서 이제 사용하지않을 내용을 삭제하고 조금 수정도 해주겠습니다.
Print 코드들을 수정,삭제할것인데 이전에 Print_Inorder 라는 함수는 만들기는 했지만 따로 사용은 하지않았습니다. 삭제 하겠습니다. 

그리고 Print 함수에서는 node->key 만 출력하고 있었는데 이번에 추가된 개념인 color 도 같이 표시해주겠습니다.
색상은 텍스트로 출력하는것보다 이전에 Maze 프로젝트에서 콘솔에서 색상을 바꿀 수 있느는 windows API 도 사용했었는데 그걸 가져다 사용합니다. 

#include <Windows.h>

enum class ConsoleColor
{
	BLACK = 0,
	RED = FOREGROUND_RED,
	GREEN = FOREGROUND_GREEN,
	BLUE = FOREGROUND_BLUE,
	YELLOW = RED | GREEN,
	WHITE = RED | GREEN | BLUE,
};

void SetCursorColor(ConsoleColor color)
{
	HANDLE output = ::GetStdHandle(STD_OUTPUT_HANDLE);
	::SetConsoleTextAttribute(output, static_cast<SHORT>(color));
}

이렇게 커서 색을 바꾸는 기능을 추가하고 

void BinarySearchTree::Print(Node* node, int x, int y)
{
	if (node == nullptr)
		return;

	SetCursorPosition(x, y);

	if (node->color == Color::Black)
		SetCursorColor(ConsoleColor::BLUE);
	else
		SetCursorColor(ConsoleColor::RED);

	cout << node->key << endl;
	Print(node->left, x - (5 / (y + 1)), y + 1);
	Print(node->right, x + (5 / (y + 1)), y + 1);

	SetCursorColor(ConsoleColor::WHITE);
}

프린트 할때 node의 color 정보에 따라 색을 바꿔서 출력하도록 만들어 줬습니다. (블랙을 왜 파란색으로 했나면 콘솔의 배경이 검은색이라 안보여서입니다.)

이부분은 부차적인 내용이고 

본 내용으로 돌아가서 _nil 을 생성자에서 생성하는 것 까지 했는데 이제 다음으로 해줄 작업은 nullptr 이 등장하는 부분을 모두 _nil 로 바꿔줘야합니다.
정의부에서 nullptr 부분은 모두 _nil 로 바꿔주고 while 문 같은데서 변수가 nullptr 인지 체크하는 부분도 모두 != _nil 이라고 바꿔줍니다. 


그리고 이제 Insert 함수를 본격적으로 수정할것입니다. 
그냥 BST 의 Insert 의 코드 대부분을 재사용할 수 있고 필요한 내용을 추가하고 Insert 의 끝부분에 노드를 추가해주는 부분 다음 
이 상태가 레드 블랙 트리의 조건을 만족하는지를 검사하는 부분을 넣어줄것입니다. 

이전 Insert 에서는 추가할 노드 newNode 를 생성하고 _root 가 nullptr 인지 체크해서 nullptr 이라면 _root = newNode 후 리턴 해줬었습니다. 
void BinarySearchTree::Insert(int key)
{
    Node* newNode = new Node();
    newNode->key = key;

    if (_root == nullptr)
    {
        _root = newNode;
        return;
    }   
    //...
}

이중에 _root 를 체크하는 조건문을 삭제합니다. 

하지만 트리가 비었을때 _root 를 채워주는 부분은 분명 필요한데 이부분을 나중에 해줍니다. 
{	
	Node* node = _root;
	Node* parent = _nil;

	// _root 는 생성자 때 _nil 로 설정해줘서 이 반복문을 무시합니다. 
	while (node != _nil)
	{
		parent = node;
		if (key < node->key)
			node = node->left;
		else
			node = node->right;
	}

	newNode->parent = parent;

	// keyNode 와 parent 의 key 값을 비교해서 왼쪽, 오른쪽을 정합니다. 
	if (parent == _nil)
		_root = newNode;
	else if (newNode->key < parent->key)
		parent->left = newNode;
	else
		parent->right = newNode;
        

    // 검사
}

왜 일부러 이렇게 수정을 했냐면 레드 블랙 트리의 조건을 검사하는 부분때문인데 이전 코드였다면 _root 에 첫번째 노드를 넣는 부분에서 검사를 하고 
맨 밑 부분에서도 다시 검사를 진행해야 합니다. 지금의 코드로 수정하면 검사를 한번에 처리할 수 있습니다. 

검사 부분의 내용은 이렇습니다.

	// 검사
	newNode->left = _nil;
	newNode->right = _nil;
	newNode->color = Color::Red;

	InsertFixup(newNode);

위에서 parent 노드와 연결된 newNode 는 새로 추가된 노드이기 때문에 좌 우 자식노드들 모두 _nil 로 설정해줘야합니다. 
기본적으로 새로 추가하는 노드들은 모두 일단 레드 노드로 만들어 줄것입니다. 

그 밑에 새로보는 함수인 InsertFixup 이 있는데 이 함수는 새로 추가된 노드가 레드 블랙 트리의 조건을 지키고 있는지를 확인하는 함수 입니다.
내용은 곧 만들어 줄것입니다.

그래서 Insert 함수의 내용 자체는 거의 바뀌지 않고 검사하는 부분이 새로 추가되는걸로 잘 구현이 될겁니다. 


InsertFixup 를 만들어 주겠습니다. 

일단 검사할 상황이 세가지가 있다고 합니다. 
- 1) parent = red, uncle = red                  parent 와 uncle 모두 레드인 상황
- 2) parent = red, uncle = black (triangle)     parent 는 레드인데 uncle은 블랙 (트라이앵글인 상황)
- 3) parent = red, uncle = black (list)         parent 는 레드인데 uncle은 블랙 (리스트인 상황)

새로운 용어인 uncle 이 등장하고 트라이앵글 상황, 리스트 상황 같이 잘 이해가지 않는 말도 나옵니다. 
이 내용들은 코드를 보면서 설명하겠습니다. 

일단 while 반복을 돌건데 조건은 인자로 받은 node 의 부모의 색이 레드인 동안 반복을 돌겁니다. 

	while (node->parent->color == Color::red)
	{}

이 안에서는 if else 문을 사용할겁니다. 체크 할 것은 노드의 부모(p라고 하겠습니다.) p 가 pp(부모의 부모) 의 왼쪽자식인지 오른쪽 자식인지를 체크합니다. 
이진 트리이기때문에 좌우 대칭으로 코드가 짜입니다. 

	if (node->parent == node->parent->parent->left)
	{}
	else 
	{}

왜 p가 어느쪽 자식노드인지를 체크하냐면 p의 반대쪽 노드가 위에서나온 용어인 uncle 이기 때문입니다. 

	Node* uncle = node->parent->parent->right; // 또는 left

그런데 이때 이 uncle 노드는 실제 존재하는 노드인지, 있다면 색이 어떤 색인지 아직 모릅니다. 
_nil 을 적용하기 전이라면 이때 uncle 노드가 nullptr 인지 체크 해줬어야 하는데 적용후인 지금은 null 체크를 하지 않아도 됩니다. 
_nil 은 nullptr 과 비슷하게 사용되지만 일단 Node 이긴 합니다. 불필요하게 null 체크를 계속 할 필요없게끔 더미 노드를 도입한것입니다.

그래서 이때 uncle이 없다면 _nil 노드라는 뜻이기 때문에 블랙 노드 라고 인정이 될겁니다. 
uncle 이 존재 한다면 그 색상을 체크해야하는데 이제 또 레드인지 블랙인지 갈리는데 조금 쉬운 케이스는 뭐냐면 uncle의 color 가 레드일때입니다. 

지금 상황을 다시 정리하면 일단 Insert 하려는 노드의 색은 기본적으로 레드 입니다. 그리고 InsertFixup 으로 들어와서 검사를 시작하는데 
이 안에서 while 문 안으로 들어오려면 추가하려는 노드의 부모 노드 p 의 색상이 레드여야 합니다. 이것은 레드 블랙 트리의 4번째 조건에 부합 하지 않습니다. 
연달아 레드이기때문에 문제 상황이라서 무언가 조취를 취하려 while 문 안으로 들어온겁니다. 
그리고 나서 다시 p가 pp 의 왼쪽 자식일때 오른쪽 자식인 uncle 의 색상이 또 레드인 경우입니다. Insert 하려는 노드의 윗 항렬이 모두 레드인겁니다. 
이 상황에서 어떻게 해야 하냐면 p의 색상을 블랙으로, uncle 의 색상을 블랙으로, pp 의 색상을 레드로 바꿔줍니다.
			
그런데 여기서 끝낼 수 없습니다. 왜냐면 추가하려는 노드의 p 와 uncle , pp 의 색을 정해준것까지는 했는데 pp 의 색을 바꿨으니 pp의 p 의 색이 또 레드라면 
다시 4번 조건에 위배됩니다. 그래서 부모를 하나 건너뛰면서 위로위로 올라가면서 체크를 해줘야 합니다. 
어떻게 하냐면 while (node->parent->color == Color::red) 이 조건을 이용하면되는데 node = node->parent->parent 로 바꿔주고 다음 while 루프를 돌면됩니다. 
	
	// ...
	Node* uncle = node->parent->parent->right;
	if (uncle->color == Color::Red)
	{
		node->parent->color = Color::Black;			// p
		uncle->color = Color::Black;				// uncle
		node->parent->parent->color = Color::Red;	// pp
		node = node->parent->parent;
	}
	// ...
	
이렇게 하면 p 와 uncle 둘다 레드인 상황 베스트 케이스를 처리한겁니다. 

그러면 이제 이외의 상황을 또 처리해야합니다. 남은 케이스는 p는 레드, uncle은 블랙인데 이게 트라이앵글 구조인지 리스트 구조인지에 따른 두가지 케이스가 남았습니다.

트라이앵글 구조, 리스트 구조가 어떤 상황인지를 먼저 설명해보면 
		//		    [pp(B)] 
		//		[p(R)]   [u(B)]
		//		  [n(R)]

이렇게 임의로 모델링해본 트리에서 n 이라는 노드가 추가할 노드입니다. 지금 트리는 n과 p와 pp 가 한번꺽여져서 삼각형을 이루고 있는데 이걸 트라이 앵글 구조라고 하고 
		//		    [pp(B)] 
		//		[p(R)]   [u(B)]
		//	 [n(R)]
이렇게 n, p, pp 가 일렬로 이루어져 있으면 리스트 구조라고 합니다.

두가지 상황중 먼저 트라이 앵글을 기준으로 생각해보겠습니다.
트라이 앵글이라면 3번 상황 리스트 구조처럼 바꿔주고 시작해야 합니다. 그런데 지금은 이진 탐색트리로 각 노드의 크기에 따라 정렬이 되어 있습니다. 
그래서 그냥 n 을 p의 left 로 바꿔주는것은 안됩니다. 
방법은 n 과 p 를 바꾸고 p를 n의 left 로 삼는겁니다. 표현해보면 이렇습니다. 
		//		    [pp(B)] 
		//		[n(R)]   [u(B)]
		//	 [p(R)]  
이걸 로테이트 라고 하는데 이 기능을 하는 레드 블랙 트리 전용 함수를 만들어 주겠습니다. 
	
	void	LeftRotate(Node* node);
	void	RightRotate(Node* node);

좌 우 로테이션을 만들어 둘것인데 먼저 왼쪽 부터 보겠습니다. 

x , y 로 다시 예시를 들어 보겠습니다. 

		 [y]	
	 [x]     [3]
   [1] [2]	
이렇게 생긴 트리에서 x 와 y 를 로테이션 시킬겁니다. 

	  [x]     
   [1]   [y]
        [2] [3]
이상황은 이제 y 가 x 를 기준으로 오른쪽, 시계방향으로 회전한것 같은 모양세입니다. [2] 노드도 y 의 왼쪽으로 들어왔습니다. 
이게 오른쪽 회전 입니다. 

그러면 반대로 왼쪽 회전은 위 예시의 반대 상황입니다. y 가 반시계 방향 왼쪽으로 회전하면서 x가 y 의 왼쪽으로 내려갑니다. 그리고 [2] 는 x의 오른쪽으로 들어갑니다.
이것이 왼쪽 회전입니다.

왼쪽 회저 LeftRotate 의 코드는 아래와 같습니다. 

void BinarySearchTree::LeftRotate(Node* x)
{
	Node* y = x->right;

	x->right = y->left;

	if (y->left != _nil)
		y->left->parent = x;

	y->parent = x->parent;

	if (x->parent == _nil)
		_root = y;
	else if (x == x->parent->left)
		x->parent->left = y;
	else
		x->parent->right = y; 

	y->left = x;
	x->parent = y;
}
햇갈리지 않게 인자의 이름을 x 로 바꾸고 시작했습니다. 
	  [x]     
   [1]   [y]
        [2] [3]
이 모델을 따라서 y는 x 의 right 라고 만들어 줬습니다. 그리고 x 의 오른 자식을 y의 왼자식으로 설정하는데 이 부분은 모델에서 [2] 를 x 노드에 연결해주는 부분입니다.
그런데 이때 x 랑 y 는 _nil 이 아닌게 확실한데 [2] 에 해당하는 노드는 존재 할지 안 할지 아직 모릅니다. 그래서 체크를 해주는데 
[2] 에 해당하는 노드가 _nil 이 아니라면 부모가 x 라고 가리킵니다. _nil 이면 부모를 거리키지 않아도 됩니다. 
이제 [2] 는 옮겼고 y 노드를 x의 위쪽으로 옮길 차례입니다. 
먼저 y 의 부모가 x의 부모라고 넣어주는데 이때도 혹시 x 가 루트 노드여서 x의 부모가 _nil 일 수도 있습니다. 
그때는 y 노드가 _root 라고 가리킵니다.
x의 부모가 _nil 이 아니었다면 x가 x의 부모의 왼쪽 자식이었는지 오른쪽 자식이었는지를 체크해서 y에 알맞게 연결해줍니다. 
현재 [2] 에 해당하는 노드를 옮겼고 y를 x의 부모와 연결했습니다. 이제 x 노드를 y 노드 아래로 옮깁니다. 
y의 left 가 x 이고 x 의 부모가 y이다 까지 하면 왼쪽 회전이 됩니다. 

이제 오른쪽 회전 RightRotate 의 내용을 체워줍니다. LeftRotate 와 거의 대칭될것입니다. 

이제 이렇게 만든 두 함수를 가지고 이진 탐색 트리에서 두 노드를 회전 시킬수 있게 되었습니다. 

어쩌다 이 회전이 필요하게 되었냐면 InsertFixup 에서 트라이앵글 상황일때 를 설명하다 여기까지 왔습니다.
트라이 앵글 상황
 		//		    [pp(B)] 
		//		[p(R)]   [u(B)]
		//		  [n(R)]

	if (node = node->parent->right) // Triangle 타입
	{
		node = node->parent;
		LeftRotate(node);
		//		    [pp(B)] 
		//		[p(R)]   [u(B)]
		//	  [n(R)]
	}
노드를 부모쪽으로 한칸 올린 다음 왼쪽 회전으로 리스트 구조로 고쳐주게 되었습니다.

이쯤에서 다시 3가지 상황을 요약 해보겠습니다.
	//- 1) parent = red, uncle = red                
	//	   -> p = black, uncle = black, pp = red 로 바꿈
	//- 2) parent = red, uncle = black(triangle)   
	       -> 회전을 통해서 case 3으로 바꿈
	//- 3) parent = red, uncle = black(list)
	       -> 색상 변경 + 회전 

이제 case 3 의 색상 변경 + 회전 부분을 만들어 보겠습니다.
먼저 코드를 보고 어떤 수정을 하는지 알아보겠습니다.

	// List 타입
	node->parent->color = Color::Black;
	node->parent->parent->color = Color::Red;
	RightRotate(node->parent->parent);

이걸 모델링을 가지고 살펴보면
	    [pp(B)] 
	[p(R)]   [u(B)]
  [n(R)]

이 상황에서 p를 블랙으로 pp 를 레드로 바꾸고 pp 를 오른회전을 합니다. 
	    
	  [p(B)]   
  [n(R)] [pp(R)] 
			[u(B)]

결국 위 아래로 레드 레드 연달아 나오는 상황을 피하기 위해서 노드의 색을 적절히 바꾸고 회전도 해줬다고 할 수 있습니다. 

사실은 여기까지가 레드 블랙 트리의 Insert 코드의 끝이라고 할 수 있습니다. 나머지 p 가 pp의 오른쪽 자식일때만 처리해주면 됩니다.
대칭하게 코드를 처리해주고 난다음 InsertFixup 의 while 문 을 빠져나온 뒤 가장 마지막에 할 일은 _root->color 를 블랙으로 변경해주어야 합니다. 
레드 블랙 트리의 조건중에 루트는 항상 블랙이라는 조건이 있었기 때문입니다.


- 테스트 및 정리 
이제 테스트를 할 차례입니다. 
30, 10, 20, 25, 40, 50 을 Insert 해볼것입니다. 

레드 블랙 트리의 조건들을 지키면서 매 Insert 마다 어떻게 재배치가 될지 예상해보겠습니다. 

1 - 30 을 root 에 Insert 색은 root 니까 블랙
	     [30(B)]

2 - 10 을 30 의 left 에 Insert 10 의 색은 레드 
	     [30(B)]
      [10(R)]

3 - 20 을 10 의 right 에 Insert 하는데 10 도 레드 20도 레드 라서 InsertFixup 에 걸립니다. 이때 20 의 p 인 10 은 pp인 30의 left 이고 
	20 의 uncle 은 leaf 인 _nil(블랙) 입니다. 그러면 InsertFixup 의 2번째 case 트라이 앵글 구조이고 10 을 LeftRotate 합니다. 
			[30(B)]
		[20(R)] 
	[10(R)]
	이제 리스트 케이스에 들어서고 10 의 p를 블랙, pp 를 레드로 바꿔줍니다. 그리고  pp 를 RightRotate합니다. 
	    [20(B)] 
	[10(R)]   [30(R)]

4 - 25 를 30 의 left 에 Insert 합니다. 그런데 연달아서 레드 노드 입니다. InsertFixup 의 케이스 중 p 와 uncle 둘다 레드인 상황입니다. 
	이 경우 p 와 uncle 을 블랙으로 색을 바꾸고 pp 를 레드로 바꾸는데 25 의 pp 는 루트 노드이기 때문에 블랙으로 유지됩니다. 
		 [20(B)] 
	[10(B)]   [30(B)]
            [25(R)]

5 - 40을 30의 right 에 Insert 합니다. p가 블랙 노드 이니까 그냥 Insert 됩니다. 
		 [20(B)] 
	[10(B)]    [30(B)]
            [25(R)] [40(R)]

6 - 50 을 40의 right 에 Insert 합니다. 레드 노드가 연속되어 InsertFixup 에 진입합니다. uncle 도 레드 노드이기 때문에 색 변환만 일어납니다. 
	25 와 40 을 블랙으로 하고 30 을 레드노드로 바꿉니다. 
		   [20(B)] 
	[10(B)]       [30(R)]
                [25(B)] [40(B)]
                           [50(R)]


이렇게 예상한 과정과 실제 프로그램도 일치합니다. 
