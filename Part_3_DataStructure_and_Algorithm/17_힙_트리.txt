

        힙 트리


우선순위 큐를 지탱하는 힙 트리에 대해 알아볼겁니다. 

힙 트리도 결국 트리입니다.

- 이진트리 
먼저 이진 트리라는 개념을 알아보겠습니다.
이진트리는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 입니다.

여기서 유의할 점은 각 노드가 항상 두개의 자식노드를 가지고 있는것이 아니라 '최대' 두개의 자식노드를 '가질수' 있다는 점입니다. 
자식노드가 하나일수도, 두개일수도 혹은 아예없을 수도 있습니다. 

그래서 이전에 연결리스트를 배우면서 앞 뒤 양옆의 노드를 연결시키는 연습을 해보았기때문에 
이진트리도 노드를 이용해서 양옆으로 이어가면서 만들면 될것 같습니다.
정확히는 양쪽 자식트리를 연결하는것이긴 합니다. 

이진트리는 왜 필요한가? 
이진트리는 이진 검색 트리라고 해서 검색을 할때 특히 유용하다고 할 수 있습니다.
검색을 아무조건 없이 할 수 있는것은 아니고 데이터가 상위 노드에서 왼쪽타고 들어가면 값이 작아지고 오른쪽으로 타고 들어가면 값이 커지도록 
정렬이 되어 있어야 합니다. 이것이 전제조건입니다. 

이런 각 자식노드의 값들이 크기에 따라 정렬하는것 부터 꽤나 시간이 걸릴수 있겠다는 생각이 듭니다. 
하지만 어쩌다 보니 이미 이렇게 정렬이 되어잇다는 가정하에 이진 검색 트리는 효율적으로 원하는 값을 검색할 수 있습니다. 

만약에 관리하는 데이터의 크기가 천만단위로 많다라면 그 데이터들을 linear(선형적) 하게 관리하는것보다 이진트리로 관리하는것이 
훨씬 좋다고 합니다.
선형적 자료구조에서 어떤 데이터를 찾고 싶다면 가장 앞의 데이터부터 하나씩 확인하면서 내가 찾는 데이터인가를 체크해야 합니다. 
배열이나 동적배열은 임의접근이 가능하니까 빠르지 않겠냐는 의문이 생길 수 도 있는데 임의접근은 이미 그 데이터의 인덱스번호를 안다는 가정일때 
사용할 수 있습니다. 
이진 검색 트리에서 원하는 데이터를 검색할 때는 원하는 값이 루트 노드보다 크냐, 작냐 를 판별하면서 양쪽 자식노드 어디로 갈것인지를 정합니다. 
이 방식은 매 비교시도 마다 거의 절반씩 데이터를 쳐내면서 검색이 됩니다. 그렇기 때문에 천만개의 데이터가 있다고 했으면 첫번째 비교 시도에서 
오백만의 데이터를 처냅니다.

이진 검색 트리가 이런 이론만 보면 굉장히 아름답지만 데이터를 정렬해서 이진 검색 트리로 만드는 것 부터가 난제라고 할 수 있습니다.

만약에 이진검색트리안의 데이터가 1 부터 9 까지 정수로 이루어지도록 맨처음 만들었다고 해보겠습니다. 
그런데 이 트리에 데이터를 더 저장하면서 운이 나쁘게 10, 11, 12 라는값들이 추가 되었다고 해보겠습니다. 이러면 처음 만들었을때보다 오른쪽 자식노드 부분만 
비대해집니다. 이게 극한으로 가서 오른쪽으로 계속 데이터가 밀어 넣어진다면 이게 말이 좋아 이진 검색트리이지 
나중에 가면 연결리스트와 다를 바가 없어집니다. 
위에서 말했듯이 이진 검색 트리는 한번의 비교마다 거의 절반만큼식의 데이터를 날릴 수 있어야 의미가 있는데 한쪽 데이터만 많아지면 의미가 없어집니다. 

그래서 데이터가 불균형하게 추가되면 어떤 알고리즘에 따라 이진트리 전체를 다시 적절히 좌우 노드들의 균형이 맞도록 재배치 해주는것이 과제입니다.
지금 말한 어떤 알고리즘은 나중에 트리 탐색에 대한 시간에 더욱 자세히 알아보겠습니다. 

- 힙 트리 
일단 길찾기에서 필요한 트리는 이진 트리가 아니고 오늘의 주제인 힙 트리, 그리고 힙 트리를 기반으로 한 우선순위 큐가 중요합니다.

힙 트리가 무엇인지 알아보면 일단 힙 트리도 이진 트리이긴 이진 트리입니다. 
그런데 여기에 두가지 법칙이 있습니다. 
- 힙 트리 1 법칙 : [부모노드]가 가진 값은 항상 [자식노드]가 가진 값보다 크다.
-- 이 법칙에서 값이 크다는 부분은 하는 작업에서 찾고 있는 값이 큰값이라면 부모노드가 크게 해주고 작은 값을 찾고 있는것이라면 부모노드가 작게 해줍니다.

이 1법칙은 이진 검색 트리에 비해 대단히 널널한 조건입니다. 이진 검색 트리때는 좌우로 크고 작은게 나눠지고 거기에 그 조건이 자식 노드들 모두에 적용되야 했습니다.
힙 트리에서는 자식 노드들 보다 크기만 하면되고 그 이후 자식 노드들의 배치는 상관이 없습니다.

- 힙 트리 2 법칙 : 마지막 레벨을 제외한 모든 레벨에는 노드가 꽉 차 있어야 한다.(완전이진트리), 마지막 레벨에 노드가 있을 경우 항상 왼쪽 부터 채워야 한다.
- 위의 조건을 적용하면 이런 성질을 띄게 됩니다. '노드 개수를 알게 되면, 트리 구조를 무조건 확정할 수 있다'

그래서 이 두가지 법칙을 유의 하면 힙트리 구조는 누워서 떡먹기라고 합니다. 

특히 두번째 법칙을 활용하면 유용한 특징을 알 수 있는데 힙 트리를 연결리스트 처럼 각 노드의 포인터를 들고 있게 해서 관리 하지 않아도 되고 
배열로 관리 할 수 있다는 겁니다. 
어째서 배열로 관리 할 수 있는것이냐면 배열로 힙 트리를 이루는 노드의 개수를 알게 되면 바로 힙 트리의 구조를 알 수 있고 그 구조에 따라 
배열의 원소들을 배치하면 되기 때문입니다. 

예시로 노드가 5개인 힙 트리가 있다고 하겠습니다. 위에서 말했듯이 이 힙 트리를 동적배열로 관리해보겠습니다. 
vector<int> heap(5);

이 heap 에는 각 원소들이 크기 순서대로 담겨 있어야 하고 
이때 이런 규칙으로 힙 트리의 구조를 알 수 있습니다. 
1) i 번 노드의 왼쪽 자식은 [(2*i) + 1] 번
2) i 번 노드의 오른쪽 자식은 [(2*i) + 2] 번
3) i 번 노드의 부모는 [(i-1)/2] 번      // 이때 계산값이 소수점이 나올텐데 C++ 이나 C# 특성상 정수 타입에 소수점이 생기면 그냥 날립니다.

이런 특징으로 힙 트리는 코드상에서 사실 배열로 관리를 할 수 있다는 것을 기억해야 합니다. 
좀 있다가 실습에서 이 부분을 적극적으로 활용할것입니다.

이제 힙 트리에 새로운 데이터를 추가 하면 어떤 과정으로 정렬되는지 한번 생각해 본 다음 실습으로 넘어 가겠습니다. 
- 상황 : 어떤 힙 트리에 새로운 데이터가 추가 되었다
-- 1단계 : 힙 트리 2 법칙에 의해 먼저 트리 구조를 맞춰서 데이터를 추가 해줍니다.
--- 어떤 값이건 간에 일단 힙 트리의 원소 개수가 하나 늘었다는 것이니까 힙 트리의 구조는 확정 할 수 있기 때문입니다. 
-- 2단계 : 힙 트리 1 법칙에 의해 새로 추가된 노드는 자신의 부모 노드와 값을 비교하면서 도장깨기를 한다 부모의 값이 자신의 값보다 크다면 정지
--- 도장깨기가 뭐냐면 힙 트리에서 자신의 부모노드의 인덱스를 알 수 있는 식이 있었는데 이것으로 부모의 값과 자신의 값을 비교해서 
    자신이 더 크다면 자리를 뒤바꾸는 것입니다. 

이 두가지 단계를 거치면 새로운 데이터를 추가해도 힙 트리의 조건에 맞도록 재배치가 됩니다.

이번에는 데이터를 추가하는것이 아닌 데이터를 꺼내는 과정을 보겠습니다.
그런데 힙 트리에서는 중간의 데이터를 빼내는것이 아닌 최상위에 있는 데이터만 꺼내가게 됩니다. 
힙 트리를 사용하는 이유는 모든 데이터들을 관리하고 원하는 값을 꺼내는것이 아닌 관리하는 데이터중 가장 큰 값, 혹은 가장 작은 값 꺼내 써야할 필요가 있을때 
장점을 가지는 자료구조입니다.

- 1 단계 : 최상위의 노드를 꺼내 사용합니다. 
-- 이렇게 되면 힙 트리의 전체 개수가 하나줄게되고 루트 노드가 사라집니다. 
- 2 단계 : 가장 마지막의 데이터를 루트로 옮깁니다. (힙 트리 2법칙을 만족)
-- 중간에 있는 데이터가 아닌 가장 마지막에 추가된 데이터를 루트 노드로 옮깁니다.
- 3 단계 : 역 도장깨기를 한다 (힙 트리 1법칙을 만족)
-- 역 도장깨기는 이제 루트 노드 부터 자식노드들과 비교해서 자신이 작으면 그 노드와 교체하는겁니다. 
-- 과정은 먼저 두 자식 노드 둘 중 더 큰값을 찾습니다. 큰 값과 자신을 비교합니다. 자신이 작아서 자리 교체를 했다면 다시 반복합니다. 

이렇게 힙 트리의 개념과 특징, 데이터를 넣어서 재배치 하는과정, 최상위 데이터를 꺼낸 다음 재 배치하는 과정을 배웠습니다. 
코드로 실습하는것보다 일단은 이 내용을 이해하는것이 중요합니다. 

힙 트리, 우선순위 큐 를 배우기 시작한 이유는 
이전 시간 다익스트라 알고리즘에서 발견한 노드들 discovered 중에 가장 코스트가 좋은 노드를 찾기위해서 모든 노드를 for 문으로 순회하면서 비교 했었던 것을
지금 배운 힙 트리 처럼 가장 좋은 값을 꺼내기 쉬운 자료구조를 적용하기 위해서 배웠습니다.

이제 두 방법 이전처럼 리스트나 배열로 discovered 를 관리하는것과 힙 트리로 discovered 를 관리하는것의 시간복잡도를 비교해보면 
리스트나 배열은 O(N) 이었고 힙 트리에서는 O(logN) 입니다. 

part 3 처음에 배웠던 것 처럼 N 과 logN 의 차이는 데이터 개수가 많아질 수록 차이가 많이 납니다. 

마무리 하면서 직접 이해한 내용을 공책에 그려서 복습 해보는 시간을 가져 보겠습니다. 