

        그래프


좀 더 복잡한 알고리즘을 위해서 그래프 라는것을 배워야 합니다. 

일단은 그래프가 무엇인지부터 알아야 겠습니다.

    그래프란? : 현실 세계의 사물이나 추상적인 개념 간의 연결관계를 표현 한다라고 합니다. 

    그래프를 이루는 두가지 요소가 있습니다. 정점(vertex)과 간선(edge)라고 합니다. 
    정점 vertex : 그래프 상의 점으로 표현, 데이터를 표현합니다. 사물, 개념 등 
    간선 edge : 정점들을 연결하는데 사용

이렇게만 설명을 들으면 잘 감이 오지않습니다. 
예시를 들면 인간관계도나 마인드 맵 같은 이미지를 떠올리면 어떤 데이터 들이 점점히 있고 그 사이에 연관관계 같은 기준으로 
간선이 이어져 있는 이미지를 본 적이 있을겁니다. 이런게 그래프라고 할 수 있을것 같습니다. 

이전 시간들에서 배운 내용으로 말하면 연결리스트 같은 선형 자료구조는 노드 사이에 앞뒤에 데이터가 있을 수 있지만 결국은 선형으로 만들어지는것에 비해서 
그래프에서는 그런 제약이 없습니다. 어떤 데이터와 연결되는 다른 데이터가 1개일수도 있고 5개일수도 있고 그렇습니다. 

그러면 이런 그래프를 어디에 사용할 수 있는지 궁금한데 그래프가 활용되는 곳은 정말 다양합니다. 
예를 들면 도로 교통망, 소셜 네트워크에서 친구 추가 관계 같은 것이 있을겁니다. 예시들은 선형으로 표현할 수 없고 1 대 다수 의 관계를 맺을 것입니다. 
그런 복잡한 관계를 그래프를 통해서 표현할 수 있습니다. 

물론 그래프에도 종류가 많습니다. 기본적으로 정점과 간선들로 만든 기본 그래프도 있고 간선에 가중치를 두는 가중치 그래프(Weighted Graph) 라고 합니다. 

가중치 그래프는 연결 관계 뿐만 아니라 연결된 간선에 어떤 수치를 준다고 해보겠습니다. 
예를 들어 지하철 노선도인데 각 역 사이에 어떤 수치가 있습니다. 어떤 파라미터를 가중치로 주는지에 따라 역의 이동 인구등 같은 데이터를 나타 낼 수 도 있을 겁니다. 

또 방향 그래프 (Directed Graph) 라는 것도 있는데 그래프의 정점들이 서로 양방향으로만 가리키는게 아니라 한 방향을 가리키는 간선으로 표현되는 그래프입니다. 
이런 방향 그래프의 경우 어떤 경우에 활용되냐면 일방통행 도로망이나 아니면 인물들 사이의 호감도 같은걸 표현 할 수 있을것 같습니다. 

그래서 다양한 종류의 그래프로 다양한 데이터를 표현할 수 있다는걸 알았습니다.
이제 이 내용을 C++ 코드로 어떻게 구현할 수 있는지 고민해보겠습니다. 

- 코드 

일단 Algorithm 프로젝트를 시작 프로젝트로 설정하고 여기서 실습을 해보겠습니다. 

목표는 방향 그래프와 가중치 그래프를 만들어 보는것입니다. 

-> 노드 기반의 방향 그래프 1

    void CreaetGraph_1()
    {
        struct Vertex
        {
            vector<Vertex*> edges;
            // int _data;
        };

        vector<Vertex> v;
        v.resize(6); 

        v[0].edges.push_back(&v[1]);
        v[0].edges.push_back(&v[3]);
        v[1].edges.push_back(&v[0]);
        v[1].edges.push_back(&v[2]);
        v[1].edges.push_back(&v[3]);
        v[3].edges.push_back(&v[4]);
        v[5].edges.push_back(&v[4]);

        // Q. 0번 -> 3번 정점이 연결되어 있나요?
        bool connected = false;
        for (Vertex* edge : v[0].edges)
        {
            if (edge == &v[3])
            {
                connected = true;
                break;
            }
        }
    };

    연결리스트를 배울때 사용했던 Node 는 이전 노드와 다음 노드만 들고 있었습니다. 그런데 그래프라는 자료구조는 앞뒤 데이터만 가리키는게 아니라 
    필요에따라서 수 많은 데이터들을 가리키도록 만들어야 합니다. 
    그래서 가리킬 노드를 필요에 따라 늘리도록 vector 에 담아서 관리해주겠습니다. 또 실 사용에서는 데이터를 들고 있을것이지만 지금은 테스트로 그냥 
    누굴 가리키고 있는지만 테스트하겠습니다. 

    이렇게 만든 Vertex 를 가지고 정점이 6개인 그래프를 만들어 보았습니다. 그리고 몇번 정점이 누구를 가리키고 있는지도 
    하나하나 입력해 줬습니다. 
    
    이렇게 그래프를 표현했는데 만약 0번 정점이 3번을 가리키고 있는지를 체크하고 싶다면 가리키는지 아닌지를 알려줄 bool 변수를 하나 만들고 
    v[0] 의 edges(기리키는 정점들) 을 순회 돌면서 그 중에 v[3] 의 주소가 있는지를 체크하고 있습니다. 

이렇게 우리가 이전 선형 자료구조에서 배웠던 내용 안에서 직관적으로 만들어 봤습니다. 
여기서 더 개선할 점이 있는지를 생각해보자면 서로 가리키는 정점들을 포인터로 물고 있는것도 거슬리고 
나중에 가면 실제 데이터와 간선을 분리해서 관리하는게 더 유용한 상황이 생기기도 한다고 합니다. 지금 구조는 구현은 안했지만 
Vertex 라는 구조체 안에 실제 데이터와 간선들을 같이 관리하고 있습니다. 

이제 CreaetGraph_1 를 수정해보겠습니다. 

-> 연결된 정점들을 실제 데이터와 분리해서 관리하는 방법 

    void CreateGraph_2()
    {
        struct Vertex
        {
            // int _data;
        };

        vector<Vertex> v;
        v.resize(6);

        vector<vector<int>> adjacent(6);

        adjacent[0] = { 1, 3 };
        adjacent[1] = { 0, 2, 3 };
        adjacent[3] = { 4 };
        adjacent[5] = { 4 };

        // Q. 0번 -> 3번 정점이 연결되어 있나요?
        bool connected = false;
        for (int vtx : adjacent[0])
        {
            if (vtx == 3)
            {
                connected = true;
                break;
            }
        }
        // STL
        vector<int> adj = adjacent[0];

        bool connected_2 = (std::find(adj.begin(), adj.end(), 3) != adj.end());
    };

    이번에는 정점은 실제 데이터만 들고 있고 서로 어떻게 연결되었는지는 외부에서 2차 벡터로 관리하는 방법입니다. 

    2차 벡터 부분부터 설명을 해볼건데 vector<int> 를 현재 그래프에서 사용할 정점의 갯수 만큼 만들었습니다.

    그러면 각 정점의 인덱스에 int 형 데이터들을 밀어 넣어 줄 수 있는데 이것으로 각 정점이 어느 정점을 가리키고 있는지 인덱스를 줍니다. 

    이 내용에 맞춰서 아까 0번 정점이 3번 정점을 들고 있는지를 판별하는 코드를 수정 해줘야 하는데 
    순회를 도는 데이터의 타입이 이제는 포인터가 아니라 인덱스로 관리하고 있습니다. 

    그리고 for 문 말고 STL 로 찾고 싶다면 connected_2 와 같이 찾을 수도 있습니다. 


간선의 연결을 2차 백터로 관리하는 방법이었습니다. 
여기서 다시 생각을 해봐서 이게 정말 최선의 방법인지를 고민해보았습니다. 
지금 이 방법도 충분히 좋지만 좀 비효율 적일 경우를 찾아보았습니다.

예를 들어서 정점이 100 개 정도 있다고 하고 
지하철 노선도라고 해보겠습니다. 지하철 노선도는 보통 각 역이 빽빽 하게 연결되어 있지는 않습니다. 환승역이 아니라면 앞 뒤 역과 선형적으로 연결되어 있는 경우가 
많고 환승역일때는 좀 연결이 많아 지는 경우가 있습니다. 
이 예시는 지금 위에서 한 2차 벡터로 관리하기 용이한 경우 입니다. 

반면 이번에는 소셜 네트워크 라고 해보겠습니다. 한 반에 100 명이 있는데 서로서로 너무 친해서 각각 모든 반 친구들을 전부 친구 추가 했다고 하겟습니다. 
이러면 위의 코드를 가져와서 예시를 들어보면 
adjacent[0] = { 1, 2, 3, 4, ... , 99 };
...
이렇게 연결하는 데에도 수고스럽고 더욱 여기서 어떤 정점이 다른 정점과 이어져있는지를 확인하려면 이것도 성능을 많이 잡아 먹습니다. 

이런 경우에 사용할 다른 방법이 있다고 합니다. 메모리를 희생해서 성능을 향상 시키는 방법이라는고 합니다. 

-> 정점들의 연결을 행렬로 관리하는 방법 

    void CreateGraph_3()
    {
        struct Vertex
        {
            // int _data;
        };

        vector<Vertex> v;
        v.resize(6);

        // 연결된 목록을 행렬로 관리 
        //	[X][O][X][O][X][X]
        //	[O][X][O][O][X][X]
        //	[X][X][X][X][X][X]
        //	[X][X][X][X][O][X]
        //	[X][X][X][X][X][X]
        //	[X][X][X][X][O][X]

        // 읽는 방법 : adjacent[form][to]
        // 행렬을 이용한 그래프 표현(2차원 배열)
        // 메모리 소모가 심하지만 빠른 접근이 가능
        // (간선이 많은 경우 이점이 있다.)
        vector<vector<bool>> adjacent(6, vector<bool>(6, false));

        adjacent[0][1] = true;
        adjacent[0][3] = true;
        adjacent[1][0] = true;
        adjacent[1][2] = true;
        adjacent[1][3] = true;
        adjacent[3][4] = true;
        adjacent[5][4] = true;

        // Q. 0번 -> 3번 정점이 연결되어 있나요?
        bool connected = adjacent[0][3];
    };

    행렬로 간선을 관리하는 방법은 정점의 실제 데이터와 간선을 분리하는 부분까지는 똑같고 간선을 어떻게 만드는지가 다릅니다. 
    간선의 연결상태 adjacent 를 6열 6행의 bool 타입 행렬로 만들어서 기본 값을 false 로 만들어 줬습니다. 
    그리고 각각 어떻게 연결되어있는지 인덱스로 접근해서 true 로 수정해줬습니다. 
    이렇게 만드니까 연결되어있는지를 체크하는 코드가 매우 단순하게 해당위치의 bool 값을 가져오면 되었습니다. 


이제 방향 그래프를 만드는 몇가지 방법에 대해 알아 봤습니다. 
다음은 가중치 그래프는 어떻게 만들지에 대해 고민해보겠습니다. 
가중치는 간선과 같이 관리하는게 좋을것 같은데 

위에서 알아본 2차 벡터를 인덱스로 활용하는 방법에서는 들고 있을 간선정보를 단순히 인덱스로 관리하는게 아니라
std::pair 로 인덱스와 가중치를 같이 들고 있게끔 해줘도 될것같습니다. 

이게 아니고 행렬을 이용한 방법은 좀 더 간단하게 행렬안의 원소 타입을 bool 이 아니라 가중치를 나타내는 타입으로 직접 만들어 주면 편할것 같습니다. 

-> 가중치 그래프의 표현 방법 
    // 2차 벡터
    
	// 가중치 표현 
	pair<int, int> ;

	vector<vector<pair<int, int>>> adjacent2(6);

	adjacent2[0] = { { 1,15 } , { 3, 35 } };
	adjacent2[1] = { { 0, 15 } , { 2, 5 } , { 3 , 10 } };
	adjacent2[3] = { { 4, 5 } };
	adjacent2[5] = { { 4, 5 } };

	// Q. 0번 -> 3번 정점이 연결되어 있나요?
	bool WeightConnected = false;
	for (pair<int, int> vtx : adjacent2[0])
	{
		if (vtx.first == 3)
		{
			connected = true;
			break;
		}
	}
	// STL
	vector<pair<int, int>> WeightAdj = adjacent2[0];

	bool WeightConnected_2 = (std::find(adj.begin(), adj.end(), 3) != adj.end());

    std::pair 를 활용하였습니다. 


    // 행렬 

    
	// 가중치 표현 
	vector<vector<int>> adjacent2 = 
	{
		vector<int> { -1, 15, -1, 35, -1, -1},
		vector<int> { 15, -1, +5, 10, -1, -1},
		vector<int> { -1, -1, -1, -1, -1, -1},
		vector<int> { -1, -1, -1, -1, +5, -1},
		vector<int> { -1, -1, -1, -1, -1, -1},
		vector<int> { -1, -1, -1, -1, +5, -1},
	};

	// Q. 0번 -> 3번 정점이 연결되어 있나요?
	bool connected2 = adjacent2[0][3] > -1;

	// Q2. 0번 -> 4번의 가중치는 얼마인가요?
	int weight = adjacent2[0][4];

    여기서는 가중치가 -1 이면 연결되어 있지 않다는 의미라고 정했습니다. 


- 결론
이렇게 해서 그래프의 개념과 기초적인 구현을 해보았고 
다음 시간부터 그래프를 구체적으로 어떻게 활용해야 할지를 알아보겠습니다. 