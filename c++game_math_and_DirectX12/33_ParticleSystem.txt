

33. Particle System


이번시간에 배울 파티클시스템은 이것 자체로도 뿐만 아니라 다른 개념들의 이해에 도움이 되는 개념 입니다. 

바로 전 강의에서 배운 Compute Shader , 이론으로만 배운 Geometry Shader, Structured Buffer 등 아직 배우지 않은 내용도 오늘 곂치게 될겁니다. 

파티클 시스템이란 
무엇이냐면 그냥 파티클 은 입자라는 뜻인데 어떤 입자를 하나만 그냥 사용하지는 않고 하나의 시스템으로 여러 파티클을 사용하기 때문에 
파티클 시스템이라고 부릅니다. 
사용하는 곳은 게임에서 이펙트(연기, 빛무리, 불꽃 등) 을 만들때 사용합니다. 이런 파티클들은 이펙트이다 보니깐 출력되고 나서 가만히 있는것이 아니라 움직입니다.

이런 파티클 시스템을 적용시킨후의 우리 테스트 프로그램은 이전 시간 상태에서 구체 가운데부터 여러개의 방울들이 사방으로 랜덤하게 막 뿌려지는 상태가 될것입니다. 

이런 결과물을 오늘 주제인 파티클 시스템을 배우지 않고 구현한다고 생각한다면 이때 까지 배운 내용으로는 생각할 수 있는것이 
SceneManager::LoadTestScene 에서 구체나 UI 오브젝트를 만들었듯이 수만은 방울 모양 오브젝트를 생성하면서 사방으로 흩뿌리는 방법이 생각납니다. 
하지만 이런 방법으로는 수만은 오브젝트들을 별 의미없이 많은 부하를 가져올 수 있을겁니다. 

여기서 수많은 오브젝트들을 만드는 방법은 CPU 에서 렌더링 파이프라인을 방울들 하나씩 전부 거치면서 생성해주는 방법입니다.

이렇게 무거운 작업을 파티클에 사용하는것은 본말전도일것입니다. 게임에서 그정도로 성능을 잡아먹을 만한 이펙트는 없을겁니다. 

그러면 어떻게 이 파티클 시스템을 사용해야할까요
정답은 Instancing 이라는 기술을 사용할것입니다. 인스턴싱이란 기술을 처음 들은것 같지만 사실은 이미 우리 코드에서 인스턴싱을 활용하고 있었습니다. 
어디에서 찾아 볼 수 있냐면 

Mesh::Render() { (생략)  GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, 1, 0, 0, 0); }

이런 코드가 Mesh 클래스 안에 있었습니다. 이 함수의 인자중에 두번째 인자인 1은 어떤 정보가 들어가야 하냐면 InstanceCount 가 들어갑니다. 
우리가 메쉬 코드를 사용해서 물체를 하나씩만 그려줄 용도로 InstanceCount 를 1 을 준겁니다. 
그렇지만 이제 우리가 물체를 하나가 아니라 여럿을 그리고 싶다고 한다면, 그리고 파티클 시스템을 사용할것이라고 한다면 이 DrawIndexedInstanced 라는 함수의 두번째 인자에 
1 이 아니라 원하는 갯수의 물체 만큼을 입력해야 합니다. 

그렇게 되면 렌더링 파이프라인의 IA 단계에서 Vertex 정보, Index 정보, Topology 정보등을 한번 넘겨주지만 이 한번의 정보로 InstanceCount 로 준 횟수만큼 반복해서 
물체를 만들어 낼것입니다. 

결국 파이프라인을 천번씩 반복한다면 무엇이 다른가 할 수 있는데 다른점이 무엇이냐면 최초의 정점 데이터 등등을 넣어주는 횟수가 한번으로 줄어들게 되는것이 다릅니다. 
지금까지 만들었던 큐브같은 정점데이터 말고 좀 더 복잡한 메쉬였다면 이 메쉬를 매번 넘겨주는 작업만 해도 무시못하였을 것이고 정보들을 IA 단계로 넘기면서 그때 
처리해야할 렌더링 세팅값들이 최초의 한번으로 퉁치고 나머지 작업부터 반복실행 되는 장점이 있습니다. 
이 과정을 유식하게 표현하면 Draw Call 을 줄인다 라고 한답니다. 

그러면 인스턴싱으로 물체를 여러개 만드는 것까지 알겠는데 이 물체들 각각을 구별 할 수 있어야 의미가 있을것입니다. 
이펙트의 파티클들 도 전부 동일한 위치에 곂쳐서 나타나는게 아니라 불규칙한 모양으로 생성되고 움직이듯이 말입니다. 
인스턴싱을 사용해서 여러개의 물체를 그릴 때 인풋값을 한번만 준다고 했는데 입력 값이 동일하다더라도 구분할 수 있는 id 값같은게 있어야 하지 않을까 싶습니다. 

그러기 위해 하나의 물체가 들고 있는 정보가 지금은 position, uv, normal, tangent 이렇게 있는데 여기에 추가로 SV_InstanceID 라는 것을 하나더 들고 있고 
인스턴스가 반복 될 때 마다 물체의 인스턴스 ID를 하나씩 발급 받으면 될것 같습니다. 
이제 이 ID 를 가지고 각 번호에따라 각각 어떻게 위치하거나 움직이라고 처리해주면 되겠습니다.

인스턴싱으로 만든 수많은 물체들을 각각 어떻게 특정할지를 알았습니다. 그러면 이제 문제는 특정한 이 물체들에게 어디에 위치할지, 어디로 움직일지, 스케일은 어떻게 될지 
같은 정보를 어떻게 넘겨줘야할지 입니다. 

지금까지 배운 내용에서 생각하기로 정보를 넘겨줄때 그 정보들을 전역으로 관리해서 각각 순서에 맏는 정보들을 받아 사용하면 어떨까요 
이런 방법이 빛의 정보를 넘기기 위해 사용했었습니다. LightInfo 를 50 짜리 배열로 만들어서 넘긴다음 셰이더에서는 g_light[50] 이라는 이름으로 관리하고 
실제 만든 빛의 갯수를 g_lightCount 라고 관리하고 그랬습니다.

이 방법의 단점은 처음에 정한 데이터의 양을 조절하지 못합니다. 무슨 말이냐면 위의 경우인 빛 정보같은 경우도 LightInfo 가 50 개 까지 들고 있을 수 있게 해놨지만 
실제로 3개의 빛만 사용한다고 해도 나머지 47개의 용량을 그냥 들고 있어야 합니다. 즉 이 버퍼의 사이즈가 정해져서 사용됩니다. 

또 하나의 단점이 있는데 버퍼의 사이즈가 정해져 있다는 단점에도 불구하고 Constant Buffer 를 사용한다고 할때  CPU에서 GPU로의 전송 비용이 많이 발생합니다. 
Constant Buffer 를 사용하는 방법으로 CPU에서 필요한 계산을 해준 다음 GPU로 계산 결과를 넘겨준후 그걸 GPU에서 출력을 해주는 방법으로 사용했었습니다. 
그리고 Constant Buffer 상수 버퍼라는 이름이 붙은 이유가 GPU에서는 이 상수버퍼를 읽기용도로만 사용할수 있는 상수 같다고 해서 붙여진 이름입니다. 
이런 상황에서 CPU <-> RAM , GPU <-> VRAM 간의 데이터 전송속도에 비해서 CPU <-> GPU 사이의 데이터 전송속도가 느리다는 특징이 있었습니다. 

이 두가지 단점 Constant Buffer 를 만들때 실제로 사용할 데이터가 1개 일때나 1000개 일때나 항상 최대 크기인 1000개로 만들어야 한다는 점과 
CPU에서 모든 계산을 마치고 GPU로 느린속도로 데이터를 전송해야 한다는 점이 곂치게 됩니다. 

이런 이유로 지금까지 빛정보를 사용하기 위해 넘기던 상수 버퍼 대신 사용할 방법을 찾아야 합니다. 
그 방법으로 StructuredBuffer 구조화 버퍼라는 방법이 있습니다. 

ConstantBuffer 나 StructuredBuffer 둘 다 사용하는 프로그래머 입장에서는 정보를 넘기기 위한 버퍼라는것은 별 차이없습니다. 
그렇지만 각각의 미묘한 차이가 있는데 
접근 속도로만 보면 ConstantBuffer 가 접근속도가 더 빠르기는 한데 큰 용량을 사용할 수 없다는 단점도 공존합니다. 
반면 StructuredBuffer 같은 경우에는 사이즈 자체를 유동적으로 정해 줄 수 있다는 점이 있습니다. 

상수버퍼를 정의할때 이미 사용할 정보의 타입과 갯수를 미리 정의하고 시작하는 것에 비해 구조화 버퍼는 딱히 갯수에 대한 정보가 없습니다. 
또 이 구조화 버퍼를 컴퓨트 셰이더에서 활용할때는 읽기/쓰기 용 버퍼로 u 레지스터 슬롯에 묶던지 아니면 그래픽스 로 활용할때는 t 레지스터 슬롯에 묶는데 
t 레지스터는 이전에 텍스쳐를 묶을때 사용하던 레지스터 였습니다. 
그리고 텍스쳐 크기는 CPU 쪽에서 정해주는 것에 따라 달라지는 거였지 셰이더 쪽에서 텍스쳐가 예를들얼 800 x 600 이라는걸 명시해 주지 않았습니다. 
그러니까 구조화 버퍼는 GPU 레지스터 쪽에 묶어 주는 순간에 버퍼 크기를 정할 수 있다는 장점이 있습니다. 

이번 시간에 어떻게 파티클 시스템을 구조화 버퍼로 넘겨줄거냐면 CPU 에서 버퍼의 모든 계산을 다 한다음 GPU로 넘겨주는게 아니라 
CPU 가 파티클들의 대략적인 묘사를 GPU 에 건내주면 GPU에서 묘사된 버퍼를 계산해줄 겁니다. 

이런 방식이 괜찮은 이유가 뭐냐면 파티클들이 움직이는 방향은 대단히 중요한 점이 아니고 적당히 랜덤히 움직여 주면 되기 때문에 이런 계산까지 꼭 CPU 에서 계산을 해줄 필요가 
없습니다.
일단 이렇게 적은 용량의 데이터를 GPU에 넘기게 되면 CPU,GPU 간의 느린 데이터 전송속도를 극복할 수 있을 것입니다. 
이게 구조화 버퍼를 사용하는 첫번째 이유가 될것이고 

그 다음에 구조화 버퍼의 경우에는 상수버퍼와 다르게 동작한다고 했었습니다. 구조화 버퍼도 리소스이긴 하기 때문에 VRAM 에 크게 할당하게 될것입니다.  
구조화 버퍼는 말하자면 배열이라고 보면 됩니다. 그래서 파티클이라는 struct 가 있는데 이걸 가지고 StructuredBuffer 를 만들게 되면 
아직 사이즈가 정해지지않은 배열을 만들어 준다고 보면 되겠습니다. 물론 만들어진 다음에는 사이즈가 고정이지만 CPU 에서 묶일때 는 정해주는대로 사이즈를 
변경할 수 있습니다.
그러면 이제 VRAM 에 CPU 에서 묶은 만큼의 struct들의 배열인 StructuredBuffer 를 할당 했다면 이제 이 배열에 연산한 결과들을 채워주면 될것입니다. 
이 연산을 어디서 하냐면 아까 말했던 u 레지스터 슬롯을 사용하는 컴퓨트 셰이더 에서 연산을 해줄 것 입니다. 
컴퓨트 셰이더에서 파티클들의 위치나 움직일 방향, 속도나 이 파티클이 생존해 있는 시간 같은걸 연산해줍니다. 

이 다음 문제 입니다. 파티클을 1000개 만드는 작업을 한다고 해도 1000개의 파티클이 실질적으로 동시에 존재 한다는 의미는 아닐겁니다. 거품이 뿜어지는 이펙트를 생각하면 
프레임 단위로 나눠서 첫 프레임부터 1000개의 거품이 발생하는게 아니고 시작할때의 프레임에는 한두개의 거품이 있을것이고 그 거품들도 언제 까지고 존재하는게 아니라 
일정 시간이나 거리를 이동하면 점차 사라질것입니다. 
파티클이 생겨나고 사라지는것은 파티클 struct 에서 멤버로 살아있는지 아닌지를 판별할 변수를 하나 들고 있고 이것에 따라 화면에 그려주던가 안그려주던가 하면될것입니다. 

이제 또 문제가 그러면 해당 파티클을 안그려준다는 것은 어떻게 해야하는가 하면 지금까지 배운내용에서 생각하면 해당 파티클이 죽었다면 이 파티클을 카메라에서 안보이는 곳으로 옮겨서 
Culling 을 해준다던지 하는 방법이 있을겁니다. 

좀 더 효율적인 방법은 이제부터 배울 Geometry Shader 단계에서 하는 방법입니다. 이 Geometry Shader (이하 GS) 에서는 도형 자체의 정보를 수정할 수 있습니다. 
어떤 정점을 제거할 수도 있고 추가 할 수도 있고 그래서 어떤 파티클이 그려지지 않아야 한다면 GS에서 끊어줄것이고 그려져야 한다면 그대로 통과해서 그려주게 됩니다.
예시입니다. 

[maxvertexcount(6)]  // 최대 정점 갯수를 정의 해주고 있습니다. 6개의 정점으로 삼각형 두개를 붙혀 사각형을 만들수 있는 갯수입니다. 
void GS_Main(point VS_OUT input[1], inout TriangleStream<GS_OUT> outputStream)  // 인자로 정점들로 만든 삼각형이 아니라 정점 하나만 받고 있습니다. 
{                                                                               // 두번째로 받는 인자인 함수는 삼각형의 정점들의 목록을 만들어 넣어주면 그것으로 삼각형의 
    GS_OUT output[4] =                                                          // 정점이 만들어져 그려지게 됩니다.
    {
        (GS_OUT)0.f, (GS_OUT)0.f, (GS_OUT)0.f, (GS_OUT)0.f
    };

    VS_OUT vtx = input[0];
    uint id = (uint)vtx.id;
    if (0 == g_data[id].alive)      // 이부분에서 인풋 받은 정점의 데이터중에 alive 가 0 이라면 그려줄 필요가 없고 바로 리턴을 해버려서 사실상 소멸합니다.
        return;
        
    output[0].position = vtx.viewPos + float4(-scale, scale, 0.f, 0.f);  // alive가 0이 아님을 통과 한후 인풋으으로 받은 정점을 가지고 나머지 정점들을 계산해서 만들고 있습니다.
    output[1].position = vtx.viewPos + float4(scale, scale, 0.f, 0.f);
    output[2].position = vtx.viewPos + float4(scale, -scale, 0.f, 0.f);
    output[3].position = vtx.viewPos + float4(-scale, -scale, 0.f, 0.f);

    outputStream.Append(output[0]);     // 삼각형을 구성할 각 정점들을 순서대로 Append 해줍니다. 
    outputStream.Append(output[1]);
    outputStream.Append(output[2]);
    outputStream.RestartStrip();        // RestartStrip 이라는 메소드를 실행하면 여기서 삼각형 한개를 마무리하고 다음 삼각형의 정점들을 받아줄 준비를 합니다. 

    outputStream.Append(output[0]);     // 두번째 삼각형
    outputStream.Append(output[2]);
    outputStream.Append(output[3]);
    outputStream.RestartStrip();
}

Geometry Shader 라는것이 새로운 셰이더 개념이다 보니까 어렵게 느껴 질 수 있는데 한번 정리해보면 생각보다 간단합니다. 
셰이더의 한 단계이고 어떤 정점 을 받아서 GS_Main 이라는 함수 내에서 이 정점이 그려질지 안그려질지를 판별해서 정점을 없애거나 삼각형으로 그려주거나 하는 역할을 합니다. 

이렇게 이번 강의의 오리엔테이션을 보았고 다시 한번 정리 해보겠습니다. 
결국 우리가 하고 싶은것은 파티클 시스템을 구현하고 싶은건데 현재까지 배운 기술로는 성능상 너무 느리다 보니까 인스턴싱이라는 기술을 사용해서 파티클시스템을 구현하려고 합니다. 
인스턴싱은 물체를 처음그릴때 몇개의 물체를 그릴지를 선택할 수 있는거고 그렇게 선택을 하게 되면 우리가 선택한 갯수만큼 렌더링 파이프라인이 반복을 할것이다. 
이때 각각의 파티클들을 따로 관리할 수 있도록 ID값을 하나씩 붙여야하는데 이 ID값은 SV_InstanceID 라는 것으로 추적을 할 수 있다는 것 이 ID에 따라 물체를 그려줄것인지 무시할것인지를
알 수 있게 된다.
이때 물체를 그려주기 전에 물체들에 대한 세부적인 좌표계산은 렌더링 파이프라인 이전에 컴퓨트 셰이더 단계에서 물체를 그려져야 되는지 어디 위치해야 하는지를 계산해줄것입니다. 
실질적인 렌더링은 인스턴싱을 할때 그려줄것입니다. 인스턴싱을 시작할때 IA 단계에서 건내주는 정보가 사각형 메쉬 전체를 건네주지 않고 정점 하나만 건내주는데요 
왜냐면 이 물체가 그려질지 안그려질지부터 판별하기 위해 그렇습니다. 그리고 정점 하나를 건내줌과 동시에 SRV에 거품 모양의 텍스쳐를 매핑해서 같이 건내줘야 합니다. 
이렇게 IA 단계를 지나서 VS 단계에서는 좌표계산을 통해서 넘겨준 점이 어디 위치할것인지를 계산해주고 , 다음단계인 GS 단계에서 실질적으로 이 거품이 그려져야할지 안 그려져야할지를 
판별하는데 만약 그려져야 한다면 그때서야 정점 하나를 기준으로 해서 나머지 점 세개를 추가로 만들어서 삼각형 두개를 이어붙혀 사각형 메쉬로 만듭니다.
안 그려도 되는 거품이었다면 여기서 중단하고 다음 인스턴스 물체로 넘어가게 될것입니다. 
이렇게 처리하게 되면 CPU 부담없이 파티클 시스템을 구현 할 수 있게됩니다.


- 코드 

코드 작업으로 들어가보겠습니다. 우선 파티클로 사용할 리소스를 다운받아야 합니다. 구글에 원하는 이펙트 png 라고 검색해서 다운 받고 파일을 
프로젝트 폴더에서 Resources/Texture/Particle 이라는 폴더 안에 저장하겠습니다. 현재는 Particle 폴더가 없지만 생성해서 저장해주면 됩니다. 


1) paticle.fx

이번에도 먼저 셰이더 파일부터 만들겠습니다. 
기본적으로 #ifndef 같은 처리는 먼저 해줍니다. 그리고 params.fx, utils.fx 를 include 하였습니다.
 
struct Particle 이라는 구조체를 만들어 줄것인데 들고 있을 내용물은 float3 타입의 worldPos, worldDir 이름에서 알 수 있듯이 월드 스페이스에서의 포지션과 방향을 의미합니다.
그리고 float 타입의 curTime, lifrTime 파티클의 생존시간에 관련한 멤버 같습니다. 그리고 int 타입의 alive 이 멤버는 0과 1로 해당 파티클이 현재 살았는지 죽었는지를 판별할때 
쓰일것입니다. 마지막으로 float3 타입의 padding 이 패딩은 hlsl 에서 데이터를 16바이트 단위로 나눠서 관리해야 성능상 더 좋기 때문에 넣은 잉여 데이터 입니다. 

이 Particle 이라는 구조체는 렌더링을 할때도 사용될것이고 컴퓨트 셰이더를 할때도 사용될것입니다. 

아까 요약했던 내용에서 파티클에 대한 실제로 어디 위치하는지, 그려져야하는지를 계산하는 것은 컴퓨트 셰이더라고 했습니다. 그리고 이 컴퓨트셰이더는 IA 단계 이전에 
실행된다고 했습니다. 

1-1) particle-compute shader

이번 컴퓨트 셰이더에서 사용하는 레지스터는 u0,u1 두개를 사용합니다. 
u0 슬롯에는 RWStructuredBuffer<Particle> 타입의 g_particle 이라는 버퍼를 연결해서 사용하고 
u1 슬롯에는 RWStructuredBuffer<ComputeShared> 라는 타입의 g_shared 라는 버퍼를 사용합니다. 여기서 ComputeShared 라는 구조체가 나왔는데 
이건 컴퓨터 셰이더 에서 공용으로 사용될 구조체입니다. 

ComputeShared 구조체가 들고 있는 멤버는 int addCount 와 float3 padding 두개 입니다. 

ComputeShared 를 컴퓨트 셰이더 내부에서 공용으로 사용한다고 했는데 컴퓨트 셰이더에서 numthread 같이 하나의 스레드 그룹으로 묶으면 좋은점이 
여기서 사용한 레지스터 데이터를 이 스레드 그룹 안에서의 전역처럼 공통된 메모리에 접근 할수 있고 또 각종 동기화 기법도 사용할 수 있다고 합니다. 

다시 StructuredBuffer 에 대해 말하자면 이것은 일종의 배열이라고 생각하면 됩니다. 거기에 이제 우리가 사용할 두개의 버퍼는 

RWStructuredBuffer<Particle> g_particle : register(u0);
RWStructuredBuffer<ComputeShared> g_shared : register(u1);

이렇게 두개를 사용한다고 했었는데 파티클로 사용할 g_particle 은 대략 1000 개의 크기를 가진 1차원 배열로 GPU 로 넘겨줄것이고 
g_shared 같은 경우에는 배열이긴한데 딱 한개만 넣는 크기가 1인 배열로 넘겨줄것이고 하나의 버퍼를 공용으로 계속 사용할것입니다. 

다음으로 파티클의 컴퓨트 셰이더에서 사용할 파라미터들이 몇가지 있습니다. 
// g_vec2_1 : DeltaTime / AccTime   
// DeltaTime 은 이전 프레임에서 현재 프레임까지 걸리는 시간을 말하고 AccTime 은 누적시간을 계산할것인데 이 AccTime 을 시드로 랜덤값을 계산하기 위해서 넣어주었습니다.
// g_int_0  : Particle Max Count    // 말그대로 파티클이 최대 몇개인지를 담는 파라미터
// g_int_1  : AddCount              // 카운트를 세는 파라미터겠죠
// g_vec4_0 : MinLifeTime / MaxLifeTime / MinSpeed / MaxSpeed
// 최소 최대 생존시간, 속도 인데 이 두가지 파라미터의 범위를 정하고 그 안에서 랜덤으로 값을 부여하면 좀더 생동감있고 랜덤같은 파티클 시스템이 될것입니다. 

이 파라미터들을 이제 나중에 CPP 코드 Material 에서 담아준 다음 Dispatch 를 때려줄것입니다. 그런데 이번 Dispatch는 그리드 크기를 (1,1,1) 로 만들것입니다. 
대신 numthread 를 (1024,1,1) 로 주어서 1차원 배열같은 형태로 만들것입니다. 

/*
        Conpute Shader 시간에 말 못한 내용 보충
    저번 시간에 그냥 넘어간 부분이 있습니다. 이번시간에 새로 배운 StructuredBuffer 는 배열 같이 사용하는 버퍼라고 했고 같은 스레드 그룹에서는 버퍼를 거의 공용으로 사용된다고도 했습니다.
    이런 내용을 기반으로 이번 파티클 시스템을 만들때 numthread 로 만든 1024 개의 x 좌표를 가지고 1000개의 g_particle의 각 인덱스에 접근해서 작업을 할려고 했습니다.
    
    그러니까 코드로 보면 
    [numthread(1024,1,1)]
    void CS_Main(int3 threadIndex : SV_DispatchThreadID)
    {
        // 이러면 threadIndex.x 값이 0 부터 1023 까지 있을것입니다. 이 값을 가지고 내가 지금 몇번을 연산해주고 있는지를 알게 될건데 
        // 만약에 나에 해당하는애가 아니라 옆에 있는 애를 건드린다고 해보겠습니다. 

        g_particle[threadIndex.x] = g_particle[threadIndex.x - 1];

        // 이런 상황이 있다고 해보겠습니다. 코드상으로 정확한 것은 아니라도 대충 이렇습니다.
        // 이전 인덱스의 값을 현재의 인덱스에 넣는다고 했을때 문제가 되는데 이유는 
        // 컴퓨트 셰이더는 병렬로 작업을 실행하는데 이 때 순서가 보정이 되지 않습니다. 병렬로 작업을 처리한다는것은 여러개의 작업을 각각의 ALU 에서 동시에 실행된다는 것인데 
        // CPU 에서 사용하던 배열처럼 사용하려다 보면 문제가 생깁니다. 각각의 배열의 연산은 서로가 작업이 끝났는지도 모르는데 그러 값을 꺼내서 사용한다는 것 자체가 
        // 말이 안됩니다. 
        // 만약 이게 말이 되려면 병렬로 진행되는 작업을 동기화를 해줘서 순서를 보장을 해줘야 할것입니다.

        // 또 한가지 문제는 g_int_1 에 받아준 AddCount 라는 파라미터인데 AddCount 에 받은 값의 의미가 이번에 2개의 파티클을 만들어 주세요 하면 AddCount 2 가되고 이 값에 따라 파티클을 
        // 만든다고 가정을 해보겠습니다. 
        // 이제 g_particle 이라는 배열 하나하나의 원소들의 속성중에 alive 라는 값이 있었습니다. 0이면 죽었고 1이면 살아있다는 의미였는데 
        // 예시로 g_particle 의 처음부터 5개의 원소들의 alive 값이 각각 0, 1, 1, 0, 0 이었다고 해보겠습니다.
        // 그러면 이중에서 0 인 애들이 후보군이 되는겁니다. 그련데 여기서 각각의 작업이 병렬로 진행된다는 것이 문제가 됩니다. 
        // alive 가 0 이었던 1,4,5 번째 파티클들이 서로 살았는지 죽었는지를 모릅니다. 저희가 의도한 작업은 선착순으로 2개의 파티클만 다시 살리는 것였는데 GPU 스레드 에서는 
        // 각자 자기는 첫번째로 다시 살아났다고 하는 상황이 생길 수 있는겁니다. 
        // 이게 공유 자원에 대한 이야기를 하고 있는겁니다. 
        // 다음 파트인 서버 시간에 자주 등장할 내용인데 이런 문제 때문에 어떤 스레드가 먼저 실행되고 어떤 스레드가 다음에 실행되는 순서 보장이 필요하다고 할 수 있겠습니다. 
    }
*/

파티클의 컴퓨트 셰이더 코드에서 이런 부분이 있습니다.
[numthreads(1024, 1, 1)]
void CS_Main(int3 threadIndex : SV_DispatchThreadID)
{
    int maxCount = g_int_0;
    int addCount = g_int_1;
    int frameNumber = g_int_2;
    float deltaTime = g_vec2_1.x;
    float accTime = g_vec2_1.y;
    float minLifeTime = g_vec4_0.x;
    float maxLifeTime = g_vec4_0.y;
    float minSpeed = g_vec4_0.z;
    float maxSpeed = g_vec4_0.w;
    // 컴퓨트 셰이더의 지역 변수에 파라미터들을 알기 쉽게 받아주고 있습니다.

    g_shared[0].addCount = addCount;

}

여기 나오는 g_shared 는 1024 개에 달하는 스레드 들이 모두 같이 사용하는 공용 메모장 같은 것입니다. 그런 공용 메모장에 파라미터로 넘겨받은 addCount 로 넣어주고 있습니다. 
그런데 이 셰이더를 하나씩 실행하는게 아니라 천여개의 스레드들이 병렬적으로 실행되는데 어떤 스레드는 이미 다음 코드들에서 이 addCount 를 이리 저리 사용하고 있는데 
좀 느린 스레드에서는 이제서야 다시 파라미터의 값으로 g_shared[0].addCount 를 다시 초기화 해줄 수 있습니다. 

g_shared[0].addCount = addCount; 

라는 코드가 무엇을 하고 싶은거냐면 CPU에서 넘겨주었던 파라미터가 3개의 파티클을 살려내고 싶다고 공통 메모장에 적고 있는겁니다. 아 남은 부활 횟수가 3이구나 합니다.
이제 다음 코드는 조건문과 반복문을 돌면서 현재의 스레드의 alive가 0 이었다면 자신의 alive 를 1로 돌리면서 addCount 의 값을 1 씩 줄이면서 원하는 갯수의 파티클들을 부활 시킵니다.  

그런데 이때 스레드들이 병렬적으로 실행되다 보니까 공용 메모장에 3이라고 적혀있다가 2줄었던 부활시킬 파티클의 수가 다시 다른 스레드가 실행될때 처음 addCount 값인 3으로 다시 초기화 되어 
원하는 결과인 3개의 파티클만 부활시키는 결과가 나오지 않을 수 있습니다. 

모든 스레드가 공용 버퍼에 병렬적으로 접근할수 잇어서 이런 일이 생기는데 이때 필요한 것이

    GroupMemoryBarrierWithGroupSync();

입니다. 이 함수가 하는일은 모든 스레드가 일단 이 함수가 적혀있는데 까지 진행이 되고 모두 이 배리어 까지 진행 되었다면 그때 다음 코드로 진행하도록 해주는 역할입니다. 
이 함수를 처음에 g_shared[0].addCount 를 초기화 한 다음에 실행해 주면 모든 스레드가 이후 부터 진행이 되게 될겁니다. 

    g_shared[0].addCount = addCount;
    GroupMemoryBarrierWithGroupSync();

사실 이 작업은 파티클의 갯수를 정확히 맞추는게 그리 중요하지는 않기 때문에 배리어를 사용하지 않아도 되지만 동기화에 대한 내용을 설명 하기 위한 것이었습니다. 

그리고 이제 부활 시킬 파티클의 수를 알고 나서 파티클을 부활 시키는 코드를 보겠습니다. 

    if (g_particle[threadIndex.x].alive == 0)
    {
        while (true)
        {
            int remaining = g_shared[0].addCount;
            if (remaining <= 0)
                break;

            int expected = remaining;
            int desired = remaining - 1;
            int originalValue;
            InterlockedCompareExchange(g_shared[0].addCount, expected, desired, originalValue);

            if (originalValue == expected)
            {
                g_particle[threadIndex.x].alive = 1;
                break;
            }
        }

alive 가 0 인것을 체크해서 생각 보다 복잡한 코드가 있습니다. InterlockedCompareExchange 이라는 처음 보는 함수가 나오는데 이것도 작업들이 병렬적으로 진행되다 보니까 동기화 관련된 
함수입니다. 

그냥 CPP 에서 처리한다고 한다면 
while(g_shared.addCount > 0)
{
    g_shared.addCount--;
    // 부활하는 코드 
}
이런식으로 처리하면 되지 않겠나 싶은데 이건 병렬 진행을 고려 하지 않은 코드입니다. addCount 를 빼주는 부분이 한번에 여러 스레드에서 실행될 가능성도 있기 때문에 이런 코드는 
컴퓨트 셰이더 에서는 적합하지 않습니다. 

코드를 보면 일단 무한 루프를 돌고 있는데 먼저 remaining 이라는 변수에 g_shared.addCount 를 복사해주고 있습니다. 공용 버퍼에는 직접 접근하지 않으려는것 같습니다. 
if (remaining <= 0)
    break;
즉 이미 부활할 파티클이 다 지나갔다면 그냥 여기서 함수를 빠져나가는 코드입니다. 
하지만 이 조건을 빠져나간다면 이제 AddCount 라는 부활권 쟁탈을 해야 합니다. 5개라는 부활권이 있었다면 4로 줄인다음 줄인 하나의 부활권을 확보해야하는데 
이 addCount 에서 하나를 빼주는걸 아까 처럼 -- 연산자를 사용한다면 다 동시에 실행되기 때문에 병렬에서 문제가 생긴다고 했었습니다. 그래서 InterlockedCompareExchange 이라는 함수를 호출하고 있는데

이 함수는 뭘하는거냐면 한번에 무조건 한번만 실행된다고 보면 되겠습니다. 
인자는 4개를 받아주고 있는데 

InterlockedCompareExchange(g_shared[0].addCount, expected, desired, originalValue);

이 함수의 내용을 말로 설명해보자면 첫번째 인자인 addCount 와 두번째 인자인 expected 라는값이 같다면 세번째 인자인 desired 값을 첫번째 인자에 넣어주고 원래 첫번째 인자의 값은 
네번째 인자인 originalValue 에 저장합니다. 
이걸 의사 코드로 표현하자면 이럴것입니다. 
{
    originalValue = g_shared[0].addCount
    if(g_shared[0].addCount == expected)
    {
        g_shared[0].addCount = desired;
    }
}
이제 이게 어떻게 진행되는지 예를 들어보겠습니다. addCount 가 5라고 하고 운좋게 지금 스레드가 가장 먼저 이 함수를 실행하였습니다. 그러면 addCount 는 5이고 expected도 5일것입니다. 
이때 그럼 desired 의 값 4 를 addCount 에 담고 원래 있던 5라는 값은 originalValue 에 담습니다. 
위의 경우가 가장 먼저 도달한 스레드의 경우고 
이번에는 그 이외의 스레드일때입니다. 먼저 InterlockedCompareExchange 를 실행한 스레드가 있을것이기 때문에 이미 addCount 는 4가 되어있습니다. 그런데 expected 와 addCount 의 값이 다를것이기 때문에
이번에는 실패를 하고 desired 값을 addCount 에 담지 않습니다. originalValue 에는 4가 담길것입니다. 

InterlockedCompareExchange를 통과한후의 코드인데 originalValue 와 expected 의 값이 같다면 가장 먼저 도착한 스레드라는 것이고 그러면 이 파티클을 살려줄것입니다. 
            if (originalValue == expected)
            {
                g_particle[threadIndex.x].alive = 1;
                break;
            }
위 처럼 originalValue 와 expected가 같은 값인가를 통해서 함수가 통과 되었는지를 알아보는 방법도 있고 다른 곳 CPP Atomic 에서는 그냥 이 함수 의 반환이 
bool 값으로 나와서 성곡했는지 실패했는지를 알 수도 있다고 합니다.  

InterlockedCompareExchange 라는 함수에 관해서는 나중에 서버 파트에서 자세히 알아볼것입니다. 

다음으로는 g_particle[threadIndex.x].alive == 1 일 때의 코드입니다. 이미 살아있는 파티클이라면 각각 랜덤한 방향으로 움직이도록 만들어 줄겁니다. 
그런데 hlsl 에서는 랜덤이라는 함수가 존재하지 않다고 합니다. 
직접 랜덤 비슷한 느낌이 나도록 함수를 만들어 줘야 하는데 지금까지 프로젝트에서 함수를 만들어 두는 곳은 utils.fx 였습니다. 


1-2) utils.fx

여기에 추가로 만들어줄 랜덤 함수의 코드는 이렇습니다.

float Rand(float2 co)
{
    return 0.5 + (frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 0.5;
}

시드 값을 넣어주면 랜덤 비슷하게 뱉어주는 함수인데 인자로 받는것도 float 두개 짜리 를 받고 일정 값과 서로 연산을 하고 있습니다. 
연산하는 것들은 dot 내적, sin 사인 값, 그리고 frac 이라는 잘 모르겠는 함수가 있는데 이 함수는 실수의 소수점 자리만 추출하는 함수입니다.
결국 frac 까지 연산한 값이 0 ~ 1 사이의 수이고 여기에 0.5 를 곱했으니 0 ~ 0.5 사이의 숫자가 되고 여기에 괄호 밖에서 한번더 0.5 를 더하였으니
0.5 ~ 1 사이의 랜덤한 값이 나오게 될것입니다. 


1-3) particle.fx

hlsl 에서 사용할 랜덤 함수도 만들었으니 아까 하던 코드를 이어서 보면 g_particle[threadIndex.x].alive == 1 일 때의 코드 였습니다. 
이 조건문은 alive가 0이었던 파티클이 1로 변하고 break 로 while 문을 빠져나온 상태이다 보니까 지금 새로 생성되는 파티클입니다. 
        if (g_particle[threadIndex.x].alive == 1)
        {
            float x = ((float)threadIndex.x / (float)maxCount) + accTime;
            // x 는 랜덤값을 만들기 위한 시드의 의미입니다. 이 시드에 accTime 이 들어가는데 accTime 의 원래용도는 아니고 시간에 따라 변하는 값을 추가 하기 위한것입니다.
            // accTime 은 DeltaTime 이라는 이전 프레임에서 현재 프레임까지 걸린시간을 파티클이 생존해 있는동한 프레임 마다 더해가는 시간입니다.

            float r1 = Rand(float2(x, accTime));
            float r2 = Rand(float2(x * accTime, accTime));
            float r3 = Rand(float2(x * accTime * accTime, accTime * accTime));
            // r1,r2,r3 를 Rand 함수로 랜덤 값을 뽑고 있는데 각 값을 계산하는 방식은 별의미가 있는것은 아니고 최대한 랜덤 비슷하게 뽑기위한 것 입니다. 

            // [0.5~1] -> [0~1]
            float3 noise =
            {
                2 * r1 - 1,
                2 * r2 - 1,
                2 * r3 - 1
            };
            // 노이즈 라는 변수에 3개의 float 값을 넣어주고 있는데 Rand 함수의 반환값이 0.5 ~ 1 이었던걸 0 ~ 1 의 값으로 변환해서 저장합니다.


            // [0~1] -> [-1~1]
            float3 dir = (noise - 0.5f) * 2.f;
            // 노이즈를 가지고 다시 dir 방향을 만들어 주는데 -1 ~ 1 사이의 값으로 만들어 주고 있습니다.

            g_particle[threadIndex.x].worldDir = normalize(dir);
            g_particle[threadIndex.x].worldPos = (noise.xyz - 0.5f) * 25;
            g_particle[threadIndex.x].lifeTime = ((maxLifeTime - minLifeTime) * noise.x) + minLifeTime;
            g_particle[threadIndex.x].curTime = 0.f;
            // 이 부분에서는 파티클의 각 속성들을 채워주고 있는데 worldDir 은 계산했던 dir을 단위벡터화 해서 주었고 worldPos 는 적당히 랜덤값처럼 주었습니다.
            // lifeTime 은 minLifeTime , maxLifeTime 사이의 값을 주기 위해서 noise.x 를 곱해주었습니다.
            // curTime 은 생존했던 시간인데 이제 막 생성된 파티클이기 때문에 0.f 값을 주었습니다.
        }


지금 이 프로젝트에서는 임시로 랜덤값을 만드는 함수를 사용했는데 이런 방법 말고 또다른 방법은 노이즈 텍스쳐라는 텍스쳐를 사용하는 방법이 있습니다. 
인터넷에서 노이즈 텍스쳐를 다운 받아서 셰이더에 u1 레지스터 같은데 연결하고 uv 좌표값으로 매핑해 값을 가져오면 랜덤값을 추출해 낼 수 있습니다.

이제 다음은 else 에 걸리는 파티클들인데 여기 걸리는 파티클 들은 이미 살아있던 파티클들입니다. 
    else
    {
        g_particle[threadIndex.x].curTime += deltaTime;
        // 이전 프레임까지 생존해있던 시간에 현재 프레임의 델타 타임을 더해줍니다. 생존한 시간을 갱신해주는 겁니다.

        if (g_particle[threadIndex.x].lifeTime < g_particle[threadIndex.x].curTime)
        // lifeTime 이 curTime 보다 적어진다는 의미는 수명이 다했다는 의미입니다. 
        {
            g_particle[threadIndex.x].alive = 0;
            // 수명이 다해서 이 파티클을 죽여줍니다.
            return;
        }

        float ratio = g_particle[threadIndex.x].curTime / g_particle[threadIndex.x].lifeTime;
        // 스피드에 사용할 생존시간/수명 비 입니다.
        float speed = (maxSpeed - minSpeed) * ratio + minSpeed;
        // 파티클의 최소 스피드는 보장하고 수명이 다 할수록 maxSpeed 에 가까워 지도록 보정합니다. 
        g_particle[threadIndex.x].worldPos += g_particle[threadIndex.x].worldDir * speed * deltaTime;
        // 속도만큼 이동시킵니다.
    }

아까 g_shared 를 건드릴 때는 병렬연산의 문제점때문에 동기화를 해야한다고 하더니 여기서는 또 그런건 신경쓰지 않고 진행하고 있는데 
그 이유는 
지금 사용하는 threadIndex 라는 것이 스레드마다 할당된 고유의 값이기 때문에 공용 버퍼인 g_shared 와는 상황이 다른겁니다. 
그냥 자신만의 데이터를 수정하고 있는것이기 때문에 다른 스레드에서 간섭하지 않을것입니다. 

이제 이 파티클 컴퓨스 셰이더 에서 사용하단 u 레지스터 버퍼들은 렌더링에 사용되기 위해 t 레지스터로 넘겨져서 사용 될 것입니다. 
즉 이 컴퓨트 셰이더는 파티클의 생명주기와 이동방향 속도등을 계산하기 위한 과정이었습니다. 


1-4) params.fx - MATERIAL_PARAMS

다음 작업으로 넘어가기 전에 이번 컴퓨트 셰이더에서 사용하던 
g_vec4_0 : MinLifeTime / MaxLifeTime / MinSpeed / MaxSpeed
으로 받아서 사용하던 파라미터는 사실 아직 까지 사용하지 않던 타입의 파라미터입니다. 
잊지말고 추가 해주겠습니다. 

cbuffer MATERIAL_PARAMS : register(b2)
{
    // 생략
    
    float4  g_vec4_0;
    float4  g_vec4_1;
    float4  g_vec4_2;
    float4  g_vec4_3;
}

1-5) particle.fx - Vertex Shader

컴퓨트 셰이더 단계를 마치고 나서 렌더링 파이프라인으로 간다고 했습니다. 
아까 계산한 u0 레지스터에 있던 structuredBuffer g_particle 의 정보가 이제는 

StructuredBuffer<Particle> g_data : register(t9);

이쪽으로 이어지게 됩니다. 

이제 VS_Main 을 보겠습니다. 
여기서 사용되는 VS_IN struct 는 position, uv, normal, tangent 말고도 SV_InstanceID 라는 고유 아이디를 들고 있을것이라고 했었습니다. 

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0.f;

    float3 worldPos = mul(float4(input.pos, 1.f), g_matWorld).xyz;
    // 인풋 받은 대로 worlde position 으로 변환을 해주고 있는데 
    worldPos += g_data[input.id].worldPos;
    //변환한 포지션에 컴퓨트 셰이더에서 계산해준 curTime 에 따른 좌표이동값을 ID 값을 인덱스로 사용해서 찾아와 더해줍니다. 

    output.viewPos = mul(float4(worldPos, 1.f), g_matView);
    output.uv = input.uv;
    output.id = input.id;

    return output;
}

이전에는 VS 다음으로 PS 로 넘어갔는데 이론 시간에 배웠던 GS 단계가 중간에 있을겁니다. 

GS 단계에서 해당 파티클이 그려질지 안그려 질지를 판별했었습니다. 그때 판별은 삼각형을 가지고 했던게 아니라 점 하나로 판별을 했었는데 
이렇게 점하나 를 넘겨주는건 IA 단계에서 부터 넣어주는겁니다. 즉 VS 때도 삼각형의 정점들을 계산해준것이 아니라 정점 하나를 계산해준것이었습니다.

1-6) particle - Geometry Shader

시그니쳐를 보면 인풋으로 VS의 결과물을 점 하나로 받아주고 있고 TriangleStream<GS_OUT> outputStream 을 뱉어주고 있습니다. 
VS_OUt 을 point 라는 타입으로 받아주고 있는데 애당초 IA에서 삼각형을 넘겨줬으면 point가 아니라 triangle 이라던지 다른 타입으로 바뀌게 됩니다.

[maxvertexcount(6)]
void GS_Main(point VS_OUT input[1], inout TriangleStream<GS_OUT> outputStream)
{
    GS_OUT output[4] =
    {
        (GS_OUT)0.f, (GS_OUT)0.f, (GS_OUT)0.f, (GS_OUT)0.f
    };

    VS_OUT vtx = input[0];
    uint id = (uint)vtx.id;
    if (0 == g_data[id].alive)
        return;
    // 여기서 현재 파티클의 alive 를 체크해서 0 이라면 그냥 여기서 부터 리턴을 해줍니다. 

    float ratio = g_data[id].curTime / g_data[id].lifeTime;
    float scale = ((g_float_1 - g_float_0) * ratio + g_float_0) / 2.f;
    // 생존시간에 따라 스케일도 변하게 해줍니다.

    // View Space
    output[0].position = vtx.viewPos + float4(-scale, scale, 0.f, 0.f);
    output[1].position = vtx.viewPos + float4(scale, scale, 0.f, 0.f);
    output[2].position = vtx.viewPos + float4(scale, -scale, 0.f, 0.f);
    output[3].position = vtx.viewPos + float4(-scale, -scale, 0.f, 0.f);
    // 인풋과 scale 을 가지고 사각형 메쉬를 이룰 정점들 4개를 만들어서 뷰 스페이스 변환을 해주었습니다.

    // Projection Space
    output[0].position = mul(output[0].position, g_matProjection);
    output[1].position = mul(output[1].position, g_matProjection);
    output[2].position = mul(output[2].position, g_matProjection);
    output[3].position = mul(output[3].position, g_matProjection);
    // 뷰 스페이스 에서 다시 프로젝션 변환을 해줍니다.

    output[0].uv = float2(0.f, 0.f);
    output[1].uv = float2(1.f, 0.f);
    output[2].uv = float2(1.f, 1.f);
    output[3].uv = float2(0.f, 1.f);
    각 모서리가 될 정점들의 uv 좌표를 매핑해줍니다. 

    output[0].id = id;
    output[1].id = id;
    output[2].id = id;
    output[3].id = id;
    // 네 정점들이 공통된 id 를 가지도록 해줍니다. 

    outputStream.Append(output[0]);
    outputStream.Append(output[1]);
    outputStream.Append(output[2]);
    outputStream.RestartStrip();

    outputStream.Append(output[0]);
    outputStream.Append(output[2]);
    outputStream.Append(output[3]);
    outputStream.RestartStrip();
    // 이부분들에서 TriangleStream 의 역할인데 각각 순서대로 정점들을 넣어서 삼각형을 만들어줍니다. 두개 를 만드는데 빗면을 같이 써서 4각형 메쉬가 됩니다.
}


1-6) particle - Pixel Shader

다음 픽셀 셰이더는 간단한데 

float4 PS_Main(GS_OUT input) : SV_Target
{
    return g_tex_0.Sample(g_sam_0, input.uv);
}

사각형의 각 모서리 uv 좌표를 텍스쳐와 매핑해줍니다. 


2) StructuredBuffer.cpp 

이제 CPP 코드 쪽을 수정할 차례입니다. 

파티클 컴퓨트 셰이더에서 처음 사용하기 시작했던 Structured Buffer 를 CPP 코드에서도 사용할 수 있도록 만들어 줘야 합니다. 

어떻게 해야 하는지 생각해보니까 이전에 셰이더로 파라미터를 넘기기 위해서 ConstantBuffer 라는 클래스를 만들어서 그래픽스, 컴퓨트 버퍼들을 
푸쉬 하여서 셰이더로 넘거주었었는데 
이런 형태 비슷하게 StructuredBuffer 도 구현해주겠습니다. 

먼저 Init 함수 부터 보겠습니다. 

void StructuredBuffer::Init(uint32 elementSize, uint32 elementCount)
    // 인자를 보면 원소의 사이즈와 갯수를 받아주고 있는데 구조화 버퍼는 배열같이 사용되기에 이렇게 받아주고 있습니다.
    // 그리고 구조화 버퍼는 셰이더에서 살펴보았듯이 레지스터를 이리저리 옮겨다닙니다. 컴퓨트 셰이더 에서 사용할때는 u 슬롯 레지스터에 매핑되었다가 
    // VS에서 사용될 때는 t 슬롯 레지스터에 연결되기도 했습니다. 그래서 SRV일때 UAV 일때 둘 다 만들어 줘야 합니다. 
{
	_elementSize = elementSize;
	_elementCount = elementCount;
	_resourceState = D3D12_RESOURCE_STATE_COMMON;
    // StructuredBuffer 클래스의 멤버 변수들을 인자와 리소스 스테이트 커먼으로 채워주고 있습니다.

	// Buffer
	{
		uint64 bufferSize = static_cast<uint64>(_elementSize) * _elementCount;
        // 만들 리소스의 크기를 정합니다.
		D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
        // 리소스의 Descriptor 기술자를 버퍼의 사이즈 만큼 플레그는 Unordered Access 로 만들어줍니다.
		D3D12_HEAP_PROPERTIES heapProperties = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
        // 힙의 속성은 디폴트 입니다.

		DEVICE->CreateCommittedResource(
			&heapProperties,
			D3D12_HEAP_FLAG_NONE,
			&desc,
			_resourceState,
			nullptr,
			IID_PPV_ARGS(&_buffer));
        // CreateCommittedResource 는 리소스(버퍼)와 암시적 힙을 동시에 만들어 주는데 만든 리소스가 충분히 담길 만한 크기로 만들어 줍니다. 
        // 만들때 필요한 여러 인자들을 받아서 해당하는 옵션으로 만듭니다.
	}

	// SRV 셰이더 리소스 뷰 : 셰이더에서 텍스쳐에 접근할 수 있는 형태로 랩핑하는 뷰 , 읽기 전용
	{
        // VS 부터 파티클 텍스쳐를 사용하기 위해 SRV를 만듭니다.

		D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
		srvHeapDesc.NumDescriptors = 1;
		srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
		srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
		DEVICE->CreateDescriptorHeap(&srvHeapDesc, IID_PPV_ARGS(&_srvHeap));
        // 기술자의 갯수는 한개, 타입은 CBV,SRV,UAV 용도로 플래그는 없이 이런 타입의 SRVHeap 을 멤버 변수인 _srvHeap 에 만들어 줬습니다.

		_srvHeapBegin = _srvHeap->GetCPUDescriptorHandleForHeapStart();
        // 방금 만든 _srvHeap의 시작 주소를 저장합니다.

		D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
        // SRV의 기술자를 만듭니다. 
		srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
		srvDesc.Format = DXGI_FORMAT_UNKNOWN;
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
		srvDesc.Buffer.FirstElement = 0;
		srvDesc.Buffer.NumElements = _elementCount;
		srvDesc.Buffer.StructureByteStride = _elementSize;
		srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

		DEVICE->CreateShaderResourceView(_buffer.Get(), &srvDesc, _srvHeapBegin);
        // 필요한 옵션과 버퍼, srvHeap 의 시작 주소를 주고 리소스 데이터에 접근하기 위한 SRV를 시작주소에 만듭니다.
	}

	// UAV  불규칙한 접근을 하는 뷰 : 컴퓨트 셰이더 같이 불규칙하게 리소스에 접근하는 방식의 뷰입니다. 읽기/쓰기 가능
	{
		D3D12_DESCRIPTOR_HEAP_DESC uavheapDesc = {};
		uavheapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
		uavheapDesc.NumDescriptors = 1;
		uavheapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
		DEVICE->CreateDescriptorHeap(&uavheapDesc, IID_PPV_ARGS(&_uavHeap));
        
		_uavHeapBegin = _uavHeap->GetCPUDescriptorHandleForHeapStart();

		D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
		uavDesc.Format = DXGI_FORMAT_UNKNOWN;
		uavDesc.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
		uavDesc.Buffer.FirstElement = 0;
		uavDesc.Buffer.NumElements = _elementCount;
		uavDesc.Buffer.StructureByteStride = _elementSize;
		uavDesc.Buffer.CounterOffsetInBytes = 0;
		uavDesc.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;

		DEVICE->CreateUnorderedAccessView(_buffer.Get(), nullptr, &uavDesc, _uavHeapBegin);
        // _buffer 의 데이터를 uavHeap 을 시작주소부터 만들어줍니다.
	}
}

그리고 데이터를 Push 하는 함수 세개가 있습니다.

void StructuredBuffer::PushGraphicsData(SRV_REGISTER reg)   // SRV를 그래픽스 DescHeap에 세팅
{
	GEngine->GetGraphicsDescHeap()->SetSRV(_srvHeapBegin, reg);
}

void StructuredBuffer::PushComputeSRVData(SRV_REGISTER reg) // SRV를 컴퓨트 DescHeap에 세팅 
{
	GEngine->GetComputeDescHeap()->SetSRV(_srvHeapBegin, reg);
}

void StructuredBuffer::PushComputeUAVData(UAV_REGISTER reg) // UAV를 컴퓨트 DescHeap에 세팅
{
	GEngine->GetComputeDescHeap()->SetUAV(_uavHeapBegin, reg);
}

각각 그래픽스나 컴퓨트 셰이더에서 사용할 레지스터 번호를 지정해서 푸쉬하고 있습니다. 

여기에 추가로 버퍼, 리소스 스테이트, srvHeap, uavheap 들을 외부에서 꺼내는 Get 함수들도 있습니다.
리소스 스테이트는 설정하는 함수도 있습니다. 

이제 이 내용을 요약해보자면 
StructuredBuffer::Init 에서 버퍼를 만드는 부분은 GPU 쪽에 우리가 사용할 크기의 배열을 만들어 달라고 요청을 한다음 (Buffer 부분)
그걸 우리가 원하는 레지스터에 연결할 수 있게 뷰를 SRV, UAV 로 만들어 놨다 라고 요약할 수 있겠습니다.

이다음으로 무엇을 해야 하냐면 파티클을 만들어야 하니까 게임 오브젝트에 관련된 클래스가 필요합니다. 
이 클래스를 컴포넌트로 추가해서 게임 오브젝트에 필요할때 추가해 사용할 수 있게 해주겠습니다. 


3) ParticleSystem

먼저 파티클 시스템에서 관리할 두가지 struct 가 있는데 ParticleInfo 와 ComputeSharedInfo 입니다.

이것들이 무엇이냐면 ParticleInfo 는 이번 강의 첫 부분에서 만들었던 particle.fx 에서 struct Particle 의 정보들입니다. 이 구조체는 
구조화 버퍼(StructuredBuffer) 의 타입이 되는 구조체 엿습니다. 즉 각 파티클들이 가지고 있을 정보들입니다. 
ComputeSharedInfo 도 particle.fx 와 관련있는데 파티클 셰이더 파일의 컴퓨트 셰이더 부분에서 사용되는 공용 메모장 u1 레지스터를 사용하는 그것 입니다. 
이 구조체들은 CPP 파일에서 직접 사용할 것은 아니지만 구조화 버퍼를 만들때 사이즈를 똑같이 만들어 주기 위해서 포멧을 똑같이 만들어 놓은것입니다. 

다음은 이제 클래스의 선언부를 보겠습니다. 
class ParticleSystem : public Component // 우선 ParticleSystem 도 컴포넌트로 사용될것이다 보니까 Component 를 상속 받습니다. 
{
public:
	ParticleSystem();
	virtual ~ParticleSystem();

public:
	virtual void FinalUpdate();
	void Render();

public:
	virtual void Load(const wstring& path) override { }
	virtual void Save(const wstring& path) override { }

private:    // 멤버 변수
	shared_ptr<StructuredBuffer>	_particleBuffer;
	shared_ptr<StructuredBuffer>	_computeSharedBuffer;
	uint32							_maxParticle = 1000;

	shared_ptr<Material>		_computeMaterial;
	shared_ptr<Material>		_material;
	shared_ptr<Mesh>			_mesh;

	float				_createInterval = 0.005f;
	float				_accTime = 0.f;

// 셰이더에 파리미터로 넘어갈 정보들
	float				_minLifeTime = 0.5f;
	float				_maxLifeTime = 1.f;
	float				_minSpeed = 100;
	float				_maxSpeed = 50;
	float				_startScale = 10.f;
	float				_endScale = 5.f;
};

이렇게 되어 있고 바로 정의부를 보겠습니다. 
생성자 함수 부터 보겠습니다. 
ParticleSystem::ParticleSystem() : Component(COMPONENT_TYPE::PARTICLE_SYSTEM)   // 컴포넌트는 생성될때 자신의 타입을 정하고 시작 했었습니다.
{
	_particleBuffer = make_shared<StructuredBuffer>();
	_particleBuffer->Init(sizeof(ParticleInfo), _maxParticle);
    // 위의 두 줄은 아까 만든 StructuredBuffer 를 만드는데 elementSize는 ParticleInfo 만큼 elementCount 는 멤버 변수로 있던 _maxParticle 만큼 만들어 달라고 합니다.

	_computeSharedBuffer = make_shared<StructuredBuffer>();
	_computeSharedBuffer->Init(sizeof(ComputeSharedInfo), 1);
    // 두번째로 파티클을 몇개나 만들것인지를 관리하던 공용 버퍼를 StructuredBuffer로 만들고 있습니다.

    // 여기서 위의 두 구조화 버퍼를 만드는 부분에서 중요한것은 CPP 코드에서는 CPU에게 구조화 버퍼를 만들기는 했지만 그 안의 내용물을 여기서 채워주고 있지는 않습니다.
    // CPU 에서는 틀 만 만들어 GPU로 넘겨주고 내용물은 컴퓨트 셰이더가 채워줄것입니다.

	_mesh = GET_SINGLE(Resources)->LoadPointMesh();
	_material = GET_SINGLE(Resources)->Get<Material>(L"Particle");
	shared_ptr<Texture> tex = GET_SINGLE(Resources)->Load<Texture>(
		L"Bubbles", L"..\\Resources\\Texture\\Particle\\bubble.png");
    // 이 부분의 코드에서 파티클의 메쉬와 텍스쳐를 담을 마테리얼을 가져오고 있습니다. 

	_material->SetTexture(0, tex);

	_computeMaterial = GET_SINGLE(Resources)->Get<Material>(L"ComputeParticle");
    // 컴퓨트 셰이더 도 가져오고 있습니다.
}

일단 생성자 함수를 보았는데 아직 다른 코드에서 구현이 되지 않은 부분이 있습니다. 
COMPONENT_TYPE::PARTICLE_SYSTEM , GET_SINGLE(Resources)->LoadPointMesh(); , GET_SINGLE(Resources)->Get<Material>(L"Particle"); ,
GET_SINGLE(Resources)->Get<Material>(L"ComputeParticle");
이런 부분입니다. 

이것들은 좀 있다 만들어 줄것이고 계속 파티클 시스템을 살펴보겠습니다.

우리가 만들고 있는 엔진의 게임 오브젝트들이 업데이트 되는 과정이 매 프레임마다 Awake Start Update LateUpdate FinalUpdate Render 이런 식으로 진행됩니다. 

파티클 시스템의 경우에도 FinalUpdate 후 Render 가 실행됩니다. 
FinalUpdate 부터 보겠습니다. 
void ParticleSystem::FinalUpdate()
{
	_accTime += DELTA_TIME;
    // _accTime 을 갱신해줍니다. 프레임 간의 시간을 더해주면 그 파티클이 생존했던 시간이 될것입니다. 

	int32 add = 0;
	if (_createInterval < _accTime)
	{
		_accTime = _accTime - _createInterval;
		add = 1;
	}
    // add 라는 값을 만드는 조건문입니다. 이 add 는 밑에서 SetInt(1, add); 가 되는데 이 슬롯은 처음 셰이더 파일 설명때 생성할 파티클의 수 addCount 의 값입니다. 

	_particleBuffer->PushComputeUAVData(UAV_REGISTER::u0);
	_computeSharedBuffer->PushComputeUAVData(UAV_REGISTER::u1);
    // u0, u1 레지스터에 Init 에서 만들었던 버퍼를 넘겨줍니다.

	_computeMaterial->SetInt(0, _maxParticle);
	_computeMaterial->SetInt(1, add);

	_computeMaterial->SetVec2(1, Vec2(DELTA_TIME, _accTime));
	_computeMaterial->SetVec4(0, Vec4(_minLifeTime, _maxLifeTime, _minSpeed, _maxSpeed));
    // 컴퓨트 셰이더에서 사용하는 파라미터들을 전부 세팅하였습니다.

	_computeMaterial->Dispatch(1, 1, 1);
    // 디스패치를 때려서 컴퓨트 셰이더를 실행합니다. 
}

FinalUpdate 에서는 컴퓨트 셰이더를 실행하기 위한 과정이었습니다. 함수 마지막에는 디스패치로 컴퓨트 셰이더를 실행하고 있습니다. 

렌더 부분입니다.
void ParticleSystem::Render()
{
	GetTransform()->PushData();
    // 변환 행렬들을 ConstantBuffer에 푸시하는 부분

	_particleBuffer->PushGraphicsData(SRV_REGISTER::t9);
    // FinalUpdate 때 컴퓨트 셰이더를 실행하면서 내용물을 채운 파티클 버퍼를 그래픽스 셰이더 쪽으로 다시 넘겨줍니다. 
	_material->SetFloat(0, _startScale);
	_material->SetFloat(1, _endScale);
	_material->PushGraphicsData();

	_mesh->Render(_maxParticle);
}

여기까지 파티클 시스템의 로직이었고 
중간 중간에 에러가 나고 있는 부분들은 아직 추가 수정해주지 않은 부분인데 이걸 수정해보겠습니다. 


4) 에러 수정

4-1) Component
파티클 시스템 생성자 함수 때 처음부터 에러를 뱉고 있는 컴포넌트 타입입니다.
enum class COMPONENT_TYPE : uint8
{
	TRANSFORM,
	MESH_RENDERER,
	CAMERA,
	LIGHT,
	PARTICLE_SYSTEM,
	// ...
	MONO_BEHAVIOUR,
	END,
};
이렇게 LIGHT 뒤에 새로 추가 해줍니다. 

4-2)Material
이전에 SetVec2 까지는 만들었는데 SetVec4 는 아직 만들지 않았어서 만들어 주겠습니다. 

마테리얼에서 파라미터의 갯수를 관리해주고 있는 enum 에도 추가
enum
{
	MATERIAL_INT_COUNT = 4,
	MATERIAL_FLOAT_COUNT = 4,
	MATERIAL_TEXTURE_COUNT = 4,
	MATERIAL_VECTOR2_COUNT = 4,
	MATERIAL_VECTOR4_COUNT = 4, // 이부분 추가
};

넘겨주는 파라미터들의 설계도인 struct MaterialParams 도 Vec4 관련 내용들을 추가 
struct MaterialParams
{
	void SetInt(uint8 index, int32 value) { intParams[index] = value; }
	void SetFloat(uint8 index, float value) { floatParams[index] = value; }
	void SetTexOn(uint8 index, int32 value) { texOnParams[index] = value; }
	void SetVec2(uint8 index, Vec2 value) { vec2Params[index] = value; }
	void SetVec4(uint8 index, Vec4 value) { vec4Params[index] = value; }    // 이부분

	array<int32, MATERIAL_INT_COUNT> intParams;
	array<float, MATERIAL_FLOAT_COUNT> floatParams;
	array<int32, MATERIAL_TEXTURE_COUNT> texOnParams;
	array<Vec2, MATERIAL_VECTOR2_COUNT> vec2Params;
	array<Vec4, MATERIAL_VECTOR4_COUNT> vec4Params;                         // 이부분
};

그리고 실제 Material 클래스에서도 함수를 불러 수정할 수 있도록

 	void SetVec4(uint8 index, Vec4 value) { _params.SetVec4(index, value); }

멤버 함수도 추가 해주었습니다. 

4-3) Mesh
ParticleSystem::Render()
{
    // 생략
    _mesh->Render(_maxParticle);
}
이부분도 에러가 뜹니다. 왜 그런지 따라 들어가 보니 
이전까지 Mesh::Render() 함수는 따로 인자를 받아주고 있지 않습니다. 이 걸 이제는 인자로 인스턴스 카운트를 받도록 수정할것입니다. 
선언부는 이렇게 

	void Render(uint32 instanceCount = 1);

인자를 받기 시작하지만 따로 주지 않았을때는 한개가 기본값이 되도록 해줍니다. 

정의부는 이렇게 
void Mesh::Render(uint32 instanceCount)
{
	// GRAPHICS_CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	
    GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, instanceCount, 0, 0, 0);
    // 이전에 이 함수의 두번째 인자가 그냥 상수 1 이었는데 이것을 인자로 받은 InstanceCount 로 변경했습니다.
}

그리고 렌더 함수 윗쪽에 코드 한줄을 주석 처리했는데 이부분도 수정해줘야 합니다. 무슨 함수였냐면 메쉬의 기본단위를 삼각형 형태로 설정하는 코드인데 

앞으로 파티클 시스템에서는 점 형태의 단위도 사용할것이기 때문에 이대로 그냥 사용하지는 못합니다. 
다른 곳으로 옮겨야 하는데 일단은 주석처리로 해놓겠습니다. 

이건 일단 그렇다 치고 파티클 시스템의 렌더하는 부분을 보면 에러가 통과 됐습니다. 

4-4) Resources
다음 수정할 코드는 Resources 입니다. 
여기서는 LoadPointMesh 와 디폴트 셰이더 디폴트 마테리얼을 추가 해줄것입니다. 

LoadPointMesh 부터 추가 해줄건데 왜 점하나만 있는 메쉬를 만들어야 하는지는 이론시간때와 셰이더 파일을 만들때 알아보았습니다. 

Geometry Shader 에서 이 파티클이 그려질 파티클인지 안그릴 파티클인지를 구별한다음 그려질 파티클만 그때서야 삼각형 두개로 RectangleMesh 를 만들었었습니다. 
그리지도 않을 파티클을 CPU 에서부터 사각 메쉬로 넘기지 않기 위해서 입니다. 

LoadPointMesh 의 내용입니다.
shared_ptr<Mesh> Resources::LoadPointMesh()
{
	shared_ptr<Mesh> findMesh = Get<Mesh>(L"Point");
	if (findMesh)
		return findMesh;
    // 이미 포인트 메쉬가 있다면 그걸 리턴해주는 부분

    // 없다면 생성
	vector<Vertex> vec(1);  // 정점 하나
	vec[0] = Vertex(Vec3(0, 0, 0), Vec2(0.5f, 0.5f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
    // Vertex 클래스의 생성자 함수로 인자는 순서대로 Position, UV, Normal, Tangent 값

	vector<uint32> idx(1);
	idx[0] = 0;

	shared_ptr<Mesh> mesh = make_shared<Mesh>();
	mesh->Init(vec, idx);
	Add(L"Point", mesh);

	return mesh;
}

이어서 디폴트 셰이더, 마테리얼을 추가 해주겠습니다. 

Resources::CreateDefaultShader() 에서 마지막에 추가 했던 내용이 Compute Shader 였습니다. 
여기에 Paticle Shader, ComputeParticle Shader 를 추가해줍니다. 
	// Particle
Resources::CreateDefaultShader()
	{
		ShaderInfo info =
		{
			SHADER_TYPE::PARTICLE,
			RASTERIZER_TYPE::CULL_BACK,
			DEPTH_STENCIL_TYPE::LESS_NO_WRITE,
			BLEND_TYPE::ALPHA_BLEND,
			D3D_PRIMITIVE_TOPOLOGY_POINTLIST
		};

		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->CreateGraphicsShader(L"..\\Resources\\Shader\\particle.fx", info, "VS_Main", "PS_Main", "GS_Main");
		Add<Shader>(L"Particle", shader);
	}

	// ComputeParticle
	{
		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->CreateComputeShader(L"..\\Resources\\Shader\\particle.fx", "CS_Main", "cs_5_0");
		Add<Shader>(L"ComputeParticle", shader);
	}

여기서도 에러가 몇개 발생하고 있습니다. ShaderInfo 와 CreateGraphicsShader 의 인자 부분인데 
ShaderInfo 는 셰이더 타입이야 추가해주면 되고 마지막 멤버가 토폴로지를 설정해주고 있는데 아까 Mesh::Render 에서 옮겨준다고 했던 토폴로지 입니다. 
셰이더의 정보를 설정할때 어떤 기본 단위로 할 것인지를 여기서 정해주도록 할것입니다. 

또 다른 에러는 CreateGraphicsShader 의 마지막 인자입니다. GS_Main 을 설정해주는데 오류가 납니다. 왜냐면 지금까지 VS 와 PS 만 사용하고 있었습니다. 
이번 강의에서 처음으로 GS를 도입 했죠 이부분도 수정해줄 부분입니다. 

하지만 이 Shader 클래스를 수정하기 전에 할 일이 있습니다. 

까먹기 전에 CreateDefaultMaterial 에 내용들을 추가해줍니다. 
Resources::CreateDefaultMaterial
	// Particle
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Particle");
		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);
		Add<Material>(L"Particle", material);
	}

	// ComputeParticle
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"ComputeParticle");
		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);

		Add<Material>(L"ComputeParticle", material);
	}


4-5) Shader
생각보다 셰이더 클래스에서 수정할내용이 많습니다. 
셰이더 타입을 관리하는 enum class 는 LIGHT 와 COMPUTE 사이에 PARTICLE 을 끼워줍니다. 왜냐면 파티클까지가 그래픽스고 컴퓨트는 별개이니까 그렇습니다. 
enum class SHADER_TYPE : uint8
{
	DEFERRED,
	FORWARD,
	LIGHTING,
	PARTICLE,
	COMPUTE,
};

그리고 나서 ShaderInfo 를 수정해야 합니다. 
ShaderInfo 는 그래픽스 셰이더를 만들때 인자로 들어가서 셰이더의 여러 설정을 할 수 있도록 도와 줍니다. 
멤버들 중에서는 이전에도 토폴로지에 관여하는 

	D3D12_PRIMITIVE_TOPOLOGY_TYPE topologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

이런 멤버가 있었지만 D3D12_PRIMITIVE_TOPOLOGY_TYPE 이라는 enum 은 파이프라인이 Geometry 나 Hull 셰이더에서 기초요소를 어떻게 해석할지를 특정하는 옵션이었습니다.
하지만 이번에 IA 단계서부터 정점 하나만 넣는 것은 D3D_PRIMITIVE_TOPOLOGY 를 사용해야 한다고 합니다. 
D3D_PRIMITIVE_TOPOLOGY 는 IA부터 바인딩되어 넘어온 정점 데이터를 파이프라인에서 어떻게 해석해야하는지를 정하는 enum 입니다. 

struct ShaderInfo
{
	SHADER_TYPE shaderType = SHADER_TYPE::FORWARD;
	RASTERIZER_TYPE rasterizerType = RASTERIZER_TYPE::CULL_BACK;
	DEPTH_STENCIL_TYPE depthStencilType = DEPTH_STENCIL_TYPE::LESS;
    BLEND_TYPE blendType = BLEND_TYPE::DEFAULT;;
    D3D_PRIMITIVE_TOPOLOGY topology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
};
이렇게 ShaderInfo 도 수정을 마쳤고 

다음은 이전 가지 사용하지 않던 GS 를 그래픽스 셰이더를 만드는데에 추가해줍니다.
Shader::CreateGraphicsShader 선언부 인자를 이렇게 바꿨습니다.
    
	void CreateGraphicsShader(const wstring& path, ShaderInfo info = ShaderInfo(), const string& vs = "VS_Main", const string& ps = "PS_Main", const string& gs = "");

VS, PS 는 각각 생성하는 함수를 사용했었습니다. GS 도 마찬가지로 함수가 필요해집니다.
그런데 이 GS 는 항상 사용하는게 아니라 필요한 경우에만 사용했었습니다. 필요없으면 빈문자열로 설정되게 기본값을 설정 해주었습니다. 
이걸 활용하여 

if(gs.empty() == false)
    CreateGeometryShader(path, gs, "gs_5_0"); 

으로 체크를 해줄것입니다. 

이제 CreateGeometryShader 를 만들겠습니다. 
void Shader::CreateGeometryShader(const wstring& path, const string& name, const string& version)
{
	CreateShader(path, name, version, _gsBlob, _graphicsPipelineDesc.GS);
}

그리고 Shader.h 에 멤버 변수로 

	ComPtr<ID3DBlob>					_gsBlob;

이것도 추가하였습니다. 

아직 수정할 내용이 있습니다. ShaderInfo 의 멤버들을 가지고 switch case 문을 도는게 몇가지 있는데 
그중에 이번 Particle 이라는 ShaderType 이 생겼으니 이부분도 추가해줘야 합니다. 
	switch (info.shaderType)
	{
	case SHADER_TYPE::DEFERRED:
		_graphicsPipelineDesc.NumRenderTargets = RENDER_TARGET_G_BUFFER_GROUP_MEMBER_COUNT;
		_graphicsPipelineDesc.RTVFormats[0] = DXGI_FORMAT_R32G32B32A32_FLOAT; // POSITION
		_graphicsPipelineDesc.RTVFormats[1] = DXGI_FORMAT_R32G32B32A32_FLOAT; // NORMAL
		_graphicsPipelineDesc.RTVFormats[2] = DXGI_FORMAT_R8G8B8A8_UNORM; // COLOR
		break;
	case SHADER_TYPE::FORWARD:
		_graphicsPipelineDesc.NumRenderTargets = 1;
		_graphicsPipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		break;
	case SHADER_TYPE::LIGHTING:
		_graphicsPipelineDesc.NumRenderTargets = 2;
		_graphicsPipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		_graphicsPipelineDesc.RTVFormats[1] = DXGI_FORMAT_R8G8B8A8_UNORM;
		break;
	case SHADER_TYPE::PARTICLE:     // 이부분 추가
		_graphicsPipelineDesc.NumRenderTargets = 1;
		_graphicsPipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		break;
	}

    
아직도 남은 수정점은 아까 ShaderInfo 의 멤버중 토폴로지 타입을 그냥 토폴로지 자체로 바꿔서 들고 있었습니다.
이전의 토폴로지 타입은 _graphicsPipelineDesc.PrimitiveTopologyType 을 설정해주는 데에 사용되고 있었습니다.
지금은 타입 대신 토폴로지 자체를 들고 있기 때문에 변환을 해줘야 하는데 이 변환 함수 GetTopologyType 도 만들어줍니다.
내용은 많이 길어서 생략하지만 자신이 어떤 토폴로지인가에 따라 토폴로지 타입을 반환하는 switch case 문 함수입니다. 

이렇게 Shader 까지 코드 수정이 끝났습니다. 


5) SceneManager
다음은 이제 물체를 배치해보겠습니다. 
항상 물체를 배치할때는 LoadTestScene 에서 했습니다. 

이 함수의 마지막 부분에 파티클 시스템 물체를 만들어 줄겁니다. 
#pragma region ParticleSystem
	{
		shared_ptr<GameObject> particle = make_shared<GameObject>();
		particle->AddComponent(make_shared<Transform>());
		particle->AddComponent(make_shared<ParticleSystem>());      // SceneManager.cpp 에 ParticleSystem 클래스를 include 해줘야 합니다.
		particle->SetCheckFrustum(false);
		particle->GetTransform()->SetLocalPosition(Vec3(0.f, 0.f, 100.f));
		scene->AddGameObject(particle);
	}
#pragma endregion
하는 내용은 간단합니다. 게임 오브젝트 객체를 만들고 트랜스폼, 파티클시스템 컴포넌트를 추가한다음 로컬 포지션을 원래 있던 큐브 정도에 설정했습니다.

이제 파티클시스템 이라는 컴포넌트가 게임 오브젝트에 장착이 되는것 까지 끝났는데, 파티클 시스템을 꺼내오는 부분은 아직 안만들었습니다. 


6) GameObject
게임 오브젝트에서는 게임오브젝트가 들고 있을수 있는 컴포넌트를 외부로 꺼내는 함수들이 있습니다. 
그중에 GetParticleSystem을 만들것입니다. 

정의부입니다.
shared_ptr<ParticleSystem> GameObject::GetParticleSystem()
{
	shared_ptr<Component> component = GetFixedComponent(COMPONENT_TYPE::PARTICLE_SYSTEM);
	return static_pointer_cast<ParticleSystem>(component);
}
// 선언부에서는 전방선언만 했기때문에 정의부에서는 #include "ParticleSystem.h" 를 해줘야합니다. 


6) Camera
이제는 파티클들을 어떻게 그려주는지를 생각해야하는데 그려주는것은 카메라에서 하고 있었습니다. 

이전까지 카메라에서 어떻게 그려주고 있었는지를 다시 보면 그려주기 전에 정렬을 먼저하면서 Deferred 와 Forward 를 분류해서 렌더링 하고 있습니다. 

그러면 파티클을 둘중 어디에 속할까요 사실 둘다 아니고 새로운 타입으로 봐야합니다. 

정렬해서 각 타입의 vector 에 담고 있었는데 파티클 벡터도 만들었습니다. 

	vector<shared_ptr<GameObject>>	_vecParticle;

이제는 정렬하는 함수를 다시 봐야합니다. 정렬할 타입이 하나더 늘었기 때문입니다. 
변경점을 보면 
void Camera::SortGameObject()
{
	shared_ptr<Scene> scene = GET_SINGLE(SceneManager)->GetActiveScene();
	const vector<shared_ptr<GameObject>>& gameObjects = scene->GetGameObjects();

	_vecForward.clear();
	_vecDeferred.clear();
	_vecParticle.clear();       // 변경점 새로 정렬할 벡터를 정렬시작전에 한번 clear 해줍니다. 

	for (auto& gameObject : gameObjects)
	{
		if (gameObject->GetMeshRenderer() == nullptr && gameObject->GetParticleSystem() == nullptr)
        // 변경점 이전에는 메쉬렌더러가 없을때만 continue 해줬는데 파티클시스템은 메쉬 렌더러가 없을 수도 있기 때문에 둘 다 없을때만 continue 를 해줍니다. 
			continue;

		if (IsCulled(gameObject->GetLayerIndex()))
			continue;

		if (gameObject->GetCheckFrustum())
		{
			if (_frustum.ContainsSphere(
				gameObject->GetTransform()->GetWorldPosition(),
				gameObject->GetTransform()->GetBoundingSphereRadius()) == false)
			{
				continue;
			}
		}

		if (gameObject->GetMeshRenderer())
		{
			SHADER_TYPE shaderType = gameObject->GetMeshRenderer()->GetMaterial()->GetShader()->GetShaderType();
			switch (shaderType)
			{
			case SHADER_TYPE::DEFERRED:
				_vecDeferred.push_back(gameObject);
				break;
			case SHADER_TYPE::FORWARD:
				_vecForward.push_back(gameObject);
				break;
			}
		}
		else  // 변경점 Frustum 체크도 통과하고 Deferred, Forward 타입 둘 다 아니라면 파티클시스템일테니까 _vecParticle 에 푸시 벡 합니다.
		{
			_vecParticle.push_back(gameObject);
		}
	}
}


정렬까지 되었고 이제 렌더링을 어디서 해야 하냐면 
Render_Deferred 가 아니라 Render_Forward 에서 해줄겁니다. 

void Camera::Render_Forward()
{
	S_MatView = _matView;
	S_MatProjection = _matProjection;

	for (auto& gameObject : _vecForward)
	{
		gameObject->GetMeshRenderer()->Render();
	}

	for (auto& gameObject : _vecParticle)
	{
		gameObject->GetParticleSystem()->Render();  // 파티클시스템 include 도 잊지말고 해줘야합니다.
	}
}

다른 포워드 셰이더를 사용하는 물체들이 다 그려지고 난 다음 파티클시스템 물체들도 전부 렌더링 해줍니다.


한번 정리 해보면 물체가 업데이트 될때 FinalUpdate 에서 아까 만든 컴퓨트 셰이더가 실행이 되면서 그려줄 위치 속도 방향등이 정해질것이고 
그리고 카메라->Render 를 하는순간 파티클을 그릴때 사용하는 데이터들으 세팅되어서 메시 렌더로 그려지게 됩니다.

7) Shader
진짜 마지막으로 빼먹은 부분이 있는데 
Shader::Update 입니다. 
void Shader::Update()
{
	if (GetShaderType() == SHADER_TYPE::COMPUTE)
		COMPUTE_CMD_LIST->SetPipelineState(_pipelineState.Get());
	else
	{
		GRAPHICS_CMD_LIST->IASetPrimitiveTopology(_info.topology);  // 변경점 
		GRAPHICS_CMD_LIST->SetPipelineState(_pipelineState.Get());
	}	
}

이전에는 IASetPrimitiveTopology 를 하는 부분이 없었습니다. 이 메소드는 인풋 어셈플리 단계에서 기본 토폴로지가 어떤 형태인지를 세팅하는 함수인데 
이제부터 경우에 따라 기본 토폴로지가 삼각형이던지 점이던지 할 수 있기 때문에 이렇게 그때에 맞게 설정을 해주겠습니다. 
이것 때문에 ShaderInfo 에서도 D3D12_PRIMITIVE_TOPOLOGY_TYPE 에서 D3D_PRIMITIVE_TOPOLOGY 로 바꾼 것 입니다. 


8) 결론 

이러면 파티클 시스템을 구현하였습니다. 

이번시간에 배운 내용은 파티클이란 무엇인지 왜 파티클 시스템이라고 하는지 이전 강의에서 배운 컴퓨트 셰이더를 통해 파티클 시스템의 데이터를 계산하는 것 

상수 버퍼를 사용해 파티클 시스템을 구현하면 왜 성능 손실이 많은지, 그걸 극복하기 위해 구조화 버퍼라는 것을 배운것 
컴퓨트 셰이더에서 계산한 구조화 버퍼를 그대로 다시 t 레지스터에 연결을 해서 렌더링을 한 기술 

이런 내용들을 배웠습니다. 




/*
버그 리포트

버그 1) SceneManager::LoadTestScene 에서 파티클 시스템 오브젝트를 만들때 파티클 시스템 컴포넌트가 상위 클래스인 컴포넌트로 변환이 되지 않았습니다. 
조금 해맸는데 파티클 시스템 헤더를 include 해주지 않아서 그랬습니다. (해결)

버그 2) 구현을 마치고 실행을 해보니 Texture::Load 에서 hr 이 nullptr로 나오는 버그가 발생했습니다. 
강의 예제 프로젝트를 같은 지점에서 중단점을 걸고 디버그 모드를 실행 시킨것과 비교 해보니까 Texture 의 _image 가 예제에는 데이터가 있고 
현재 저의 프로젝트에서는 값들이 전부 0 으로 나옵니다. 제대로 이미지 파일을 읽어오지 못하는것 같습니다. 

Texture::Load 의 코드 진행을 따라가 봤습니다. 확장자 제대로 얻었고 확장자 분류도 png 케이스 까지 잘 갔습니다.
그런데 거기서 
::LoadFromWICFile(path.c_str(), WIC_FLAGS_NONE, nullptr, _image); 
을 실행한 후에 _image 가 텅 비어있었습니다. 

경로를 잘못 설정한것 같아서 다시 입력하고 솔루션도 껏다가 다시 키고 다시 빌드 하기도 했습니다.
그래도 안되서 파티클 이미지가 있는 폴더를 가보니까 파일이름이 bubble.png 라고 해놨더라구요 확장자도 직접 적어놓은겁니다. 
이걸 그냥 bubble 이라고 수정하고 해보니까 통과 되었습니다. 

*/