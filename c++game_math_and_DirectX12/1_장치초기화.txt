
	장치 초기화

장치 초기화는 GPU 에게 외주를 떠넘기기 위한 사전작업입니다.

오늘의 강의는 DirectX 경험이나 Windows API를 다뤄본 경험이 없다면 너무 생소한 내용이 많을 거라고 합니다. 
모든 내용을 외울 필요도 없고 필요할때 그때 그때 찾아서 하면되니깐 겁먹지 말고 배워보겠습니다.

오늘은 주로 Engine 프로젝트에서 진행을 할겁니다. 필요한 클래스들을 만들어줘야 하는데 환경설정때 Engine프로젝트에 
Engine, Resources, Utils라는 필터들을 만들었습니다. 그 중 Engine 필터에 Engine, CommandQueue, Device, DescriptiorHeap, SwapChain
클래스들을 만들어줍니다.

Engine클래스가 핵심기능들을 담게 될것입니다. 
나머지 네가지 클래스들은 각각 기능들을 담당하고 이 Engine클래스로 모아서 관리하게 합니다.

여담으로 DirectX12 책들을 보게 되면 지금처럼 클래스를 쪼개 놓지 않고 단일 클래스에 모든 코드를 담아 놓는 경우가 많은데요 
그러면 너무 많은 코드들이 뒤섞여있어 해석하기 어려울 수 있다고 합니다.

Engine 클래스에 우선 어떤 함수들이 올지 모르지만 void Init();  void Render(); 라는 함수들을 만들어주겠습니다.
Engine을 Init할때는 Client 쪽에서 호출해 줄것입니다. 그때 받아줄 정보가 몇가지 있는데 출력 윈도우 핸들, 윈도우의 너비 , 높이, 창모드 인지 전체화면인지
를 받아 줘야 합니다.

필요한 정보들을 받아줄 struct를 EnginePch.h에 만들어 주겠습니다. 
struct WindowInfo
{
	HWND	hwnd;	// 출력윈도우 핸들
	int32	width;	// 너비
	int32	height;	//높이
	bool	windowed;// 창모드 or 전체화면
};
Engine클래스를 EnginePch.cpp로 include해주고 언제어디서든 가져다 쓸수 있게 하고 싶을때 여러가지 방법이 있는데 
대표적으로는 싱글 톤이라는 디자인 패턴이 있고 간단하게 하기 위해서는 그냥 전역 클래스로 만드는 것도 방법입니다. 
Engine클래스를 동적 할당 할때 무심코 생 포인터를 쓰지 말고 스마트 포인터, 이번에는 유니크 포인터로 만들어 주겠습니다.
std::unique_ptr<Engine> GEngine;  (전역이라는 의미에서 G를 붙였습니다.)
그리고 EnginePch.h에 이 GEngine이라는 클래스가 등장 할것이라는 선언을 해놓습니다. 
extern unique_ptr<class Engine> GEngine;   

이제 EnginePch에 Engine을 만들어 줬고 Engine의 내용을 채워보겠습니다. 
아까 Init에 필요한 정보들을 struct로 만들었으니깐 Init의 인자로 주고 그 데이터를 들고 있을 멤버 변수도 만드고,
void Init(const WindowInfo& window);
WindowInfo		_window;
아직 뭔지 모를 
D3D12_VIEWPORT	_viewport = {};  
D3D12_RECT	_scissorRect = {};
라는 멤버 변수도 만들어 주었습니다. 이 세가지 정보가 그려질 화면 크기 관련된 정보입니다. 
잘 모르는 D3D12로 시작하는 두 변수는 나중에 GPU쪽으로도 전달할 정보입니다.

Init함수의 구현부에서 받은 WnidowInfo를 _window에 초기화 해줍니다.
_window = window;

또 void ResizeWindow(); 함수를 만들어서 받은 windowinfo로 창크기를 조절 해주겠습니다.
구현부는 
	_window.width = width;
	_window.height = height;

	RECT rect = { 0, 0, width, height };
	::AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, false);
	::SetWindowPos(_window.hwnd, 0, 100, 100, width, height, 0);
이렇습니다.  처음보는 함수들과 형식들입니다.  함수들은 윈도우 API고 
함수 앞에 :: 이 붙는 형태는 처음인데 이 기호는 클래스의 멤버 함수를 호출할때와 닮아있습니다. 
:: 의 정체는 글로벌 네임스페이스 입니다. 사실 :: 을 때고 사용해도 별상관없지만 굳이 ::를 붙임으로 인해서 이 함수는 
다른 클래스나 외부 라이브러리 함수가 아닌 C++의 기본적으로 지원하는 윈도우 관련 함수라는 것을 암시 해줍니다.

AdjustWindowRect는 윈도우의 크기를 조절 하는 기능
SetWindowPos는 윈도우를 원하는 위치에 세팅해주겠다 는 기능
 ↳ ( 윈도우 핸들(_window.hwnd)를 이용해가지고 창 크기를 width랑 height만큼 변경한다음 위치를 100, 100에 위치해달라는 의미라고 합니다.)

Engine의 Init 함수에 방금 만든 ResizeWindow를 넣어서 화면 크기도 초기화 해줍니다.
초기화 해주는 김에 멤버 변수 _viewport, _scissorRect도 초기화 해줍니다.
	_viewport = { 0, 0, static_cast<FLOAT>(info.width), static_cast<FLOAT>(info.height), 0.0f, 0.1f};
	_scissorRect = CD3DX12_RECT(0, 0, info.width, info.height);

	첨부 ) _viewport의 인자들이 궁금해서 찾아보니 struct였고 인자들은 순서대로 이렇게 였습니다.
 	   FLOAT TopLeftX;
 	   FLOAT TopLeftY;
 	   FLOAT Width;
  	   FLOAT Height;
  	   FLOAT MinDepth;
  	   FLOAT MaxDepth; 

	_scissorRect의 값으로 준 CD3DX12_RECT는 이전에 윈도우의 비공식적인 공인 라이브러리 d3dx12.h에서 가져온것입니다.
	_scissorRect의 타입인 D3D12_RECT를 좀더 쉽게 사용하도록 다듬은 클래스입니다. 인자 순서 차례대로
	LONG타입 Left, Top, Right, Bottom값입니다.


이제 가장 중요한 우리들의 사총사(CommandQueue, Device, DescriptiorHeap, SwapChain)를 추가해주겠습니다.
Engine 클래스의 멤버 변수로 들고 있을것인데 
스마트 포인터 타입(shared_ptr)로 들고 있을것입니다. 

	// 오늘의 주인공 4총사
	shared_ptr<class Device>		_device;
	shared_ptr<class CommandQueue>	_cmdQueue;
	shared_ptr<class SwapChain>	_swapChain;
	shared_ptr<class DescriptorHeap>     _descHeap;
이 4멤버 변수들의 기능에 대해서는 각각 구현을 하면서 알아보도록 하고 
일단 Engine::Init에서 각 포인터를 make_shared로 초기화 해주었습니다.

이제 각 포인터들에 동적할당을 해주었고 다음으로 각 객체를 초기화(Init)해주어야 합니다.
각 클래스들을 구현 해보겠습니다. 


#### 우선 Device클래스 입니다.
private 변수로 세가지를 만들었습니다. 
	ComPtr<ID3D12Debug>		_debugController;
	ComPtr<IDXGIFactory>		_dxgi; // 화면 관련 기능들
	ComPtr<ID3D12Device>		_device; // 각종 객체 생성
Comptr이라는 아이가 갑작스럽게 등장했는데 
일단 먼저 다이렉트X에 대해 다시 요약해보자면 다이렉트X자체는 GPU를 제어하고 프로그래밍할때 쓰이는 저수준 그래픽 API라고 했습니다.
우리는 다이렉트X만 신경쓰고 GPU제조사와 마이크로소프트가 서로 다이렉트X에 맞게 제조를 한다고 했습니다.
그리고 그걸 가능하게 하는 기술중 하나가 COM이라는 기술입니다.

COM(Component Object Model)
- DX의 프로그래밍 언어 독립성과 하위 호환성을 가능하게 하는 기술
- COM 객체(COM 인터페이스)를 사용. 세부사항은 우리한테 숨겨짐
- ComPtr 일종의 스마트 포인터

우리가 GPU의 자세한 세부 스펙에 대해 몰라도 COM객체를 사용해서 GPU에 접근해 기능들을 사용하는것 처럼 해주는 장점이 있습니다.
그래서 우리는 아무런 위화감 없이 COM이라는 객체를 만들어서 사용하면 되겠습니다. 
ComPtr은 COM객체를 받아주는 스마트 포인터라고 보면 되겠습니다.
우리가 COM객체를 사용할때 셋트로 ComPtr이 따라오고 이것은 일반 포인터 처럼 new, delete를 신경쓰는게 아니라 마치 스마트 포인터 처럼
처음 생성해주면 알아서 Reference Count를 추적해 0이 되면 알아서 delete가 될것입니다.

그럼 이제 Device클래스에서 이 _debugController, _dxgi, _device를 초기화 해줘야 하는데
	void Init();

	ComPtr<IDXGIFactory> GetDXGI() { return _dxgi; }
	ComPtr<ID3D12Device> GetDevice() { return _device; }
이렇게 초기화 함수 하나와 혹시 외부에서 _dxgi나 _device를 꺼내쓸수 있으니 Get 함수도 만들었습니다.

Device.cpp 로 와서 구현부를 만들겠습니다.
#ifdef _DEBUG
	::D3D12GetDebugInterface(IID_PPV_ARGS(&_debugController));
	_debugController->EnableDebugLayer();
#endif
	::CreateDXGIFactory(IID_PPV_ARGS(&_dxgi));
	::D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&_device));
어떤 API들에게 각 세변수들의 주소를 주면서 값을 초기화 하고 있습니다. 
_debugController는 #ifdef _DEBUG에서 보이듯이 디버그를 할때 활성화가 됩니다. 디버깅시 유용한 데이터를 출력해줍니다.

그런데 위 코드들에 공통적으로 IID_PPV_ARGS라는 typedef이 보입니다.
API들이 받는 인자 타입을 보니 const IID 라는것과 void **라는 이중 포인터를 받고 있습니다. 이런 작업들을 
IID_PPV_ARGS라는 typedef이 포인터를 주면 알아서 추출해주는 것 같습니다.

중요한 것은 _device와 _dxgi입니다. 
_device는 디스플레이 어뎁터(그래픽 카드)를 나타내는 객체입니다.
::D3D12CreateDevice라는 API가 받는 인자는 
- pAdapter : nullptr 지정하면 시스템 기본 디스플레이 어댑터
 - MinimumFeatureLevel : 응용 프로그램이 요구하는 최소 기능 수준 (구닥다리 걸러낸다)
- riid : 디바이스의 COM ID
- ppDevice : 생성된 장치가 매개변수에 설정
입니다. 이중 뒤의 두가지 인자는 IID_PPV_ARGS로 주었고 첫번째 인자는 nullptr을 주어서 시스템 기본 디스플레이 어댑터로 설정 했습니다.
재밌는것은 두번째로 오는 인자 인데 이 부분은 이 게임이 최소 이정도 되는 그래픽 카드 이상에서 지원합니다. 라는 의미입니다. 
D3D_FEATURE_LEVEL_11_0 뒤의 11_0 이부분이 최소 DirectX11 을 지원하는 그래픽카드 이상을 뜻합니다.


_device가 그래픽 카드를 나타낸다고 해도 모든 기능들이 전부 여기 들어가 있는 것은 아닙니다.
사실 일반적인 화면 디스플레이와 관련된 기능들은 dxgi에 들어 있습니다. 
(전체 화면 모드 지원, 사용할수 있는 그래픽 카드들을 열거 등) (나중에 swapchain기능도 dxgi를 이용합니다.)


이제 Device의 Init을 구현했으니 Engine에서 _device 객체를 Init 해주려고 하는데 에러가 뜹니다 그 이유는 
Engine.h에서 전방 선언은 해주었지만 실제 Device가 어떤 클래스인지를 안알려 주어서 그렇습니다. 
기왕 include 하는김에 4가지 클래스 전부 include 해두겠습니다.


### CommandQueue

예전 DirectX9 시절 같은경우는 모든 명령을 Device로 전부 처리 했습니다. 하지만 요즘 DirectX12같은 경우 명령이 복잡해 지면서 커맨트 큐가 등장했습니다.

외주로 일감을 줄때 하나주고 그 일이 끝나면 다시 하나주고 하는 방법은 비효율적이겠죠? 한번에 할일들을 왕창 주면 알아서 쭉 처리하는게 더 효율적입니다.

	ComPtr<ID3D12CommandQueue>		_cmdQueue;
	ComPtr<ID3D12CommandAllocator>		_cmdAlloc;
	ComPtr<ID3D12GraphicsCommandList>	_cmdList;

	ComPtr<ID3D12Fence>			_fence;
	uint32					_fenceValue = 0;
	HANDLE					_fenceEvent = INVALID_HANDLE_VALUE;

	shared_ptr<SwapChain>		_swapChain;
	shared_ptr<DescriptorHeap>	_descHeap;

이렇게가 Command Queue의 멤버 변수들 입니다. 이중 위의 세개가 중요한데
_cmdAlloc, _cmdList는  _cmdQueue에 명령을 넣어주는 헬퍼들이라고 할 수 있습니다.
_cmdAlloc은 명령을 넣어주기 위해 메모리를 할당하는 Allocator라고 할수 있고 _cmdList는 말그대로 명령 리스트라고 할수 있습니다.
