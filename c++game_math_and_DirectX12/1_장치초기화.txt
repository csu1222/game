
	장치 초기화

장치 초기화는 GPU 에게 외주를 떠넘기기 위한 사전작업입니다.

오늘의 강의는 DirectX 경험이나 Windows API를 다뤄본 경험이 없다면 너무 생소한 내용이 많을 거라고 합니다. 
모든 내용을 외울 필요도 없고 필요할때 그때 그때 찾아서 하면되니깐 겁먹지 말고 배워보겠습니다.

오늘은 주로 Engine 프로젝트에서 진행을 할겁니다. 필요한 클래스들을 만들어줘야 하는데 환경설정때 Engine프로젝트에 
Engine, Resources, Utils라는 필터들을 만들었습니다. 그 중 Engine 필터에 Engine, CommandQueue, Device, DescriptiorHeap, SwapChain
클래스들을 만들어줍니다.

Engine클래스가 핵심기능들을 담게 될것입니다. 
나머지 네가지 클래스들은 각각 기능들을 담당하고 이 Engine클래스로 모아서 관리하게 합니다.

여담으로 DirectX12 책들을 보게 되면 지금처럼 클래스를 쪼개 놓지 않고 단일 클래스에 모든 코드를 담아 놓는 경우가 많은데요 
그러면 너무 많은 코드들이 뒤섞여있어 해석하기 어려울 수 있다고 합니다.

Engine 클래스에 우선 어떤 함수들이 올지 모르지만 void Init();  void Render(); 라는 함수들을 만들어주겠습니다.
Engine을 Init할때는 Client 쪽에서 호출해 줄것입니다. 그때 받아줄 정보가 몇가지 있는데 출력 윈도우 핸들, 윈도우의 너비 , 높이, 창모드 인지 전체화면인지
를 받아 줘야 합니다.

필요한 정보들을 받아줄 struct를 EnginePch.h에 만들어 주겠습니다. 
struct WindowInfo
{
	HWND	hwnd;	// 출력윈도우 핸들
	int32	width;	// 너비
	int32	height;	//높이
	bool	windowed;// 창모드 or 전체화면
};
Engine클래스를 EnginePch.cpp에 include해주고 언제어디서든 가져다 쓸수 있게 하고 싶을때 여러가지 방법이 있는데 
대표적으로는 싱글 톤이라는 디자인 패턴이 있고 간단하게 하기 위해서는 그냥 전역 클래스로 만드는 것도 방법입니다. 
Engine클래스를 동적 할당 할때 무심코 생 포인터를 쓰지 말고 스마트 포인터, 이번에는 유니크 포인터로 만들어 주겠습니다.
std::unique_ptr<Engine> GEngine = make_unique<Engine>();  (전역이라는 의미에서 G를 붙였습니다.)
그리고 EnginePch.h에 이 GEngine이라는 클래스가 등장 할것이라는 선언을 해놓습니다. 
extern unique_ptr<class Engine> GEngine;   

이제 EnginePch에 Engine을 만들어 줬고 Engine의 내용을 채워보겠습니다. 
아까 Init에 필요한 정보들을 struct로 만들었으니깐 Init의 인자로 주고 그 데이터를 들고 있을 멤버 변수도 만드고,
void Init(const WindowInfo& window);
WindowInfo		_window;
아직 뭔지 모를 
D3D12_VIEWPORT	_viewport = {};  
D3D12_RECT	_scissorRect = {};
라는 멤버 변수도 만들어 주었습니다. 이 세가지 정보가 그려질 화면 크기 관련된 정보입니다. 
잘 모르는 D3D12로 시작하는 두 변수는 나중에 GPU쪽으로도 전달할 정보입니다.

Init함수의 구현부에서 받은 WnidowInfo를 _window에 초기화 해줍니다.
_window = window;

또 void ResizeWindow(); 함수를 만들어서 받은 windowinfo로 창크기를 조절 해주겠습니다.
구현부는 
	_window.width = width;
	_window.height = height;

	RECT rect = { 0, 0, width, height };
	::AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, false);
	::SetWindowPos(_window.hwnd, 0, 100, 100, width, height, 0);
이렇습니다.  처음보는 함수들과 형식들입니다.  함수들은 윈도우 API고 
함수 앞에 :: 이 붙는 형태는 처음인데 이 기호는 클래스의 멤버 함수를 호출할때와 닮아있습니다. 
:: 의 정체는 글로벌 네임스페이스 입니다. 사실 :: 을 때고 사용해도 별상관없지만 굳이 ::를 붙임으로 인해서 이 함수는 
다른 클래스나 외부 라이브러리 함수가 아닌 C++의 기본적으로 지원하는 윈도우 관련 함수라는 것을 암시 해줍니다.

AdjustWindowRect는 윈도우의 크기를 조절 하는 기능
SetWindowPos는 윈도우를 원하는 위치에 세팅해주겠다 는 기능
 ↳ ( 윈도우 핸들(_window.hwnd)를 이용해가지고 창 크기를 width랑 height만큼 변경한다음 위치를 100, 100에 위치해달라는 의미라고 합니다.)

Engine의 Init 함수에 방금 만든 ResizeWindow를 넣어서 화면 크기도 초기화 해줍니다.
초기화 해주는 김에 멤버 변수 _viewport, _scissorRect도 초기화 해줍니다.
	_viewport = { 0, 0, static_cast<FLOAT>(info.width), static_cast<FLOAT>(info.height), 0.0f, 0.1f};
	_scissorRect = CD3DX12_RECT(0, 0, info.width, info.height);

	첨부 ) _viewport의 인자들이 궁금해서 찾아보니 struct였고 인자들은 순서대로 이렇게 였습니다.
 	   FLOAT TopLeftX;
 	   FLOAT TopLeftY;
 	   FLOAT Width;
  	   FLOAT Height;
  	   FLOAT MinDepth;
  	   FLOAT MaxDepth; 

	_scissorRect의 값으로 준 CD3DX12_RECT는 이전에 윈도우의 비공식적인 공인 라이브러리 d3dx12.h에서 가져온것입니다.
	_scissorRect의 타입인 D3D12_RECT를 좀더 쉽게 사용하도록 다듬은 클래스입니다. 인자 순서 차례대로
	LONG타입 Left, Top, Right, Bottom값입니다.


이제 가장 중요한 우리들의 사총사(CommandQueue, Device, DescriptiorHeap, SwapChain)를 추가해주겠습니다.
Engine 클래스의 멤버 변수로 들고 있을것인데 
스마트 포인터 타입(shared_ptr)로 들고 있을것입니다. 

	// 오늘의 주인공 4총사
	shared_ptr<class Device>		_device;
	shared_ptr<class CommandQueue>	_cmdQueue;
	shared_ptr<class SwapChain>	_swapChain;
	shared_ptr<class DescriptorHeap>     _descHeap;
이 4멤버 변수들의 기능에 대해서는 각각 구현을 하면서 알아보도록 하고 
일단 Engine::Init에서 각 포인터를 make_shared로 초기화 해주었습니다.

이제 각 포인터들에 동적할당을 해주었고 다음으로 각 객체를 초기화(Init)해주어야 합니다.
각 클래스들을 구현 해보겠습니다. 


#### 우선 Device클래스 입니다.
private 변수로 세가지를 만들었습니다. 
	ComPtr<ID3D12Debug>		_debugController;
	ComPtr<IDXGIFactory>		_dxgi; // 화면 관련 기능들
	ComPtr<ID3D12Device>		_device; // 각종 객체 생성
Comptr이라는 아이가 갑작스럽게 등장했는데 
일단 먼저 다이렉트X에 대해 다시 요약해보자면 다이렉트X자체는 GPU를 제어하고 프로그래밍할때 쓰이는 저수준 그래픽 API라고 했습니다.
우리는 다이렉트X만 신경쓰고 GPU제조사와 마이크로소프트가 서로 다이렉트X에 맞게 제조를 한다고 했습니다.
그리고 그걸 가능하게 하는 기술중 하나가 COM이라는 기술입니다.

COM(Component Object Model)
- DX의 프로그래밍 언어 독립성과 하위 호환성을 가능하게 하는 기술
- COM 객체(COM 인터페이스)를 사용. 세부사항은 우리한테 숨겨짐
- ComPtr 일종의 스마트 포인터

우리가 GPU의 자세한 세부 스펙에 대해 몰라도 COM객체를 사용해서 GPU에 접근해 기능들을 사용하는것 처럼 해주는 장점이 있습니다.
그래서 우리는 아무런 위화감 없이 COM이라는 객체를 만들어서 사용하면 되겠습니다. 
ComPtr은 COM객체를 받아주는 스마트 포인터라고 보면 되겠습니다.
우리가 COM객체를 사용할때 셋트로 ComPtr이 따라오고 이것은 일반 포인터 처럼 new, delete를 신경쓰는게 아니라 마치 스마트 포인터 처럼
처음 생성해주면 알아서 Reference Count를 추적해 0이 되면 알아서 delete가 될것입니다.

그럼 이제 Device클래스에서 이 _debugController, _dxgi, _device를 초기화 해줘야 하는데
	void Init();

	ComPtr<IDXGIFactory> GetDXGI() { return _dxgi; }
	ComPtr<ID3D12Device> GetDevice() { return _device; }
이렇게 초기화 함수 하나와 혹시 외부에서 _dxgi나 _device를 꺼내쓸수 있으니 Get 함수도 만들었습니다.

Device.cpp 로 와서 구현부를 만들겠습니다.
#ifdef _DEBUG
	::D3D12GetDebugInterface(IID_PPV_ARGS(&_debugController));
	_debugController->EnableDebugLayer();
#endif
	::CreateDXGIFactory(IID_PPV_ARGS(&_dxgi));
	::D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&_device));
어떤 API들에게 각 세변수들의 주소를 주면서 값을 초기화 하고 있습니다. 
_debugController는 #ifdef _DEBUG에서 보이듯이 디버그를 할때 활성화가 됩니다. 디버깅시 유용한 데이터를 출력해줍니다.

그런데 위 코드들에 공통적으로 IID_PPV_ARGS라는 typedef이 보입니다.
API들이 받는 인자 타입을 보니 const IID 라는것과 void **라는 이중 포인터를 받고 있습니다. 이런 작업들을 
IID_PPV_ARGS라는 typedef이 포인터를 주면 알아서 추출해주는 것 같습니다.

중요한 것은 _device와 _dxgi입니다. 
_device는 디스플레이 어뎁터(그래픽 카드)를 나타내는 객체입니다.
::D3D12CreateDevice라는 API가 받는 인자는 
- pAdapter : nullptr 지정하면 시스템 기본 디스플레이 어댑터
 - MinimumFeatureLevel : 응용 프로그램이 요구하는 최소 기능 수준 (구닥다리 걸러낸다)
- riid : 디바이스의 COM ID
- ppDevice : 생성된 장치가 매개변수에 설정
입니다. 이중 뒤의 두가지 인자는 IID_PPV_ARGS로 주었고 첫번째 인자는 nullptr을 주어서 시스템 기본 디스플레이 어댑터로 설정 했습니다.
재밌는것은 두번째로 오는 인자 인데 이 부분은 이 게임이 최소 이정도 되는 그래픽 카드 이상에서 지원합니다. 라는 의미입니다. 
D3D_FEATURE_LEVEL_11_0 뒤의 11_0 이부분이 최소 DirectX11 을 지원하는 그래픽카드 이상을 뜻합니다.


_device가 그래픽 카드를 나타낸다고 해도 모든 기능들이 전부 여기 들어가 있는 것은 아닙니다.
사실 일반적인 화면 디스플레이와 관련된 기능들은 dxgi에 들어 있습니다. 
(전체 화면 모드 지원, 사용할수 있는 그래픽 카드들을 열거 등) (나중에 swapchain기능도 dxgi를 이용합니다.)


이제 Device의 Init을 구현했으니 Engine에서 _device 객체를 Init 해주려고 하는데 에러가 뜹니다 그 이유는 
Engine.h에서 전방 선언은 해주었지만 실제 Device가 어떤 클래스인지를 안알려 주어서 그렇습니다. 
기왕 include 하는김에 4가지 클래스 전부 include 해두겠습니다.


### CommandQueue

예전 DirectX9 시절 같은경우는 모든 명령을 Device로 전부 처리 했습니다. 하지만 요즘 DirectX12같은 경우 명령이 복잡해 지면서 커맨트 큐가 등장했습니다.

외주로 일감을 줄때 하나주고 그 일이 끝나면 다시 하나주고 하는 방법은 비효율적이겠죠? 한번에 할일들을 왕창 주면 알아서 쭉 처리하는게 더 효율적입니다.

	ComPtr<ID3D12CommandQueue>		_cmdQueue;
	ComPtr<ID3D12CommandAllocator>		_cmdAlloc;
	ComPtr<ID3D12GraphicsCommandList>	_cmdList;

	ComPtr<ID3D12Fence>			_fence;
	uint32					_fenceValue = 0;
	HANDLE					_fenceEvent = INVALID_HANDLE_VALUE;

	shared_ptr<SwapChain>		_swapChain;
	shared_ptr<DescriptorHeap>	_descHeap;

이렇게가 Command Queue의 멤버 변수들 입니다. 이중 위의 세개가 중요한데
_cmdAlloc, _cmdList는  _cmdQueue에 명령을 넣어주는 헬퍼들이라고 할 수 있습니다.
_cmdAlloc은 명령을 넣어주기 위해 메모리를 할당하는 Allocator라고 할수 있고 _cmdList는 말그대로 명령 리스트라고 할수 있습니다.

커맨드 큐 다음으로 _fence라는 이름이 붙은 변수들이 3개 있는데 이 펜스는 
그래픽 카드가 하는 작업이 각각 연관이 없는 일이 수가 매우 많은걸 처리하는건데 그 중에 가끔 그래도 선행 작업이 끝나야 다음 작업을 할수 있는 
명령이라면 이 펜스에서 잠깐 명령주는걸 멈춰봐라 하는 기능입니다. 
그래픽 처리를 CPU가 명령을 적어서 GPU에 넘길때 커맨드 큐를 통해 넘기게 되는데 이 CPU와 GPU의 동기화를 위한 기능이 펜스입니다.
CPU가 연산을 통해 어떤 그림을 그려야하는지를 GPU에게 넘겨주고 GPU는 그림을 그립니다. 
만약 CPU가 연산을 GPU가 그림을 그리는 시간보다 빨라서 GPU가 그림을 다못그렸는데 다음 그림 도안을 넘겨주게 되면 의도하지 않던 그림이 그려질 것입니다.
이 CPU의 그림도안을 잠시 멈춰두게 해주는것이 펜스 입니다.

_cmdQueue, _fence, 다음으로 _swapChain, _descHeap이 멤버 변수로 옵니다. 커맨드 큐는 명령들을 모아서 주는 역할이기 때문에 
스왑체인과 디스크립터 힙의 정보가 필요할때도 있기 때문에 변수로 받아 주고 있습니다. 

이제 함수들을 만들어 줄 것인데 Init함수와 WaitSync함수를 만들어 주겠습니다. Init은 초기화 하기 위한 함수일것이고, 
WaitSync는 _fence를 동작하기 위한 함수입니다.

Init 함수부터 분석 해보면 인자로 device, swapChain, descHeap을 받아 주고 있습니다. 
받은 swapChain과 descHeap으로 초기화 해주고 있고, D3D12_COMMAND_QUEUE_DESC queueDesc = {}; 라는 지역 변수도 만들어주었습니다. 
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
queueDesc객체의 Type과 Flags라는 멤버 변수에 어떤 값을 설정해주고 있습니다. 이 데이터를 기준으로 커맨드 큐의 멤버 변수들을 만들어 줄 것입니다.

그 다음이 중요한데 인자로 받은 device의 멤버 함수CreateCommandQueue로 queueDesc 라는 형식으로 자신의 멤버 변수_cmdQueue에 
커맨드 큐를 만들어 주고있습니다. _cmdQueue에 직접 new ~~~ 로 만들어 주고 있는것이 아니라 device의 함수를 이용해 간접적으로 만들어 주고 있는걸 알 수 있습니다.

그리고 _cmdAlloc과 _cmdList도 비슷하게 device의 멤버 함수 CreateCommandAllocator, CreateCommandList로 초기화 해주고 있습니다.

CreateCommandAllocator는 CreateCommandQueue와 인자가 비슷하지만 CreateCommandList는 인자가 좀 많습니다.
	// GPU가 하나인 시스템에서는 0으로
	// DIRECT or BUNDLE
	// Allocator
	// 초기 상태 (그리기 명령은 nullptr 지정)
device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, _cmdAlloc.Get(), nullptr, IID_PPV_ARGS(&_cmdList));

이런 식인데 모든 인자를 지금 전부 이해해야 하지는 않지만 세번째로 받는 인자가 바로 위에서 만든 _cmdAlloc입니다. 
이 부분이 이전에 배운 std::vector와 비슷한데 벡터도 capacity로 메모리영역을 잡고 그 안에 데이터를 넣어줬습니다. 그리고 
벡터를 clear를 하면 데이터는 날라가지만 이미 잡아 뒀던 capacity는 그대로였습니다. 
커맨드 큐가 이 벡터와 비슷하게 동작합니다. 커맨드 큐의 담아 뒀던 명령들을 싹 날리고 다시 명령을 넣기도 할 텐데 그때도 메모리를 전부 날리는게 아니라 
_cmdAlloc가 메모리를 관리 하고 있을것입니다.

_cmdList는 open / close 상태가 있는데 
open상태에서 list에 command를 넣다가 close 상태일때 제출하는 개념입니다.

다음으로 _fence도 device의 멤버 함수인 CreateFence로 만들어 줍니다. _fenceEvent는 DirectX와 관련된 함수가 아닌 ::CreatEvent로 만들어 줍니다. 
_fenceEvent는 신호등 같은 역할을 하는데 어떤 조건이 만족되면 파란불을 켜주고 어떤 조건이 되면 파란불이 꺼지고 합니다.

CommandQueue 클래스의 소멸자를 만들어주고 소멸자에서 위의 _fenceEvent를 ::CloseHandle(_fenceEvent); 로 닫아 주겠습니다. 
이건 new를 하면 결국 delete를 해주는 것처럼 닫아주는게 정석이라고 합니다.

WaitSync 함수를 분석해보겠습니다. 
일단 _fenceValue는 0부터 시작해서 WaitSync함수의 구현부 첫줄에서  _fenceValue++; 을 해줍니다. 
다음으로 _cmdQueue에도 펜스 벨류를 건내주고 _fence에게도 펜스 벨류를 줘서 거기 까지 끝났으면 _fenceEvent를 실행 시켜달라고 하고 있습니다.

그 실행된 _fenceEvent 라는것 이벤트의 open, close를 스위칭 해준다는 이야기 같고 , event가 open 될때 까지 
::WaitForSingleObject(_fenceEvent, INFINITE);
이부분까지 CPU가 진행을 하다가 _fenceEvent가 close 상태라면 잠시 멈춰있고 이후에 GPU가 _fence->SetEventOnCompletion까지 와서 밀려있던 작업을 끝냈으면
_fenceEvent를 open으로 바꿔주어 CPU의 진행을 다시 재개 시킵니다.
(저는 cpu든 gpu든 통합해서 코드를 한줄씩 읽을 수 있는걸로 착각해서 이해가 조금 걸렸습니다. 
하지만 cpu의 진행과 gpu의 진행이 각각 이라면 이해가 갑니다.)

멀티 쓰레드 에서 이벤트를 다뤄 봤으면 쉽게 이해갈 부분이라고 하는데 경험이 없어서 이해하는데 좀 걸렸습니다.

하지만 이런 중간에 cpu를 놀리는 코드는 별로 좋지 못하다고 합니다. gpu가 일을 하는동안 cpu는 다른 작업 (몬스터 ai같은거) 라도 하고 있어야 
컴퓨터의 모든 성능을 쓸수 있을 겁니다 . 첫 코드이다 보니 간단하게 만들기 위해 그런듯 합니다.

다른 함수로 RenderBegin과 RenderEnd가 있는데 이 함수는 나중에 다른 클래스들을 만들고 나서 다시 배우는걸로 하겠습니다.

GetCommandQueue라는 함수는 외부에서 커맨드 큐가 필요할때 사용하기위한 함수입니다.

일단은 커맨드 큐는 여기까지 하고 



다시 Engine.cpp로 돌아가 _cmdQueue를 초기화 시켜주겠습니다. _cmdQueue는 인자로 device와 swapChain, descHeap이 필요했습니다.
이제 다음 클래스 SwapChain을 알아보겠습니다.

### SwapChain

SwapChain은 한국어로는 교환 사슬 이라고 합니다.

[외주 과정]
- 현재 게임세상에 있는 상황을 묘사하고 그 묘사한 상황을 어떤 공식으로 어떻게 계산할것인지 던져줌니다. 
  그러면 GPU가 열심히 계산(외주)를 합니다. 결과물을 받아서 화면에 그려줍니다.

그러면 [외주 결과물] 을 어떻게 받지?
- 어떤 종이(Buffer)에 그려달라고 부탁해서 결과물을 받아 보는 방법을 해보겠습니다. 
  그러면  특수한 종이를 만들어서 -> 처음에 상황 건내줄때 같이 건내주고 -> 결과물을 받을때 종이에 받는다 OK
  -> 우리 화면에 특수한 종이(외주 결과물)을 출력한다.

이러면 문제가 해결됐을까요? 
게임은 특별한종이 하나를 출력한다고 끝나는 프로그램이 아닙니다. 매 초당 몇십장의 특별한 종이를 출렬해야합니다. 
우리가 만든 특수 종이는 이미 외주 결과물을 출력하고 있는데 다음 장면은 어떻게 그릴까요? 
이전 외주 결과물이 그려진 종이를 다시 GPU에게 건내고 그위에 다시 그려달라고 한다면 지금 프레임과 다음프레임이 살짝 섞이게 될것입니다.

이러지 말고 그냥 처음에 특수 종이를 두개를 만들고 하나는 화면을 그리는 용도 하나는 외주를 맡기는 용도로 사용하면 되겠습니다.
이것이 Double Bufferring!

이렇게 버퍼를 교환하는 작업을 SwapChain이 해줍니다. 
SwapChain이 꼭 두개의 버퍼만 작동하는건 아니고 두개면 충분하니까 두개로 예시를 든 겁니다.

스왑 체인은 프라이빗 변수를 3개 가지고 있을건데 

	ComPtr<IDXGISwapChain>	_swapChain;
	ComPtr<ID3D12Resource>	_renderTargets[SWAP_CHAIN_BUFFER_COUNT];
	uint32			_backBufferIndex = 0;

이중 SWAP_CHAIN_BUFFER_COUNT 는 double bufferring으로 buffer를 두개 만 쓸것이니 2로 입력해도 되지만 매번 하드코딩으로 적는것보다 
EnginePch.h에 enum{ SWAP_CHAIN_BUFFER_COUNT = 2, }; 로 상수화 시켜서 들고 있게 하였습니다.

이제 늘 그랬듯이 초기화 함수 Init을 만들어 주겠습니다.
스왑체인은 초기화할때 windowInfo, dxgi, commandQueue를 받아 줍니다.

혹시라도 Init을 두번 했을까봐 _swapChain을 리셋 해줍니다.

다음으로 
DXGI_SWAP_CHAIN_DESC sd;
이라는 DXGI라이브러리에서 정의한 스왑 체인에 대한 정보를 가진 구조체 sd를 생성합니다. 
그 밑으로 sd구조체의 구성 요소들을 채워줍니다. 결국 버퍼에 그릴 화면이 클라이언트 화면의 크기에 맞출것이기 때문에 windowInfo의 너비 높이등을 참고하고 있습니다.

구성 요소 들을 쭉 보다 보면 BufferCount에 아까 사용했던 SWAP_CHAIN_BUFFER_COUNT( 2 라는 의미 ) 를 사용하고 있습니다.

또 특이한점은 Device가 그래픽스에서 중요하고 CommandQueue도 Device로 생성해주었었는데 
SwapChain은 DXGI에서 생성을 해주고 있습니다. DXGI가 화면 출력에 관한 기능들이 있다고 했는데 
스왑 체인도 꼭 그래픽스를 활용할때만 사용하는 기술이 아니다 보니깐 dxgi안에 들어가 있는걸 알 수 있습니다.

스왑 체인을 하면서 후면 버퍼에 그릴 정보인 cmdQueue와 위에서 필요한 정보들을 정리한 sd의 주소 , 이 스왑 체인을 생성할 _swapCain의 주소를 건내줘서 
생성합니다.

스왑 체인을 생성하면서 같이 버퍼가 만들어지는데 전면 버퍼 후면 버퍼 둘을 _swapChain의 GetBuffer를 통해 _renderTarget에 저장 해줍니다.	

다음 _backBufferIndex는 이름대로 후면 버퍼로 무슨 버퍼가 와 있는지 _renderTargets의 인덱스로 표시 해주고 있습니다. 
체인스왑이 일어나면서 0, 1, 0 ,1 로 번갈아 표시 될 것입니다.

init 다음으로 올 함수들은 

GetSwapChain() : _swapChain을 반환하는 함수입니다.
GetRenderTargets[int32 index] : _renderTargets[ ] 에서 인자로 받은 인덱스의 값을 반환합니다.
GetCurrentBackBufferIndex() : 현재의 후면 버퍼의 인덱스를 반환합니다.
GetCurrentBackBufferResource() : 현재 후면 버퍼인 _renderTargets을 반환합니다.

SwapIndex() : _backBufferIndex = (_backBufferIndex + 1) % SWAP_CHAIN_BUFFER_COUNT;  로 이 함수를 실행할 때 마다 SWAP_CHAIN_BUFFER_COUNT를 순회합니다.
Present() : 현재의 전면 버퍼를 화면에 그려줘 

이렇게 스왑 체인에 대해 알아봤으니  Engine.cpp에 초기화를 해주겠습니다.
_swapChain->Init(info, _device->GetDXGI(), _cmdQueue->GetCmdQueue());
인자로 windowInfo와 _device->GetDXGI()로 DXGI COMptr을 줬고, _cmdQueue->GetCmdQueue(); 로 _cmdQueue COMptr을 주었습니다.



### DescHeap


// [기안서]
// 외주를 맡길 때 이런 저런 정보들을 같이 넘겨줘야 하는데,
// 아무 형태로나 요청하면 못 알아먹는다
// - 각종 리소스를 어떤 용도로 사용하는지 꼼꼼하게 적어서 넘겨주는 용도

DescHeap은 리소스를 건내줄때 표준 양식 같은것

DescHeap은 DirectX12 에서 추가된?(갱신된?) 개념이라고 볼 수 있는데  이전 까지는 View라는 용어로 활용했습니다.
이게 하는 역할은 우리가 GPU에게 요청을 할 때 그냥 리소스 자체를 넘겨주는게 아니라 한번더 랩핑을 해가지고 이 리소스가 무엇인지 적은 기안서같은거라고 보면 되겠습니다.

DescHeap이 들고 있을 멤버 변수들은 
_rtvHeap , _rtvHeapSize , _rtvHandle , _swapChain 인데 rtv는 Render Targets View를 말하는 겁니다.
우리가 지금 추가해준 것이 Render Targets View 밖에 없으니깐 그런데 나중에 여러 정보들이 더 추가가 될것입니다.

이제 Init 함수를 추가 해주겠습니다. DescHeap은 인자로 Device와 SwapChain을 받아주고 있습니다. 구현부에서는 인자로 받을 스왑체인을 include해주겠습니다.

Descriptor Heap 이 DirectX12부터 생겼고 이전 DirectX11까지는 View를 사용하고 있다고 했는데 둘의 차이점은 뭘까요?
View의 경우 CBV(ConstantBufferView), SRV(ShaderResourceView), UAV(UnorderedAccessView) 이런 View들을 각각 관리를 하고 있었는데
Descriptor Heap에서는 모두 _descHeap에 모아서 한번에 관리를 해주고 있다는 차이점이 있습니다.

우리가 리소스 자체는 스왑 체인의 _renderTargets가 가지고 있었습니다. 그걸 묘사하는 기안서를 지금 만들고 있다고 볼 수 있습니다.

코드를 하나씩 읽어보자면 
처음으로 일단 _rtvHeapSize를 Device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV)
로 _stvHeap의 사이즈를 초기화 해주고 있습니다. 이후 나중에 필요한 데이터입니다.

_stvHeapSize가 필요한 이유가 DescHeap이 일종의 배열이라고 보면 되겠습니다. 배열은 배열인데 같은 종류의 데이터끼리 관리하는 배열입니다.

// 같은 종류의 데이터끼리 배열로 관리
// RTV 목록 : [ ] [ ]

다음으로 rtvDesc라는 struct를 만들어서 _rtvHeap이 어떤 사양으로 만들어 질것인지 description을 설정합니다. 
이후 device->CreateDescriptorHeap(&rtvDesc, IID_PPV_ARGS(&_rtvHeap));
로 방금 만든 rtvDesc의 사양으로 _rtvHeap을 생성해줍니다.

지금까지 DescHeap이라는 배열의 틀을 만들어 주었으니 내용물을 채워 넣어야 합니다. 내용물(리소스)은 스왑 체인이 가지고 있다고 했었습니다.

배열의 내용물을 채워주기 위해 배열 첫번째 인덱스의 주소를 알아야 하겠습니다 .
D3D12_CPU_DESCRIPTOR_HANDLE rtvHeapBegin = _rtvHeap->GetCPUDescriptorHandleForHeapStart();
rtvHeapBegin이라는 곳에 위에서 만든 _rtvHeap의 시작 주소를 건내주고( rtvHeapBegin은 진짜 포인터는 아니고 정수 형태로 주소를 관리하고 있습니다.)

이제 내용물을 채우기 위해 for문으로 SWAP_CHAIN_BUFFER_COUNT만큼 반복 해줄 것입니다. 
내용은 먼저 _rtvHandle[i]의 값을 넣어 주고 있는데요 값은 CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeapBegin, i * _rtvHeapSize);
인데 이 코드의 정체가 무었인지 타고 가다 보면 시작하는 핸들의 주소에서 _rtvHeapSize만큼 다음으로 이동하는 내용입니다. 
즉, _rtvHandel은 반복문에서 배열의 인덱스를 증가 시키는 기능을 합니다.

핸들이라는 용어가 자주 나오는데 Windows API에서 포인터 같은 역할입니다. 운영체제에서 리소스들이 있는데 이 리소스의 주소를 가리키기 위한 정수형태의 주소를 담는 변수?

_rtvHandle의 값을 주고 난 뒤에 
device->CreateRenderTargetView(swapChain->GetRenderTarget(i).Get(), nullptr, _rtvHandle[i])
스왑체인이 가지고 있는 i번째 렌더타겟을 rtvHadel[i]가 가리키고 있는 주소에 채워 줍니다.
여기 까지 초기화 함수 였습니다.

초기화 함수 다음으로 
GetRTV(int32 idx)  : Descriptor 핸들을 반환하는데 _rtvHandle[idx]를 리턴합니다.
GetBackBufferView() :  이 함수는 _rtvHandle의 인덱스를 직접 받지 않고 GetRTV(_swapChain->GetCurrentBackBufferIndex()); 를 스왑체인에 후면 버퍼의 인덱스를 받아 리턴합니다.

우리가 스왑체인에서 리소스를 GPU에게 주는데 그 리소스의 양식인 View도 같이 주고 있습니다. 
그러니깐 실제 문서를 주고 실제 문서에 내용이 없는 빈 문서, 양식도 같이 주고 있는겁니다. 

DescriptorHeap을 만들었으니 Engin.cpp에서 Init을 해주겠습니다. Init함수의 인자로 _device->GetDevice(), 스왑체인 자체를 받으니 _swapChain을 인자로 주었습니다.


--------------------------------------

이제 Engine의 Init 함수를 거의 다 채웠습니다.

길었지만 Engine 클래스의 함수는 Init 뿐만이 아니었습니다. 
Render라는 함수도 있었는데 이 두개 끝이 아니었고 또 다른 함수를 만들어 줄 것 입니다. RenderBegin과 RenderEnd() 라는 함수인데 이름이 Begin과 End지만 정말로 
렌더링의 시작과 끝이라는 말은 아닙니다.

void RenderBegin() : 렌더링을 시작 할때 커맨드 큐에 명령들을 밀어 넣을것인데 이 함수가 그런 역할을 합니다.
void RenderEnd() : 그 쌓인 명령들을 GPU에게 보내가지고 실질적으로 그 명령들을 그리는 작업이 실행되는 역할을 합니다.

각 RenderBegin과 RenderEnd는 
_cmdQueue->RenderBegin(&_viewport, &_scissorRect);
_cmdQueue->RenderEnd();
로 커맨드 큐의 멤버 함수들을 이용해 기능합니다.

void Engine::Render()
{
	RenderBegin();

	// TODO : 나머지 물체들 그려준다

	RenderEnd();
}

Render는 이렇게 구현되어있습니다. TODO부분이 비워져 있는것은 이번 강의가 장치 초기화에 대한것이기때문에 다른 렌더링은 나중에 구현할 것입니다.

그럼 이제 커맨드 큐에서 RenderBegin과 RenderEnd를 구현 해주면 작업이 끝이 날겁니다.

CommandQueue의 

RenderBegin 함수를 살펴보겠습니다.
우선 _cmdAlloc을 Reset(),  _cmdList도 Reset 해주었습니다. 새로운 명령들을 담을것이니 이전의 명령들을 싹 날려주는 부분입니다.
저번에 이부분이 벡터의 clear와 비슷하다고 했었습니다.

다음은 D3D12_RESOURCE_BARRIER 타입의 구조체 barrier 에 GetCurrentBackBufferResource와 
D3D12_RESOURCE_STATE_PRESENT // 화면출력
D3D12_RESOURCE_STATE_RENDER_TARGET // 외주 결과물을 

인자로 받는 CD3DX12_RESOURCE_BARRIER::Transition 함수의 반환값을 넣어주고 있습니다.
정확히 D3D12_RESOURCE_BARRIER라는 구조체가 무엇인지 전부 해석하지 못하였지만 Transition의 인자들을 보고 역할을 유추해보자면
화면을 출력하던 버퍼(D3D12_RESOURCE_STATE_PRESENT)를 외주 결과물(D3D12_RESOURCE_STATE_RENDER_TARGET) 과 Transition 바꿔치기를 하는 기능을 합니다.
(스왑 체인의 초기화때 이후로는 그냥 두 버퍼를 연결해 놓는 역할이고 전면 버퍼와 후면 버퍼의 교체는 지금 이 Transition에서 이뤄지는것 같습니다. 
전면 버퍼가 후면 버퍼로 온뒤 다음 그릴장면을 주는게 GetCurrentBackBufferResource 인듯 합니다.)

이 CD3DX12_RESOURCE_BARRIER::Transition 로 만든 barrier를 _cmdList에 
_cmdList->ResourceBarrier(1, &barrier);
로 밀어 넣습니다. 즉 커맨드 큐에 쌓이는 명령이 현재화면과 후방 버퍼의 화면을 바꿔라 인겁니다.

다음은 커맨드 리스트를 리셋했다면 Viewport와 rect를 다시 셋팅 해줘야 합니다. 인자로 받은 viewport와 rect를 사용합니다.

다음으로 어떤 버퍼에 그림을 그려야 하는지 특정해야 합니다.
backBufferView 를 _descheap->GetBackBufferView() 로 받아 줘서 gpu에게 작업을 해야할 후면 버퍼가 이거라고 알려주고 있습니다.
여기 ClearRenderTargetView에서 밝은 하늘 색을 지정 해줬는데 나중에 이 색이 나타나는지를 보고 잘 작동하는지 알 수 있습니다.


일감을 실제로 그리도록 해주는 RenderEnd함수를 살펴보겠습니다.
RenderBegin과 비슷하게 시작합니다만 barrier의 Transition의 인자의 순서가 PRESENT와 RENDER TARGET의 순서가 반대입니다.
이 배리어를 다시 커맨들 리스트에 넣고 close합니다. 

드디어 커맨드 리스트를 실행하는 부분입니다. 커맨드 리스트의 배열에 _cmdList.Get()으로 값을 넣어줍니다. 
다음으로 _cmdQueue->ExecuteCommandLists(_countof(cmdListArr), cmdListArr); 로 들어있던 커맨드 리스트들을 실행합니다.

스왑 체인 present , cpu와 gpu의 동기화를 위해 waitSync, 마지막으로 스왑 체인의 인덱스를 바꿔줍니다.

--------------------------------------------------------------
이제 정말 마지막으로 Client 프로젝트에서 테스트를 해보겠습니다. 
Game클래스의 Init 함수 내에서 EnginePch에서 만들어 놓은 전역 객체 GEngine을 Init() 하고 
Game의 Update함수에서 Render함수를 실행하면 되겠습니다. 

GEngine의 초기화는 WindowInfo를 받아줘야 했습니다. 그래서 Game 클래스도 WindowInfo를 받고 GEngine에게 전달해 주겠습니다. 

Game 객체가 있는 Client 클래스의 전역 객체로 WindowInfo를 생성하고 가로(800), 세로(600), 창모드(true) 를  설정해줬습니다.
hwnd 윈도우 핸들은 Client의 함수인 InitInstance에서 스택메모리에서 잠시 만든 
 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);
의 hWnd의 핸들을 
GWindow.hwnd = hWnd; 로 복사해 넣었습니다. 
이제 전부 빌드 후 실행하면 하늘색 화면이 나오면 성공 입니다.





