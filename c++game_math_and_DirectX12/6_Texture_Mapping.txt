

		6 . Texture Mapping


Texture라는 용어가 처음 등장했습니다. 그렇게 어려운 개념은 아니고 그냥 일반적으로 사용하은 2D이미지를 게임쪽에서는 텍스쳐라고 부르고 있습니다.
png, jpg 같은 이미지 파일이라고 생각하면 됩니다. 정점으로 만든 폴리곤 위에 씌우는 용도입니다.

지금까지의 몇몇 강의들로 알록달록한 삼각형들, 사각형을 만들었습니다. 그런데 실제 게임에서도 매우 복잡한 삼각형들의 집합들의 색을 수치로 일일히 지정해서 
만들수는 없습니다. 그럴때 텍스쳐를 매핑한다 라는걸 사용합니다.

텍스쳐를 매핑한다가 구체적으로 무었이냐. 바로 이전에 만든 사각형 메쉬에다가 인터넷에서 가져온 아무 이미지를 척! 갖다 붙히는 겁니다. 
텍스쳐를 붙힐때 픽셀 하나하나에 텍스쳐의 어떤 부분이 매핑되야 하는지를 정하지는 않고, 정점 단위로 매핑을 합니다. 
메쉬의 몇번 정점이 택스쳐의 어느 모서리로 오도록 하는걸 정해주게 되는겁니다.

화면에서 정점들을 표현할때 사용되는 좌표계가 여러종류가 있습니다. 여태껏 사용한 좌표계는 우리가 만든 윈도우 창 가운데를 0,0으로 두고 -1 ~ 1 사이의 float를 이용해서 표현하는
투영 좌표계를 사용했었습니다.

DirectX 진영에서 사용하는 uv 좌표계의 경우 윈도우의 왼쪽 위 끝이 0, 0 좌표를 가지고 우측 위끝은 1, 0 좌측 아래 끝은 0, 1 우측 아래 끝은 1, 1 로 표현하는 좌표계입니다.

정점 v0, v1, v2, v3로 표현한 사각형에게 각 정점에 텍스쳐에 대응하는 uv 좌표를 할당하게 되면 텍스쳐가 어느정점으로 가서 매핑되야하는지 알수 있게 됩니다.

이렇게 메쉬에 텍스쳐를 매핑하게되면 우리가 직접 색상을 지정해주지 않아도 세밀하게 색상이 정해지는걸 보면 누군가가 이 일을 대신 하고 있다는걸 알 수 있는데,
그래픽스 파이프라인이 과정에서 Input Assembler때 정점버퍼, 인덱스버퍼, 매핑할 텍스쳐에 대응하는 uv 좌표등을 건네주고 , 여러 쉐이더 과정들을 거치다
Resterizer단계에서 픽셀마다 알맞은 색상데이터가 입혀지게 됩니다.

# Rasterize? Resterize?
그래픽스 파이프라인 이란 컴퓨터속 가상공간의 3D물체들을 2D 래스터 이미지로 표현하기 위한 단계적 방법을 의미합니다. 
래스터는 컴퓨터에서 어떤 도형 혹은 이미지를 픽셀로 구성하고 이 점들의 모습을 조합, 일정한 간격으로 나열하여 화면에 표현하는것을 말합니다.
#

Resterizer 단계에 대해 좀 더 자세히 말하면, 받은 정점 데이터가 있을때 각 정점들을 이어서 이 삼각형에 포함되는 픽셀들을 찾아주는 역할을 Resterizer에서 해주고
더불어서 각 정점들 사이의 색상을 보간(두 데이터의 평균 혹은 중간 값으로 처리하는방법)작업을 통해 픽셀의 알맞는 색상을 표현합니다.
예를 들면 먼저 만들었던 삼각형에서 각 정점에 빨간색, 초록색, 파란색의 값을 주었는데 정점들의 사이의 거리를 계산해서 안을 채우는 픽셀들의 색상을 적절히 채워주는것입니다.
이 Resterizer는 색상 값만 해당되는게 아니라 uv 좌표를 건내주었을 때도 좌표들의 거리따른 색상을 적절히 계산해주게 됩니다.

이것이 오늘 할 실습의 간단한 설명이었구 이제 코드로 넘어가보겠습니다.

### 코드 ## 

## 사전 작업 DirectXTex 라이브러리
우선 실습을 시작하기전에 할 작업이 있는데, 텍스쳐라는것이 png, jpg등 이미지 파일들이라고 하였는데 이런 텍스쳐를 불러오는 부분이 DirectX에 공식적으로 추가 되어있지 않습니다.
이 부분을 따로 받아와야합니다.

그래서 오늘 사용할것은 마이크로소프트에서 제공하는 DirectXTex를 사용할 것입니다. 
외부 라이브러리를 가져오는 첫번째 실습도 겸할 건데 일단 구글에 DirectXTex를 검색하면 마이크로소프트의 깃허브가 나오는데 다운로드 zip으로 받겠습니다. 
압축을 풀면 꽤 많은 용량인걸 알수 있는데 여러 버전 솔루션들이 있습니다. 그중 지금 제가 사용하는 Visual Studio 2022 윈도우 10 버전의 솔루션을 실행하였습니다.
많은 소스코드들이 있는데 일단 Relese버전으로 한번 빌드를 하고, 다시 Debug버전으로 빌드를 해줍니다. 그러면 그 output이 어디에 있는지 속성의 출력 디렉토리를 확인하면 
bin폴더에 2022 Win 10 이런 폴더 안에 있는걸 확인했습니다. 따라 들어가서 각 Debug 버전과 Relese버전이 있는데 Debug 폴더의 DirectXTex.lib파일을 햇갈리지 않게 DirectXTex_Debug.lib으로 
이름을 바꾸어 백업해두고 , 같은 방식으로 Relese폴더의 DirectXTex.lib을 백업합니다. 이 두 파일말고 또 필요한 파일은 bin의 상위폴더인 DiretXTex폴더에 
DirectXTex.h 와 DirectXTex.inl 파일입니다. 

필요했던 파일들을 전부 우리 프로젝트로 가져와야합니다. 이 강의에서는 외부 라이브러리를 관리하기위해 프로젝트 폴더에서 Library->Lib->DirectXTex 폴더에는 DirectXTex_Debug.lib와 
DirectXTex.lib를 관리하고 Library->include->DirectXTex 폴더에는 헤더와 inl 파일을 관리하였습니다.
#

이제 새로운 라이브러리를 가져왔으니 우리프로젝트에 알려줘야합니다. 
Engine프로젝트의 Utils 필터의 EnginePch.h에서 우리가 사용할 라이브러리들을 모두 관리하고 있었는데요 적절한 위치에 include 해주었습니다

#include <DirectXTex/DirectXTex.h>
#include <DirectXTex/DirectXTex.inl>

#ifdef _DEBUG
#pragma comment(lib, "DirectXTex\\DirectXTex_debug.lib")
#else
#pragma comment(lib, "DirectXTex\\DirectXTex.lib")
#endif

하지만 지금은 경로를 설정해주지 않아서 빌드가 되지않습니다. Engine프로젝트의 속성으로 들어가서 VC++ 디렉터리->포함디렉터리->편집->$(SolutionDir)Library/include/를 추가 해서 
경로를 잡아주었습니다.
Client 프로젝트에도 경로를 추가해주겠습니다. Client는 포함디렉터리뿐만아니라 라이브러리 디렉터리도 경로를 추가해주었습니다. ($(SolutionDir)Library/Lib/ 으로)
#



## Game클래스 부터 살펴보는 전체적인 얼개

Game클래스 부터 보면 텍스쳐를 shared_ptr로 생성해주고 있습니다. 그리고 정점 데이터를 설정해줄때 uv라는 멤버도 같이 설정해줍니다. 메쉬와 텍스쳐를 매칭할때 사용하는 uv좌표계라고 했었습니다.
정점 정보의 구조는 EnginePch.h에서 pos, color로 관리하고 있었는데 여기에 uv라는 벡터도 추가해서 관리해주겠습니다. 다음으로 추가해 줄 코드는 위에서 생성한 texture객체를 Init해주겠습니다.
인자는 텍스쳐파일의 경로를 받아주고 있습니다.
이제 Game::Update에서 mesh->Render를 하기전에 mesh->SetTranform이후에 mesh->SetTexture를 해줍니다. 이 부분에서 메쉬와 텍스쳐가 uv좌표에 따라 매핑이 되도록 
textrure 파일을 준비하는겁니다.
(텍스쳐의 경로로 Resource\\Texture\\veigar.jpg로 하였습니다. 쉐이더 파일과 텍스쳐 파일을 폴더로 구별하였습니다.)



## EnginePch.h 에 추가할 내용

EnginePch.h에 또 추가해줄 내용은 
기존에 enum class로 관리하던 CBV_REGISTER가 있었는데 
비슷하게 
enum class SRV_REGISTER : uint8
{
	t0 = static_cast<uint8>(CBV_REGISTER::END),
	t1,
	t2,
	t3,
	t4,

	END
};
를 만들어 주었습니다. 첫 레지스터인 t0는 CBV_REGISTER::END로 바로 이어서 값들이 오도록 세팅되어있고 이어서 

enum
{
	SWAP_CHAIN_BUFFER_COUNT = 2,
	CBV_REGISTER_COUNT = CBV_REGISTER::END,
	SRV_REGISTER_COUNT = static_cast<uint8>(SRV_REGISTER::END) - CBV_REGISTER_COUNT,
	REGISTER_COUNT = CBV_REGISTER_COUNT + SRV_REGISTER_COUNT,
};
이렇게 수정되었습니다. 처음보다는 복잡하게 보일 수는 있지만 enum class들을 관리하면 알아서 바뀌도록 해놓았습니다.

그리고 ConstantBufferView는 상수 버퍼를 묘사하는 view였는데, 
ShaderResourceView는 우리가 텍스쳐를 넘겨주면서 쉐이더 쪽에서도 텍스쳐를 사용해야될 필요가 생기는데 그것과 관련된 부분입니다.

다음으로 default.hlsli 파일입니다. 이 쉐이더 파일에서 레지스터 b0, b1 에 올려준 것같은 데이터를 어떻게 적용할지 적어 놓았습니다. 
텍스쳐도 마찬가지로 어느경로의 텍스쳐파일을 레지스터에 올려서 이 텍스쳐를 어떻게 사용할지를 이 파일에서 정하는데, 받아줄 매개변수 비슷한걸 default쉐이더 파일에 만들어야 합니다.
Texture2D tex_0 : register(t0);

SamplerState sam_0 : register(s0);
텍스쳐 데이터는 t0라는 레지스터로 받고, 아직 배우지 않은 셈플러 라는 데이터는 s0 레지스터에 받았습니다.


##Texture 클래스

Game에서 만들어 주었던 Texture클래스를 구현해야겠습니다.
이제 Texture클래스를 만들어주겠습니다. Resource필터에 위치 할거구요, 
Texture클래스가 하는역할은 Game\\Resource\\Texture\\에 위치할 이미지 파일을 (여기서는 베이가 사진)경로를 통해 가져오고, 데이터를 버펴 형태로 GPU쪽 저장공간으로 보낸다음 
그 데이터를 묘사한 View를 GPU레지스터에게 알려주는 역할입니다. 


private 멤버 변수는 이렇게 들고 있습니다.

private:
	ScratchImage			 	_image;
	ComPtr<ID3D12Resource>			_tex2D;

	ComPtr<ID3D12DescriptorHeap>		_srvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE		_srvHandle;

처음보는 타입의 변수인 _image가 보이고 리소스 ComPtr _tex2D와 밑에는 View들을 관리할 _srvHeap, 그 주소를 가리킬 _srvHandle이 있습니다.
ConstantBuffer의 DescriptorHeap과 Texture의 DescriptorHeap의 차이점이 있는데,
ConstantBuffer를 사용할때 DescriptorHeap을 엄청 여러개를 만들어서 사용했었는데
Texture는 소수의 View만 만들고 데이터를 변경하지않고 계속 사용한다는 점이 차이점입니다.

다음으로 함수입니다. 
public:
	void Init(const wstring& path);

	D3D12_CPU_DESCRIPTOR_HANDLE GetCpuHandle() { return _srvHandle; }

public:
	void CreateTexture(const wstring& path);
	void CreateView();
Init함수는 텍스쳐 파일의 경로를 받을것이고 내부에서 CreateTexture함수와 CreateView함수를 호출해서 초기화 해줄 겁니다. 그리고 만든 View의 핸들을 꺼내쓸 
GetCpuHandle함수도 있습니다.

Init 함수의 구현부는
 CreateTexture(const wstring& path);
 CreateView();
로 간단해보입니다. 그러면 각 내부 함수들의 구현부를 다시보면
인자로 받은 경로의 텍스쳐 파일의 확장자를 체크하고 있습니다. 텍스쳐파일은 확장자가 하나가 아니라 .dds, .tga, .png, .jpg, .jpeg, .bmp등 다양한 확장자가 있고 
특정 확장자들은 처리하는 함수가 다르기 때문입니다. 확장자에 따른 처리를 한다음 _image에 받아주고 있습니다.
확장자를 얻는 공식적인 방법이 C++17에서 추가되었는데 fs( File System ) 입니다. 문제는 C++17에서 추가된 기능이기때문에 기본적으로는 막혀있습니다.
사용하는 방법은 프로젝트의 속성->C++ 탭 -> 언어 -> C++ 언어 표준 탭 -> C++ 17까지 사용 으로 기능을 사용할수있게됩니다.
그리고 EnginePch.h에 include해줘야 합니다. 
#include <filesystem>
namespace fs = std::filesystem;
파일시스템은 자주 활용하게 될 것이라 fs로 std::filesystem을 간편히 사용하도록 해줍니다.
C++17을 사용하게 되면서 우리 코드에 에러가 한가지 생기게 됩니다. 
C++17에 추가된 std::byte라는 기능과 우리 코드에서 사용하던 byte(윈도우에서 제공하는것)가 곂쳐서 생기는 에러인데요 우리 코드에서 using namespace std; 로 std를 생략 가능하게 해놔서 
그냥 byte만 쳐도 std::byte라고 인식이 되는게 문제입니다. 
이 에러를 해결하려면 using namespace std;를 지우고 코드들을 수정해서 앞에 std::를 하나씩 달아주는 방법과 
아니면 무슨 기능인지는 모르지만 추가된 std::byte를 사용안한다고 선언해 놓는것입니다. 
이 프로젝트에서는 std::byte를 사용안하는 방향으로 해 보겠습니다.
EnginePch.h에 
// std::byte 사용하지 않음
#define _HAS_STD_BYTE 0
를 추가해서 std::byte를 사용하지 않게 해주었습니다.

다음으로 텍스쳐를 GPU에 건내주기위해 CreateCommitedResource를 해주고 있는 부분도 있고 
::UpdateSubresources라는 함수의 인자로 RESOURCE_CMD_LIST가 오는게 보이는데 이 부분을 CommandQueue에서 만들어 줘야합니다.
하나의 cmdQueue 안에 cmdList와 resCmdList를 같이 관리하려는건데 

#커맨드 큐에서 리소스 커맨드리스트
왜 이미 CMD_LIST가 있는데 리소스 용으로 또 만들어줘야 하냐면 
CommandQueue에서 RenderBegin, RenderEnd의 사이에 CMD_LIST에 명령들을 모두 넣어서 RenderEnd때 한번에 실행하는 방식이었습니다.
RenderEnd에서 명령들이 실행되기전에 CMD_LIST를 close 닫아주는데 이후로는 명령을을 넣어줄 수 없습니다.
이렇게 cmdList를 열었다 닫았다 하는 중간에 명령들을 넣는 이유는 렌더링을 하면서 각 프레임마다 필요한 정보들을 확실하게 모아서 실행시키기 위해서입니다.

하지만 명령들말고 리소스의 경우는 꼭 프레임의 사이에 끼워넣어야 한다는 보장이 없을 수도 있습니다.
예를들면 RenderBegin같은 함수가 실행되기도 전에 먼저 리소스를 로드 해야 하는 경우도 생길 것 입니다.
그러다 보니 명령들과 리소스를 같이 관리하기에는 애매해서 
아예 리소스의 cmdList를 따로 만들었습니다.( _resCmdList와 _resCmdAlloc 이라는 변수로 관리합니다.)
CommandQueue::Init에서 같이 초기화를 해줍니다.
이 reCmdList를 활용하는건 RenderBegin이나 RenderEnd에서가 아니라 다른 함수에서 사용합니다.
바로 
void FlushResourceCommandQueue();
라는 함수입니다.
명령들을 받은 cmdList는 RenderEnd에서 할 일을 이 함수 FlusgResourceCommandQueue에서 하는데 
여태껏 리소스들을 받은 resCmdList를 close하고 ExecuteCommandList로 실행후 _resCmdAlloc과 _resCmdList를 리셋 해줍니다.

이렇게 리소스의 커맨드리스트는 RenderBegin, RenderEnd와 기능하는 시점이 완전히 달라지는걸 알 수 있어습니다.
#

Texture클래스 안에서 이런의미의  RESOURCE_CMD_LIST가 활용되고 있었습니다.

Texture::CreateView에서는 생성한 _image, _tex2D 변수를 묘사하는 _srvHeap, _srvHandle을 만들어 주고 있습니다.
##

여기까지 하면 이제 텍스쳐로 사용할 이미지 파일이 어디있는지 경로를 설정하였고, 그 이미지 파일의 확장자에 따라 적절하게 데이터를 _image안에 담았고, 
_image의 정보로 _tex2D와, DEVICE->CreateCommittedResource를 해주었습니다. 그리고 그 _image를 묘사한 _srvHeap과 그 핸들인 _srvHandle을 만들었습니다.

이러면 끝이냐? 아닙니다. 이 텍스쳐 리소스를 GPU레지스터에게 사용한다고 알려줘야합니다. 그 역할을 하는 클래스가 RootSignature입니다.
추가되는것이 DESCRIPTOR_RANGE range[] 라는 배열이 있었는데 이 range는 사용할 레지스터의 범위를 설정합니다. 이전에는 ConstantBuffer를 b0 ~ b4 까지 사용한다고 했었고 
이번에 추가로 SRV 타입으로 t0 ~ t4 까지 사용하는걸로 추가 하였습니다. 

그리고 또 추가되는것이 아까부터 잘 모르겠는 용어인 샘플러 입니다. RootSignature::Init에서 CreateSampler와 CreaeteSignature로 기능별로 나눠서 호출하고 있습니다. 
샘플러가 무엇인지를 알아보자면 음악쪽에서 사용하는 샘플러 라는 용어도 있는데 이 샘플러는 어떤 생활속의 소리를 녹음해 가지고 있다가 필요할때에 재생하는 도구? 개념입니다.

프로그래밍에서도 비슷하다고 하는데 
프로그래밍에서의 샘플러는 여러가지 설정이 있습니다.
예를들어 
  첫번째 오늘 강의의 결과물이 사각형 메쉬에 베이가 이미지를 매핑하는건데 
베이가 이미지의 크기보다 사각형 메쉬의 크기가 더욱 크다고 할때 네 정점에 맞게 이미지를 매핑해야하는데 중간에 비는 픽셀들이 생길것입니다. 
이럴때 어떻게 보간을 해줄것 이냐 그것과 관련된 공식을 설정하는게 있을것이고
  두번째 uv좌표계가 0 부터 1 까지의 좌표안에서 값을 준다고 했는데 만약 좌표가 1을 넘어서 1.5가 되었다 그럴때 이 텍스쳐가 1을 넘어가기 전까지만 출력하고 나머지는 버릴지 
아니면 좌표 1까지 표현후 다시 0으로 돌아가서 나머지 값을 표현해 나갈지를 설정하는것도 있을것입니다. ( WRAP이라는 설정이었다면 1을 넘어가면 다시 되돌아 와서 0부터 시작하는 설정입니다.) 
프로그래밍에서의 샘플러는 이런 그림을 어떻게 그릴 것인가? 초과하는 부분에 대해 어떻게 처리를 할 것 인가를 설정하는게 샘플러라고 할 수 있겠습니다.(텍스쳐를 그려주는 정책?)

아무튼 코드로 돌아와서 RootSignature에 이 샘플러를 만들어 주었는데 
void RootSignature::CreateSamplerDesc()
{
	_samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);
}
샘플러 DESC(0) 즉 기본으로 설정하였습니다. 

이렇게 만든 샘플러 DESC를 CreateRootSignaure에서 같이 서명을 해주었습니다. 이제 레지스터가 쉐이더 파일(default.hlsli)에서 추가한 Texture2D, SamplerState 를 레지스터에서 인식할 수 있게 되었습니다. 
이 쉐이더 파일에서 또 바뀌었던 부분이 인풋 아웃풋의 내용중에 uv좌표도 추가 해줘야 합니다. 추가한뒤 이 쉐이더 파일에 이런게 있다고 알려줘야하는데 이 부분은 Shader클래스에서 했었습니다.
(뭐가 어디에 있는지 지금은 매우 했갈립니다.)

쉐이더에서도 레지스터의 사용을 서명 했으니 TableDescriptorHeap에서도 SRV를 Commit 할 수 있게 해줘야 겠습니다


결론은 텍스쳐를 추가하기위해 이것저것 추가했지만 핵심적인내용은 생각보다 복잡하진 않다.
> 텍스쳐를 로드해서, GPU에 떠넘긴다음, View를 만들어서 사용할 준비를 끝냈고, 그와 관련된 모든 정책들을 수정해줬다 (RootSignature나 Shader, TableDescriptorHeap도)

 



 