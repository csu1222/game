

        23. Normal Mapping


이번 강의의 주제는 노멀 매핑 혹은 범프 매핑이라는 기술에 대해 학습할겁니다. 

이 기술의 필요성부터 시작하겠습니다.

 - 시작하기 전에 준비물이 필요합니다. 베이가 사진 말고 다른 텍스쳐를 사용하고 싶은데 강의에서는 무료 텍스쳐를 사용하기 위해 
 구글에서 diffuse Normal Texture 를 검색해서 두가지 텍스쳐를 구했는데 원하는 텍스쳐의 Normal 파일과 baseColor 파일 두가지씩 다운로드해서 
 저희 프로젝트의 Resources 폴더 -> Texture 폴더 안에 저장해주었습니다.

프로젝트를 조금 수정해주겠습니다. 우선 구모양의 오브젝트였던걸 큐브 형태의 메쉬로 바꾸겠습니다.

SceneManager::LoadTestScene 
{
    shared_ptr<Mesh> sphereMesh = GET_SINGLE(Resources)->LoadSphereMesh();
    meshRenderer->SetMesh(sphereMesh);
}
에서 
{
    shared_ptr<Mesh> sphereMesh = GET_SINGLE(Resources)->LoadCubeMesh();
    meshRenderer->SetMesh(sphereMesh);
}
로 

그리고 텍스쳐를 베이가에서 준비물중 Leather 로 바꾸었습니다.
			texture->Init(L"..\\Resources\\Texture\\Veigar.jpg"); 에서 
			texture->Init(L"..\\Resources\\Texture\\Leather.jpg");  로 
또 한가지 빛 오브젝트도 수정할건데 디렉셔널라이트 만 남기고 나머지는 주석 처리하겠습니다. 
빛의 색상도 diffuse (0.5f, 0.5f, 0.5f), ambient (0.1f, 0.1f, 0.1f), specular (0.1f, 0.1f, 0.1f) 로 흰색 계열로 바꾸고 
LightDirection도 (1.f, 0.f, 1.f) 로 바꾸었습니다.

이번엔 default.hlsli 로 가서 PS_Main 함수부분에서 이전 시간에는 텍스쳐 상관없이 그냥 흰색으로 표현되게 해놨던걸 다시 셈플러를 살려서 
텍스쳐대로 색을 가지도록 해주었습니다.

이대로 빌드를 하고 실행해주면 인터넷에서 받은 Leather 텍스쳐를 입은 큐브가 출력됩니다. 

그런데 물체를 가만히 보니까 좀 밋밋하다는 느낌이 듭니다. 텍스쳐는 가죽이긴한데 표면에 굴곡이 실감이 없는 느낌입니다. 말하자면 입체감이 없어 보입니다.
이런 입체감을 살리기 위한 기술이 오늘의 주제인 노멀 매핑 혹은 범프 매핑 입니다. 


- 개론

우선 왜 이렇게 밋밋한지 이유를 알아보겠습니다. 

Resources::LoadCubeMesh 에 그 이유가 있는데 이 큐브를 이루는 정점데이터 중 앞면을 구성하는 코드만 가져와 보겠습니다.
	// 앞면
	vec[0] = Vertex(Vec3(-w2, -h2, -d2), Vec2(0.0f, 1.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
	vec[1] = Vertex(Vec3(-w2, +h2, -d2), Vec2(0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
	vec[2] = Vertex(Vec3(+w2, +h2, -d2), Vec2(1.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
	vec[3] = Vertex(Vec3(+w2, -h2, -d2), Vec2(1.0f, 1.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));

여기서 vec 는 Vertex 타입의 벡터인데 이 Vertex 라는 구조체는 우리가 이전 시간중에 직접 만들었던 구조체입니다.
struct Vertex
{
	Vertex() {}

	Vertex(Vec3 p, Vec2 u, Vec3 n, Vec3 t)
		: pos(p), uv(u), normal(n), tangent(t)
	{
	}

	Vec3 pos;
	Vec2 uv;
	Vec3 normal;
	Vec3 tangent;
};

이 Vertex 의 내용물중 3번째 내용물인 normal 이 밋밋함의 원인입니다. LoadCubeMesh 와 LoadSphereMesh 함수들을 만들었을때 
Sphere 구는 normal 값을 각 정점마다 계산을해서 넣었던것에 반해 Cube 큐브는 한 면이면 같은 normal 값을 넣었습니다. 
사실 normal 이라는 값이 각 지점의 접면과 수직되는 벡터를 뜻하는데 큐브는 한면에서 normal 값이 같을 수 밖에 없기도 합니다.

그런 이유에서 한면의 정점들의 노멀값이 같다보니까 생긴 현상이 레스터라이즈나 픽셀셰이더 단계에서 각 픽셀들을 보간해 노멀값들을 픽셀마다 매겨주려고 해도 
정점데이터 부터가 그러니 보간된 픽셀들이 빛을 반사해도 질감이 밋밋해집니다.

이 문제를 해결하는 방법으로 지금 알고있는 지식에서는 정점의 갯수를 늘리면 어떨까 생각이 듭니다. 한 면을 이루는 삼각형을 여러개 만들어 각 정점들에 
노멀값을 다르게 주면 좀더 입체감 있어보이기는 할것 같습니다.
정점 데이터를 늘리는 방법의 단점이 있는데 당연하게도 프로그램의 성능이 확연하게 떨어진다는겁니다. 정점 데이터 자체의 용량도 커지고 정점데이터를 또 
레스터라이즈나 픽셀셰이더 단계를 거치는 횟수가 똑같이 늘어날겁니다.

또 다른 방법이 오늘의 주제인 노멀 매핑입니다. 이번시간 준비물로 텍스쳐마다 두개의 파일을 다운 받았었는데 그 중 하나가 지금 이미 적용해놓은 
Leather 이미지 파일이고 또 Leather_Normal 이라는 이름의 파일이 있는데 이것이 정점갯수를 늘리지 않고도 입체감을 줄수 있습니다. 
바로 미리 노멀값을 매 픽셀마다 설정해놓은 이미지 파일입니다. 매 프로그램 실행마다 컴퓨터에게 많은 정점의 계산을 시키는게 아닌 이미 있는 이미지를 덧씌우는 걸로 
같은 효과를 낼수 있습니다. 

이 노멀 파일은 텍스쳐의 형태이긴한데 파란색을 기본으로 한 이미지인데 이 이미지를 해석하기에 따라 그냥 RGB로 받아드리게 되면 그냥 파란색 텍스쳐로 표현됩니다. 
또한 이 파란색의 이미지를 노멀값으로 해석하게 되면 정점의 갯수는 그대로이지만 각 픽셀의 노멀값만 설정을 할 수 있는겁니다.

이게 노멀 매핑의 기본 설명이고 

이후에 코드로 설명하는걸 조금 요약하자면 
우리가 쉐이더 파라미터로 넘기는 Vertex 정보에는 정점의 위치와 텍스쳐에 매핑될 좌표, 노멀값을 들고 있는데 VS_Main 에서 output.uv = input.uv 로 설정해주고 
PS_Main 함수로 넘기기전에 Rasterize 단계로 보간을 해준다음 PS_Main 으로 넘어가는데 이 픽셀 셰이더 단계에 각 픽셀들의 색을 결정해주고 지금은
float4 color = g_tex_0.Sample(g_sam_0, input.uv);
으로 g_tex_0 슬롯에 넘겨준 diffuse 택스쳐를 각 픽셀에 매핑 해줬는데, 다음 슬롯인 g_tex_1 에게 노멀 텍스쳐를 줘서 픽셀의 색 뿐만아니라 노멀값도 설정해주면 되겠습니다.

그런데 이 노멀 텍스쳐를 구글에서 찾아보면 다 파란색 계열의 이미지인걸 알 수 있습니다. 텍스쳐 자체가 이미지 파일이고 RGB 의 색상으로 표현되는 파일 형식이기 때문에 
사실은 색상용도로 사용할건 아니지만 Blue 값이 다 설정 되어있어서 파란 색으로 나타납니다. x,y,z 중 z값이 설정되어있다는 말입니다. 그런데 실제 텍스쳐의 노멀이 벡터값을 가진
걸 표현한걸텐데 각 위치의 노멀 방향이 달라서 일괄 파란색이 아니라 각 부분이 빨간색일수도 있고 초록색일수도 있어야 하는데 왜 거의다 파란색 계열로 나타나는지가 이상합니다.

그 이유가 있는데 노멀 텍스쳐 자체가 로컬좌표계 즉 오브젝트 입장에서의 좌표계를 기준으로 삼지 않습니다. 노멀 텍스쳐 자체의 좌표계를 사용한다는건데 
지금까지 배웠던 로컬, 월드, 뷰, 프로젝션, 스크린 등등 많은 좌표계를 배웠는데 또 좌표계가 늘어나는겁니다. 
하여튼 이유는 게임 오브젝트가 항상 움직이지 않는다면 노멀 벡터를 다른 좌표계 기준으로 표현해도 상관없을겁니다. 그런데 게임에서 캐릭터 메쉬를 가진 게임 오브젝트는 
나중에 애니메이션을 넣어주게되면 걷는 모션, 공격하는 모션 등 메쉬에서 각 정점들의 위치가 계속 바뀔겁니다.
즉, 원본메쉬가 항상 가만히 유지되는게 아니라 로컬기준으로도 항상 변하는 문제가 생깁니다. 그럴때 노멀 벡터를 가만히 있는 로컬기준으로 설정하게 되면 문제가 생기는데
게임 오브젝트가 팔을 휘젓는다고 할때 처음 세팅한 노멀 방향이 모션에 따라 변하지 않고 처음 자세 기준의 노멀 방향을 유지하게 된다는 문제가 생깁니다.
그러면 오브젝트가 움직이는 매 프레임마다 다른 노멀 텍스쳐를 준비해야 된다면 너무 많은 용량을 차지하게 될겁니다. 
그래서 결국에는 노멀 매핑을 해줄때는 노멀 방향을 로컬 좌표계를 기준이 아니라 별도의 좌표계를 하나 더 가지고 있는데 그게 '탄젠트 스페이스'라고 합니다.

- 탄젠트 스페이스 
  이전에 Vertex struct 를 수정하면서 pos, uv 외에 normal 과 tangent 를 추가했었습니다. 그때 탄젠트는 물체의 어떤 한 점에 접한 평면 이라고 했고,
  노멀은 그 탄젠트에 수직인 단위 벡터 라고 설명을 했었는데 
  탄젠트 스페이스는 같은 의미로 어떤 점에  접하는 평면을 기준으로 좌표계를 새로 생각한다는 의미입니다.
  탄젠트 스페이스의 축은 T, B, N 세 축으로 보통 말합니다. 각각 x,y,z 와 같은 의미입니다. 각 좌표를 RGB 로 해석하면 위에서 노멀 텍스쳐가 거의 Blue 색인 이유가 여기에 있습니다.
  물체의 표면에 접한 좌표계를 기준으로 하는데 각 픽셀에 노멀값을 매긴 텍스쳐이고 노멀값이다 보니 z 값, Blue 값을 많이 들고 있을수 박에 없고 간혹 굴곡같은 부분은 비스듬한 
  벡터를 표시하게 되니깐 울긋불긋한 색을 띄게 되는겁니다.

  그런데 탄젠트 스페이스에서 N 은 평면에 수직인 축이니까 구하기 쉽지만 T나 B 는 사실 360도 사방으로 어디로든 정할수 있다보니까 딱 정하기가 쉽지않습니다.
  그래서 이 T 와 B를 구하는 공식이 있긴한데 사실 이 공식까지 알 필요는 없고 필요할때 검색으로 가져다가 쓸수 있도록 이런게 있구나 정도만 알고 가겠습니다.

이제 노멀 텍스쳐가 무엇인지 알았고 이것을 코드에 적용시켜볼 차례입니다. 
텍스쳐 코드를 고치고 쉐이더 코드에서 텍스쳐 0번 슬롯에 받아주던 diffuse 텍스쳐 외에 1번 슬롯에 노멀 텍스쳐도 받아줘서 각 픽셀마다 노멀값을 다시 설정해주도록 하겠습니다.
PS_Main 의 코드를 보면 CalculateLightColor 함수에 넘겨주는 인자중에 노멀값도 넘겨주는데 그 노멀값이 view 스페이스 기준의 노멀값입니다. 즉 탄젠트 스페이스의 노멀값을 
그대로 넘겨주는게 아닌겁니다.

노멀 텍스쳐 데이터를 탄젠트 스페이스 에서 뷰 스페이스로 변환하는 부분을 한번 생각해보겠습니다. 일단 노멀 텍스쳐의 데이터는 각 픽셀마다 RGB로 표현된 좌표값을 가지고 있을겁니다.
여기서 RGB는 각각 1바이트의 용량을 지닌 값으로 정수로 표현했을때  0 ~ 255 사이의 숫자를 담을 수 있다는 이야기입니다. 그런데 우리가 최종적으로 구하고 싶은 건 
노멀 벡터, 방향 벡터를 구하고 싶은 건데 그러면 그 값의 범위는 -1 ~ 1 사이의 범위입니다.
이 변환이 조금 생소합니다. 지금까지 벡터를 표현하기위한 float4 형태는 각 좌표값이 4바이트를 차지하는 float 로 표현된 값이었는데 지금은 각 RGB가 1바이트 만 차지하고 있는 
용량으로 float 인 단위 벡터를 표현하려고 하는겁니다.
용량차이 때문에 변환이 안될것 같지만 단위벡터는 일반 float 의 범위가 아닌 -1 ~ 1 로 한정되어 있다보니 변환이 가능해집니다.
계산기로 계산해보면 -1 에서 1 이니까 2 를 255 로 나눠보면 그 값이 0.0078.... 으로 가는 실수가 나오는데 이정도면 근사값으로 생각하면 충분히 우리가 원하는 값을 다 표현할수 
있을것 같습니다. 정수로 0이면 -1 로 정수 255 이면 1 이 되게끔 잘 변환시켜주겠습니다.

이제 어찌저찌해서 0~255 사이의 숫자를 -1~1 사이의 방향 벡터 값으로 변환을 해줬다고 치고 다음으로 할 일을 알아보겠습니다.
변환을 한 -1 ~ 1 사이의 실수 3개가 묶여서 한 픽셀을 나타내고 있고 이 3가지 원소가 탄젠트 스페이스에서 T, B, N 을 각각 나타내고 있다고 배웠습니다. 
이 중에 N이 Normal 값이기 때문에 중요하다는것도 알고 있어야 합니다.

또 탄젠트 스페이스에서 뷰 스페이스로 변환을 하려고 했었습니다. 그리고 이 좌표계 변환을 우리는 이미 몇번을 해왔습니다. 각 픽셀마다 (x,y,z) 값을 가진 벡터가 있다고 했을때 
적절한 뷰 변환 행렬을 곱해주면 그게 좌표계 변환이었습니다.
이전에는 float4 타입으로 되어있는 벡터를 주로 다뤘는데 그건 Transition, Scale, Rotation 세가지 성분을 모두 표현하기위해 (x,y,z,w) 와 4x4 행렬을 연산했었습니다
그런데 지금 노멀 벡터는 위치정보인 Transition이 필요없는 상황이기 때문에 3x3 스케일의 변환행렬을 구해주면 됩니다.

노멀 텍스쳐에 있는 각 픽셀들의 RGB 값을 방향벡터로 바꿔서 3x3 사이즈의 뷰 변환 행렬을 곱해주면 되는것 까지 알았습니다. 
이전에 변환행렬을 구하면서 변환행렬의 각 행을 어떤 특정한 방법으로 먼저 구하고 시작했었습니다. 변환이전 좌표계의 기저 벡터들 (x축 y축 z축 방향의 단위벡터들)
을 변환 이후의 기준으로 변환해서 1행에 x축, 2행에 y축, 3행에 z축을 넣어 주면 그게 좌표계 변환 행렬이라고 했습니다.
			Tx Ty Tz
(x, y, z) * Bx By Bz  = (X,Y,Z)
			Nx Ny Nz

그러면 이제 탄젠트 좌표계의 기저벡터들을 어떻게 뷰 스페이스 기준으로 변환을 하는지를 알아야합니다.
쉐이더 파일에서 사용하고 있는 CalculateLightColor의 인자중에 이미 input.viewNormal 이라는걸 이미 알고 있었습니다. 
거기에 LoadCubeMesh 함수를 보면 normal 값과 tangent 값을 설정해주고 있습니다. 거기에 normal 과 tangent 를 외적하면 Binormal 을 구할수 있습니다.
그러면 이제 3가지 기저벡터들을 알수 있다는 말이고 
(노멀과 탄젠트를 외적해주지 않고 아예 처음부터 바이노멀을 들고있게끔 Vertex struct 를 수정해줄 수도 있습니다.)
이렇게 알게된 TBN 기저벡터를 뷰 스페이스로 변환후 노멀 텍스쳐의 각 픽셀의 값을 변환해주고 CalculateLightColor 의 인자로 넣어주면 됩니다.


이제 본격적으로 코드를 수정해보겠습니다.
이번시간에 고칠 코드가 생각보다 많지 않은데 이미 이전 시간에 미리 해놨던 부분들이 있어서 그렇습니다.

먼저 SceneManager 로 가서 텍스쳐를 추가하는 부분부터 해보겠습니다. 
우리가 텍스쳐를 설정하는 방법이 큐브를 만들때 텍스쳐 객체를 만들고 텍스쳐 파일이 있는 경로를 인자로 줘서 초기화를 한 후 Matrial->SetTexture 로 텍스쳐를 설정했었습니다. 
이때 SetTexture 함수의 인자가 첫째로 Matrial 의 멤버 변수인 _textures라는 배열에 인덱스와 할당할 객체를 넘겨줍니다. 
현재 코드인 
material->SetTexture(0, texture);
이 부분은 0번 인덱스에 texture 라는 텍스쳐 객체를 할당한다는 의미이고 또 다른 텍스쳐를 할당하려면 새로 객체를 만들어서 경로를 주고 1번 텍스쳐에 세팅하면 될것 같습니다.
			shared_ptr<Texture> texture = make_shared<Texture>();
			shared_ptr<Texture> texture2 = make_shared<Texture>();
			texture->Init(L"..\\Resources\\Texture\\Leather.jpg");
			texture2->Init(L"..\\Resources\\Texture\\Leather_Normal.jpg");
			material->SetTexture(0, texture);
			material->SetTexture(1, texture2);
이런식입니다.

이러면 노멀 텍스쳐를 넘겨주는건 거의 되었고 
한가지 더 하자면 default.hlsli 에 PS_Main 에서 float4 color = g_tex_0.Sample(g_sam_0, input.uv); 이렇게 텍스쳐를 셰이더에 넘겨줄때 
만약 텍스쳐가 없는 게임 오브젝트도 있을것 같아서 g_tex_0를 null 체크를 해주고 싶은데 불행하게도 셰이더 코드에서는 null 체크가 안됩니다.
비슷한 효과를 내기위해 MATERIAL_PARAMS 에 추가로 int g_tex_on_0 시리즈를 다섯개를 더 만들어서 각 해당되는 g_tex_ 슬롯에 데이터가 있으면 1, 없으면 0을 들고 있게해서 
체크를 해주는 방법을 사용하겟습니다.
cbuffer MATERIAL_PARAMS : register(b2)
{
    int     g_int_0;
    int     g_int_1;
    int     g_int_2;
    int     g_int_3;
    int     g_int_4;
    float   g_float_0;
    float   g_float_1;
    float   g_float_2;
    float   g_float_3;
    float   g_float_4;
    int     g_tex_on_0;
    int     g_tex_on_1;
    int     g_tex_on_2;
    int     g_tex_on_3;
    int     g_tex_on_4;
};
이렇게 MATERIAL_PARAMS 를 수정했으면 똑같이 cpp 파일도 수정해줘야 합니다.
Matrial 클래스로 가서 Material.h 에 정의 해놨던 struct MaterialParams 가 있습니다. 
그 안에 int32 타입에 MATERIAL_TEXTURE_COUNT 개 크기의 배열 texOnParams 를 추가 해주고 이 texOnParams 을 세팅할 함수 SetTexOn 도 만들어 줍니다.
struct MaterialParams
{
	void SetInt(uint8 index, int32 value) { intParams[index] = value; }
	void SetFloat(uint8 index, float value) { floatParams[index] = value; }
	void SetTexOn(uint8 index, int32 value) { texOnParams[index] = value; }

	array<int32, MATERIAL_INT_COUNT> intParams;
	array<float, MATERIAL_FLOAT_COUNT> floatParams;
	array<int32, MATERIAL_TEXTURE_COUNT> texOnParams;
};

이 SetTexOn 을 직접 사용해서 텍스쳐를 추가 할 때마다 하나씩 수정해줄 수도 있지만 그냥 텍스쳐를 추가할때마다 자동으로 설정되게 해주면 더 편할것 같습니다.

텍스쳐를 추가하는 함수인 
	void Material::SetTexture(uint8 index, shared_ptr<Texture> texture) { _textures[index] = texture; }
이걸 수정 해줄건데 텍스쳐가 설정 될때의 인덱스와 같은인덱스에 _params.SetTexOn 을 해주면 될것같습니다.
	void SetTexture(uint8 index, shared_ptr<Texture> texture) {
		_textures[index] = texture;
		_params.SetTexOn(index, (texture == nullptr ? 0 : 1));
	}
여기서 처음보는 문법인 삼항 연산자라는 문법이 나왔습니다. 자세한 설명은 말고 어떤의미인지만 잠시 알아보고 넘어갈건데 
(texture == nullptr ? 0 : 1) 
texture가 nullptr와 같은지(texture == nullptr) 체크해서 (?) 참이면 0 (0) 거짓이면 1 (: 1) 이라는 뜻입니다. 
즉 간단한 if else 문인데 그걸 한줄로 표현하는 문법입니다.

이제 셰이더로 돌아가 보겠습니다. 

먼저 현재 default.hlsli 의 VS_IN에서 받아주고 있는 데이터들은 pos, uv, normal 세가지를 받아주고 있는데 하나더 tangent 를 더 받아주겠습니다. 이미 cpp에서는 넘겨주고 있었지만
셰이더에서 받지 않고 있던걸 이제야 받아주는 느낌입니다.
struct VS_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;
};
혹시나 해서 Shader 클래스를 확인해보니 Shader::Init에서 탄젠트를 받아주고 있는걸 확인했습니다.

이제 VS_IN으로 넘겨준 데이터들을 VS_main 에서 잘 계산해서 나올 VS_OUT 에는 이런 내용이 있어야 합니다. 
struct VS_OUT
{
    float4 pos : SV_Position;
    float2 uv : TEXCOORD;
    float3 viewPos : POSITION;
    float3 viewNormal : NORMAL;
    float3 viewTangent : TANGENT;
    float3 viewBinormal : BINORMAL;
};

이걸 계산하는 부분이 이겁니다.
    output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);
    output.viewTangent = normalize(mul(float4(input.tangent, 0.f), g_matWV).xyz);
    output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));
여기서 주의해야할 부분은 viewTangent 와 viewNormal 의 외적을 할때 순서인데 우리 프로젝트는 왼손좌표계를 기준으로 만들었기 때문에 지금 순서로 해야 한다고 합니다.
이 바이노멀의 방향이 툴마다 다를 수 있다고 하는데 이 부분은 모델러 쪽에서 잘 처리를 해줘야 하는 부분일 수 있고 
일단 툴이나 좌표계에 따라 벡터가 뒤집힐 수도 있다고 알고 있는게 중요합니다.

이제 PS_Main 쪽을 보겠습니다. 
처음으로 해줄 건 우리가 추가해준 텍스쳐를 받아오는것과 텍스쳐를 가지고 있는지 안가지고 있는지를 체크해서 예외처리를 하는 부분입니다. 

예외처리부터 해보겠습니다. 우선 1,1,1 인 color 를 우선 만들겠습니다. 아무런 텍스쳐가 없으면 이대로 하얀색으로 진행하도록 하는겁니다.
   float4 color = float4(1.f, 1.f, 1.f, 1.f);
   if (g_tex_on_0)
        color = g_tex_0.Sample(g_sam_0, input.uv);
   
그리고 노멀 텍스쳐를 하나 더 받았었는데 그걸 viewNormal 이라는 변수에 받아서 CalculateLightColor 의 인자로 넘겨줄겁니다. 
그런데 그러기 전에 만약 노멀 텍스쳐가 없는 게임 오브젝트라면 기본 viewNormal 을 사용하도록 하고 g_tex_on_1 을 체크해서 노멀 텍스쳐가 있는지 아닌지를 확인해보고 
위에서 말했던 255까지의 숫자가 -1~1 사이의 float로 변환되고 탄젠트 스페이스에서 뷰 스페이스로 변환하는 부분까지 넣어주겠습니다.
   float3 viewNormal = input.viewNormal;
   if (g_tex_on_1)
   {
       // [0,255] 범위에서 [0,1]로 변환
       float3 tangentSpaceNormal = g_tex_1.Sample(g_sam_0, input.uv).xyz;
       // [0,1] 범위에서 [-1,1]로 변환
       tangentSpaceNormal = (tangentSpaceNormal - 0.5f) * 2.f;
       float3x3 matTBN = { input.viewTangent, input.viewBinormal, input.viewNormal };
       viewNormal = normalize(mul(tangentSpaceNormal, matTBN));
   }
이 코드를 해석해보면 첫줄에 일단 viewNormal 이라는 변수에 inpu.viewNormal을 받아주고 있습니다.
다음으로 if g_tex_1 이 1이면 아래 코드로 갑니다. 
중괄호 안에서는 tangentSpaceNormal 탄젠트 스페이스의 노멀 텍스쳐를 받아주고 있습니다. 여기서 Sample 이라는 함수를 사용하고 있는데 
이 샘플러를하면 0~255 사이의 숫자를 0~1 사이로 변환해준다는 특징이 있습니다.
위에서도 이미지의 RGB는 0~255 사이의 숫자인데 셰이더에서는 0~1 사이의 float로 해석하기 때문에 (1.f, 1.f, 1.f) 가 흰색인겁니다.
다음으로 이제 0~1 의 범위를 가진 tangentSpaceNormal 를 -1 ~ 1 범위로 바꿔줘야합니다. 간단하게 0.5를 빼주고 거기에 두배를해서 구현합니다.
그 다음으로 해야하는게 탄젠트 스페이스에서 뷰 스페이스로 변환할 3x3 행렬을 구해합니다. 
float3x3 타입이 3x3 float행렬 matTBN 을 만들고 내용으로 input의 viewTangent, viewBinormal, viewNormal 으로 각 행을 채워주고있습니다.
이미 만들어 놨던 viewNormal 변수에 노멀 텍스쳐의 노멀을 변환한 값을 넣어주면 되겠습니다.