

		16. 좌표계 변환 행렬


지난시간에 배운 행렬 기초, SRT 다음의 연장선입니다. 

SRT는 좌표계가 가만히 있고 그 위의 물체가 움직이기위한 행렬들이었습니다. 

이번시간은 물체가 가만히 있고 좌표계가 움질일때의 변환 행렬에 대해 배우겠습니다. 


-이해하기 위한 예시를 들어보겠습니다. 

x,y 평면 좌표계에서 원점을 A라고 하겠습니다. 그리고 1사분면에 M이라는 점이 있고 그 좌표는 (x1, y1) 입니다. 
새삼스럽게 좌표가 무슨의미인지를 다시 보면 원점에서 x축 방향으로 x1만큼, y축방향으로 y1만큼 간 점이 M이라는 이야기입니다. 스칼라 값입니다. 

여기에 단위 벡터 두개 u1과 v1을 추가하겠습니다. 벡터u1은 x축 방향을 가리키는 단위 벡터이고, 벡터v1은 y축방향을 가리키는 단위 벡터입니다. 
그러면 원점 A에서 점M까지의 벡터AM은 이렇게 표현할것입니다. 
벡터AM = x1*u1 + y1*v1
이런 식이 성립되기 때문의 점 M의 좌표는(x1, y1)일 수 있습니다.

여기서 왠지는 알 수 없지만 원점을 A가 아닌 또다른 임의의 위치에 있는 B를 원점이라고 생각하도록 룰이 변경되었다고 해보겠습니다. 거기에 더해 
x축 y축이 45도 기울어져있다고 해보겠습니다. 이 B좌표계도 각자의 단위벡터 u2, v2를 가지고 있습니다.

그러면 점M이 가지고 있던 좌표는 A라는 원점을 기준으로만 유효했던것이고 B좌표계에서 점M이 어떤 좌표를 가지고 있을것인가가 오늘의 주제, 알아볼 것입니다.
 
왜 잘 살고 있던 A원점에서 B원점으로 움직인건가. 그냥 문제를 만들기 위해 만든 문제 아닌가 생각 할 수도 있지만 이런 상황은 게임에서 수시로 일어납니다. 
한가지 예시로 원점이 카메라였다고 해보면 이해가 쉽습니다. 우리가 카메라(시점)을 움직이면 물체는 가만히 있지만 화면에 표시할 물체들의 좌표는 변화가 일어납니다. 

그러면 M의 새로운좌표 (x2, y2)는 어떻게 구할수 있을까요 단위 벡터를 사용해 
벡터BM = x2*u2 + y2*v2
라는 식이 성립할것이고 이걸 어떻게 잘 이용해서 x2와 y2를 구해볼것입니다.

이런 상황은 규칙이 있을것이고 그걸 증명하는 방법이 여러가지 있을것인데 그 중 한가지 방법을 소개 하겠습니다.
벡터의 덧셈을 활용하는 방법인데요 

벡터AM은 알고있었고 A에서 B로의 벡터AB를 알 수 있다면, 
벡터AM = 벡터AB + 벡터BM 
일것입니다. 
이걸 전개하기전에 u1, v1을 B좌표계 입장으로 변환 해주어야 합니다. 왜냐하면 결국 우리는 B좌표계위의 점M을 알고 싶기 때문입니다.

u1 = u1x * u2 + u1y * v2
v1 = v1x * u2 + v1y * v2
이렇게 u1, v1을 표현할수 있을텐데 u2, v2를 어떻게 구하냐면 B좌표계가 A좌표계에 비해 기울어직 각도를 알면 삼각비를 통해 알수도 있고 아니면 행렬 변환식을 알면 그걸 가지고 값을 알 수 있을겁니다.

그래서 이걸 적용시켜서 벡터AB+BM을 전개해보면 
벡터AB+벡터BM = x1*(ux*u2 + uy*v2) +y1*(vx*u2 + vy*v2)
이러면 A좌표계에서 벡터AM을 표현한는데 u1, v1은 B좌표계시점으로 바꾼 것입니다. 

알고 싶은 것은 x2, y2좌표이니깐 위의 식을 u2와 v2로 묶으면 묵여진 괄호안을 x2, y2라고 볼수도 있을것 같습니다. 
벡터AB+벡터BM =(x1*ux + y1*vx)* u2 + (x1*uy + y1*vy)*v2 
입니다. 이제 좌항의 벡터AB를 우항으로 옮기면 벡터BM만 남을것입니다. 우항으로 넘겨진 -벡터AB는 곧 벡터BA라고도 볼 수 있습니다.

벡터BM =(x1*ux + y1*vx)* u2 + (x1*uy + y1*vy)*v2 + 벡터BA

벡터BA는 B좌표계의 원점에서 A점까지의 벡터로 표현할 수 있습니다. A점을 B좌표계 기준으로는 (Qx, Qy)라고 하겠습니다. 

벡터BM =(x1*ux + y1*vx)* u2 + (x1*uy + y1*vy)*v2 + Qx*u2 + Qy*v2
이렇게 될것입니다. 이제 다시 u2, v2로 묶으면 

벡터BM =(x1*ux + y1*vx + Qx)* u2 + (x1*uy + y1*vy + Qy)*v2 라면 이제 (x1*ux + y1*vx + Qx)를 x2 라고 볼 수 있고, (x1*uy + y1*vy + Qy)를 y2라고 볼 수 있습니다.

원리는 이렇고, 이걸 게임에서는 z축도 추가될것이고 좀 더 깔끔하게 정리하면 밑과 같습니다.

(x, y ,z, 1) 라는 좌표가 있다고 하면 어떤 행렬을 곱해줄건데 

  Ux  Uy  Uz 0
  Vx  Vy  Vz  0
  Wx Wy Wz 0
  Qx Qy Qz   1

이렇게 생긴 행렬이 좌표계 변환 행렬입니다. 
생긴게 복잡해 보일 수 있지만 차근 차근 살펴보면 위에서 증명했던 규칙이 보일겁니다. 
Ux, Vx 같은 값들이 뜻하는것은 이전 좌표계(위의 예시에서는 A좌표계)에서 기준이 되던 단위 벡터들을 바뀐 좌표계(위의 예시에서는 B좌표계) 기준으로 변환을 해준걸 말합니다.

여기까지가 좌표계가 변했을때의 위치벡터의 변환입니다. 

그런데 어느때는 좌표를 변환하는게 아니라 벡터를 변환할때도 있을겁니다.
위치벡터가 아닌 방향을 가리키고 있는 벡터는 사실 시작점이랄게 없습니다. 그래서 이전 좌표계의 원점에 붙혀서 보던지 바뀐 좌표계의 원점에 붙혀서 보던지 이 벡터가 움직인 거리자체는 
의미가 없습니다. 그래서 
벡터AB+벡터BM =(x1*ux + y1*vx)* u2 + (x1*uy + y1*vy)*v2  에서 좌항의 벡터AB가 의미가 없어져서 삭제가 됩니다. 

벡터BM =(x1*ux + y1*vx)* u2 + (x1*uy + y1*vy)*v2 
그러면 좌표계 변환 행렬도 바뀌어야 하는데 Qx, Qy, Qz같은 Translation성분들이 없어져야 합니다. 
행렬로 표시할때 
(x, y ,z, 1)  *  Ux  Uy  Uz 0	
 	    Vx  Vy  Vz  0
 	    Wx Wy Wz 0
 	    Qx Qy Qz   1
여기서 Qx Qy Qz를 건드리지 않고 (x, y ,z, 0) 이렇게 벡터를 건드리면 원하는 결과를 쉽게 낼수 있을겁니다. 
즉 위치 벡터는 (x, y, z ,1) 
    방향 벡터는 (x, y, z, 0)
으로 사용하면 좌표계 변환 행렬은 공통으로 사용해도 될것입니다.