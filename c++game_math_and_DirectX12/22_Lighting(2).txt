

        22. Lighting - 코드 (1)


 이전시간에 배운 Light의 개념을 코드로 구현하는 시간입니다.

 지금만들고 있는 엔진은 유니티 기반인 컴포넌트 패턴으로 만드는 엔진이다보니 조명도 게임오브젝트에 Light 컴포넌트를 붙여주는 식으로 구현하면 될것 같습니다.

우선 컴포넌트 필터아래로 Light 라는 클래스를 만들어 주고 Light가 컴포넌트이다 보니 상속도 같이 해줍니다. 

Light가 들고있어야할 데이터들이 있는데 그걸 먼저 만들어주겠습니다.

enum class LIGHT_TYPE : uint8
{
	DIRECTIONAL_LIGHT,
	POINT_LIGHT,
	SPOT_LIGHT,
};

struct LightColor
{
	Vec4	diffuse;
	Vec4	ambient;
	Vec4	specular;
};

struct LightInfo
{
	LightColor	color;
	Vec4		position;
	Vec4		direction;
	int32		lightType;
	float		range;
	float		angle;
	int32		padding;
};

struct LightParams
{
	uint32		lightCount;
	Vec3		padding;
	LightInfo	lights[50];
};


빛의 종류 3가지를 enum class LIGHT_TYPE 으로 만들었고 빛의 세가지 성분을 LightColor 라는 스트럭쳐로 만들었습니다. 그리고 빛을 표현하는데 필요한 데이터 전부를 
들고 있을 LightInfo도 만들었습니다. 

여기서 이상한점들이 LightColor의 요소들이 RGB 값만 가지고 있으면 되서 Vec3로도 될것 같은데 Vec4타입으로 되어있고 LightInfo의 lightType이나 padding이 int32로 되어있는데
이부분은 나중에 쉐이더로 정보를 넘겨줄때 필요한 값이니 나중에 알아볼것입니다.

마지막으로 실제 쉐이더에 넘겨줄 파라미터 정보로 LightParams 라는 스트럭처가 있는데 조명이 몇개가 있는지를 들고있을 lightCount, padding은 별의미없지만 바이트 수를 맞춰주기 
위한 값, 그리고 LightInfo 를 배열로 만들어서 최대 50개 까지 넣어줄 수 있도록 만들었습니다.

지금까지 쉐이더에서 넣어줬던 정보들은 TRANSFORM_PARAMS, MATERIAL_PARAMS 각각 하나씩 넣어줬다면 Light의 경우는 여러개를 묶어서 통으로 넘겨준다는 차이가 있다고 볼 수 있습니다.
이렇게 하는 이유가 뭐냐면 물체를 그린다거나 할때 예를 들어 구를 그린다고 할때 물체를 하나 그릴때 만다 TRANSFORM_PARAMS, MATERIAL_PARAMS 을 매번 채워주면서 하나씩 그렸습니다.
Light 같은 경우는 매 물체마다 교체하는것이 아니라 프레임마다 딱 한번만 모든 빛에 대한 정보를 셋팅해주면 그 다음은 다른 물체들과 별 상관이 없기 때문에 빛은 한번에 셋팅한다고 
볼 수 있습니다. 

여기까지가 이제 Light 에서 사용할 enum들 struct 들이고 이제 클래스의 내용을 채워줄겁니다.
	public:
		Light();
		virtual ~Light();

		virtual void FinalUpdate() override;

	public:
		const LightInfo& GetLightInfo() { return _lightInfo; }

		void SetLightDirection(const Vec3 & direction) { _lightInfo.direction = direction; }

		void SetDiffuse(const Vec3 & diffuse) { _lightInfo.color.diffuse = diffuse; }
		void SetAmbient(const Vec3 & ambient) { _lightInfo.color.ambient = ambient; }
		void SetSpecular(const Vec3 & specular) { _lightInfo.color.specular = specular; }

		void SetLightType(LIGHT_TYPE type) { _lightInfo.lightType = static_cast<int32>(type); }
		void SetLightRange(float range) { _lightInfo.range = range; }
		void SetLightAngle(float angle) { _lightInfo.angle = angle; }

	private:
		LightInfo _lightInfo = {};

내용을 해석해보자면 일단 들고있을 변수는 LightInfo _lightInfo = {}; 뿐입니다. 그리고 함수들 역시 이 _lightInfo 의 내용을 세팅해주는 함수들이 많습니다. 
생성자 에서는 컴포넌트 타입을 LIGHT로 설정해주고 소멸자는 별다른 역할은 없습니다. 
FinalUpdate 함수는 이제 게임 오브젝트에서 부터 상속받은 건데 가장 마지막 단계의 업데이트 시점에서 빛의 position 정보를 채워줍니다.

그런데 이 코드를 처음에 작성하면 Set 함수에서 에러들이 발생합니다. 받은인자는 Vec3 의 데이터를 받았는데 설정해줄 _lightInfo의 각 구조들은 Vec4로 이루어져 있다보니깐 
암시적 호환이 안되서 생긴 오류입니다. 그러면 각각 매번 캐스팅을 해줘서 값을 추출 해야하나 할수 있는데 
앞으로도 종종 Vec3를 Vec4에 넣어야 할 일이 생길겁니다. 그래서 이 구조를 수정하겠습니다. 
- Vec4 를 f12 로 따라 들어가면 EnginPch.h 에서 설정한 using 문법이 나옵니다. 거기서 다시 DirectX::SimpleMath::Vector4 를 타고들어가 보겠습니다.
  그러면 마이크로 소프트에서 비공식적으로 지원하는 SimpleMath 헤더로 들어갑니다. 밑쪽을 살펴보면 Assignment operator 항목이 있는데 그곳에 
            Vector4& operator=(const Vector3& V) noexcept { x = V.x; y = V.y; z = V.z; w = 0.f; return *this; }
  이렇게 오퍼레이터 오버로드를 하나더 추가 해줍니다. = 뒤에 Vec3 가 왔을때 x, y, z를 받은 Vec3로 채워주고 남은 w를 기본적으로 0으로 초기화 해주는 함수입니다.

잊지말아야 하는 점이 하나더 있는데 COMPONENT_TYPE에 LIGHT 도 추가 해줘야 하는데 Light 오브젝트를 만들면서 생성자에서 타입을 지정해주기 때문인데 
여기서 잊지말고 GameObject 클래스로 가서 GetLight 함수도 추가해줍니다. 이때 GameObject.h 에서도 Light를 전방선언해주고 cpp 파일에서도 Light.h 를 include 해줘야 겠습니다.


이렇게 Light 컴포넌트가 추가 되었는데 이제 이 Light를 어떻게 렌더를 할건지에 대해 생각을 해봐야 겠습니다.

- 쉐이더에서 Light 클래스
이전에 default.hlsli 파일에서 TRANSFORM_PARAMS, MATERIAL_PARAMS 처럼 b2 슬롯에 LIGHT_PARAMS 를 줘서 표현하면 되지 않을까 생각이 드는데 이렇게 처리하면 문제가 생긴다고 합니다.
어떤 문제냐 하면 게임에서 큐브를 그리고, 구를 그리고, 오크를 그릴때 마다 TRANSFORM_PARAMS, MATERIAL_PARAMS 들은 다시 세팅을 하고 있습니다.
(어디서 이런 작업을 해주고 있었냐면 TableDescriptorHeap::CommitedTable 에서 물체를 그릴때 마다 _currentGroupIndex를 하나씩 넘어가면서 세팅해주었습니다.)
이런 상황인데 Light의 다른점은 
위에서 LIGHT_PARAMS 의 LightInfo를 50개 짜리 배열로 들고있었던 이유가 물체를 그릴때 마다 빛을 다시 그릴 필요 없이 프레임마다 한번만 그려주면 되기 때문입니다. 
그래서 빛 파라미터를 물체를 그리는데 사용하던 쉐이더에 같이 두면 의미없이 물체를 그릴때마다 새로 다시 설정이 되는 상황이 됩니다.

왜 이럴수 밖에 없는가를 DirectX 거의 처음부분에서 했던 원론으로 설명해보면 우선 RootSignature 라는 GPU 의 레지스터에 서명을 해줬었습니다. 
처음에는 CBV를 직접 서명하는 방법을 사용했었는데 이렇게 사용하다보면 레지스터 용량이 부족할 수 있을것 같아서 다음 방법인  DescriptorTable을 사용하는 방법으로 바꿨습니다. 
이 DescriptorTable 방식은 어떤 조건에 따라 사용할 Table을 다른곳에서 가져와서 사용하는 개념이었는데 이 방법의 단점은 미리 준비된 Table을 사용하는 것이다 보니 중간에 
내용을 업데이트하는데 어려움이 있습니다. 
그러면 다시 DescriptorTable 을 왜 사용해야 하는지 이유가 또 있는데 우리가 그래픽카드에게 일을 시킬때 매번 한개씩 일을 시키는것보다 할일을 목록으로 한번에 넘겨주고 순서대로 
처리하게 하는 엔진 부품이 있었는데 바로 CommandList 입니다. 커맨드 리스트의 방법 자체가 한 프레임 내에 할 일을 한번에 등록해서 순차적으로 처리하는 것이기 때문입니다.
그래서 그 추가할 하나 하나의 명령들을 DescriptorTable 로 채워서 넘겨주고 있었습니다.

이 부분을 렌더링과 빛 오브젝트를 분리시켜줘야 한다는 얘기가 됩니다. 
RootSignature 에서 지금은 DescriptorTable 들만으로 이뤄져 있던 부분을 DescriptorTable 다음에 고정으로 처리해줄 CBV 같은걸 추가해서 거기서 빛 오브젝트를 계산해주면 되겠습니다.


굉장히 오래된 내용이라 가물가물 한데 우선 RootSignature 에서 선언을 해줘야합니다.
RootSignature::CreateRootSignature 에서 어떻게 서명할지 정해주고 있습니다. 여기를 수정해야 할것 같습니다.
처음에 보면
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, CBV_REGISTER_COUNT, 0), // b0~b4
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, SRV_REGISTER_COUNT, 0), // t0~t4
	};

	CD3DX12_ROOT_PARAMETER param[1];
	param[0].InitAsDescriptorTable(_countof(ranges), ranges);
이렇게 range라는 배열에 CBV와 SRV 를 b0~b4, t0~t4 까지의 영역을 사용하는 range를 만들어주고있고 이 range를 파라미터로 삼는 param을 1개짜리 배열로 만들어 주고 있습니다.
여기서 b0 슬롯 같은경우에는 전역 용도로 활용하게끔 따로 빼주겠습니다. 
왜 b5 슬롯을 전역으로 사용하지 않는지는 이미 지금까지 만들어놨던 코드들중에 EnginPch.h 에서 enum class CBV_REGISTER 나 enum class SRV_REGISTER 에서 
b0~b4 , t0~t4 까지를 잡고 있고 또 그걸로 count도 하고 있다보니 이걸 수정하면 코드가 꼬일 가능성이 있습니다. 그래서 그냥 b0를 전역으로 빼서 사용합니다.
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, CBV_REGISTER_COUNT - 1 , 1), // b1~b4
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, SRV_REGISTER_COUNT, 0), // t0~t4
	};
이렇게 CBV_REGISTER_COUNT 에서 하나뺀 수를 b 슬롯 카운트로 주고 b0 가 아니라 b1 부터 시작하도록 마지막인자를 수정했습니다. 

다음으로 param을 수정했습니다.
	CD3DX12_ROOT_PARAMETER param[2];
	param[0].InitAsConstantBufferView(static_cast<uint32>(CBV_REGISTER::b0));
	param[1].InitAsDescriptorTable(_countof(ranges), ranges);
param 배열의 크기를 두개로 늘리고 원래 사용하던 range를 1번인덱스, 전역으로 사용할 b0 를 0번 인덱스로 설정했습니다.

여기까지 수정하면 이 밑의 코드들은 param을 가지고 설정을 해줄 것이다 보니 딱히 손을 대지 않아도 될것 같고 ,
대신 RootSignature 에서 끝나는게 아니라 연계된 부품들을 같이 수정해줘야 합니다.

그래서 다음으로 볼 부품은 TableDescriptorHeap 클래스입니다. 여기서 사용하던 b0 슬롯을 빼줘야 하는데 우선 TableDescriptorHeap::Init 에서 
desc.NumDescriptors = count * REGISTER_COUNT; 부분이 있는데 여기서 b0 가 빠졌으니 수정해줘야합니다
desc.NumDescriptors = count * (REGISTER_COUNT - 1);  이렇게 
_groupSize = _handleSize * (REGISTER_COUNT - 1);  이부분도 마찬가지로 수정해주었습니다.

그리고 실제 CBV를 설정해주는 TableDescriptorHeap::SetCBV 함수를 보면 몇번 레지스터 부터 버퍼를 설정할지를 정하는 것이
	D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);
이 코드인데 여기서 GetCPUHandle 이란 함수도 TableDescriptorHeap 의 멤버 변수입니다. 살펴보자면
D3D12_CPU_DESCRIPTOR_HANDLE TableDescriptorHeap::GetCPUHandle(uint32 reg)
{
	D3D12_CPU_DESCRIPTOR_HANDLE handle = _descHeap->GetCPUDescriptorHandleForHeapStart();
	handle.ptr += _currentGroupIndex * _groupSize;
	handle.ptr += reg * _handleSize;
	return handle;
}
이렇습니다. 받은 레지스터를 uint32 로 캐스팅해서 인자로 받습니다. 여기서 그룹 사이즈로 크게 한번 이동하고 레지스터 단위로 작게 이동 할건데 이제는 b0 부터가 아니라 b1 부터 
시작할때 b1 을 캐스팅하면 1 부터 시작 하는걸 수정해주겠습니다.
D3D12_CPU_DESCRIPTOR_HANDLE TableDescriptorHeap::GetCPUHandle(uint32 reg)
{
	assert(reg > 0);
	D3D12_CPU_DESCRIPTOR_HANDLE handle = _descHeap->GetCPUDescriptorHandleForHeapStart();
	handle.ptr += _currentGroupIndex * _groupSize;
	handle.ptr += (reg - 1)*_handleSize;
	return handle;
}
assert 함수로 우선 reg가 b1 부터 시작하는게 맞는지 부터 체크하고  (reg -1) 로 사용할 핸들 주소를 조정해주었습니다.
여기까지 TableDescriptorHeap 을 수정했습니다. 

다음으로 볼 부품은 Engine 클래스인데 엔진클래스에서 CBV를 생성하는 함수가 있었습니다.
	CreateConstantBuffer(CBV_REGISTER::b0, sizeof(TransformParams), 256);
	CreateConstantBuffer(CBV_REGISTER::b1, sizeof(MaterialParams), 256);
b0를 트랜스 폼으로 사용하고 b1 을 마테리얼로 사용하고 있었는데 하나씩 밀어주었습니다.
	CreateConstantBuffer(CBV_REGISTER::b1, sizeof(TransformParams), 256);
	CreateConstantBuffer(CBV_REGISTER::b2, sizeof(MaterialParams), 256);

여기서 b0 슬롯을 설정해줄건데 
	CreateConstantBuffer(CBV_REGISTER::b0, sizeof(LightParams), 1);
이렇게 LightParams 의 크기만큼을 확보해줍니다. 그리고 세번째 인자가 1로 다른 버퍼들과 다른데 이유는 Light 가 여러번을 생성할것이 아닌 한번만 생성해주면 되기 때문입니다.

Constant Buffer 가 어떤식으로 사용되고 있었는지를 확인해보면 매 ConstantBUffer마다 ConstantBuffer::Clear 로 _currentIndex를 0으로 밀어주고 ConstantBuffer::PushData를 
통해 Mapping 된 메모리에 우리가 Push 할 데이터를 들고 있는 Buffer를 카피해주고 다음 버퍼로 넘어가는걸 반복하고 있습니다.

그런데 우리가 Light 를 넘겨줄 용도인 b0 슬롯의 데이터는 프레임마다 한번만 Push 해주면 되기 때문에 새로운 함수를 만들어서 처리해줄겁니다.
void ConstantBuffer::SetGlobalData(void* buffer, uint32 size)
{
	assert(_elementSize == ((size + 255) & ~255));
	::memcpy(&_mappedBuffer[0], buffer, size);
	CMD_LIST->SetGraphicsRootConstantBufferView(0, GetGpuVirtualAddress(0));
}
해석은 이 전역 데이터는 한번만 넘겨줄 것이기 때문에 PushData 처럼 _mappedBuffer의 인덱스를 이것저것 바꿀 필요없고 그냥 0번째 인덱스에 넣으면 되고, _currentIndex를 증가시켜 
나가는것도 필요없습니다. 이 함수를 이용해서 Light를 넘겨줄수 있을겁니다.

그리고 ConstantBuffer.h 에서 enum class CONSTANT_BUFFER_TYPE 으로 필요할때 원하는 타입의 상수 버퍼를 가져오고 있었는데 여기에 GLOBAL 도 추가해주겠습니다.
enum class CONSTANT_BUFFER_TYPE : uint8
{
	GLOBAL,
	TRANSFORM,
	MATERIAL,
	END
};
이러면 나중에 Light 에 관련해서 수정하고 싶을때 CONST_BUFFER(CONSTANT_BUFFER_TYPE::GLOBAL)로  가져와서 SetGlobalData 로 수정할수 있을겁니다.

이렇게 해준뒤 다시 Light 를 보겠습니다.
현재 Light 클래스의 내용중 FinalUpdate 에서는 그냥 Transform::position 을 설정해주고 있는데 여기서 Render 같은걸 해서 바로 데이터를 넘겨주지 않는이유는 
LightParam 이 LightInfo 50개 까지 한번에 줄수 있도록 만들었기 때문에 이 Light 를 관리해주는 상위 오브젝트에서 LightParam을 채워서 한번에 Render 해줘야 합니다.

그럼 어디서 Render를 해줘야 할지를 찾아보니 SceneManager 에서 임시로 만들었던 Render 가 있습니다. 이 함수에서는 활성화된 Scene 에서 게임오브젝트들을 순회하면서
Camera 컴포넌트가 있는 게임오브젝트를 찾아 Render 해주고 있습니다.
Light 도 비슷하게 게임 오브젝트를 순회해서 Light 컴포넌트가 있는 오브젝트를 Render 해주면 될것 같습니다. 
그런데 이 작업을 지금의 SceneManager 가 아니라 Scene 에서 하도록 이전 해주는게 좋겠습니다.



void Scene::Render()
{
	PushLightData()

	for (auto& gameObject : _gameObjects)
	{
		if (gameObject->GetCamera() == nullptr)
			continue;

		gameObject->GetCamera()->Render();
	}
}
Scene 으로 이전하면서 GetGameObject 같은걸로 가져오지 않아도 Scene 자체가 들고 있는 멤버 변수이다 보니 간략화 할 수 있습니다. 그리고 지금 GetCamera 를 할때 에러가 뜨는데 
이유는 Scene 에서 Camera 가 뭔지 몰라서 그런것이니깐 include 해줍니다.
 
지금 한 이전은 카메라를 렌더하는부분을 이전한것이고 원래 이번 강의의 주제인 Light 도 적용해볼겁니다. 
우선 Scene::Render 의 카메라를 렌더하는 코드 전에 LightParam 에 필요한 만큼의 LightInfo를 추가하는 코드를 작성할겁니다. 

void Scene::PushLightData()
{
	LightParams lightParams = {};

	for (auto& gameObject : _gameObjects)
	{
		if (gameObject->GetLight() == nullptr)
			continue;

		const LightInfo& lightInfo = gameObject->GetLight()->GetLightInfo();

		lightParams.lights[lightParams.lightCount] = lightInfo;
		lightParams.lightCount++;
	}

	CONST_BUFFER(CONSTANT_BUFFER_TYPE::GLOBAL)->SetGlobalData(&lightParams, sizeof(lightParams));
}
해석하면 일단 나중에 ConstantBuffer->SetGlobalData 의 인자로 들어갈 빈 LightParams 를 만들고나서 Scene이 들고 있는 게임오브젝트를 순회해 Light 컴포넌트를 들고 있는 오브젝트의
LightInfo를 lightParams.lights의 0번째 인덱스부터 채워줍니다. 그리고 SetGlobalData 로 전역 상수버퍼로 데이터를 푸시해주었습니다.
이렇게 구성하면 PushLightData 는 Scene::Render 할때 한 프레임에 딱 한번 실행되는걸 알수 있고
이제 엔진에서는 Light 를 적용할 준비가 되었고 이제 이 데이터를 해석해줄 쉐이더를 프로그래밍 해야합니다. 


우선 쉐이더 정돈부터 다시 할겁니다. 
먼저 
cbuffer TRANSFORM_PARAMS : register(b0)
{
    row_major matrix matWVP;
};
여기서 WVP를 한번에 묶어서 다루고 있었습니다. 바로 Screen 변환까지 가는 용도라면 상관없습니다. 그런데 W, V, P 변환들 따로 하고 싶던가 WV 변환만 하고 싶던가 할 때 가 있을수 
있습니다. TransformParams 를 EnginePch 에서 정의하고 있었는데 이걸 수정하겠습니다.
struct TransformParams
{
	Matrix matWorld;
	Matrix matView;
	Matrix matProjection;
	Matrix matWV;
	Matrix matWVP;
};
이 TransformParams 가 활용되는 코드는 Transform::PushData 에서 입니다. 
void Transform::PushData()
{
	TransformParams transformParams = {};
	transformParams.matWorld = _matWorld;
	transformParams.matView = Camera::S_MatView;
	transformParams.matProjection = Camera::S_MatProjection;
	transformParams.matWV = _matWorld * Camera::S_MatView;
	transformParams.matWVP = _matWorld * Camera::S_MatView * Camera::S_MatProjection;

	CONST_BUFFER(CONSTANT_BUFFER_TYPE::TRANSFORM)->PushData(&transformParams, sizeof(transformParams));
}
이렇게 수정을 했는데 각각 월드, 뷰, 프로젝션 , 월드*뷰, 월드*뷰*프로젝션 다섯가지의 변환 행렬들을 모두 들고 있는 transformParams 을 PushData 해주었습니다. 
그럼이제 이 형식에 맞게 쉐이더를 수정해야 하겠습니다.

TRANSFORM_PARAMS 에서 matWVP 만 가지고 있던걸 이제 각각의 행렬중에 고를수 있도록 수정했습니다.
cbuffer TRANSFORM_PARAMS : register(b1)
{
    row_major matrix g_matWorld;
    row_major matrix g_matView;
    row_major matrix g_matProjection;
    row_major matrix g_matWV;
    row_major matrix g_matWVP;
};

그리고 Light 클래스에서 만들었던 LightColor, LightInfo, LightParams 를 쉐이더에서도 똑같이 받아주도록 추가합니다.
struct LightColor
{
    float4      diffuse;
    float4      ambient;
    float4      specular;
};

struct LightInfo
{
    LightColor  color;
    float4	    position;
    float4	    direction;
    int		    lightType;
    float	    range;
    float	    angle;
    int  	    padding;
};

cbuffer GLOBAL_PARAMS : register(b0)
{
    int         g_lightCount;
    float3      g_lightPadding;
    LightInfo   g_light[50];
}
우리가 Scene::Render 에서 PushLightData() 로 넘겨준 빛 오브젝트들의 데이터를 그대로 받아주고 있습니다.

그런데 이제 쉐이더 파일의 코드를 보니까 쉐이더 함수에 넣어줄 데이터들을 정의하는 부분이 너무 길어졌습니다. 그래서 쉐이더 파일 분할을 해볼겁니다.
3가지로 분할해줄 건데 원래 있던 default, 파라미터들을 관리해줄 params, 유틸리티들을 관리할 utils 로 분할해서 프로젝트에 추가해주겠습니다.

분할해서 추가하는 작업은 쉐이더에서 헤더 파일처럼 쓴다는 느낌인데 CPP 파일에서는 헤더가 중복 되지 않도록 #pragma once 를 사용했는데 쉐이더에서는 이게 작동 되지 않는다고 합니다. 
그래서 이 pragma once 기능을 풀어서 쓰는 
#ifndef _파일_설명_
#define _파일_설명_
	내용
	내용
	"
	"
#endif
이런 형식으로 if not define _파일_설명_ : 이 파일이 정의되지 않았다면 define 과 endif 사이의 내용을 추가한다는 의미입니다. 

ifndef 방식으로 params.hlsli 파일에서 적용을 하고 이 파일의 내용은 파라미터에 관한 내용들만 모아 두었고 
default.hlsli 에서 파라미터 관련 내용은 지우고 여기도 ifndef 을 적용합니다. 그리고 #include "params.hlsli" 로 추가 해줍니다.

default.hlsli 에서 VS_IN 과 VS_OUT 의 내용을 수정합니다.
struct VS_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;
    float3 normal : NORMAL;
};

struct VS_OUT
{
    float4 pos : SV_Position;
    float2 uv : TEXCOORD;
    float3 viewPos : POSITION;
    float3 viewNormal : NORMAL;
};
VS_IN 에서는 normal 을 받아주고 VS_OUT에서는 view 스페이스에서의 position과 normal이 반환 되도록 해주었는데 이 이유는 나중에 나옵니다.

여기서 쉐이더의 입력값을 변경하면 다시 프로젝트의 Shader 클래스도 맞춰주도록 체크하는걸 습관화 해야합니다. 확인해보니 이전 시간에 Vertex 스트럭쳐를 수정할때 normal 과 tangent를 추가 
해주고 Shader 클래스에도 적용 시켜놨었습니다.

VS_IN 에서의 pos 가 VS_OUT 에서는 SV_Position 이라는 float4 값으로 변환되는데 공식문서에 그렇다고 기재 되어있습니다.

그리고 파라미터를 정의 하면서 왠지 모르게 LightColor 의 성분들을 float4로 만들었고, LightInfo, GLOBAL_PARAMS 의 성분들중 padding 이라는 걸 끼워 넣어놨었습니다.
이 잉여 데이터들은 심지어 사용도 안할 건데 왜 끼워놨느냐를 알아볼겁니다. 

마이크로 소프트 공식문서에서 Packing Rule 이라는게 있습니다. 
어떤 구조체를 만들어서 메모리에 올릴때 메모리의 정렬순서 같은 느낌으로 이해하면되는데, 내용을 약간 읽어보면 데이터는 기본적으로 4-byte 바운더리를 지키지만 HLSL 에서는 데이터가 16-byte
가 넘어가면 안된다는 이야기를 하고 있습니다.
기본적으로 4바이트 바운더리를 지킨다는것은 구조체의 내용을 4바이트 보다 적은 데이터타입이나 4바이트 보다 큰 데이터타입을 사용해도 실질적으로 4바이트 단위로 끊어서 읽는다는 이야기 이고
HLSL 에서 16 바이트 바운더리를 넘어가지 못한다는게 무슨 말인지 예시로 보면 
//  2 x 16byte elements
cbuffer IE
{
    float4 Val1;
    float2 Val2;  // starts a new vector
    float2 Val3;
};
4 바이트 짜리 float를 4개 사용하는 Val1 과 2개를 사용하는 Val2, Val3 순으로 이루어진 구조체는 16 x 2 로 범위가 잡힙니다. 그러면 그냥 각각 바이트수를 더하면 되는건가 싶은데 다음 예제를 보면
//  3 x 16byte elements
cbuffer IE
{
    float2 Val1;
    float4 Val2;  // starts a new vector
    float2 Val3;  // starts a new vector
};
Va1 과 Val2 의 타입을 서로 바꿨을 뿐인데 16 x 3 으로 범위가 잡힙니다.
여기서 16바이트 바운더리를 넘을수 없다는 말의 의미를 알 수 있는데 첫번째 예제에서는 16 바이트 짜리 Val 이 한 바운더리를 사용하고 두번째 바운더리의 절반씩을 Val2, Val3 가 사용해서 
두개의 바운더리로 정리가 되었는데 
두번째 예제에서는 첫 바운더리의 8바이트를 Val1 이 사용하고 나서 바운더리의 남은 공간이 8바이트인데 비해 Val2 의 크기는 16바이트로 범위를 초과하기때문에 바운더리1 의 남은 8바이트는 
비어있는 채로 두고 바운더리2를 새로 잡아서 Val2를 할당합니다. 바운더리 2 가 또 꽉찼으니 바운더리 3를 잡아서 8바이트의 Val3 를 할당하고 있는겁니다.

우리가 작성한 코드대로 차곡차곡 저장되는게 아니라 중간에 빈공간도있고 이렇게 멋대로 처리되는이유는 하드웨어적으로 이렇게 하는게 성능이 더 좋기 때문이라고 합니다.

이런 규칙이 HLSL 즉 쉐이더 측에서의 규칙인데 우리가 이걸 신경쓰지 않고 그냥 진행한다고 하면 데이터 순서가 어긋날 수 있습니다.
CPP 쪽에서 작성한 LightParams 와 쉐이더 쪽에서 받아들이는 GLOBAL_PARAMS 의 형태가 달라져서 제대로 인식이 안되는겁니다.
struct LightParams
{
	uint32		lightCount;
	Vec3		padding;
	LightInfo	lights[50];
};

cbuffer GLOBAL_PARAMS : register(b0)
{
    int         g_lightCount;
    float3      g_lightPadding;
    LightInfo   g_light[50];
}
 
이 두가지 구조체를 비교해서 padding 부분이 없다고 생각해보면 CPP 코드인 LightParams 는 uint32 인 lightCount 다음 바로 이어서 lights를 저장 할 수 있고 
params.hlsli 의 GLOBAL_PARAMS 에서는 g_lightCount 다음 g_light 가 덩치가 너무 크다보니 12바이트의 공간을 비워두고 다음 바운더리부터 저장을 시작하게 되는데 
이 비어있는 12바이트 만큼 cpp 코드와 쉐이더 코드의 차이가 발생하게 됩니다.

이런 부분을 쉽게 생각하면 쉐이더로 넘길 정보들은 16 바이트 단위로 정렬해서 넘겨준다고 생각하면 되겠습니다.

LightColor 의 내용물을 Vec4 타입들로 만든것도 cpp 쪽 과 쉐이더의 저장 구조를 맞춰주기 위한것입니다. 만약 Vec3 들로 만들었다면 각 내용물들 사이에 4바이트의 
패딩들을 일일히 끼워 넣어줘야 할겁니다.

이런 내용을 알고 위에서 만들었던 Light 클래스의 구조체들을 다시 보면 
LightColor도 16 바이트씩을 사용하는 원소들 3개로 이루어져있고 LightInfo 도 LightColor(16x3), position(16), direction(16), lightType(4), range(4), angle(4), padding(4)
로 16 바이트의 배수로 딱 맞춰 놨습니다. LightParams 에서 LightInfo를 50 짜리 배열로 사용할때 LightInfo 자체가 16 바이트의 배수이기 때문에 손쉽게 사용할수있습니다.
LightParams 는 lightCount(4), padding(12), lights(LightInfo) 로 이것도 16바이트의 배수로 설정이 되어있는겁니다.
여기까지 padding을 사용하는 이유에 대해 알아 봤고 

다음으로 쉐이더 함수를 보겠습니다. 
우선 이전에 VS_MAIN에서는 W,V,P 변환이 모두 완료된 VS_OUt 을 반환하고 있었는데 이번에 VS_IN에서도 normal을 추가했고 VS_OUT 에서도 viewPos, viewNormal 을 추가 
했기때문에 이 부분을 어떻게 채워주는지를 보겠습니다. 

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), g_matWVP);

    output.uv = input.uv;

    output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;
    output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);

    return output;
}

output.pos 와 output.uv 는 이전과 마찬가지로 input.pos 에 마지막 1.f 를 추가한 벡터에 g_matWVP 를 곱해주고 output.uv는 input.uv를 그대로 주고 있습니다.
이부분은 정점으로 이루어질 물체의 position과 텍스쳐가 매핑될 좌표를 설정하는 부분이라 그대로 적용이 되고 
새로 추가된 viewPos, viewNormal 을 어떻게 채워주는지를 보면 viewPos 는 input의 pos에 마지막에 1.f 를 넣어주고 있는데 행렬변환 시간에 마지막에 1을 넣으면 Transition
값을 가지게 되서 위치정보도 들고 있을 수 있었고 거기에 W,V 까지만 계산한 View 스페이스에서의 Pos를 계산하고있습니다. 
viewNormal은 위치 정보말고 방향값만 가지고 있는 벡터이기 때문에 input의 normal값의 마지막을 0.f 로 설정한겁니다.
지금설명한 VS_Main 은 말그대로 Vertex Shader 를 계산하는 함수 정점데이터를 계산해준겁니다. 이 데이터를 다시 Rasterize 를 통해 비율에 맞춰 평균화를 해주고 
PS_Main 함수는 Pixel Shader 함수 각 픽셀마다의 계산을 하는 함수인겁니다.

왜 갑자기 VS_OUT 에서 viewNormal 을 받아주는지 이유가 궁금합니다. 
Light 개론 시간에 빛의 세가지 성분을 계산하기 위해 필요했던 요소들이 몇가지 있었는데 기본적으로 빛을 계산해서 적용시켜줄 그 좌표점 그리고 그 좌표의 normal 벡터
부터 알아야할것입니다. 빛이 들어오는 벡터는 Light 오브젝트의 정보에 있을것이고 카메라의 위치는 또 카메라 오브젝트에 정보가 있을겁니다. 
게임 오브젝트 자신에게서 얻을 데이터는 좌표와 normal 벡터인겁니다. 

여기서 또 한가지 궁금점이 이 빛을 계산해서 각 픽셀에 색을 결정하는 연산을 하는 좌표계는 어디일까요?
게임 오브젝트는 일단 로컬 좌표계가 있었고 World 좌표로 변환을 했다가 카메라 기준으로 변환하는 View 변환이 있었는데 이 세가지 좌표계중 어딘가에서는 연산을 해줘야 할텐데 
사실 정해진건없고 각자 편한 좌표계에서 해주면 되는데 일반적으로 World나 View 쪽에서 해주는게 일반적이라고 합니다. 
중요한 점은 만약 normal 벡터는 World 기준으로 구하고 픽셀 좌표는 View 기준으로 구한다면 당연히 안됩니다. 즉 좌표계를 하나로 통일해서 구해줘야합니다.

기본적으로 World 좌표계에서 구해주는게 더 일반적이긴 하나 View 좌표계를 기준으로 구하는 것도 괜찮은데 View 를 기준으로 하면 한가지 장점이 있습니다.
카메라의 좌표를 추가적으로 넘길 필요가 없어진다는 겁니다. View 좌표계에서는 카메라를 원점으로 하는 좌표계이기 때문에 View 좌표계의 원점이 카메라가 되는겁니다.

그래서 지금 코드는 View 스페이스를 기준으로 계산해주고 있습니다.그래서 VS_OUT 에 추가한 viewPos 와 viewNormal 은 view 스페이스에서 연산하기 쉽도록 미리 변환을 해준겁니다.
pos와 normal을 제외한 나머지 값들도 view 스페이스로 변환을 해줘야 합니다.

다시 또 강조 해보자면 VS_Main 에서 구한 VS_OUT 을 이제 PS_Main 의 인자로 넘겨주게 되는데 여기서 viewNormal, viewPos를 사용할겁니다. 
정점 쉐이더(VS)에서 로컬 좌표를 받아 필요한 변환을 해주고 레스터라이즈를 해서 정점들사이의 공간을 보간 해준다음 픽셀 세이더(PS) 에서 그 픽셀들을 하나씩 색상 계산을 해줍니다. 

PS_Main 함수를 보겠습니다. 이전에는 각픽셀의 색상을 텍스쳐와 매핑된 색상을 입혀주었는데 
이번 시간에는 빛을 적용시킨 결과를 더 알기 쉽게 하기 위해 우선 텍스쳐의 색상 계산은 주석처리하고 float4(1.f, 1.f, 1.f, 1.f);
이렇게 아예 새하얀 색으로 물체의 색을 정해주겠습니다. 이 하얀 물체가 빛의 도입으로 어떻게 색이 변하는지를 보면 됩니다.
   float4 color = float4(1.f, 1.f, 1.f, 1.f);
	return color;

다음으로 빛을 도입해 색상을 조절해보는 코드를 보겠습니다.
    LightColor totalColor = (LightColor)0.f;

    for (int i = 0; i < g_lightCount; ++i)
    {
         LightColor color = CalculateLightColor(i, input.viewNormal, input.viewPos);
         totalColor.diffuse += color.diffuse;
         totalColor.ambient += color.ambient;
         totalColor.specular += color.specular;
    }

    color.xyz = (totalColor.diffuse.xyz * color.xyz)
        + totalColor.ambient.xyz * color.xyz
        + totalColor.specular.xyz;
물체의 색에 연산해줄 totalColor 는 Scene에서 가지고 있는 모든 빛오브젝트를 가져와서 앞으로 만들어줄 CalculateLightColor 함수를 통해 각
diffuse, ambient, specular 값을 채워주고 마지막에 픽셀의 색상 color 에 적용해주고 있습니다.
여기서 조금 자세히 보면 diffuse, ambient 는 각 값에 물체의 색상을 곱해서 정해주고 있는 반면, specular 는 그냥 자기 자신의 색을 더해주고 있는걸 알 수 있습니다.
specular 는 정반사광으로 물체의 색은 상관없이 빛자체의 색이 반사되는것이다 보니 그렇습니다.
사실 여기 빛의 색상 계산은 정해진 공식이 없고 각자 수단과 방법을 가리지 않고 간편하고 빠르게 계산할 수 있으면 된다고 합니다.

다음으로 할 것은 CalculateLightColor 함수를 구현하는 부분인데 빛 개론시간에 알아본 계산하는 방법을 잘 담아주면 되겠습니다.

우선 CalculateLightColor 함수가 받고있는 인자는 첫번째 지금이 몇번째 빛오브젝트인지에 대한 인덱스 번호, 두번째로 VS_Main에서 연산된 정점데이터의 viewNormal, 
세번째로 마찬가지 정점데이터의 viewPos 를 받고 있습니다. 
이 함수의 목적은 물체의 본래 RGB 값이 있고 빛에 따라 더 곱하거나 더해질 양(diffuse, ambient, specular) 을 구하는게 목적입니다. 
LightColor CalculateLightColor(int lightIndex, float3 viewNormal, float3 viewPos)
{
    LightColor color = (LightColor)0.f;

    float3 viewLightDir = (float3)0.f;

    float diffuseRatio = 0.f;
    float specularRatio = 0.f;
    float distanceRatio = 1.f;

    if (g_light[lightIndex].lightType == 0)
    {
        // Directional Light
        viewLightDir = normalize(mul(float4(g_light[lightIndex].direction.xyz, 0.f), g_matView).xyz);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));
    }
    else if (g_light[lightIndex].lightType == 1)
    {
        // Point Light
        float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
        viewLightDir = normalize(viewPos - viewLightPos);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));

        float dist = distance(viewPos, viewLightPos);
        if (g_light[lightIndex].range == 0.f)
            distanceRatio = 0.f;
        else
            distanceRatio = saturate(1.f - pow(dist / g_light[lightIndex].range, 2));
    }
    else
    {
        // Spot Light
        float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
        viewLightDir = normalize(viewPos - viewLightPos);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));

        if (g_light[lightIndex].range == 0.f)
            distanceRatio = 0.f;
        else
        {
            float halfAngle = g_light[lightIndex].angle / 2;

            float3 viewLightVec = viewPos - viewLightPos;
            float3 viewCenterLightDir = normalize(mul(float4(g_light[lightIndex].direction.xyz, 0.f), g_matView).xyz);

            float centerDist = dot(viewLightVec, viewCenterLightDir);
            distanceRatio = saturate(1.f - centerDist / g_light[lightIndex].range);

            float lightAngle = acos(dot(normalize(viewLightVec), viewCenterLightDir));

            if (centerDist < 0.f || centerDist > g_light[lightIndex].range) // 최대 거리를 벗어났는지
                distanceRatio = 0.f;
            else if (lightAngle > halfAngle) // 최대 시야각을 벗어났는지
                distanceRatio = 0.f;
            else // 거리에 따라 적절히 세기를 조절
                distanceRatio = saturate(1.f - pow(centerDist / g_light[lightIndex].range, 2));
        }
    }

    float3 reflectionDir = normalize(viewLightDir + 2 * (saturate(dot(-viewLightDir, viewNormal)) * viewNormal));
    float3 eyeDir = normalize(viewPos);
    specularRatio = saturate(dot(-eyeDir, reflectionDir));
    specularRatio = pow(specularRatio, 2);

    color.diffuse = g_light[lightIndex].color.diffuse * diffuseRatio * distanceRatio;
    color.ambient = g_light[lightIndex].color.ambient * distanceRatio;
    color.specular = g_light[lightIndex].color.specular * specularRatio * distanceRatio;

    return color;
}
이게 CalculateLightColor 함수의 내용인데 꽤 길어서 이해하기 어려워 보이지만 하나씩 차근차근 해석해보면 이미 아는 내용일겁니다.
우선 함수 초반에 값을 설정해주기 위한 변수들을 생성하고 있습니다.
    LightColor color = (LightColor)0.f;

    float3 viewLightDir = (float3)0.f;

    float diffuseRatio = 0.f;
    float specularRatio = 0.f;
    float distanceRatio = 1.f;
이중 color 라는 변수는 함수내에서 모든 연산을 총합해서 리턴할 값입니다. viewLightDir 이라는 변수는 Light Direction 빛의 방향입니다. 그런데 VS_Main에서 
viewNormal과 viewPos 처럼 View 스페이스 기준으로 연산을 하고 있었으니깐 빛의 방향도 view 스페이스 기준으로 가지고 있을 viewLightDir 입니다. 
다음으로 diffuseRatio 는 사실상 우리가 연산해줄 diffuse 값입니다. ambient 가 없는 이유는 ambient(환경광)은 연산과 상관없이 
상수같은 느낌으로 더해줄 물체의 최소밝기이기 때문에 따로 구해주지는 않습니다. distanceRatio는 포인트 라이트와 스포트 라이트 의 경우 광원과의 거리에 따라
밝기가 달라지는데 이값을 가지고 있을 변수입니다. 

변수들을 정의 해줬고 다음으로는 if else 문으로 각 광원들의 타입을 체크해주고 있습니다. 빛의 타입에 따라 계산하는 식이 달라졌었습니다. 
먼저 만약 빛의 타입이 Directional 이라면 이렇게 될겁니다.
    if (g_light[lightIndex].lightType == 0)
    {
        // Directional Light
        viewLightDir = normalize(mul(float4(g_light[lightIndex].direction.xyz, 0.f), g_matView).xyz);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));
    }
디렉셔널 라이트에서는 specularRatio와 distanceRatio를 그대로 두고 있습니다. 태양같이 빛을 저 멀리서 일정한 방향으로 비춰주고 있는 타입의 빛이기 때문인데
viewLightDir을 구하는 코드를 보면 g_light에서 이번 인덱스의 빛 오브젝츠를 가져와서 그 direction을 꺼내는데 이 빛 오브젝트는 이미 월드 변환을 한상태이기 때문에
거기에 g_matView를 곱하면 W,V 변환까지 마친 상태이고 거기에 normalize로 단위 벡터로 만들어 주었습니다. 
diffuseRatio를 구하는 코드는 dot 이라는 함수는 내적함수를 말하는 것이었고 -viewLightDir과 viewNormal을 내적을 해주고 있습니다.
그리고 그 내적한 값을 saturate 해주면 이 값이 무조건 0~1 사이에 있도록 보정을 해준다고 했었습니다. 즉 만약 내적값이 음수로 나온다면 그냥 0으로 밀어버린다는 이야기입니다.
빛 개론에서 디렉셔널 라이트를 계산해주는것은 빛의 입사각과 normal 이 일치하면 가장 밝고 직각이 될수로 어두워진다고 했고 그걸 cosθ값으로 알수 있고 
cosθ 를 쉽게 구하는 방법이 단위 벡터들을 내적하는것이라고 배웠고 그걸 표현한 코드입니다.

이렇게 디렉셔널 타입일때 구한 값을 어떻게 적용시켜주고 있는지를 보려면 함수의 거의 밑에 코드를 보면되는데
    color.diffuse = g_light[lightIndex].color.diffuse * diffuseRatio * distanceRatio;
    color.ambient = g_light[lightIndex].color.ambient * distanceRatio;
    color.specular = g_light[lightIndex].color.specular * specularRatio * distanceRatio;
각 세가지 성분들의 원래 값에 ratio를 곱해주고 있습니다. 이말은 원래 빛의 세기에서 각 성분들 곱해주고 있다는이야기입니다.
조명의 색이 만약 빨간색 이었다면 그 빨간색 에 비율들을 곱해주는겁니다.
그리고 디렉셔널 라이트에서는 distanceRatio를 건드려주고 있지않은데 디렉셔널 라이트 자체가 모든 곳에서 같은 밝기를 가지고 있다고 표현되기 때문에 초기값인 1.f를 그대로 
사용하고 포인트 라이트나 스포트 라이트에서는 distanceRatio를 필요에 따라 수정해서 사용하게 될겁니다.

ambient 값은 처음에 설정한 값에 distanceRatio 만 곱해주고 
specular 는 if 문 밖에서 따로 구해주는데 
    float3 reflectionDir = normalize(viewLightDir + 2 * (saturate(dot(-viewLightDir, viewNormal)) * viewNormal));
    float3 eyeDir = normalize(viewPos);
    specularRatio = saturate(dot(-eyeDir, reflectionDir));
    specularRatio = pow(specularRatio, 2);
reflectionDir 는 빛이 물체에 닿고 난 다음 반사되는 빛의 각도인데 처음의 빛의 각도에서 x축 반전을 해준 벡터입니다. 
eyeDir 은 자신의 픽셀위치에서 카메라까지의 단위 벡터를 의미하는데 world 좌표에서는 카메라의 위치 좌표에서 물체의 위치좌표를 뺀 벡터를 단위벡터화 시키면 됩니다.
그런데 지금은 view 변환을 거친 view 좌표계입니다. view 좌표계 자체가 카메라를 중심으로 모든 오브젝트들의 좌표를 변환한 좌표계인 만큼 이 view 좌표계의 원점이 바로 
카메라의 위치좌표인겁니다. 그래서 viewPos 는 물체의 view 좌표계에서의 위치이지만 이걸 벡터로 바라보면 카메라에서 물체를 향한 벡터가 됩니다. 이걸 eyeDir 이라고 부릅니다.
그런데 우리가 구하고 싶던 벡터는 물체에서 카메라로 가고 있는 벡터 cameraDir 을 구하고 싶었으니깐 eyeDir에 - 를 곱해주면 됩니다.
이제 specularRatio에 -eyeDir와 reflectionDir 의 내적으로 값을 구해주고 있습니다.
여기까지가 정반사광을 계산한 것인데 그 밑에 pow 를 사용한 계산이 하나 더 있습니다. 이부분은 옵션같은건데 
pow 가 무슨함수이냐면 제곱을 해주는 함수인데 즉 위의 코드는 내적을 통해 구한 specularRatio를 2제곱 해준 것입니다.
specular 값이 cos 값이다 보니 파동 모양으로 되어 있을건데 보다 가파르게 표현하고 싶어서 이런 처리를 해줬다고 할 수 있습니다.
specularRatio 값 자체가 내적을 한 결과물이다 보니 0~1 사이의 값인데 이걸 제곱한다면 가장 밝을 1일때를 제외하고 나머지 범위의 값들은 더욱 어두워지는 효과가 있습니다. 
이 제곱을 하지않으면 반사광을 표현하는 부분이 너무 넓게 퍼져있을수 있는데 이걸 좀더 그럴듯하게 다듬어 주는겁니다.

이렇게 디렉셔널 라이트에서의 diffuse, ambient, specular 를 구했고 
다른 빛타입인 포인트 라이트, 스포트 라이트의 경우 viewLightDir, diffuseRatio, distanceRatio 를 각각 알맞게 구해줄겁니다. 

포인트 라이트의 경우 디렉셔널 라이트와 다르게 광원이 어디있는지가 중요했고 빛의 방향도 빛과 물체간의 위치에 따라 달라졌습니다. 거기에 빛에서 멀어질수록 빛의 세기가 
약해지기도 하고 일정 범위를 넘어가면 아예 빛이 닿지 않는 성질도 있습니다.
        // Point Light
        float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
        viewLightDir = normalize(viewPos - viewLightPos);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));

        float dist = distance(viewPos, viewLightPos);
        if (g_light[lightIndex].range == 0.f)
            distanceRatio = 0.f;
        else
            distanceRatio = saturate(1.f - pow(dist / g_light[lightIndex].range, 2));
첫줄부터 view 스페이스에서의 빛의 위치를 받아주고 있습니다.
그리고 viewLightDir 을 구하고 있는데 디렉셔널에서는 direction을 따로 가지고 있던것과 다르게 viewPos 에서 viewLightPos를 빼준 벡터의 단위벡터로 구합니다.
지금구한 viewLightDir 을 이용해 diffuseRatio를 구해줍니다. 이 구하는 방법은 나중에 스포트 라이트와 같은 방법입니다.
다음으로 diffuseRatio를 구하는 과정인데 먼저 물체와 광원사이의 스칼라값을 구하는 distance 라는 함수를 사용했고 if else 문으로 예외 처리를 해주는데 
light의 range가 0이면 distanceRatio를 0을 줘서 아무런 밝기가 없게 하고있습니다. 여기서 light.range는 광원의 빛이 닿는 범위인데 
이 범위가 0이라는것은 광원에서 빛이 나지않는다는이야기 일겁니다.
else 에서는 range가 0이 아닐테니까 광원에서 빛이 나오고 있는중입니다. 실제 거리/ 광원의 최대 범위 를 이용해서 distanceRatio를 구해주고 있습니다.
이때 혹시 dist 가 range 보다 크다면 어떻게 될까요 이 말의 의미는 물체가 광원의 최대거리 밖에 있다는 의미이고 수식으로 보면 saturate 안의 값이 
음수로 나올것이기 때문에 saturate에 의해 0으로 보정이 돠고 결국 distanceRatio = 0.f 라는 결과가 나옵니다. 
distanceRatio는 거리에 의한 밝기 라는 의미도 있지만 또 빛이 비추는 범위에 있는가를 알수 있는값이기도 한겁니다.

마지막 스포트 라이트를 살펴보면 좀 더 복잡하긴 하지만 사실 포인트 라이트에서 광원의 각도가 추가된 개념입니다.
        // Spot Light
        float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
        viewLightDir = normalize(viewPos - viewLightPos);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));

        if (g_light[lightIndex].range == 0.f)
            distanceRatio = 0.f;
        else
        {
            float halfAngle = g_light[lightIndex].angle / 2;

            float3 viewLightVec = viewPos - viewLightPos;
            float3 viewCenterLightDir = normalize(mul(float4(g_light[lightIndex].direction.xyz, 0.f), g_matView).xyz);

            float centerDist = dot(viewLightVec, viewCenterLightDir);
            distanceRatio = saturate(1.f - centerDist / g_light[lightIndex].range);

            float lightAngle = acos(dot(normalize(viewLightVec), viewCenterLightDir));

            if (centerDist < 0.f || centerDist > g_light[lightIndex].range) // 최대 거리를 벗어났는지
                distanceRatio = 0.f;
            else if (lightAngle > halfAngle) // 최대 시야각을 벗어났는지
                distanceRatio = 0.f;
            else // 거리에 따라 적절히 세기를 조절
                distanceRatio = saturate(1.f - pow(centerDist / g_light[lightIndex].range, 2));
        }
내용을 보면 viewLightPos, viewLightDir, diffuseRatio를 구하는 방법이 포인트 라이트와 같습니다. 거기에 light.range 가 0일때 예외 처리해주는 부분까지도 같고 
그 다음내용인 distanceRatio를 구하는 부분이 다른데
우선 halfAngle 을 구하고 있습니다 광원의 최대각도의 절반입니다. viewLightVec는 view 스페이스에서 광원에서 물체까지의 벡터입니다. 비슷한 viewLightDir은 normalize 해준값이다 
보니 그냥 다시 구해줬습니다. 
다음 변수인 viewCenterLightDir 는 무슨 의미냐면 빛 오브젝트 자체가 바라보고있는 방향을 말하는데 비슷한 viewLightDir는 광원에서 물체 까지의 방향을 말한다면 지금이
viewCenterLightDir는 물체 상관없이 빛 오브젝트의 방향입니다.
centerDist 라는 변수는 viewLightVec 와 viewCenterLightDir 를 내적한 값인데 물체가 viewCenterLightDir 방향으로 얼마나 갔느냐에 대한 값입니다.
이 centerDist 를 사용해서 1차적으로 distanceRatio 를 구해줄수 있는데 이 값이 최종값은 아닙니다. 
lightAngle 은 viewCenterLightDir 에서 물체 로의 벡터 사이 각도가 얼마인지를 말하는데 viewLightvec를 단위벡터화 하고 (즉 viewLightDir)
viewCenterLightDir 을 내적하면 그사이 각도의 cosθ 값이 나오고 코사인을 가지고 각도를 알수 있는 아크 코사인 함수 acos 으로 각도를 가져옵니다.

그 다음 if else 문은 물체가 빛의 범위를 벗어났는지를 체크하는 부분입니다. 
centerDist < 0.f 이부분은 물체가 광원에 뒷방향에 있는상태이고  centerDist > g_light[lightIndex].range 는 물체가 광원의 최대 범위 밖에 있는 상황입니다. 
lightAngle > halfAngle 여기는 위에서 구했던 물체와 광원의 centerDir 사이의 각도가 광원의 최대 각도 밖에 있을경우입니다. 
위 의 경우는 distanceRatio 를 모두 0으로 밀어서 빛이 닿지 않는걸 표현합니다. 
이외의 상황 else 에서는 물체가 빛이 비추는 범위 안에 있으니 거리에 따라 세기를 조절해줍니다.



이렇게 쉐이더 까지 완료 되었으니까 Light 클래스가 잘 작동하는지를 테스트해보고 싶어집니다. 

먼저 환경설정을 좀 할건데 이전 프로그램보다 직관적이게 카메라를 0, 0, 0 원점에 두고 싶습니다. 
카메라 같은 오브젝트들을 SceneManager::LoadTestScene에서 해주고 있었습니다. 
다음으로 이번 실습에서는 큐브는 사용하지 않고 구만 하나 사용해줄겁니다. 구가 역시 normal의 변화를 보기 더 좋을거 같습니다. 
구의 스케일은 그대로 (100.f, 100.f, 100.f) 고 position 을 (0.f, 0.f, 150.f) 정도로 세팅했습니다.

다음은 오늘의 주제인 조명을 3가지 타입으로 세팅해줄겁니다.
#pragma region Green Directional Light
	{
		shared_ptr<GameObject> light = make_shared<GameObject>();
		light->AddComponent(make_shared<Transform>());
		//light->GetTransform()->SetLocalPosition(Vec3(0.f, 150.f, 150.f));
		light->AddComponent(make_shared<Light>());
		light->GetLight()->SetLightDirection(Vec3(0.f, -1.f, 0.f));
		light->GetLight()->SetLightType(LIGHT_TYPE::DIRECTIONAL_LIGHT);
		light->GetLight()->SetDiffuse(Vec3(0.1f, 1.f, 0.1f));
		light->GetLight()->SetAmbient(Vec3(0.f, 0.1f, 0.f));
		light->GetLight()->SetSpecular(Vec3(0.1f, 0.1f, 0.1f));

		scene->AddGameObject(light);
	}

#pragma endregion
초록색 디렉셔널 라이트 입니다. Position 부분은 주석처리되어있는데 디렉셔널 라이트 자체가 광원 위치가 의미가 없기 때문이고 LightDirection 은 지면에 수직으로 쭉 
내리쬐는 방향입니다. 3속성을 보면 diffuse 는 green은 만땅인 1.f 고 나머지 red, blue는 0.1f 씩 쪼금씩만 설정해줬습니다. ambient는 green만 0.1f 만큼 쬐금
초록색을 줬습니다. specular 값은 약한 흰색으로 0.1f 씩 주었습니다.


#pragma region Red Point Light
	{
		shared_ptr<GameObject> light = make_shared<GameObject>();
		light->AddComponent(make_shared<Transform>());
		light->GetTransform()->SetLocalPosition(Vec3(150.f, 150.f, 150.f));
		light->AddComponent(make_shared<Light>());
		//light->GetLight()->SetLightDirection(Vec3(0.f, -1.f, 0.f));
		light->GetLight()->SetLightType(LIGHT_TYPE::POINT_LIGHT);
		light->GetLight()->SetDiffuse(Vec3(1.f, 0.1f, 0.1f));
		light->GetLight()->SetAmbient(Vec3(0.1f, 0.f, 0.f));
		light->GetLight()->SetSpecular(Vec3(0.1f, 0.1f, 0.1f));
		light->GetLight()->SetLightRange(10000.f);
		//light->GetLight()->SetLightAngle(XM_PI / 4);
		scene->AddGameObject(light);
	}
#pragma endregion
빨간색 포인트 라이트 입니다. 포인트 라이트 부터는 광원의 위치가 필요하고 또 디렉셔널 라이트와 달리 LightRange 라는 값을 설정해야 합니다. 위치는 구의 오른쪽 위에 위치할것이고 

#pragma region Blue Spot Light
	{
		shared_ptr<GameObject> light = make_shared<GameObject>();
		light->AddComponent(make_shared<Transform>());
		light->GetTransform()->SetLocalPosition(Vec3(-150.f, 0.f, 150.f));
		light->AddComponent(make_shared<Light>());
		light->GetLight()->SetLightDirection(Vec3(1.f, 0.f, 0.f));
		light->GetLight()->SetLightType(LIGHT_TYPE::SPOT_LIGHT);
		light->GetLight()->SetDiffuse(Vec3(0.f, 0.1f, 1.f));
		//light->GetLight()->SetAmbient(Vec3(0.f, 0.f, 0.1f));
		light->GetLight()->SetSpecular(Vec3(0.1f, 0.1f, 0.1f));
		light->GetLight()->SetLightRange(10000.f);
		light->GetLight()->SetLightAngle(XM_PI / 4);
		scene->AddGameObject(light);
	}
#pragma endregion
파란색 스포트 라이트입니다. 구의 왼쪽에 위치해 있을것이고 포인트 라이트와 거의 비슷 하지만 LightAngle 이라는 각도를 설정해줍니다.

여기까지 했으면 아마 실행해도 괜찮을것 같아서 실행해보니까 

쉐이더를 불러오지 못했다고 에러메세지가 뜨네요 
아마도 쉐이더 파일들쪽에서 문제가 있는것 같은데 디버깅을 할때 쉐이더 쪽에서 문제가 생기면 해결하기가 좀더 어렵습니다.
문제는 우리가 이번강의에서 처음으로 쉐이더 파일들을 헤더처럼 분리해서 관리하고 있었는데 params.hlsli 파일은 include해줬는데 CalculateLightColor 함수를 utils 에 만들고는
막상 default.hlsli 에 include 해주지 않았었습니다.

쉐이더 쪽에서 버그가 났을때 디버깅 팁으로 큰 기능 마다 주석 처리를 해보면서 실행을 해본다고 합니다. 그러면 어느 부분을 주석 했을때 잘 돌아 간다면 주석한 부분이 문제인것이고 
거기서 또 조금씩 범위를 줄여가면서 주석하는 방법으로 버그를 잡는다고 합니다.

아무튼 이렇게 쉐이더 쪽 버그를 잡고 나서 다시 디버깅으로 실행해보면
TableDescriptorHeap::CommitedTable 에서 CMD_LIST->SetGraphicsRootDescriptorTable(0, handle) 에서 엑세스 위반이 일어났다는 에러메세지가 떴습니다.
이 엑세스 위반 에러는 실제 서비스에서 서버쪽에 발생하면 정말 무서운 에러라고 합니다.
문제의 원인은 RootSignature 에서 서명부분이 문제라고 합니다.
RootSignature::CreateRootSignature 에서 
    CD3DX12_ROOT_PARAMETER param[2];
	param[0].InitAsConstantBufferView(static_cast<uint32>(CBV_REGISTER::b0)); // b0
	param[1].InitAsDescriptorTable(_countof(ranges), ranges);
이 코드인데 이전에는 param을 1개짜리 배열로 0번 인덱스만 사용했다가 지금은 0,1 인덱스 두개로 사용하고 있습니다.
0번 인덱스는 그냥 ConstantBuffer 용으로 1번 인덱스를 TableDescriptorHeap 용도로 변경했는데 
void TableDescriptorHeap::CommitTable()
{
	D3D12_GPU_DESCRIPTOR_HANDLE handle = _descHeap->GetGPUDescriptorHandleForHeapStart();
	handle.ptr += _currentGroupIndex * _groupSize;
	CMD_LIST->SetGraphicsRootDescriptorTable(0, handle);

	_currentGroupIndex++;
}
SetGraphicsRootDescriptorTable의 첫번째 인자가 RootParameterIndex 인데 0번인 채 입니다 이부분을 1로 변경해줘야 합니다.

이렇게 까지 버그를 잡아주었지만 빌드 통과후 실행해보니 예상한대로 빛의 효과가 나타나지 않고 있습니다. 
아직 고쳐야 할 부분이 있습니다. 

그런제 잠시 현재 프로그램의 배경색이 하늘색인것을 검은색으로 바꿔야 빛 효과가 더 두드러지게 보일것 같아서 변경해주려고 합니다. 
이걸 어느 부분에서 하고 있었는지를 찾아보니까 일단 Engine::RenderBegin 에서 _cmdQueue->RenderBegin(&_viewport, &_scissorRect);를 해주고 있습니다. 
또 이걸 타고 들어가니 이 함수 내에서 
_cmdList->ClearRenderTargetView(backBufferView, Colors::LightSteelBlue, 0, nullptr);
이부분에 LightSteelBlue 를 Black 으로 바꿔 주었습니다. 

이제 다시 디버깅으로 돌아와서 지금처럼 빌드는 통과하지만 원하는결과가 나오지 않을때의 디버깅 하는방법은 
아까 쉐이더 파일 디버깅 방법처럼 각 부품들을 하나씩 꺼보는겁니다. 

의심되는 부분이 혹시 Light::FinalUpdate 에서 Transform 이 제대로 전달이 된것인지를 체크해봤습니다. 중단점을 설정하고 Transform 값을 체크해보니 이상한 값을 가지고 있습니다.

Transform.h 로 가서 
    cosnt Vec3& GetWorldPosition() { return _matWorld.Translation(); }

	Vec3 GetRight() { return _matWorld.Right(); }
	Vec3 GetUp() { return _matWorld.Up(); }
	Vec3 GetLook() { return _matWorld.Backward(); }
이런 부분이 있는데 
밑의 부분은 _matWorld의 성분들을 복사 방식으로 꺼내고 있는데 _matWorld.Translation() 은 const & 방법으로 꺼내오고 있습니다. 
이전에 배웠었는데 SimpleMath 에서 이 함수들은 임시값을 만들어서 그대로 리턴하는 방식이었고 이 임시값들은 스택 메모리에 있는 변수들이다 보니 참조를 하면 엉뚱한 메모리를 
참조 하고 있게 되었었습니다.
이 GetWorldPosition 의 반환타입을 Vec3 로 복사방식으로 바꿔 주겠습니다.

이러면 의도한대로 결과물이 나왔습니다.