

		8 . Input 과 Timer


이번시간에는 간단한 부품 하나를 추가 할 것 입니다.

지금까지 우리가 만들고 있는 것은 3D물체를 표현하기위한 부품들을 만들고 있었는데요 3D그래픽을 표현하려면 필연적으로 카메라가 있어야 
이곳 저곳을 찍을수 있을 것인데 이 카메라를 이곳 저곳 움직이려면 일단 입력을 받는게 제일 첫번째 일것입니다.
그리고 이동을 할때도 임의의 거리를 이동하는게 아니라 일정시간동안 이동을 하는게 필요한게 두번째 입니다.

그래서 Input과 Timer라는 부품을 추가 해주겠습니다.

Engine에 각각 클래스를 추가해주고

# Input 
input 클래스 부터 시작하겠습니다. Input의 기능은 지금 사용자가 키보드나 마우스의 버튼을 누르고 있는지, 이전 프레임부터 계속 누르고 있는 상태인지, 버튼을 누르던걸 땠는지를 
감지하는 기능을 가지고 있습니다.

이번시간은 키보드 입력만 다룰 것이고 마우스는 다른 시간에 추가해줄것입니다.

가지고 있는 private 멤버 변수는 윈도우 핸들 HWND _hwnd 와 KEY_STATE라는 타입의 vector _states; 를 가지고 있습니다.

가지고 있는 함수는 Init 함수(_hwnd를 초기화), Update함수로 매 프레임 입력이 어떤지 추적해주고있습니다.
그리고 3가지 함수 GetButton, GetButtonDown, GetButtonUp 이 있는데 각 기능은
GetButtonDown : 내가 키보드를 누른 순간 true 반환하는 함수
GetButtonUp : 내가 누르고 있던 키보드를 때는 순간 true를 반환하는 함수
GetButton : 매 프레임마다 계속 누르고 있는 상태에 라면 true 를 반환하는 함수 

다음으로 몇몇 enum class와 enum을 추가 해 줄것입니다. 이 enum들은 입력에 대한 것들인데, 그냥 EnginePch에 추가해 줄 수 도 있지만 
용도가 입력에 대한 enum들이고 입력은 무조건 이 Input클래스를 포함해야 하니깐 Input클래스에 추가 해줘도 무방할것입니다.

enum class KEY_TYPE
{
	UP = VK_UP,
	DOWN = VK_DOWN,
	LEFT = VK_LEFT,
	RIGHT = VK_RIGHT,

	W = 'W',
	A = 'A',
	S = 'S',
	D = 'D',
};

enum class KEY_STATE
{
	NONE,
	PRESS,
	DOWN,
	UP,
	END
};

enum
{
	KEY_TYPE_COUNT = static_cast<int32>(UINT8_MAX),
	KEY_STATE_COUNT = static_cast<int32>(KEY_STATE::END),
};

KEY_TYPE은 이번에 입력받을 버튼을 방향키들과 wasd만 일단 받을것입니다. 나중에 필요해지면 다른 버튼들도 추가해줄것입니다.
VK_UP같은것들은 우리가 직접 추가한 것이 아니라 Windows에서 지원하는 define입니다.

또 한가지 의문점으로 그러면 직접 VK_UP같은 define을 사용하면 되지 왜 굳이 KEY_TYPE이라는 enum class를 또 한번 랩핑을 했는가?
- 일단 이름을 외우기 쉽게 해줄려는 의도가 하나 있고 , 또 지금은 모르지만 만약 Window가 아닌 환경에서 이 게임을 실행했을때 대응을 하기 쉽도록 이렇게 한번 랩핑으로 관리를 해주고 있습니다.

KEY_STATE는 함수3형제들과 관련된 enum class입니다.
NONE은 입력이 없는상태, DOWN은 입력을 한 순간, PRESS는 입력이 유지되고있을때, UP은 입력이 해제된순간, END는 그냥 이 enum class의 갯수를 세기위해 넣어놓았습니다.

마지막 enum은 각 enum class의 count를 쓰기위해 만든 enum입니다. KEY_STATE는 END로 갯수를 관리하는데 KEY_TYPE은 왜 그렇게 안할까요?
KEY_TYPE은 순서대로 나열되기만 한게 아니라 각각 임의의 값을 대입해주었기 때문에 마지막에 END를 추가해도 그게 갯수를 의미 하지 않기 때문입니다.
그래서 그냥 unsigned int 8bit max 만큼 즉 255개라고 해놓았습니다. 지금은 키를 8개 밖에 사용하고 있지 않지만 점차 늘려갈수 있으니 그냥 큰숫자로 해두었습니다.

GetButton 함수들의 구현은 GetState라는 함수의 리턴 값이 각 KEY_STATE와 같은지 체크하고 있고 
또 GetState는 
GetState(KEY_TYPE key) { return _states[static_cast<uint8>(key)]; }
_state를 리턴하고 있습니다.
즉,vector<KEY_STATE> _states; 는 각 키에 해당하는 state를 관리하는 벡터라고 할 수 있습니다.
예를 들어 W 키를 눌렀다면 GetButton의 인자로 W를 주고 구현부의 GetState에서 W의 state를 가지고 있는 _state에서 값을 가져와 체크를 할것입니다.


이제 Input 과 Update함수의 구현부를 살펴보겠습니다.
Input에서는 인자로 받은 HWND를 _hwnd에 받아주고 , _state.resize로 크기는 KEY_TYPE_COUNT(UINT8_MAX(255))만큼 모든 스테이트는 NONE으로 설정해주었습니다.
(_hwnd가 필요한이유는 이 프로그램이 비활성화 일때도 화살표 버튼이나 wasd버튼을 누르면 우리 게임에서 반응을하지 않도록 현재 활성화된 윈도우를 체크해서 입력을 받지 않도록 해주기 위해서 입니다.
이 부분은 Update 초반에 나옵니다.)

다음으로 Update 함수의 구현부 입니다. Input::Update는 매 프레임마다 갱신이 되는 함수입니다. 
왜 입력을 매 프레임마다 체크를 해야 하냐면 입력이 한 프레임 내에서는 유지 된다고 가정을 해야 하기 때문입니다. 
어떤 A프레임에서 한번 체크할때는 W라는 버튼이 누른 상태였는데 다시 A프레임 내에서 두번째 체크를 할때 W가 때진 상태면 모순이 발생할것이기 때문입니다.
그러다 보니 매 프레임마다 입력은 고정된 값을 가지게 하기 위해서 매 프레임마다 Update를 호출할것입니다.

Update 함수의 첫 할일은 _hwnd를 Active 상태인지 체크해서 아니라면 _state의 모든 키의 상태를 NONE으로 바꿔주는 일입니다. 
게임창을 내린상태에서도 입력을 받는다면 이상하겠죠?

다음으로 for문이 또 나오는데 uint32타입의 key라는 변수가 KEY_TYPE_COUNT만큼 반복을 돌아 줄것입니다.
그리고 if 문으로 ::GetAsyncKeyState(key) & 0x8000 이것을 체크해 줍니다. 이건 Windows에서 제공하는 키가 눌렸는지를 체크하는 방법입니다.
눌렸다면 
		KEY_STATE& state = _states[key];

		// 이전 프레임에 키를 누른 상태라면 PRESS
		if (state == KEY_STATE::PRESS || state == KEY_STATE::DOWN)
			state = KEY_STATE::PRESS;
		else
			state = KEY_STATE::DOWN;
	else
		{
			KEY_STATE& state = _states[key];

			// 이전 프레임에 키를 누른 상태라면 UP
			if (state == KEY_STATE::PRESS || state == KEY_STATE::DOWN)
				state = KEY_STATE::UP;
			else
				state = KEY_STATE::NONE;
		}
이렇게 _state의 모든 요소들을 체크해서 업데이트 해 줍니다.

이제 이렇게 만든 Input 클래스를 Engine 에도 추가 해주겠습니다. include, Get함수 shared_ptr, make_shared를 해주고 Engine::Init에서 Input::Init 도 해주었습니다.

( 이때 다시 코드를 정리 했는데 make_shared를 Engine.cpp에서 하지않고 그냥 Engine.h에서 생성자에게 넘겼습니다. 이런 습관은 전방선언을 해주지 않으면 안되기 때문에 좋은 습관은 아니지만 ,
지금 프로젝트에서는 전방선언 대신 아예 클래스들을 include 하고 있으니깐 허용 됩니다.)

오랜만에 Engine에 새로운 함수를 추가 해줄건데 Update입니다. 앞으로는 이 Update함수가 여러개 나올수도 있는데 각 업데이트 시점마다 달라지는 것들이 있을수 있기때문입니다.
Engine::Update는 지금은 간단하게 _Input->Update() 만 해주겠습니다.

그리고 Game::Update로 가서 GEngine객체를 Update해주겠습니다. 위치는 RenderBegin하기 이전에 넣어주겠습니다.
(지금은 Game::Update에서 렌더링을 해주고 있지만 나중에는 전부 Engine안에서 하게 될겁니다.)

이제 Game이 루프를 돌때마다 Update가 될것이고 Input으로 어떤 실습을 할거냐면 지금까지는 베이가 사진에게 offset으로 trasform이라는 고정값을 줬지만 지금부터는 입력으로 줘보도록 하겠습니다.
지금까지 사각형 메쉬에 베이가를 매핑해놨던 코드가 이런 형태 였습니다.
	{
		Transform t;
		t.offset = Vec4{ 0.0f, 0.f, 0.f, 0.f };
		mesh->SetTransform(t);

		mesh->SetTexture(texture);

		mesh->Render();
	} 
이전 테스트에서는 베이가를 두개 생성했었는데 일단 한개만 사용할것이고 이 코드에서 입력에 따라 offset이 바뀌도록 하려면 이렇게 바꿔야합니다.

	{
		static Transform t = {};

		if (INPUT->GetButton(KEY_TYPE::W))
			t.offset.y += 1.f;
		if (INPUT->GetButton(KEY_TYPE::S))
			t.offset.y -= 1.f;
		if (INPUT->GetButton(KEY_TYPE::A))
			t.offset.x -= 1.f;
		if (INPUT->GetButton(KEY_TYPE::D))
			t.offset.x += 1.f;

		mesh->SetTransform(t);

		mesh->SetTexture(texture);

		mesh->Render();
	} 
우선 Trasform t; 가 앞에 static이 붙었습니다. 이전프레임의 값을 유지하도록 지금이 { } 의 유효범위를 넘어서도 유지되도록 해준것이고, 각 if문으로 인풋의 어떤 버튼을 누르고 있는지를 체크하고 있습니다.
( 여기서 INPUT이라는 define을 사용했는데 내용은 GEngin->GetInput()입니다. EnginPch.h에 추가하였습니다. )
if문으로 W, S, A, D를 각각 체크해서 Transform의 x 좌표와 y좌표를 가감하고 있습니다. 
이렇게 해서 실행해보면 첫화면에는 베이가가 있고 WASD의 아무 버튼이나 누르면 그림이 없어집니다. 
그 이유는 Update가 매 프레임 일어나고 있는데 CPU의 처리속도가 매우 빠르기 때문에 우리가 WASD중 하나를 잠깐만 눌러도 그 방향으로 수십 수백 이나 좌표가 움직여버리기 때문입니다. 
(이문제를 해결하기위해 이 다음에 배울 TImer가 필요합니다.)
일단 미봉책으로 각 좌표에 0.001씩을 곱해서 실행해 봤습니다. 이러니까 그럴싸 하게 속도가 느려졌습니다. 
이러면 되는거아닌가? 꼭 Timer가 필요한가 싶지만, 이렇게 고정값으로 처리하면 컴퓨터 마다 처리속도가 다른데 그러면 각 컴퓨터마다 이 베이가가 움직이는 속도가 달라집니다. 모두가 같은 속도로 움직이게 하기위해 
프레임사이의 시간을 재서 적절한 속도가 나도록하는게 Timer클래스입니다.


# Timer


class Timer
{
public:
	void Init();
	void Update();

	uint32 GetFps() { return _fps; }
	float GetDeltaTime() { return _deltaTime; }

private:
	uint64	_frequency = 0;
	uint64	_prevCount = 0;
	float	_deltaTime = 0.f;

private:
	uint32	_frameCount = 0;
	float	_frameTime = 0.f;
	uint32	_fps = 0;
};

이렇게 선언부가 되어 있고 deltaTime은 이전 프레임과 현재 프레임간의 걸린 시간을 말하는 것이고 , fps는 말그대로 Frame per Second 초당 몇 프레임이 지나갔는가를 알려주는 것입니다.

이제 Init과 Update의 구현부도 보겠습니다.

void Timer::Init()
{
	::QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(&_frequency));
	::QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&_prevCount)); // CPU 클럭
}

void Timer::Update()
{
	uint64 currentCount;
	::QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&currentCount));

	_deltaTime = (currentCount - _prevCount) / static_cast<float>(_frequency);
	_prevCount = currentCount;

	_frameCount++;
	_frameTime += _deltaTime;

	if (_frameTime > 1.f)
	{
		_fps = static_cast<uint32>(_frameCount / _frameTime);

		_frameTime = 0.f;
		_frameCount = 0;
	}
}

Init에서는 Window에서 제공하는 함수를 사용하고 있는데, Window에서도 시간을 재는 함수를 여러가지 사용하고있습니다 예를 들어 GetTickCount라는 함수는 시간에 따른 틱이라는 단위를 세는 함수인데
여기서 시간이란 시 분 초 같이 보편적으로 정밀한 시간을 사용하는것이 아닌 상대시간을 사용합니다. 이전 기준점에서 지금까지 얼만큼의 시간이 흘렀는지를 잴수 있으면 충분합니다.
GetTickCount함수의 단점은 정밀도가 떨어진다는 점인데 그걸 보완하는게 Windows에서 제공하는 
::QueryPerformanceCounter 입니다. 이 함수는 CPU클럭과 관계있다고 합니다.
_frequency(빈도?)와 _prevCount(이전 클럭수)를 Init할때 초기화 하고 
업데이트 함수에서 현재 클럭수 CurrentCount 를 구한다음 현재 클럭수에서 이전 클럭수를 빼면 한 프레임당 클럭이 얼마나 지났는지를 알수 있고 이 한 프레임의 클럭수를 다시 빈도로 나눠주면 
_deltaTime이 나옵니다.

( 델타 타임이란? 델타 타임이 무엇인지 이해가 잘 안가서 따로 찾아본 내용입니다. 
컴퓨터간의 성능차이가 생기기 시작한 후로 부터 게임에서 한프레임당 1M를 간다고 치면 연산능력이 2배 빠른 컴퓨터는 기존 컴퓨터보다 같은시간에 두배 멀리 갈수 있게 되었습니다.
하지만 어떤성능의 컴퓨터라도 항상 동등한 게임 경험을 받도록 하고 싶기때문에 '델타 타임'이 등장하였는데요 이 '델타 타임의 의미는 이전 프레임이 걸린시간' 이라는 뜻이라고 합니다. 
이게 어째서 동등한 성능을 내기위한 개념인가? 할 수 있는데 프레임당 이동거리에 델타타임을 곱해주면 되는데요
어떤 컴퓨터 A의 FPS가 10프레임이 나온다고 한다면 이 컴퓨터 A의 델타타임은 1/10초 인겁니다. 반면 컴퓨터 B의 FPS는 20프레임이라면 이 컴퓨터 B의 델타타임은 1/20입니다.
컴퓨터 A가 어떤 캐릭터를 1프레임에 1M 이동시킨다고 한다면 1M * 1/10초 이므로 1프레임당 0.1M를 움직이고 FPS로 따지면 초당 1M를 움직입니다.
컴퓨터 B의 경우 1M * 1/20초 이므로 프레임당 0.05M 를 움직이지만 fps 20 프레임이니깐 1초당 1M를 움직이게 됩니다. 
이렇게 성능이 다른 두 컴퓨터가 동등한 게임 경험을 가지게 됩니다.)
( 위 코드에서 (currentCount - _prevCount) 이부분에서 한 프레당 몇번의 클럭이 지나갔는가를 알수 있습니다. 예를 들어 20 클럭이 지나갔다고 합니다.
또 ::QueryPerformanceFrequency라는 함수의 결과물인 _frequency는 1초당 이 CPU가 몇 클럭을 수행하는가 입니다. 100 클럭이라고 해보겟습니다. 이러면 초당 100클럭인데 한프레임당 20클럭이니깐
FPS 가 5프레임이지 않을까? 라는생각이 듭니다. 그래서 _deltaTime을 구하는 수식을 직접 계산해 보면 20 / (100/1sec) 입니다. 계산후 0.2sec라는 값이 나옵니다. 
정말 한 프레임당 걸리는 시간이 나왔습니다.)

_deltatime을 구하고 나서는 다음 프레임의 클럭수 계산을 위해 _prevCount에 currentCount값을 넣어줍니다.
그리고 _frameCount는 한 프레임이 지났으니 1증가시켜주고 1프레임당 시간인 _deltaTime을 _framTime에 += 해줍니다. 
다음으로 _fps 값을 구하기 위해 if 문을 돌아 _framTime이 1초가 지났는지를 체크 해줍니다. 이 때의 _frameCount는 1초동안의 frame수가 쌓여있을것이고 _frameTime은 1초와 근사값이므로 
프레임 수와 시간을 나누어서 _fps에 넣어줍니다. 그리고 나서는 다시 _frameCount 와 _frameTime을 0으로 초기화 해줍니다. 다음 _fps를 측정하기 위해서

이렇게 Timer 클래스에서는 _deltaTime과 _fps를 구해주었습니다. 좀 더 고급으로가면 더 다양한 기능이 있다고 하는데 지금 단계에서는 필요 최소한의 기능만을 구현하였습니다.
( Timer를 일시정지 시킨다거나 더 빠르게 돌린다거하 하는 기능들)

# Engine에 Timer 클래스 추가 

Engine.h에 Timer클래스를 include해주고 GetTimer함수와 Timer 멤버 변수를 만들어줍니다. 
Engine.cpp에서는 Engine::Init에서 _timer->Init() 을 해주고 Engine::Update에서는 _timer->Update()를 해주어서 매 프레임 업데이트 되도록 해주겠습니다. 
한가지 더 추가 기능을 넣어 볼것입니다. 바로 윈도우에 fps를 출력하는 기능입니다. 
ShowFps라는 함수를 만들고 Engine::Update에 같이 실행되도록 넣어줍니다. 
ShowFps의 구현부는 _timer->GetFps를 받아서 윈도우 API를 이용해 화면에 출력하는 간단한 기능입니다.

void Engine::ShowFps()
{
	uint32 fps = _timer->GetFps();

	WCHAR text[100] = L"";
	::wsprintf(text, L"FPS : %d", fps);

	::SetWindowText(_window.hwnd, text);
}

# Game에서 DeltaTime 적용

우리가 Timer를 만든이유가 Input으로만 이동을 구현하면 컴퓨터의 성능에 따라 이동 속도가 좌우되는걸 동등하게 하기 위해서였습니다. 
Input에 Timer에서 구한 deltaTime을 곱해주면 되는데 이 deltaTime이 이곳 저곳에서 쓰일것 같으니 EnginePch에 define을 해주면 편할것 같습니다.

#define DELTA_TIME			GEngine->GetTimer()->GetDeltaTime()

Input에 의한 이동 코드는 이제 
	{
		static Transform t = {};

		if (INPUT->GetButton(KEY_TYPE::W))
			t.offset.y += 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::S))
			t.offset.y -= 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::A))
			t.offset.x -= 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::D))
			t.offset.x += 1.f * DELTA_TIME;

		mesh->SetTransform(t);

		mesh->SetTexture(texture);

		mesh->Render();
	} 
이렇게 될것입니다. DeltaTime은 1프레임당의 시간이니깐 우리가 느끼기에는 이제 1초에 1.f씩 움직이는걸로 될것입니다.
즉, 사실상 이제 이 프로그렘에서 1.f라는 부분이 이동속도를 의미하게 되었습니다. 
1.f(속도) * DELTA_TIME(시간) = t.offset.y(거리) 가 되는겁니다.
