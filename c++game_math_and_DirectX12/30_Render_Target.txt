

        30. Render Target



이번 시간 다룰 주제는 렌더 타겟입니다. 
그중에서도 다중 렌더 타겟 Multiple Render Target 입니다. 

아주 중요한 내용입니다. 다음 시간에 배울 Deferred Rendering 과도 연관성이 있고 그 기초 작업을 하고 있다고도 할 수 있습니다. 

먼저 기초 지식을 알아보고 가겠습니다. 

우리가 지금까지 사용하고 있던 셰이더 방식은 Forward Shader 라고 합니다. 
엔진을 만들기 시작하면서부터 봤던 렌더링 파이프라인 이미지가 있을겁니다. 처음부터 훑어보자면 
시작부분 Input Assembler 단계에서 Vertex, Index 정보를 넘겨주었고 다음으로 이 정보를 가지고 셰이더를 통해서 이 정보가 어떤 일을 해야하는지 쫙 기술해준 다음
쭉 처리를 해서 마지막으로 Pixel Shader 를 마친 연산된 결과물을 출력해주고 있었습니다. 다음 Output Merge 단계에서 최종 연산 결과물을 Render Target View 라는 곳에 
그려주고 있습니다. 

Part.2 의 초반에 만들었던 엔진 뼈대 부분에 이 렌더타겟뷰에 대한 코드가 들어있는데 오랜만에 다시 떠올려보자면 
CommendQueue 클래스안에 있는 내용인데 RenderBegin, RenderEnd 라는 멤버 함수 안에 이런 코드들이 있었습니다. 
// Specify the buffers we are going to render to.
D3D12_CPU_DESCRIPTOR_HANDLE backBufferView = _swapChain->GetBackRTV();
_cmdList->ClearRenderTargetView(backBufferView, Colors::Black, 0, nullptr);

D3D12_CPU_DESCRIPTOR_HANDLE depthStencilView = GEngine->GetDepthStencilBuffer()->GetDSVCpuHandle();
_cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, &depthStencilView);

_cmdList->ClearDepthStencilView(depthStencilView, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

오랜 만에 해석해보자면 시작은 backBufferView 라는 변수를 만들어주고 있는데 이 변수는 스왑체인에서 백버퍼를 가져오고 있습니다. 백버퍼라는것은 프론트 버퍼와 한쌍을 이루는데
버퍼라는 특수한 종이에 그릴 장면을 그려주는데 이 버퍼를 두개 만들어서 하나는 현재 프레임의 화면을 표현하고 남은 하나의 버퍼는 다음 프레임에 표현할 장면을 뒤에서 그려주고 있는
겁니다. 이 현재 버퍼를 프론트 버퍼, 다음 버퍼를 백 버퍼라고 하는데 매 프레임마다 스왑체인에서 교체해주는것으로 화면에 잔상같은것없이 화면의 움직임을 표현합니다. 

다음 코드는 커맨드 리스트의 함수인 ClearRenderTargetView 를 실행하고 있습니다. 인자로 방금 만든 backBufferView 변수로 주고 있는데 다음 프레임의 화면을 그려주기전에 
백버퍼의 이전 내용을 깨끗이 밀어주고 있습니다. 

depthStencilView 라는 변수를 만들어주고 있습니다. 이 뎁스 스텐실 이란 기능은 화면의 물체들의 깊이차를 계산해서 물체들이 가려져서 표현되는 기능입니다. 
백 버퍼와 뎁스 스텐실 버퍼를 인자로 받고 있는 OMSetRenderTargets 메소드에서 OM(Output Merge) 단계에서  두 버퍼를 바인드 해주고 있습니다. 
마지막으로 다음에 사용될 뎁스 스텐실 뷰를 밀어주고 있습니다.

그리고 실질적으로 그려주는 부분은 셰이더 쪽 Forward.fx 의 픽셀셰이더 부분에서 해주고 있습니다. 

C++ 에서 작성한 렌더 타겟 뷰 부분의 코드와 셰이더의 코드가 맞물려서 결국 OM 단계에서 우리가 지정한 렌더 타겟에 그려주고 있습니다. 

이렇게 그려준것을 나중에 등장할 Present 라는 함수를 통해서 화면에 그려줄겁니다. 

이 내용의 아쉬운 부분이 있습니다. 
2010년도 이후와 이전으로 나눠서 생각해야하는데 2010년 이전에 만들었던 게임들은 모두 지금 프로젝트의 방식 즉 Forward Shader 방식으로 만들어 주고 있었습니다.
근데 이 방식에서 아까운 부분이 무엇이냐면 우리가 열심히 만든 중간적 부분이 다 날라간다는 문제가 있습니다. 
이 말이 무슨 의미이냐면 IA 부분에서 정점, 인덱스 데이터를 넣어주고 셰이더의 과정을 따라가면서 여러 가공을 해주는 부분 정점데이터를 만들고 텍스쳐를 입히고 보간을하고 빛연산을
하고 노멀값을 가져와서 빛반사도 계산한 다음 결과적을 픽셸셰이더에 color 라는 변수에 담아서 리턴을 해주는데 이 color 말고 이전에 계산하던 부분들은 모두 날라갑니다. 

이 문제에 대한 대안으로 나온것인 다음강의에 배울 Deferred Shader 입니다. 디퍼드 셰이더에 대한 내용은 다음 강의로 남기고 
이번 강의에서는 렌더 타겟에 대한 내용을 더 깊게 다룰건데 

렌더타겟은 결국엔 셰이더의 최종 결과물을 어디에 그려줄것인가를 얘기하고 있는겁니다. 어떤 대상(Target)에 그릴것(Render)이냐는 말이죠
경우에 따라 화면에 그려주는것 뿐만 아니라 별도의 텍스쳐를 만들어서 그 버퍼에 그려주는 경우도 많습니다.

사실 버퍼라는 것 자체도 텍스쳐로 충분히 표현할 수 있습니다. 그냥 2차원 배열로 표현할수 있는 정보가 버퍼이다 보니깐 버퍼를 텍스쳐로 표현할 수 있고,
그 텍스쳐에다가 셰이더를 통해서 그림을 그려주는것도 충분히 가능합니다.

이 내용을 어떻게 응용할 수 있냐면 https://www.youtube.com/watch?v=vYAub_fSax8 이 영상에 예시가 나오는데 
어떤 내용이냐면 유니티에서 한 게임화면안에 CCTV를 출력하고 있는 TV가 하나더 있고 이 TV의 CCTV 영상은 멈춰있는게 아니라 별도의 카메라가 찍고있는화면을 가져다가 
실시간으로 출력하고 있는 상황입니다.

이런걸 표현하기 위해서는 지금까지 카메라의 촬영내용을 화면 전체에 그려주고 있었지만 그게 아니라 중간 단계를 거쳐서 텍스쳐라는 버퍼에다가 CCTV 카메라의 결과를 그려준 다음 
실제 TV의 화면부분에 그 텍스쳐를 입혀주면 CCTV 기능을 구현할 수 있다는 얘기입니다. 

유니티를 기준으로보면 유니티의 카메라 컴포넌트의 옵션중에 Target Texture 를 지정할 수 있는 부분이 있는데 이 카메라의 결과를 화면이 아니라 어떤 텍스쳐에다가 그려주세요 라는
기능입니다. 최종적으로 이 텍스쳐를 다른 게임오브젝트에 씌울수 있는 기능입니다. 

이런게 렌더 타겟의 개념인데 렌더 타겟을 왜 이해해야 하나면 결국은 디퍼드 셰이더와 연관이 있습니다.

- 디퍼드 셰이더 

지금까지 사용하던 포워드 셰이더 방법은 낭비가 심하다는 문제가 있습니다.
우리가 DirectX 를 배우고 엔진을 만들면서 하고 싶었던 것은 카메라도 만들고 물체도 만들고 빛에 대한 정보도 있고 그런걸 다 계산해서 화면에 그리고 싶은겁니다. 

그렇기때문에 여러 정보들을 GPU에 넘겨준다음 셰이더 들을 이용해서 이런저런 작업을 해달라고 요청을 하는건데 
버텍스 셰이더에서는 인풋을 가공하면서 아웃풋에 포지션, uv, 뷰 포지션, 뷰 노멀, 뷰 탄젠트, 뷰 바이노멀 같은 걸 계산해 아웃풋에 담아서 다음 셰이더로 넘겨주고 
다음 셰이더인 픽셀셰이더 에서는 중간에 정점들 사이의 픽셀들을 받아서 각 픽셀에 대한 색상을 텍스쳐에 매핑된 색상과 빛의 반사 결과에 따른 색상을 계산해서 color 로 
최종적으로 넘겨주는데 이 중간에 계산하던 부분들이 싹 날아가고 있습니다.

포워드 방식에서 중요한 문제가 특히나 빛연산이 굉장히 느리다는 단점이 있습니다. 
우리가 빛연산을 어떻게 하고 있었는지를 보면 빛에 대한 모든 정보를 글로벌 버퍼에 받아놨다가 그걸 for문을 돌면서 하나씩 하나씩 모든 물체들을 빛에 대한 연산을 하나씩 해줬습니다.

이렇게 밖에 할 수 없었던 이유는 어떤 물체가 있고 주변에 빛이 100개가 있다고 가정을 해보겠습니다.
이때 물체가 실제로 주변의 100개의 광원에서 빛을 받을지 아닐지를 알 길이 없기 때문에 한땀 한땀 for문을 돌아가면서 체크해야합니다.

빛에 대해 배울때도 알아 봤지만 디렉셔널 라이트 처럼 무한대로 비춰주는 광원같은경우는 상관없지만 포인트 라이트나 스포트 라이트 같은 경우는 광원의 범위가 있었습니다.
횃불같은게 물체에서 멀리 떨어져서 사실 빛 연산을 할 필요가 없지만 실제로 서로 연산 할 필요가 없는지를 체크하려면 광원과 물체사이의 광원 체크를 하나씩 전부 해줘야 하는겁니다.
이런 방식은 굉장히 낭비적입니다. 

대안적인 방법을 찾은것이 2010년 이후의 디퍼드 렌더링이라는 방법입니다. 
요즘 사용하는 게임엔진들은 모두 디퍼드 렌더링으로 갈아탔다고 합니다. 

그러면 디퍼드 방식은 뭐가 달라지냐면 포워드 방식에서 한번 계산하고 버려지던 정보들을 다 저장한다는 특징이 있습니다.
왜냐면 이 정보들 자체도 재사용해야할 정보일 수 있기 때문입니다. 

옛날 방식인 포워드 셰이더 방식은 각 물체들을 그래픽 파이프라인을 따라 가면서 렌더 타겟에 저장되는 방식이었고
디퍼드 방식은 물체가 그래픽 셰이더를 따라가는것은 비슷한데 마지막 픽셀셰이더 단계에서 빛의 색을 연산하는 것을 당장 하지 않을것이고 잠깐 보류해줍니다. 
그리고 이 단계에서 중간에 보존할만한 가치가 있는 데이터들을 다 렌더 타겟에다가 보존 해주게 됩니다. 이 보존할 데이터는 꼭 한개가 아닐것입니다. 
예를 들어 색상정보, 노멀정보, 깊이정보 같은 것들이 있을 수 있습니다.
이렇게 중간 렌더 타겟인 텍스쳐에 보존하면 무슨 장점이 있는가 하면 텍스쳐의 어떤 해당 픽셀에 대해서 이 픽셀에 진짜 물체가 있는지 없는지를 판별할 수 있습니다. 
그 판단에 의해서 물체가 있는 픽셀에 빛연산을 해준다는 점 도 있을 것이고 빛 연산 정책에 노멀도 포함되어있다면 노멀값도 포함해서 계산한 다음 최종 렌더 타겟에 넘겨줄 수 있는
 다양한 장점들이 있을겁니다.

디퍼드 렌더링 방식을 구현하기 위해 이번 시간에 수정할 여러가지중 하나인 셰이더 파일을 잠깐 보면 이전까지 셰이더 파일의 셰이더들은 반환타입이 float4 같은 단순한 
타입의 데이터만 반환하는 식이었지만 수정 후에는 새로운 스트럭트를 만들어서 보존한 데이터들을 각각 들고 반환할 수 있도록 해줄겁니다.

그렇지만 이번시간에서는 디퍼드 셰이더를 바로 적용하기 전에 기초작업으로 다중으로 렌더 타겟에 넘기고 받아주는 부분을 작업할겁니다. 


- 코드 

1) 셰이더 파일
가장 먼저 수정할 부분은 셰이더 입니다. 지금껏 사용하던 forward.fx 를 하나 더 복사해서 deferred.fx 라고 이름 을 변경하고 프로젝트에 추가해줬습니다. 
그리고 이 디퍼드 셰이더 파일에서 수정을 해줄 건데 먼저 utils.fx 를 include 하던 걸 삭제 해줍니다. 왜냐면 이 디퍼드 에서는 더이상 빛연산을 해주지 않고 
중간 렌더 타겟에서 빛연산을 해줄것이기 때문입니다. 

그 밑으로 VS_IN 과 VS_OUT, VS_Main 까지는 그대로 사용할 것이고 
그다음인 픽셀 셰이더 부분이 주로 변경되는데 위에서 설명했듯이 지금까지 픽셀 셰이더는 단일 타겟을 사용했지만 이번에 수정할것은 반환되는게 여러 데이터를 
한번에 반환할것입니다. 그러기 위해 먼저 반환되 타입을 선언해주겠습니다. 
struct PS_OUT
{
    float4 position : SV_Target0;
    float4 normal : SV_Target1;
    float4 color : SV_Target2;
};
픽셀 셰이더의 반환될 데이터들입니다. 기존에 반환하던 color 이외에도 포지션, 노말값이 같이 묶여서 반환됩니다. 

픽셀 셰이더 함수의 코드는 이렇게 수정됩니다. 
PS_OUT PS_Main(VS_OUT input)
{
    PS_OUT output = (PS_OUT)0;

    float4 color = float4(1.f, 1.f, 1.f, 1.f);
    if (g_tex_on_0)
        color = g_tex_0.Sample(g_sam_0, input.uv);

    float3 viewNormal = input.viewNormal;
    if (g_tex_on_1)
    {
        // [0,255] 범위에서 [0,1]로 변환
        float3 tangentSpaceNormal = g_tex_1.Sample(g_sam_0, input.uv).xyz;
        // [0,1] 범위에서 [-1,1]로 변환
        tangentSpaceNormal = (tangentSpaceNormal - 0.5f) * 2.f;
        float3x3 matTBN = { input.viewTangent, input.viewBinormal, input.viewNormal };
        viewNormal = normalize(mul(tangentSpaceNormal, matTBN));
    }

    output.position = float4(input.viewPos.xyz, 0.f);
    output.normal = float4(viewNormal.xyz, 0.f);
    output.color = color;

    return output;
}
먼저 반환할 데이터들을 담을 output 을 생성하고 각 픽셀의 색상을 텍스쳐에서 가져와 color 에 답았습니다. viewNormal 은 일단 input.viewNormal 로 담아 두고 
만약 노멀 텍스쳐가 있다면 그 뷰 텍스쳐를 적용하는 부분도 똑같습니다. 
이후 이렇게 구해준 position, normal, color를  output 에 담아서 리턴합니다.
빛연산하는 부분이 없어졌는데 빛연산은 이제 픽셀 셰이더 단계에서 해주는게 아니라 나중에 해줄것입니다.

셰이더는 이렇게 수정 해주었고 
이번 수정에서 픽셀셰이더에 반환타입으로 여러 데이터를 묶어서 반환 해주고 있는데 이걸 가능하게 해주도록 클래스를 새로 만들어줘야 합니다. 
Multiple Render Target 이라고 합니다.


2) RenderTargetGroup

새로 만들어줄 클래스이름은 RenderTargetGroup 입니다. 이 역할을 하는 클래스의 이름은 무엇이든 상관없지만 강의에서는 이 단어가 맘에 들어서 이 이름으로 했다고 합니다. 
이 이름 혹은 유니티 문서에서 부르는 MultipleRenderTarget 이라는 이름으로도 사용해도 됩니다.

이 클래스에서 텍스쳐를 사용할것이기 때문에 텍스쳐 클래스를 인클루드 해주겠습니다. 그리고 클래스에서 사용할 enum class , enum, struct 들을 만들어 주겠습니다.
#include "Texture.h"

enum class RENDER_TARGET_GROUP_TYPE : uint8
{
	SWAP_CHAIN, // BACK_BUFFER, FRONT_BUFFER
	G_BUFFER, // POSITION, NORMAL, COLOR
	END,
};

enum
{
	RENDER_TARGET_G_BUFFER_GROUP_MEMBER_COUNT = 3,
	RENDER_TARGET_GROUP_COUNT = static_cast<uint8>(RENDER_TARGET_GROUP_TYPE::END)
};

struct RenderTarget
{
	shared_ptr<Texture> target;
	float clearColor[4];
};

렌더 타겟 그룹 타입 이라는 이넘클래스에서 스왑체인과 지오메트리 버퍼라고 렌더 타겟들을 타입으로 관리하고 있습니다. 
렌더타겟이라는 말 자체가 텍스쳐라는 의미인데 이 클래스에서 텍스쳐를 건내줘서 픽셀 셰이더에서 이것저것 기입해주기를 바라는거죠 

지금까지 배웠던 내용들을 다시 정리해야합니다. 우리가 텍스쳐 클래스를 만들어서 오브젝트에 베이가 텍스쳐를 씌우기도 했었습니다. 
그런데 사실은 이 텍스쳐 클래스 외에도 텍스쳐라고 할 수 있는 클래스들이 있습니다. depthStencilBuffer 라는 클래스도 Tex2D 라는 걸 desc 로 만들어서 
사용하고 있습니다. 마찬가지로 SwapChain 쪽에서도 스왑체인 내부적으로 버퍼를 두개 만들어 줍니다. 이 만든 버퍼 자체도 텍스쳐로 충분히 표현할 수 있습니다.

그래서 오늘 할 중요한 작업은 코드들을 정리하면서 텍스쳐들을 Texture 단일 클래스로 몰아 줄겁니다. 
이렇게 Texture 로 모든 텍스쳐들을 모아서 관리해줄것이기 때문에 Texture 를 인클루드 하고 RENDER_TARGET_GROUP_TYPE 으로 관리해주고 있는겁니다.

RENDER_TARGET_GROUP_TYPE 의 내용물인 스왑체인은 백버퍼 프론트 버퍼들이고 , G_BUFFER 는 지오메트리 버퍼라고 최종 버퍼로 가기전에 기하학적인 정보를 여기서 사용할겁니다.

그 밑의 enum의 내용의 RENDER_TARGET_G_BUFFER_GROUP_MEMBER_COUNT 는 G_BUFFER 의 내용물인 POSITION,NORMAL,COLOR 의 갯수를 의미하고 
RENDER_TARGET_GROUP_COUNT 는 SWAP_CHAIN, G_BUFFER 의 갯수를 말합니다. 

그다음인 struct RenderTarget 을 보겠습니다. 우리가 실질적으로 그릴 대상 셰이더로 넘겨줘서 픽셸셰이더에서 그려줄 대상을 가지고 있고 
clearColor 라고 해서 매프레임 마다 초기 색상으로 밀어주던 색상이 있었습니다. 처음에는 하늘색에서 나중에 검은색으로 바꿧던 부분입니다.

이제 본체인 RenderTargetGroup 클래스의 본문으로 가서 
class RenderTargetGroup
{
public:
	void Create(RENDER_TARGET_GROUP_TYPE groupType, vector<RenderTarget>& rtVec, shared_ptr<Texture> dsTexture);

	void OMSetRenderTargets(uint32 count, uint32 offset);
	void OMSetRenderTargets();

	void ClearRenderTargetView(uint32 index);
	void ClearRenderTargetView();

	shared_ptr<Texture> GetRTTexture(uint32 index) { return _rtVec[index].target; }
	shared_ptr<Texture> GetDSTexture() { return _dsTexture; }

private:
	RENDER_TARGET_GROUP_TYPE		_groupType;
	vector<RenderTarget>			_rtVec;
	uint32					_rtCount;
	shared_ptr<Texture>			_dsTexture;
	ComPtr<ID3D12DescriptorHeap>	        _rtvHeap;

private:
	uint32					_rtvHeapSize;
	D3D12_CPU_DESCRIPTOR_HANDLE		_rtvHeapBegin;
	D3D12_CPU_DESCRIPTOR_HANDLE		_dsvHeapBegin;
};

이 클래스가 들고있들 멤버 변수들 부터 보겠습니다.
하나씩 살펴보면 _groupType 은 맨위에 만들었던 enum class RENDER_TARGET_GROUP_TYPE 을 받아주고 있습니다. 

_rtVec 는 렌더 타겟 벡터를 받아주고 있는데 이 벡터는 콘테이너 벡터를 말합니다. 
나중에 Create 함수를 보면 알수 있는데 렌더타겟그룹에 연결할 렌더타겟들을 벡터로 받고있습니다. 벡터로 받고있기때문에 여러개의 렌더타겟들을 여러개 받을 수 있는겁니다.
예를 들어서 G_BUFFER 를 연결할때는 포지션, 노멀, 컬러 세가지 렌더 타겟을 벡터에 담아서 Create 해주게 되는겁니다. 

Create 의 인자를 좀더 보면 깊이 텍스쳐 같은 경우에는 따로 받아주고 있습니다. 렌더링을 할때 깊이 텍스쳐를따로 받아왔어야 했는데 어디였냐면 
CommendQueue::RenderBegin 에서 마지막에 OMSetRenderTargets 의 인자로 backBufferView 와 depthStencilView를 주고 있습니다. 그래야지만 그래픽 파이프라인을 
그려질때 이 깊이 버퍼를 참조해서 물체가 그려질지 안그려질지를 판별 할 수 있었습니다. 
이 깊이텍스쳐를 렌더타겟그룹 안에서 만들어 주지 않고 외부에서 따로 받아주는 이유는 경우에 따라 똑같은 뎁스 스텐실 버퍼를 사용해야 할 수도 있기 때문입니다.
매번 마다 새로 교체해주게 되면 물건마다 덧붙여주는게 아니라 완전히 서로 따로따로 다른 세상을 그리는게 될 수 있기 때문입니다.


이제 구현부를 보겠습니다. 
RenderTargetGroup::Create 에서는 인자로 받은 그룹 타입, 렌더 타겟 벡터, 깊이 텍스쳐를 멤버 변수에 받아줍니다.
이렇게 여러 렌더 타겟들을 받기는 했지만 결국은 Descriptor Heap 을 만들어서 렌더 타겟들을 모두 기술 해준 다음 한번에 OMSetRenderTargets 을 할때 넘겨줘야 합니다.
그래서 멤버 변수들을 채워준 다음 렌더 타겟들이 뭉쳐있는 벡터를 묘사하는 heapDesc 를 만들어서 묘사하는 옵션들을 채워주고 이 옵션에 따라 멤버 변수 _rtvHeap에다가 
DEVICE->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&_rtvHeap)); 을 해줍니다. 그 후에는 for문을 돌면서 핸들과 사이즈를 가지고 _rtVec 의 내용들을 기술 해줍니다.
인자로 받은 렌더 타겟들도 각각 별도의 뷰가 있을 테지만 렌더타겟그룹에 연결하면서 각각의 렌더 타겟들을 하나의 _rtvHeap에 모아주고 있는겁니다.

Create 함수가 어렵고 나머지 함수들은 비교적 간단합니다. 

RenderTargetGroup::OMSetRenderTargets 라는 함수가 어떤 일을 하냐면 이전에 CommandQueue::RenderBegin 에서 ClearRenderTargetView, OMSetRenderTargets, 
ClearDepthStencilView 를 해주는 부분을 지금 RenderTargetGroup 클래스에서 대신해주게 될겁니다. 
렌더 타겟 그룹 객체를 여러개를 관리한 다음 호출할 텍스쳐에 따라 그 객체의 OMSetRenderTargets 함수를 호출해주게 됩니다.
이 OMSetRenderTargets 함수 같은경우는 두가지 버전이 있는데 만약에 렌더 타겟에서 넣어줘야 할 것들이 여러개 이다 라면 (G_BUFFER 처럼 포지션,노말,컬러 같은경우)

void RenderTargetGroup::OMSetRenderTargets()
{
	CMD_LIST->OMSetRenderTargets(_rtCount, &_rtvHeapBegin, TRUE/*다중*/, &_dsvHeapBegin);
}
이 버전을 사용하면 되는데 세번째 인자의 TRUE 의 의미가 넣어줄 렌더 타겟이 여러개라는 의미입니다.

그러면 한개 짜리의 버전은 어떻게 하냐면
void RenderTargetGroup::OMSetRenderTargets(uint32 count, uint32 offset)
{
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = CD3DX12_CPU_DESCRIPTOR_HANDLE(_rtvHeapBegin, offset * _rtvHeapSize);
	CMD_LIST->OMSetRenderTargets(count, &rtvHandle, FALSE/*1개*/, &_dsvHeapBegin);
}
이 버전인데 인자로 받은 렌더 타겟의 갯수, _rtvHeapBegin 이라는 핸들로 부터 몇번째의 위치에 있는 렌더 타겟인지를 OMSetRenderTargets 에게 알려주고 있습니다. 
이 방법이 CommandQueue 에서의 방법과 비슷하다고 합니다.
한개일때의 버전을 좀더 수월하게 이해하기 위해서는 이번 강의 전체를 듣고 나서 다시 보면 더 이해하기 쉽다고 합니다.

다음 함수는 ClearRenderTargetView 함수입니다. 이 함수도 두가지 버전이 있는데 마찬가지로 여러개의 렌더 타겟을 지우는지 하나만 지우는지 차이입니다.
이것도 CommandQueue에 있던 부분을 옮겨오는 겁니다.

그런데 이 RenderTargetGroup.cpp 가 지금은 통과 되지 않습니다. Create 함수안에 GetDSV, GetRTV 부분이 빨간줄이 그어져 있습니다. 
이 에러는 이어서 작업할 Texture 클래스에서 해결 해줄겁니다. 

3) Texture 

텍스쳐 클래스에서 어떤 변경점이 있을것이냐면 지금까지 텍스쳐 클래스는 이미지 파일을 로드해서 그 텍스쳐를 사용했는데 
이번에는 depthStencilBuffer 나 SwapChain 의 실질적인 백 프론트 버퍼들 같이 프로그램에서 코드로 작성한 버퍼를 텍스쳐로 사용할 수 있도록 바꿔줄겁니다.
이유는 디퍼드 셰이더에서 사용할 포지션 노말 컬러 같은 데이터를 받아주기 위한 새로운 텍스쳐(버퍼) 를 만들어 줘야하는데 그 버퍼를 텍스쳐 클래스에서 실시간으로 
만들어 주는게 편리하기 때문입니다.

앞으로 텍스쳐 클래스는 잡동사니처럼 이곳저곳에서 모은 버퍼들을 다 포함할 클래스가 되겠습니다.

코드로는 바뀌는 것이 무엇이냐면 지금까지의 텍스쳐는 _srvHeap 리소스 텍스쳐만 사용했었습니다. 리소스 텍스쳐는 외부의 이미지를 가져다가 쓰는것입니다.
이제부터는 여기에 _rtvHeap, _dsvHeap 도 들고 있을것입니다.

(약간 수정으로 기존의 _srvHandle 이라는 변수 이름을 _srvHeapBegin 으로 뜻을 알기 쉽게 바꾸고 멤버 함수중에도 GetCPUHandle 이라는 이름을 GetSRVHandle 으로 바꿔줬습니다.)

다음은 CreateTexture 와 CreateView 함수입니다. CreateTexture 는 경로를 인자로 받아서 해당경로에 있는 이미지 파일을 ComPtr<ID3D12Resource> _tex2D;
에 담는 함수이고 CreateView 함수는 _tex2D 를 묘사해주는 _srvHeap 를 만들어줍니다.
이 함수들이 바뀔 내용에서는 텍스쳐를 만드는 방법이 여러가지가 될것이기 때문에 이 함수를 그냥 사용할 수는 없습니다.

지금까지는 이 두 함수를 Load 함수에서 사용하고 있었습니다. Load 함수는 경로의 이미지 파일을 가져와서 텍스쳐로 사용하는 함수였기 때문에 따로 빼놨던 두 함수를 
다시 복사 붙여넣기를 해주겠습니다. 이제 Load 는 외부 파일을 불러오는 용도가 확실해 졌습니다.

나중에 잊지 않게 지금 _tex2D, _srvHeap, _rtvHeap, _dsvHeap 를 외부에서 가져올수 있는 Get 함수 4개를 파주었습니다.

이제 본격적으로 Texture 에서 만들어줄 Create 함수 두가지가 있습니다. 
public:
	void Create(DXGI_FORMAT format, uint32 width, uint32 height,
		const D3D12_HEAP_PROPERTIES& heapProperty, D3D12_HEAP_FLAGS heapFlags,
		D3D12_RESOURCE_FLAGS resFlags, Vec4 clearColor = Vec4());

	void CreateFromResource(ComPtr<ID3D12Resource> tex2D);
CreateFromResource 이라는 함수는 리소스가 이미있는 상태에서 텍스쳐로 만들어 주는 함수이고 Create 함수는 아예 처음부터 만들어 나가는 함수입니다.
실질적으로 텍스쳐를 만들어 줄 수 있는 경우가 세가지가 있다고 볼 수 있겠습니다.

CreateFromResource 처럼 리소스가 이미 있는 경우는 어떤 경우이냐면 스왑체인에서 CreateSwapChain 을 호출 할때 실질적으로 리소스 버퍼가 만들어 졌습니다. 
이걸 _swapChain->GetBuffer 로 가져와서 사용했었는데 이 작업을 Texture::CreateFromResource 로 대체해서 사용할것입니다.

Create 함수는 인자로 포멧, 화면 넓이, 높이, 힙 프로퍼티, 힘 플레그, 리소스 플레그, 클리어 컬러 까지 많은 인자를 받고 있는데 
이 함수내에서 처음부터 텍스쳐를 만들어줘야하기 때문에 데이터가 많이 필요한 것 입니다.
함수 구현부에서는 Tex2D 로 포멧, 넓이, 높이 등으로 만들어주는데 구현부의 많은 내용이 DepthStencilBuffer 안에 있던 내용들입니다.
Tex2D 의 플래그를 DepthStencilBuffer 에서는 직접 D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL 라고 설정을 해줬지만 
Texture 에서는 인자로 resFlags 를 받아서 이 타입의 플레그로 설정해주고 있습니다.

그리고 밑에서 if else 문으로 resFlags 의 타입을 체크 해주고 있습니다. 깊이 타입인지 렌더 타겟 타입인지를 체크해서 해당 용도로 사용할 수 있다는 내용입니다.
해당용도에 사용하는 optimizedClearValue 와 resourceStates 로 세팅해준 다음
HRESULT hr = DEVICE->CreateCommittedResource(
		&heapProperty,
		heapFlags,
		&desc,
		resourceStates,
		&optimizedClearValue,
		IID_PPV_ARGS(&_tex2D));
이렇게 _tex2D 를 생성해준다음 CreateFromResource(_tex2D); 만든 리소스로 호출해주고 있습니다.

공용 구현부를 CreateFromResource 에다가 구현해놨기 때문이 이 함수로 넘기고 있습니다. 

CreateFromResource 함수를 보겠습니다. 
이 함수는 인자로 ComPtr<ID3D12Resource> tex2D 를 받고 있습니다. 윗 함수인 Create에서 만든 _tex2D 나 아니면 이미 만들어진 _tex2D 를 받아서 
사용합니다. 
제일 먼저 해주는 일은 인자를 객체의 멤버 변수 _tex2D 에 넣는 일입니다. Create 에서 넘어왔으면 상관없겠지만 외부에서 받은 리소스라면 객체가 들고 있어야 하기 때문입니다.

그리고 여기서는 리소스의 타입에 따라 조합을 해서 사용하는데 세가지 경우가 있습니다. 
1- DSV 단독 (조합X)
2- SRV
3- RTV + SRV
입니다. 깊이 버퍼 단독으로 사용하는경우, 일반 이미지를 텍스쳐로 활용하는 경우, 렌더 타겟 뷰와 이미지를 같이 사용하는 경우가 있습니다.

인자로 받은 tex2D 에서 GetDesc 로 받은 변수를 desc 라는 이름으로 만들고 이 desc.Flags 를 if else 로 체크해서 각각 D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL 인지
아니라면 SRV 나 RTV 라는 뜻이 되고 또 그 안에서 D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET 인지도 체크해서 모든 조합에 따른 처리를 해주게 됩니다. 

DSV 일 경우 어떤 과정을 거치냐면 if 문 안에서 Descriptor Heap 을 heapDesc 라는 이름으로 만듭니다. 
이 heapDesc 의 타입, Descriptor 의 갯수, Flags, NodeMask 등을 설정한 후 
DEVICE->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&_dsvHeap));
멤버 변수 _dsvHeap 에 묘사한 형태의 Descriptor Heap 을 생성합니다. 그리고 이 _dsvHeap 의 시작 핸들을 가져와서 hDSVHandle 라는 이름의 CPU Descriptor Handle 타입 
변수에 담아줍니다. 
그 다음으로 인자로 받은 tex2D를 hDSVHandle 위치부터 view를 만들어 줍니다.
DEVICE->CreateDepthStencilView(_tex2D.Get(), nullptr, hDSVHandle);

이것과 같은 작업을 DepthStencilBuffer 클래스에서 해주고 있었습니다. 이제는 깊이 버퍼를 Texture 클래스에서 관리 해줄것이기 때문에 
DepthStencilBuffer 는 삭제 해주었습니다. 물론 삭제하면 이 클래스를 쓰고 있던 코드들에 에러가 나겠지만 나중에 한번에 처리해줄겁니다.

RTV 일 경우도 비슷하게 진행됩니다. RTV에 맞는 타입으로 heapDesc 로 묘사해주고 _rtvHeap 에 Descriptor Heap 을 만들고 tex2D 를 가지고 View 도 _rtvHeap 의 시작 
핸들부터 만들어 줍니다. 
이 부분은 SwapChain::CreateRTV 함수에서 해주고 있던 부분입니다. DepthStencilBuffer 와 마찬가지로 이 시간 이후로는 사용하지 않을것이기 때문에 지워 줘도 되는데 
SwapChain 전체를 지우는것이 아니라 리소스를 들고있던 멤버 변수들
	ComPtr<ID3D12Resource>			_rtvBuffer[SWAP_CHAIN_BUFFER_COUNT];
	ComPtr<ID3D12DescriptorHeap>	_rtvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE		_rtvHandle[SWAP_CHAIN_BUFFER_COUNT];
이 부분은 이제 Texture 에서 관리해줄 것이기 때문에 삭제 해주고 SwapChain::CreateRTV 함수도 삭제 해주고  각 변수를 Get 하는 함수들도 삭제해주었습니다. 
CPP 파일에서는 CreateRTV 구현부 삭제, 그리고 CreateSwapChain 의 마지막 부분에 _rtvBuffer 를 가지고 _swapChain->GetBuffer 하는 부분이 있는데 여기도 삭제 해줍니다. 
나중에 이부분은 다른 곳에서 다시 구현해줄겁니다.
지금껏 삭제했던것과 반대로 새로운 함수 하나를 추가 해주어야 합니다. 
	uint8 GetBackBufferIndex() { return _backBufferIndex; }
SwapChain 의 멤버 변수인 _backBufferIndex 를 외부에서 가져올수 있는 함수입니다. 지금까지는 SwapChain 안에서 진행되다보니까 _backBufferIndex 을 외부로 굳이 빼줄 
이유가 없었습니다.

돌아와서 이번엔 SRV 일 경우 입니다. SRV는 지금껏 사용하던 텍스쳐 그 용도 라고 보면 됩니다. 위에 경우와 같이 srvHeapDesc 를 생성하고 용도를 정한다음 
CreateDescriptorHeap 을 _srvHeap 에 해주고 그 시작 핸들을 하나 만들어 주었습니다. 
DSV, RTV 와 다른점은 View를 만들어주는 메소드의 두번째 인자가 nullptr 이 아니고 D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc를 만들어서 넣어주어야 합니다.
각각 필요한 내용들을 설정해주고 
DEVICE->CreateShaderResourceView(_tex2D.Get(), &srvDesc, _srvHeapBegin);
해줍니다. 

결국 지금 수정한 내용들을 보게되면 _srvHeap, _dsvHeap, _rtvHeap 세가지로 활용되는 Descriptor Heap 들이 있지만 전부 동시에 활용되는게 아닙니다.
경우에 따라서 DSV 만 사용될 수 있고 SRV 만 사용될수도 있고 SRB RTV 가 같이 사용될수도 있습니다.


4) 에러잡기

이 시점에서 한번 프로젝트를 빌드 해주고 에러를 잡아주겠습니다. 
빌드를 시작하면 맨 먼저 Engine 클래스 부터 멱살을 잡습니다. include 되어있던 DepthStencilBuffer 를 삭제해주고 Engine.cpp에서도 DepthStencilBuffer init 해주던 
코드를 삭제해주었습니다. 멤버 변수로 _depthStencilBuffer 라고 들고 있던 것과 이걸 꺼내는 Get 함수도 지워주었습니다. 

여기서 바로 다시 빌드해서 에러를 잡아 줄 수 도 있지만 이번 시간에 만들었던 RenderTargetGroup 클래스를 Engine에 추가해주고 가는것도 괜찮을것 같습니다.
include, 멤버 변수(array 로 만들어줌), index 를 받는 Get 함수를 엔진 헤더쪽에 만들어 줬고 
어쨋거나 이 렌더 타겟 그룹도 초기화를 해줘야 할것이기 때문에 CreateRenderTargetGroups 라는 함수를 새로 만들어 줬습니다.

이제 Engine.cpp 로가서 잊기전에 Engine::Init 안에 CreateRenderTargetGroups 도 추가해주고 구현부를 만들어 주겠습니다.
우리가 DepthStencilBuffer 를 날려버렸기 때문에 Engine 에서도 깊이버퍼를 가지고 있지 않습니다. 지금 이 CreateRenderTargetGroups 에서 만들어 줘야 합니다. 
void Engine::CreateRenderTargetGroups()
{
	// DepthStencil
	shared_ptr<Texture> dsTexture = GET_SINGLE(Resources)->CreateTexture(L"DepthStencil",
		DXGI_FORMAT_D32_FLOAT, _window.width, _window.height,
		CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
		D3D12_HEAP_FLAG_NONE, D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL);
}
그런데 아직 만들지 않은 코드들이 엮여 있기때문에 에러가 여기저기서 납니다. 위의 코드에서는 Resources 의 CreateTexture 라는 함수가 없어서 에러가 납니다.
Resources 에서 만들어준 이유는 매번 make_shared 를 해주기 보다는 리소스 매니저를 통해가지고 key로 관리하는게 더 편하기 때문입니다. 메쉬들을 만들어 주는 것과 같은
원리입니다.
만들어줄 함수는 Resources::CreateTexture , CreateTextureFromResource 인데 사실 이 함수들은 Texture 에서 만들어줬던 함수들에서 Key 만 인자로 하나 더받아서 랩핑 
해주는 함수들 입니다.

shared_ptr<Texture> Resources::CreateTexture(const wstring& name, DXGI_FORMAT format, uint32 width, uint32 height,
	const D3D12_HEAP_PROPERTIES& heapProperty, D3D12_HEAP_FLAGS heapFlags,
	D3D12_RESOURCE_FLAGS resFlags, Vec4 clearColor)
{
	shared_ptr<Texture> texture = make_shared<Texture>();
	texture->Create(format, width, height, heapProperty, heapFlags, resFlags, clearColor);
	Add(name, texture);

	return texture;
}

shared_ptr<Texture> Resources::CreateTextureFromResource(const wstring& name, ComPtr<ID3D12Resource> tex2D)
{
	shared_ptr<Texture> texture = make_shared<Texture>();
	texture->CreateFromResource(tex2D);
	Add(name, texture);

	return texture;
}

구현부인데 내용은 그냥 이 함수내에 텍스쳐를 만들어서 첫번째 인자인 key 를 가지고 Add 해주는 함수입니다.

이제 Engine.cpp 로 돌아가면 에러들이 통과 되어있습니다.
CreateRenderTargetGroups 을 이어서 해석 해보겠습니다. 

DSV 는 만들어 줬고 다음은 SwapChain 에서 사용할 SwapChain그룹입니다.
	// SwapChain Group
	{
		vector<RenderTarget> rtVec(SWAP_CHAIN_BUFFER_COUNT);

		for (uint32 i = 0; i < SWAP_CHAIN_BUFFER_COUNT; ++i)
		{
			wstring name = L"SwapChainTarget_" + std::to_wstring(i);

			ComPtr<ID3D12Resource> resource;
			_swapChain->GetSwapChain()->GetBuffer(i, IID_PPV_ARGS(&resource));
			rtVec[i].target = GET_SINGLE(Resources)->CreateTextureFromResource(name, resource);
		}

		_rtGroups[static_cast<uint8>(RENDER_TARGET_GROUP_TYPE::SWAP_CHAIN)] = make_shared<RenderTargetGroup>();
		_rtGroups[static_cast<uint8>(RENDER_TARGET_GROUP_TYPE::SWAP_CHAIN)]->Create(RENDER_TARGET_GROUP_TYPE::SWAP_CHAIN, rtVec, dsTexture);
	}
맨 먼저 RenderTarget 이라는 타입으로 벡터를 만드는데 크기는 SWAP_CHAIN_BUFFER_COUNT 만큼으로 만들고 있습니다. 
이때 RenderTarget이라는 구조체는 Texture와 clearColor를 들고 있는 구조체입니다.

그리고 스왑체인 그룹을 만들어 주기 위해서는 스왑체인의 버퍼를 꺼내 와야 합니다. 그러기 위해서 for문을 돌면서 
_swapChain->GetSwapChain()->GetBuffer(i, IID_PPV_ARGS(&resource)); 로 스왑체인의 버퍼들을 하나씩 외부로 꺼내오고 있습니다. 
이 버퍼들을 위에서 만든 벡터에 담아주고 있습니다.

이렇게 꺼낸 스왑체인 버퍼들을 렌더타겟그룹에 담아주고 있습니다. 이때 reVec 과 dsTexture 를 같이 넘겨주고 있습니다.

이어서 Deferred 그룹도 만들어 줍니다.
	// Deferred Group
	{
		vector<RenderTarget> rtVec(RENDER_TARGET_G_BUFFER_GROUP_MEMBER_COUNT);

		rtVec[0].target = GET_SINGLE(Resources)->CreateTexture(L"PositionTarget",
			DXGI_FORMAT_R32G32B32A32_FLOAT, _window.width, _window.height,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
			D3D12_HEAP_FLAG_NONE, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);

		rtVec[1].target = GET_SINGLE(Resources)->CreateTexture(L"NormalTarget",
			DXGI_FORMAT_R32G32B32A32_FLOAT, _window.width, _window.height,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
			D3D12_HEAP_FLAG_NONE, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);

		rtVec[2].target = GET_SINGLE(Resources)->CreateTexture(L"DiffuseTarget",
			DXGI_FORMAT_R8G8B8A8_UNORM, _window.width, _window.height,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
			D3D12_HEAP_FLAG_NONE, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);

		_rtGroups[static_cast<uint8>(RENDER_TARGET_GROUP_TYPE::G_BUFFER)] = make_shared<RenderTargetGroup>();
		_rtGroups[static_cast<uint8>(RENDER_TARGET_GROUP_TYPE::G_BUFFER)]->Create(RENDER_TARGET_GROUP_TYPE::G_BUFFER, rtVec, dsTexture);
	}
스왑 체인 그룹처럼 rtVec을 만들어주는데 크기는 RENDER_TARGET_G_BUFFER_GROUP_MEMBER_COUNT 로 만듭니다.
그리고 각 인덱스를 CreateTexture 로 채워주는데 각각의 이름과 포멧이 조금씩 다릅니다.

여기까지 하고 원래 우리가 하던 작업인 에러잡기를 계속하겠습니다.
다음으로 걸리는 지점은 CommandQueue 입니다. RenderBegin에서 걸리는데 _swapChain->GetBackBUffer 로 후면 버퍼를 가져오고 있는데 이제는 
후면버퍼를 스왑체인에서 관리하는게 아니라 렌더타겟그룹에서 관리해주고 있습니다.
GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::SWAP_CHAIN)->GetRTTexture(backIndex)->GetTex2D().Get() 이런 코드로 후면버퍼를 가져올 수 있습니다.
다음 에러는 RenderTargetGroup 에서 대신해줄 ClearRenderTargetView, OMSetRenderTargets, ClearDepthStencilView 입니다. CommandQueue 의 이 기능들은 전부 날려줍니다.

CommandQueue::RenderEnd 에서도 에러가 걸리는데 후면버퍼를 가져오는 부분입니다. 아까와 똑같이 처리해줍니다.

다시 빌드하면 이번에는 Shader 에서 걸립니다. _pipelineDesc.DSVFormat 이 DepthStencilBuffer 에서 가져와 설정해주고 있었는데 DepthStencilBuffer 를 삭제 해서 
생기는 오류입니다. 사실 다른 객체의 포멧값을 가져오지 않아도 깊이 버퍼는 DXGI_FORMAT_D32_FLOAT 형식을 쓸것이기 때문에 고정으로 설정 해줍니다. 
이러면 이제 빌드는 통과가 됩니다.


5) Shader 

이왕 셰이더 클래스로 온김에 고쳐 줄것이 있습니다.

디퍼드 셰이더를 이번시간 첫부분에서 새로 알게 되었는데 포워드 방식에 비해 장점들이 많다고 했었습니다. 
그러면 모든 오브젝트들이 디퍼드 셰이더를 사용할것이냐면 그건 아닙니다. 디퍼드 셰이더는 중간에 연산할 데이터가 많은 오브젝트일 수록 효율이 좋아지는데 
UI 같은 오브젝트는 굳이 빛연산 같은게 필요없습니다. 그래서 일부 오브젝트들은 여전히 포워드 셰이더를 쓰게 될 텐데 

Shader 클래스에서 두가지 셰이더를 사용하게 된다면 각각 오브젝트들이 어떤 셰이더를 따를지를 판별할 줄 알아야 할것입니다. 

그러면 어떻게 구별 할 것이냐? 
셰이더를 만들어줄때 그 셰이더가 어떤 용도로 사용될지를 알려줄겁니다.

지금까지 셰이더를 Init 할때 경로와 ShaderInfo 라는 인자를 가지고 초기화 해줬습니다. 
여기서 ShaderInfo 는 CULL 옵션과 DEPTH_STENCIL을 어떤 타입으로 할것인지를 들고 있는 구조체였습니다.
여기에 추가로 Shader 타입이 추가 될겁니다.
enum class SHADER_TYPE : uint8
{
	DEFERRED,
	FORWARD,
};
ShaderInfo 에도 추가해주겠습니다.
struct ShaderInfo
{
	SHADER_TYPE shaderType = SHADER_TYPE::FORWARD;
	RASTERIZER_TYPE rasterizerType = RASTERIZER_TYPE::CULL_BACK;
	DEPTH_STENCIL_TYPE depthStencilType = DEPTH_STENCIL_TYPE::LESS;
	D3D12_PRIMITIVE_TOPOLOGY_TYPE topologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
};
그런데 네번째 멤버는 갑자기 추가 됐습니다. 토폴로지 타입이라고 물체를 그려줄때 작은 평면들로 묘사해주는데 그 평면을 지금은 기본으로 삼각형으로 그려주겠다는 옵션입니다.
ShaderInfo 가 갑자기 이렇게 바뀌면 다시 에러가 이곳 저곳에서 뜰것이지만 나중에 한번에 고쳐 주겠습니다.

셰이더 정보를 수정해준다음 나중에 그 물체의 셰이더가 어떤 타입을 따를것인지 알기 위해서는 셰이더 클래스에서 ShaderInfo를 직접 들고 있어야 합니다.
private:
	ShaderInfo							_info;
그리고 혹시 외부에서 이 물체의 셰이더 타입을 알고 싶을때 꺼내쓸수 있게 Get 함수도 만들어 주겠습니다.

이제 Shader.cpp 로 가서 Shader::Init의 첫부분에서 자신의 ShaderInfo를 저장해줍니다.
Shader::Init
	_info = info;

_pipelineDesc 옵션 부분에서 아까 셰이더 정보에 추가해준 토폴로지 옵션을 고정에서 바꿔줍니다.
	_pipelineDesc.PrimitiveTopologyType = info.topologyType;

셰이더 정보중에 컬링 옵션을 Switch case 문법으로 처리해주고 있는데 그 위에 역시 셰이더 타입도 swhich case 로 처리해줍니다.
	switch (info.shaderType)
	{
	case SHADER_TYPE::DEFERRED:
		_pipelineDesc.NumRenderTargets = RENDER_TARGET_G_BUFFER_GROUP_MEMBER_COUNT;
		_pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R32G32B32A32_FLOAT; // POSITION
		_pipelineDesc.RTVFormats[1] = DXGI_FORMAT_R32G32B32A32_FLOAT; // NORMAL
		_pipelineDesc.RTVFormats[2] = DXGI_FORMAT_R8G8B8A8_UNORM; // COLOR
		break;
	case SHADER_TYPE::FORWARD:
		_pipelineDesc.NumRenderTargets = 1;
		_pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		break;
	}
_pipelineDesc.NumRenderTargets 는 셰이더에서 몇개의 렌더 타겟을 넘겨줄 것이냐 이고 포워드는 연산을 한번에 하고 color를 결과물로 넘겨 줬었습니다. 
디퍼드 방식에서는 연산을 중간 버퍼인 G_BUFFER 에서 해주게끔 연산에 필요한 데이터들도 같이 넘겨주고 있습니다. 그리고 넘겨주는 순서도 
셰이더 파일에서와 같은 순서로 맞춰줬습니다.
설정해주는 포멧들인 DXGI_FORMAT_R32G32B32A32_FLOAT, DXGI_FORMAT_R8G8B8A8_UNORM 가 무슨 의미인지는 R,G,B,A 각각 뒤의 숫자는 몇비트를 가지고 있을지
그리고 뒤에 FLOAT 나 UNORM 은 각각 float 타입, unsigned-normalized-integer 타입이라는 의미라고 합니다.

이게 중요한데 셰이더 파일에서 어떤 데이터를 사용할지를 정해도 CPP 의 Shader 클래스의 파이프라인과 정책을 똑같이 맞춰주지 않으면 작동을 안합니다.

Shader 클래스는 여기까지 하고 

다시 빌드를 해보겠습니다. 


6) 다시 에러 수정

셰이더 클래스에서 ShaderInfo 를 수정한 탓에 이전 구조를 그냥 쓰고 있던 코드가 에러를 뱉을 것입니다.

에러가 나고 있는 위치는 Resources::CreateDefaultShader 입니다.
// Sky box
		ShaderInfo info =
		{
			SHADER_TYPE::FORWARD,
			RASTERIZER_TYPE::CULL_NONE,
			DEPTH_STENCIL_TYPE::LESS_EQUAL
		};
이렇게 수정해주니 에러가 사라졌습니다. ShaderInfo 의 멤버들 순서가 SHADER_TYPE 이 맨 먼저 였기 떄문에 기본값을 지정 해줬어도 한번 언급은 해줘야 
하는것 같습니다.
스카이 박스도 기본은 포워드 처럼 사용되고 컬링 모드와 깊이 타입만 안쪽에서 하늘 텍스쳐를 볼 수 있도록 변경해주었습니다.

기존의 포워드 셰이더도 
SHADER_TYPE::FORWARD 
로 설정해주었습니다.

이번에 새로 디퍼드 셰이도 도 디폴트 셰이더에서 로드되게끔 추가 해주었습니다.
	// Deferred (Deferred)
	{
		ShaderInfo info =
		{
			SHADER_TYPE::DEFERRED
		};

		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->Init(L"..\\Resources\\Shader\\deferred.fx", info);
		Add<Shader>(L"Deferred", shader);
	}

여기 까지 하고 다시 빌드를 해서 에러가 없는지 체크 해보니 잘 통과 됐습니다.


7) SceneManager

다음으로 SceneManager 를 볼텐데 지금까지 여기서 했던 작업은 빛 오브젝트와 큐브 메쉬를 하나 띄워줬고 스카이 박스도 만들었고 원근투영 레이어 카메라와 직교투영 레이어 카메라도 
만들었고 직교투영용 레이어 UI 오브젝트도 만들었었습니다.

여기서 바꿔줄 내용을 찾아보니 지금껏 셰이더를 고치고 있었으니까 오브젝트들이 그려줄 셰이더 타입을 고쳐 주겠습니다. 
카메라들은 상관없고, 스카이 박스 같은경우는 Skybox 전용 셰이더를 사용하니까 그대로 이고 
큐브의 셰이더가 Forward 인데 이걸 Deferred 로 바꿔주겠습니다.
그 다음에 UI 오브젝트를 지금은 하나만 사용하고 있었는데 우리가 지금 텍스쳐를 3개를 사용하고 있습니다. 그러니까 G_BUFFER 용도로 사용하고 있는 것들
Position, Normal, Color 세가지를 UI 오브젝트의 사각형 메쉬에 넘겨줄것입니다.
지금까지는 이 UI 텍스쳐를 이미지를 로드해서 출력 했었는데 이런것 말고 우리가 최종 렌더 타겟을 가기전에 잠시 저장 해뒀던 텍스쳐들을 그대로 출력 해보려고 하는겁니다.
for(int32 i = 0; i < 3; i++)
{
	//UI 오브젝트 내용들
	sphere->GetTransform()->SetLocalPosition(Vec3(-350.f + (i * 160), 250.f, 500.f));
	// 생략
	shared_ptr<Texture> texture = GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->GetRTTexture(i);
	// 생략
}
이런코드를 수정해주면 됩니다.로컬 포지션을 수정하는 부분은 지금 부터 만들 3개의 UI 가 한곳에 곂쳐있지 않게 해주는 방법이고 
텍스쳐를 외부 이미지 경로를 줘서 로드하지 않고 렌더링 파이프라인 내부에 있던 렌더타겟그룹의 텍스쳐들을 하나씩 꺼내 붙이고 있습니다.


8) Scene
수정할점 또 한가지는 우리가 RenderTargetGroup::OMSetRenderTargets 에서 렌더타겟들을 OM 해주고 있는데 이부분은 CommandQueue 에서 해주던 작업이었습니다. 
그런데 기능을 옮겨오기는 했지만 실행되는 코드에는 다른 수정을 하지 않았습니다. 
프로그램이 제대로 작동하기위해 수정을 해야하는데 어디서 커맨드큐의 OMSetRenderTargets 를 호출해주고 있었는지 알기 위해
Engine::Render 를 보니 RenderBegin 과 RenderEnd 사이에서 SceneManager->Render  가 호출됩니다. 
해당 코드로 따라 가보면 SceneManager 에서는 다시 _activeScene->Render() 를 호출하고 있습니다. 
결국 우리가 화면에 그려주는 것들을 핵심적으로 다루고 있는것이 Scene의 Render 라고 볼 수 있는거죠
다시 따라가면 
void Scene::Render()
{
	PushLightData();

	for (auto& gameObject : _gameObjects)
	{
		if (gameObject->GetCamera() == nullptr)
			continue;

		gameObject->GetCamera()->Render();
	}
}
여기서 무엇인가를 추가해주면 될것인데
	// SwapChain Group 초기화
	int8 backIndex = GEngine->GetSwapChain()->GetBackBufferIndex();
	GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::SWAP_CHAIN)->ClearRenderTargetView(backIndex);

	// Deferred Group 초기화
	GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->ClearRenderTargetView();

PushLightData 와 for문 사이에 이 코드가 삽입될것입니다. 스왑체인을 해주기 위해 후면버퍼의 인덱스를 받아오고 렌더링 시작하기전에 다음 프레임을 위해 
이전 데이터를 전부 초기화 해주고 있습니다.

초기화 이후에는 이제 물체를 렌더링 해주는 부분 for문 안을 수정해야하는데 
이전시간과 달리 지금부터 고려해야 할 부분은 Scene 이 게임오브젝트들을 많이 들고 있긴 할건데 일부는 Forward 셰이더로 그려야 하고 
일부는 Deferred 셰이더로 그려야합니다.
이걸 구별하기위해서 다시 for 문을 돌면서 포워드 디퍼드를 구별할 수도 있지만 여기서는 먼저 게임오브젝트들이 어떤 셰이더로 그려질지 정렬을 한번 한다음에
두 정책들을 분리를 시킨다음 정렬된 정보를 이용해서 좀더 깔끔하게 그려지도록 해보려고 합니다.

gameObject->GetCamera()->Render() 이 부분을 


		gameObject->GetCamera()->SortGameObject();

		// Deferred OMSet
		GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->OMSetRenderTargets();
		gameObject->GetCamera()->Render_Deferred();

		// Light OMSet

		// Swapchain OMSet
		GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::SWAP_CHAIN)->OMSetRenderTargets(1, backIndex);
		gameObject->GetCamera()->Render_Forward();

이렇게 교체해주겠습니다. 
먼저 sorting 정렬을 먼저 하고 G_BUFFER의 버퍼들을 OMSet 하고 그 후에 디퍼드 정책인 게임 오브젝트들을 렌더링,
다음 SWAP_CHAIN 의 후면버퍼를 OMSet 한다음 나머지 포워드 게임 오브젝트 들도 렌더링해주고 있습니다.

여기서 G_BUFFER 와 디퍼드가 한쌍이고 스왑체인과 포워드가 한쌍인것 처럼 코드가 붙어있는데 그런 의미가 아니라 
픽셀셰이더 까지 통과한 데이터들을 최종 스왑체인의 후면버퍼에 그려지기전에 G_BUFFER 에 담아서 한번그려주고 난 다음 후면버퍼에 세팅되고 난 다음 
포워드 셰이더 를 사용하는 물체들도 한번에 같이 렌더링 되게 됩니다.

이부분의 G_BUFFER 를 세팅할때 왜 이번시간에 RenderTargetGroup 을 만들었는지 이유를 알수 있는데 G_BUFFER 에서 position, normal, color 세가지 버퍼를 
한번에 넘겨주고 관리도 묶어서 하기위해 만들었던 클래스임을 알수 있습니다.

위 코드를 보면 알겠지만 정렬이랑 분류해서 렌더링 하는 구현부는 Scene 이 아니라 Camera에서 해주고 있습니다.


9) Camera

Scene::Render 에서 사용되었던 SortGameObject, Render_Deferred, Render_Forward 를 만들어 줍니다.

지금까지 카메라 클래스에서 Render 는 하나로 통일 되어있었는데 이 함수가 날라가고 두 셰이더 버전으로 만들어 줄겁니다.
void Camera::Render() 는 삭제하고 

	void SortGameObject();
	void Render_Deferred();
	void Render_Forward();

세가지 함수를 추가 해줍니다.

그리고 정렬과 분류를 위해 카메라가 렌더할 물체들을 임시저장하고 있는 임시 변수들을 벡터로 들고 있겠습니다.
private:
	vector<shared_ptr<GameObject>>	_vecDeferred;
	vector<shared_ptr<GameObject>>	_vecForward;

이제 새로만든 함수들의 구현부를 보겠습니다.	  
먼저 Render_Deferred 와 Render_Forward 는 별 내용이 없습니다. Sort 함수에서 정렬해 담아놓은 게임 오브젝트 들을 각각 렌더 해주는 것뿐입니다.
void Camera::Render_Deferred()
{
	S_MatView = _matView;
	S_MatProjection = _matProjection;

	for (auto& gameObject : _vecDeferred)
	{
		gameObject->GetMeshRenderer()->Render();
	}
}

void Camera::Render_Forward()
{
	S_MatView = _matView;
	S_MatProjection = _matProjection;

	for (auto& gameObject : _vecForward)
	{
		gameObject->GetMeshRenderer()->Render();
	}
}

그러면 다음은 SortGameObject 인데 차례대로 해석해보면 
먼저 Scene 타입의 shared_ptr<Scene> scene  변수를 하나 만들었습니다. 내용은 SceneManager 를 싱글톤으로 불러와서 GetActiveScene() 으로 활성화된 씬을 담아줍니다. 
그리고 const vector<shared_ptr<GameObject>>& gameObjects = scene->GetGameObjects() 로 활성화된 씬의 게임오브젝트들을 벡터에 받아주었습니다.

이제 이 벡터 안의 게임오브젝트들을 정렬해주면 되는데 그 전에 
	_vecForward.clear();
	_vecDeferred.clear();
로 이전 프레임의 데이터를 정리해줍니다.

for 문을 돌면서 gameObjects 를 체크해주는데 
첫번째 if 에서는 MeshRenderer 컴포넌트를 가지고 있는가? 메쉬렌더러가 없다면 카메라에서 그려줄 게임 오브젝트가 아니기 때문에 
없다면 continue

두번째 if 문은 카메라의 멤버 함수 IsCulled 를 gameObject의 레이어 인덱스가 통과되는지를 체크합니다. 카메라 마다 촬영할 레이어를 가지고 있게끔 이전시간 중에 
수정 했었습니다. 그 부분을 체크 해주고 있는것이고 레이어가 맞지 않다면 여기서 다시 continue

세번쨰 if 문에서는 또다른 컬링인 Frustum Culling 체크 입니다. 프러스텀 컬링은 게임의 성능에 매우 큰 역할을 하는데 게임 세상의 모든 오브젝트들을 매 프래임 그려주는건 
너무나 큰 성능 손실이기 때문에 카메라의 촬영범위인 Frustum 안에 게임 오브젝트가 들어있는지 를 체크해서 그 안에 들어온 게임 오브젝트만 그려줄것입니다. 
이 세번째 체크안에서 다시 체크를 해줄건데 Frustum 의 경계에 너무 정확하게 체크해주기 보다는 약간의 여유를 두고 렌더링 해주는게 카메라 회전할때 부드럽게 그려질수 
있게 해주는데 그 방법에 frustum.ContainsSphere 함수입니다. 물체의 경계로부터 일정 반지름을 가진 원까지는 통과시켜주는 기능입니다. 
여기서도 걸리게 되면 continue

이제 본격적으로 _vecDeferred, _vecForward 로 분류를 해줄건데 
필요한것은 지금 for 문을 돌고 있는 게임오브젝트가 사용하는 셰이더 타입입니다. 
		SHADER_TYPE shaderType = gameObject->GetMeshRenderer()->GetMaterial()->GetShader()->GetShaderType();
이렇게 shaderType 을 가져와서 switch case 문으로 분류해 해당하는 벡터에 push_back 해줍니다.


여기까지 하고 한번 빌드를 해보니까 통과가 되고 
실행해보면 새까만 큐브와 상단에 G_BUFFER 의 텍스쳐들이 각각 표시가 됩니다.


10) 마무리 

이번 시간에 배운내용은 렌더 타겟이라는 개념은 지금까지는 게임 화면 그리는것만 생각하고 있었으니까 
렌더 타겟 = 화면 이라는 착각을 하고 있었는데 사실은 렌더타겟은 계산된 텍스쳐이고 이걸 리소스의 메쉬들에 붙혀서 출력할 수 있다는 걸 알수 있습니다.