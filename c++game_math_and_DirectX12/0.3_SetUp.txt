    C++/언리얼 엔진 Part.2 환경설정입니다. 
    새 프로젝트 생성을 윈도우 어플리케이션 템플릿으로 생성했습니다. 
    여러 처음보는 용어들이 많은데 윈도우API에 대한 것들이라고 합니다. 처음 배울때는 그냥 그런게 있구나 하면서 넘어가고
    이후 다시 복습할때 조금씩 찾아보면서 배우라고 하셨습니다. 

	요약 ) 
	1) 새 프로젝트를 윈도우즈 데스크톱 어플리케이션 템플릿으로 생성
	2) 메세지를 받는 부분을 게임에 맞는 스타일로 교정 (while의 조건인 GetMessage를 true로 반복안에서 PeekMessage로 메세지를 체크)
	3) PeekMessage 조건문 안에서 msg.message == WM_QUIT라면 브레이크하고 아니라면 기존의 메세지 처리코드를 실행
	4) 프리 컴파일드 헤더 설정
	5) Game 클래스 템플릿 생성 (Client 파일 내에서 게임을 구현하기에 너무 복잡해서 외부로 뺐습니다.)
	6) Game 객체를 Client파일에 unique_ptr로 동적할당.
	7) Engine이라는 정적 라이브러리 새 프로젝트를 생성 (이 프로젝트 뿐아니라 공용으로 쓸만한 라이브러리, include, typedef등을 모아놓기 위해)
	8)  폴더 구조를 설계 ( Client:게임 클라이언트 자체, Engine:클라이언트에 쓰일 Engine 코드, Output: 출력물, Resources: 나머지 리소스 파일들)
	9) 이제 Client 프로젝트와 Engine 프로젝트를 연결해줍니다.
	  9 - 1) Client 프로젝트의 속성 -> 구성 속성 -> C++ 디렉터리 ( 포함 디렉터리 = 헤더파일의 경로, 라이브러리 디렉터리 = .lib 파일의 경로(Output파일))
	  9 - 2) Client와 Engine을 링크해주기 속성->링커->추가종속성에 Engine.lib추가 혹은 Client프로젝트의 pch.h 폴더 내에 
		#pragma comment(lib, "Engine.lib") 으로 컴파일러에게 시키기



    조금 밑으로 가면 wWinMain함수가 있습니다. 이게 이전 C++콘솔 프로젝트의 main함수역할인것 같습니다.
    
    기본 메세지 루프입니다 라는 주석이 있는데 
    while문으로 계속 루프시켜주고 있습니다. 게임이건 다른 윈도우즈 프로그램이건 상관없이 whlie루프로 프로그램을 유지하고 있습니다.

    while이 조건으로 GetMessage함수를 받고있는데 이 함수는 실제적으로 메세지를 준다거나(마우스 클릭이나 키보드 입력같은걸 말합니다.)하는 
    입력을 메세지 라는 것으로 받아주고 있습니다.
    이 함수의 단점으로 프로그램에 메세지를 주지 않으면 대기상태로 있게됩니다. 다른 프로그램이면 모르겠지만 
    게임에서는 키보드나 마우스 입력이 없더라도 게임을 계속 돌아가야합니다. 
    그래서 있던 GetMessage함수대신 그냥 true로 무한루프를 돌게 해주겠습니다.
    그 다음 GetMessage함수 대신 루프문 안에서 if로 PeekMessage함수를 체크해줍니다.
    이 피크 메세지 함수의 인자로 들어오는게 복잡한데요, 이런걸 하나하나 문서를 찾아보는것은 어려운 일입니다. 나중에 두세번째 다시 공부 할때 
    그때 관심이 생기면 하나씩 찾아보기로 하고 간략하게 어떤 인자가 오는지만 집고 가겠습니다.
    첫째로 받을 메세지를 넣고, 두번쨰 로 핸들이라는 것이 오는데 어떤 윈도우즈 핸들?을 사용하는지 지정할수 있다고 합니다. 지금은 nullptr을 
    넣게 되면 현재 쓰레드와 관계된 모든 메세지룰 받게됩니다. 그냥 그렇게 알고 있으면 되고, 세번째 네번째로 필터 min, max가 오게됩니다. 
    이 필터로 어떤 특정 메세지만 필터링 해서 받아주겠다. 를 할 수 있지만 그냥 0, 0으로 넣어주어 모든 메세지를 필터없이 받아주겠습니다.
    마지막으로 PM_REMOVE를 인자로 넣어주겠습니다. 이 PM_REMOVE를 조금 살펴보자면 우리가 프로그램에서 키보드입력이나 마우스 입력을 메세지로 
    받는다고 했습니다. 메세지라 큐에 쌓이고 지금 메세지 루프에서 메세지를 하나씩 처리하고 있는것인데 이 처리를 꺼낸 메세지를 어떻게 처리하느냐
    에 대한 인자라고 볼수 있습니다. PM_REMOVE는 꺼낸 메세지를 사용하고 나서 지우겠다는 의미입니다.

    이 메인 루프에 대해 상세하게 알아볼 필요가 별로 없다고 합니다. 메인 루프는 한번만 만들고 나서 신경쓰지 않을것이기 때문이라고 합니다.

    PeekMessage if문 안에서 다시 if로 msg.message == WM_QUIT라면 break;로 루프를 빠져나가도록 해주었습니다. 이 코드는 보통 프로그램을 종료할때 
    자주 사용되는 코드라고 알고 있으면 되겠습니다.

    메세지를 처리하던 코드를 PeekMessage 조건문 안으로 옮겨주었습니다. PeekMessage가 true 라고 하는것은 어떤 메세지가 있었다는 이야기이기 때문입니다.

    PeekMessage 조건문 밖 while반복문 안에 이제 우리의 게임 로직들을 작성해줄것입니다.


    여기서 한가지를 더 해보고 싶은데 프리컴파일드헤더(Precomfiled Header) 라는 것입니다.
    프리 컴파일드 헤더는 자주 쓰일것으로 예상되는 라이브러리들을 한곳에 모아두어서 미리 컴파일해두는 헤더 파일입니다. 
    편의성 외에도 프리 컴파일드 헤더라는 이름에서 알수 있듯이 이 헤더에 모여있는 라이브러리들은 미리 컴파일 해둔 것들로 가져다 쓰면되기 때문에 
    속도상에도 이점이 있습니다.
    이런 프리 컴파일드 헤더는 프로젝트를 만들때 같이 만들어지는 버전도 있고 아닐때도 있는데 없는 버전이어도 따로 설정해 줄수 있습니다.

    솔루션 탐색기에서 현재 사용중이 Client 프로젝트를 우클릭하고 속성에 들어갑니다. 이후 모든구성 모든 플렛폼에 대해 적용을 하고 
    C++메뉴에 미리 컴파일된 헤더란으로 들러가 사용하겠다고 바꿔주면 됩니다. 프리 컴파일드 헤더의 이름이 보통 stdafx.h 나 pch.h로 많이 사용한다고 합니다.
    (이 프로젝트에서는 pch.h로 하였습니다.)
    소스파일 밑으로 Game필터와 Utils필터를 만들고 원래 있던 Client.cpp나 그외의 파일들을 모두 Utils필터로 넣었습니다. 그리고 Utils필터에 
    추가->클래스->pch로 생성 해주었습니다. 이러면 pch.h 헤더파일이 생기는데 내용을 우리가 쓰고 싶은 라이브러리들을 다 모아두면 되겠습니니다.
    또 pch.h가 적용되려면 pch.cpp파일을 속성에 들어가 미리 컴파일된 헤더-> 사용이 아닌 만들기로 바꿔주었습니다.
    마지막으로 코드 맨위에 pch.h를 include해주면 되겠습니다. 
    이제부터 새로 만드는 클래스 템플릿들은 모두 맨위에 pch.h가 include되어 있을 겁니다. 

다음으로 Game필터 밑으로 Game이라는 클래스 템플릿을 만들어 주었습니다. 역시 Game.cpp에는 pch.h가 include 되어 있습니다.
이 Game헤더에는 같은이름의 Game클래스가 있는데요 이안에 public으로 Init, Update함수를 만들어 주겠습니다. 헤더에는 선언만 하고 정의는 
Game cpp 파일에서 할것입니다.

tip) 여태껏 정의부분을 만들때 직접 void Init() { } 이렇게 손수 타이핑을 했었는데요 비주얼 스튜디오의 단축키를 이용하면 훨씬 손쉽게 만들수 있습니다.
	ctrl + . 을 하면 어떤 매뉴가 나오는데 그중 정의 만들기 (단축키 D) 를하면 바로 Game.cpp에 정의 부분이 만들어집니다.

왜 Game파일들을 만들었는가 하면 처음 프로젝트 생성하고 본 Client파일은 윈도우즈 창을 만들고 걔를 렌더링하는 부분이 복잡하게 들어가 있는데
거기에 우리가 만들 게임코드까지 추가하면 매우 복잡해질것이기때문에 따로 빼서 관리하려고 만들었습니다.

이 Game의 Init 함수와 Update함수를 어떻게 할것이냐?
Client에서 설정해주던 그 메세지를 받는 부분에서 Init을 해주고 while문 안쪽에서 Update를 해줄것입니다.
이러면 처음에 초기화후 while문을 돌때마다 update를 해주게 됩니다. 
이 구조는 어떤 게임이건 이렇게 이루어져 있다고 합니다.

이때 Game객체를 만들어서 함수들을 사용할텐데 기왕이면 스택 메모리 말고 동적할당을 하고 싶습니다. 
동적할당을 하기위해 Game 포인터 타입을 만들어 줄 텐데 C++ 문법을 배우면서 사용하던 생 포인터 대신 약간의 성능을 포기하더라도 
안정성을 위해 스마트 포인터를 사용하겠습니다. 
여기서 사용할 스마트 포인터는 unique_ptr입니다.
std::unipue_ptr<Game> game = std::make_unique<Game>(); 로 동적할당해주었습니다. 
스마트 포인터를 쓰면서 생 포인터를 사용할때의 메모리 누수 문제까지 해결하였습니다.


이제 Client 프로젝트를 빌드해보고 성공했으면 실행 해보겠습니다. 
잘 실행이 됐지만 기본 설정으로 파일, 도움말 메뉴가 있는게 조금 거슬려서 없애고 싶습니다. 
메뉴를 없애려면 Client cpp 파일에서 wWinMain함수 밑에 MyRegisterClass라는 구조체안에 lpszMenuName이라는 항목이 있습니다. 그곳을 
nullptr로 날리면 됩니다.

이런식으로 윈도우즈 API를 필요에 맞게 조금씩 수정해야 하는데 이번 강의에서는 이정도만 할것입니다.


이제 렌더링 하는 Engine을 별도의 프로젝트로 빼서 만들고 라이브러리로 불러올것입니다.
라이브러리란 누군가가 만들어놓은 코드를 가져와서 사용하는것입니다. 

왜 Engine을 Client프로젝트에 한번에 관리하지 않고 따로 빼서 관리를 하느냐? 라는 질문이 생깁니다.

공통적인 기능들을 프로젝트 외부로 빼주면 여러 장점이 있습니다. 
예를 들면 이 첫번째 게임말고 또다른 게임을 만든다거나 할때도 이 기능이 필요할때 첫번째 게임 코드에서 필요한 코드를 한땀 한땀 복사해서 
가져다 써야 할것입니다. 하지만 공용으로 관리하는 라이브러리 프로젝트를 만들어주면 다시 재사용이 용이하게 되는 장점이 있습니다.

그래서 렌더링을 할 Engine 프로젝트를 생성하겠습니다. 솔루션 탐색기의 맨위 솔루션 'Game'을 오른클릭해서 추가-> 새 프로젝트를 클릭해줍니다.
여태껏 만들었던 프로젝트들은 콘솔 앱이라던가 윈도우즈 데스크톱 어플리케이션이었는데 조금 내려보면 
라이브러리 항목 두개가 있습니다. 정적 라이크러리(.lib)와 동적 라이브러리(.dll)인데 
정적 라이브러리의 설명은 다른 windows 실행 파일 내에 패키지될 수 있는 .lib를 빌드하세요 라고 되어있고 
동적 라이브러리의 설명은 실행 중인 여러 windows앱 간에 공유될 수 있는 .dll을 빌드하세요 라고 되어있습니다.
강사님의 비유는 노트북을 비유로 정적 라이브러리는 노트북의 빌트인된 부품 처럼 프로그램이 컴파일될때 부터 적용되어있는 라이브러리고
동적라이브러리는 노트북 외부의 그래픽 카드를 끼우듯 하는 프로그램이 실행될때 연결되서 적용되는 라이브러리라고 합니다.

이번 프로젝트에서는 정적 라이브러리를 사용할것입니다. 동적 라이브러리같은경우 .dll파일을 따로 관리해줘야하는 불편이 있지만 
정적 라이브러리는 처음부터 프로그램의 일부처럼 작동하기 때문에 편하다고 하십니다.

Engine이라는 이름으로 정적 라이브러리를 만들고 보니 Engine.cpp에는 특이하게 main함수가 없습니다. 시작 프로젝트로 설정해서 실행해봐도 
실행이 안됩니다. 라이브러리 답게 exe파일로 실행되는게 아닌 다른 프로젝트의 부품으로 동작할것이기 때문입니다.
다음으로 Engine프로젝트를 정리해주겠습니다. 아무것도 없는 리소스 파일부터 삭제하고 main함수가 없는 Engine.cpp파일도 삭제해도 됩니다. 
삭제할때 원본 파일까지 날려주겠습니다. Engine 프로젝트의 pch.h 파일에 framework파일이 include 되어 있길레 열어보니 
#define WIN#@_LEAN_AND_MEAN 이라는 코드만 하나 있어서 직접 pch파일에 복사해주고 framework파일은 삭제해주겠습니다.

지울껀 지웠고 이제 다시 만들건 만들겠습니다. Engine프로젝트의 Utils필터에 다시 클래스 템플릿을 EnginePch라는 이름으로 만들었습니다.
pch헤더가 있는데 EnginePch를 따로 만든이유는 Client 프로젝트에서 쓰일 각종 include, lib파일, typedef들을 한곳에 묶어 관리하기 위함입니다.
이 EnginePch에 강사님이 올려놓은 수업자료의 각종 컨테이너들, include할것들, DirectX관련 헤더, DirectX 관련 lib파일, 타이핑을 줄이기 위한 
typedef들을 붙여 넣었습니다. 
붙여놓은 코드들중 d3dx12.h 라는 파일이 없다고 나오는데 이 파일은 마이크로 소프트에서 만든 비공식 헤더파일이라고 합니다. 
강사님의 수업자료에서 붙여 넣어도 되고 아니면 인터넷에서 다운 받아도 됩니다.
이 파일의 정체는 우리가 앞으로 굉장히 많은 타이핑을 해야하는데 그 타이핑양을 줄여주기 위한 파일이라고 합니다.

지금 붙여넣은 헤더들을 이전 파트에서 하듯 에러가 날 때마다 하나씩 추가 해 줄 수도 있겠지만 그러면 에러가 너무 많이 날것이기 때문에 
한번에 미리 추가하였습니다.

Engine프로젝트가 정상적으로 Client프로젝트에 적용이 되는지 확인하기위해 void HelloEngine이라는 함수를 EnginePch에 만들어주겠습니다.

프로젝트에 파일탐색기 폴더를 열면 Client 폴더, Engine 폴더 외에도 x64폴더나 debug 폴더가 있을 수 있습니다. 이 폴더들을 정리해주고 
프로젝트의 결과물을 Output이라는 새로운 폴더에서 볼 수 있도록 설정해주겠습니다.
비쥬얼 스튜디오 솔루션 탐색기에서 Client, Engine 프로젝트의 속성에 들어가서 일반, 출력 디렉토리를 제가 만든 Output 폴더로 지정하고 
빌드를 해보니 Output 폴더내에 잘 출력한 결과가 있습니다.
다음으로 Client, Engine, Output 폴더 외에 Resources라는 폴더를 하다 더 만들어 주겠습니다. 
Client는 제가 만들 게임 클라이언트 자체, Engine은 클라이언트에 쓰일 Engine 코드가 들어갈것이고, Output은 출력물,  Resources는 나머지
리소스 파일들이 들어가게 될겁니다.


이제 Client 프로젝트에서 Engine프로젝트의 파일들을 끌어다 쓰고 싶습니다. 이 처리를 하려면 Client 프로젝트에 두 가지 정보를 알려줘야 하는데요
헤더 파일이 어디 있는지와 lib파일이 어디 있는지 입니다. 
파일이 어디 있는지 알려줄때 절대 경로와 상대 경로 두가지 방법을 사용할 수 있습니다. 절대 경로는 컴퓨터 최상위 디렉토리부터 지금 파일이 어디있는지 
전부 적는 방법이고 상대 경로는 우리의 솔루션 파일의 위치를 기준으로 파일들이 어디 있는지 알려주는 방법입니다. 
우리 솔루션이 다른 경로의 폴더로 옮길 일이 많지 않을것같지만 혹시 그런 경우에도 경로가 유효하게 작동하기위해 상대 경로 방법으로 하겠습니다.
그래서 경로를 추가하는 방법은 비주얼 스튜디오 솔루션 탐색기에서 Client프로젝트의 속성에 들어가 '구성 속성 -> VC++디렉터리' 로 들어갑니다.
그 옵션의 오른쪽 항목들 중 포함 디렉터리가 헤더 파일이 있을 디렉터리를 지정하면 되겠고, 라이브러리 디렉터리는 lib파일이 있을 디렉터리를 지정하면되겠습니다.

이제 Engine 프로젝트가 Client 프로젝트에서 작동하는지 확인하기 위한 HelloEngine함수를 실행하는 작업을 해보겠습니다.
Client가 EnginePch를 가져오도록 Client 프로젝트의 pch.h에 #include "EnginePch.h"를 해주었습니다. 그리고 Game.cpp에서 Init 함수안에 HelloEngine함수를 넣고 
빌드를 해보니 에러가 뜹니다. 무슨 이유인가 보니깐 확인할 수 없는 외부 기호 라고 합니다. 강사님이 라이브러리를 링크를 안해줬다는 문제라고 하셨습니다.
그래서 링크는 어떻게 하는가? 다시 솔루션 탐색기 -> Client 프로젝트 속성 -> 링커 -> 입력 -> 추가 종속성 항목에 Engine.lib를 추가해줍니다.
그러고 다시 빌드를 해보니 정상적으로 빌드 됐습니다.

이제 정말 마지막으로 매번 추가 종속성을 만들어주는 것도 귀찮습니다. 그래서 추가종속성으로 링크를 처리하는 것 말고 다른 방법이 있습니다.
그 방법은 위에서 EnginePch.h에 붙여넣기 했던 코드들중 lib파일 부분, #pragma comment(lib, "lib 파일 이름") 입니다. 이 명령어로 컴파일러에게 전처리로 라이브러리를
링크 시켜줄수 있습니다. 그러면 이 라이브러리를 링크시킬 파일이 Client 프로젝트의 pch.h였으니깐 그 파일에 #pragma comment(lib, "Engine.lib") 을 해주겠습니다.


