    C++/언리얼 엔진 Part.2 환경설정입니다. 
    새 프로젝트 생성을 윈도우 어플리케이션 템플릿으로 생성했습니다. 
    여러 처음보는 용어들이 많은데 윈도우API에 대한 것들이라고 합니다. 처음 배울때는 그냥 그런게 있구나 하면서 넘어가고
    이후 다시 복습할때 조금씩 찾아보면서 배우라고 하셨습니다. 

    조금 밑으로 가면 wWinMain함수가 있습니다. 이게 이전 C++콘솔 프로젝트의 main함수역할인것 같습니다.
    
    기본 메세지 루프입니다 라는 주석이 있는데 
    while문으로 계속 루프시켜주고 있습니다. 게임이건 다른 윈도우즈 프로그램이건 상관없이 whlie루프로 프로그램을 유지하고 있습니다.

    while이 조건으로 GetMessage함수를 받고있는데 이 함수는 실제적으로 메세지를 준다거나(마우스 클릭이나 키보드 입력같은걸 말합니다.)하는 
    입력을 메세지 라는 것으로 받아주고 있습니다.
    이 함수의 단점으로 프로그램에 메세지를 주지 않으면 대기상태로 있게됩니다. 다른 프로그램이면 모르겠지만 
    게임에서는 키보드나 마우스 입력이 없더라도 게임을 계속 돌아가야합니다. 
    그래서 있던 GetMessage함수대신 그냥 true로 무한루프를 돌게 해주겠습니다.
    그 다음 GetMessage함수 대신 루프문 안에서 if로 PeekMessage함수를 체크해줍니다.
    이 피크 메세지 함수의 인자로 들어오는게 복잡한데요, 이런걸 하나하나 문서를 찾아보는것은 어려운 일입니다. 나중에 두세번째 다시 공부 할때 
    그때 관심이 생기면 하나씩 찾아보기로 하고 간략하게 어떤 인자가 오는지만 집고 가겠습니다.
    첫째로 받을 메세지를 넣고, 두번쨰 로 핸들이라는 것이 오는데 어떤 윈도우즈 핸들?을 사용하는지 지정할수 있다고 합니다. 지금은 nullptr을 
    넣게 되면 현재 쓰레드와 관계된 모든 메세지룰 받게됩니다. 그냥 그렇게 알고 있으면 되고, 세번째 네번째로 필터 min, max가 오게됩니다. 
    이 필터로 어떤 특정 메세지만 필터링 해서 받아주겠다. 를 할 수 있지만 그냥 0, 0으로 넣어주어 모든 메세지를 필터없이 받아주겠습니다.
    마지막으로 PM_REMOVE를 인자로 넣어주겠습니다. 이 PM_REMOVE를 조금 살펴보자면 우리가 프로그램에서 키보드입력이나 마우스 입력을 메세지로 
    받는다고 했습니다. 메세지라 큐에 쌓이고 지금 메세지 루프에서 메세지를 하나씩 처리하고 있는것인데 이 처리를 꺼낸 메세지를 어떻게 처리하느냐
    에 대한 인자라고 볼수 있습니다. PM_REMOVE는 꺼낸 메세지를 사용하고 나서 지우겠다는 의미입니다.

    이 메인 루프에 대해 상세하게 알아볼 필요가 별로 없다고 합니다. 메인 루프는 한번만 만들고 나서 신경쓰지 않을것이기 때문이라고 합니다.

    PeekMessage if문 안에서 다시 if로 msg.message == WM_QUIT라면 break;로 루프를 빠져나가도록 해주었습니다. 이 코드는 보통 프로그램을 종료할때 
    자주 사용되는 코드라고 알고 있으면 되겠습니다.

    메세지를 처리하던 코드를 PeekMessage 조건문 안으로 옮겨주었습니다. PeekMessage가 true 라고 하는것은 어떤 메세지가 있었다는 이야기이기 때문입니다.

    PeekMessage 조건문 밖 while반복문 안에 이제 우리의 게임 로직들을 작성해줄것입니다.


    여기서 한가지를 더 해보고 싶은데 프리컴파일드헤더(Precomfiled Header) 라는 것입니다.
    프리 컴파일드 헤더는 자주 쓰일것으로 예상되는 라이브러리들을 한곳에 모아두어서 미리 컴파일해두는 헤더 파일입니다. 
    편의성 외에도 프리 컴파일드 헤더라는 이름에서 알수 있듯이 이 헤더에 모여있는 라이브러리들은 미리 컴파일 해둔 것들로 가져다 쓰면되기 때문에 
    속도상에도 이점이 있습니다.
    이런 프리 컴파일드 헤더는 프로젝트를 만들때 같이 만들어지는 버전도 있고 아닐때도 있는데 없는 버전이어도 따로 설정해 줄수 있습니다.

    솔루션 탐색기에서 현재 사용중이 Client 프로젝트를 우클릭하고 속성에 들어갑니다. 이후 모든구성 모든 플렛폼에 대해 적용을 하고 
    C++메뉴에 미리 컴파일된 헤더란으로 들러가 사용하겠다고 바꿔주면 됩니다. 프리 컴파일드 헤더의 이름이 보통 stdafx.h 나 pch.h로 많이 사용한다고 합니다.
    (이 프로젝트에서는 pch.h로 하였습니다.)
    소스파일 밑으로 Game필터와 Utils필터를 만들고 원래 있던 Client.cpp나 그외의 파일들을 모두 Utils필터로 넣었습니다. 그리고 Utils필터에 
    추가->클래스->pch로 생성 해주었습니다. 이러면 pch.h 헤더파일이 생기는데 내용을 우리가 쓰고 싶은 라이브러리들을 다 모아두면 되겠습니니다.
    또 pch.h가 적용되려면 pch.cpp파일을 속성에 들어가 미리 컴파일된 헤더-> 사용이 아닌 만들기로 바꿔주었습니다.
    마지막으로 코드 맨위에 pch.h를 include해주면 되겠습니다. 
    이제부터 새로 만드는 클래스 템플릿들은 모두 맨위에 pch.h가 include되어 있을 겁니다. 

다음으로 Game필터 밑으로 Game이라는 클래스 템플릿을 만들어 주었습니다. 역시 Game.cpp에는 pch.h가 include 되어 있습니다.
이 Game헤더에는 같은이름의 Game클래스가 있는데요 이안에 public으로 Init, Update함수를 만들어 주겠습니다. 헤더에는 선언만 하고 정의는 
Game cpp 파일에서 할것입니다.

tip) 여태껏 정의부분을 만들때 직접 void Init() { } 이렇게 손수 타이핑을 했었는데요 비주얼 스튜디오의 단축키를 이용하면 훨씬 손쉽게 만들수 있습니다.
	ctrl + . 을 하면 어떤 매뉴가 나오는데 그중 정의 만들기 (단축키 D) 를하면 바로 Game.cpp에 정의 부분이 만들어집니다.

왜 Game파일들을 만들었는가 하면 처음 프로젝트 생성하고 본 Client파일은 윈도우즈 창을 만들고 걔를 렌더링하는 부분이 복잡하게 들어가 있는데
거기에 우리가 만들 게임코드까지 추가하면 매우 복잡해질것이기때문에 따로 빼서 관리하려고 만들었습니다.

이 Game의 Init 함수와 Update함수를 어떻게 할것이냐?
Client에서 설정해주던 그 메세지를 받는 부분에서 Init을 해주고 while문 안쪽에서 Update를 해줄것입니다.
이러면 처음에 초기화후 while문을 돌때마다 update를 해주게 됩니다. 
이 구조는 어떤 게임이건 이렇게 이루어져 있다고 합니다.

이때 Game객체를 만들어서 함수들을 사용할텐데 기왕이면 스택 메모리 말고 동적할당을 하고 싶습니다. 
동적할당을 하기위해 Game 포인터 타입을 만들어 줄 텐데 C++ 문법을 배우면서 사용하던 생 포인터 대신 약간의 성능을 포기하더라도 
안정성을 위해 스마트 포인터를 사용하겠습니다. 
여기서 사용할 스마트 포인터는 unique_ptr입니다.
std::unipue_ptr<Game> game = std::make_unique<Game>(); 로 동적할당해주었습니다. 
스마트 포인터를 쓰면서 생 포인터를 사용할때의 메모리 누수 문제까지 해결하였습니다.


이제 Client 프로젝트를 빌드해보고 성공했으면 실행 해보겠습니다. 
잘 실행이 됐지만 기본 설정으로 파일, 도움말 메뉴가 있는게 조금 거슬려서 없애고 싶습니다. 
메뉴를 없애려면 Client cpp 파일에서 wWinMain함수 밑에 MyRegisterClass라는 구조체안에 lpszMenuName이라는 항목이 있습니다. 그곳을 
nullptr로 날리면 됩니다.

이런식으로 윈도우즈 API를 필요에 맞게 조금씩 수정해야 하는데 이번 강의에서는 이정도만 할것입니다.


이제 렌더링 하는 Engine을 별도의 프로젝트로 빼서 만들고 라이브러리로 불러올것입니다.
라이브러리란 누군가가 만들어놓은 코드를 가져와서 사용하는것입니다. 

왜 Engine을 Client프로젝트에 한번에 관리하지 않고 따로 빼서 관리를 하느냐? 라는 질문이 생깁니다.

공통적인 기능들을 프로젝트 외부로 빼주면 여러 장점이 있습니다. 
예를 들면 이 첫번째 게임말고 또다른 게임을 만든다거나 할때도 이 기능이 필요할때 첫번째 게임 코드에서 필요한 코드를 한땀 한땀 복사해서 
가져다 써야 할것입니다. 하지만 공용으로 관리하는 라이브러리 프로젝트를 만들어주면 다시 재사용이 용이하게 되는 장점이 있습니다.

그래서 렌더링을 할 Engine 프로젝트를 생성하겠습니다. 솔루션 탐색기의 맨위 솔루션 'Game'을 오른클릭해서 추가-> 새 프로젝트를 클릭해줍니다.
여태껏 만들었던 프로젝트들은 콘솔 앱이라던가 윈도우즈 데스크톱 어플리케이션이었는데 조금 내려보면 
라이브러리 항목 두개가 있습니다. 정적 라이크러리(.lib)와 동적 라이브러리(.dll)인데 
정적 라이브러리의 설명은 다른 windows 실행 파일 내에 패키지될 수 있는 .lib를 빌드하세요 라고 되어있고 
동적 라이브러리의 설명은 실행 중인 여러 windows앱 간에 공유될 수 있는 .dll을 빌드하세요 라고 되어있습니다.
강사님의 비유는 노트북을 비유로 정적 라이브러리는 노트북의 빌트인된 부품 처럼 프로그램이 컴파일될때 부터 적용되어있는 라이브러리고
동적라이브러리는 노트북 외부의 그래픽 카드를 끼우듯 하는 프로그램이 실행될때 연결되서 적용되는 라이브러리라고 합니다.

이번 프로젝트에서는 정적 라이브러리를 사용할것입니다. 동적 라이브러리같은경우 .dll파일을 따로 관리해줘야하는 불편이 있지만 
정적 라이브러리는 처음부터 프로그램의 일부처럼 작동하기 때문에 편하다고 하십니다.

Engine이라는 이름으로 정적 라이브러리를 만들고 보니 Engine.cpp에는 특이하게 main함수가 없습니다. 시작 프로젝트로 설정해서 실행해봐도 
실행이 안됩니다. 라이브러리 답게 exe파일로 실행되는게 아닌 다른 프로젝트의 부품으로 동작할것이기 때문입니다.
다음으로 Engine프로젝트를 정리해주겠습니다. 아무것도 없는 리소스 파일부터 삭제하고 main함수가 없는 Engine.cpp파일도 삭제해도 됩니다. 
삭제할때 원본 파일까지 날려주겠습니다. Engine 프로젝트의 pch.h 파일에 framework파일이 include 되어 있길레 열어보니 
#define WIN#@_LEAN_AND_MEAN 이라는 코드만 하나 있어서 직접 pch파일에 복사해주고 framework파일은 삭제해주겠습니다.

