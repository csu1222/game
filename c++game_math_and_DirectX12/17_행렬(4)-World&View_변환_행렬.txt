

		18. World, View 변환 행렬


이번시간에는 게임에서 어떤 좌표계및 좌표계변환이 필요한지를 알아보겠습니다.

유니티 엔진을 보면 오브젝트들은 자신만의 로컬 스페이스가 있습니다. 로컬스페이스는 게임세상도 카메라도 없는 오브젝트 자신만 있는 공간인데 
거기서 어떤 캐릭터(강의에서는 유니티짱이라는 캐릭터)의 로컬스페이스를 보면 캐릭터의 발밑을 원점으로 대칭하게 만들어 둔것을 알 수 있습니다. 
Scale변환이라던지, Rotation변환을 제자리서 할 수 있도록 합니다.

어쨌든 오늘의 내용은 오브젝트들이 로컬스페이스를 가지고 있다는 점입니다. 오브젝트느 로컬스페이스의 좌표계위에서 각자의 위치벡터를 계산해 만들어 져있을 겁니다.
그렇게 오브젝트를 이루는 삼각형들이 만들어졌을 텐데 
결국에는 오브젝트를 게임세상 위로 가져와야합니다. 그러면 가져온 오브젝트는 생성되면 게임세상의 0, 0, 0 위치에 위치하게되는데 모든 물체를 0, 0, 0에 배치할 것은 당연히 아닐겁니다.
게임내 상황에 따라 오브젝트의 위치가 바뀌고 항상 z축만 바라보는게 아니라 자연스럽게 방향도 바뀔것이고, 커스터마이징이나 보스몹이라거나 하는 상태에 따라 크기도 변할겁니다.(SRT)

- World변환
지금까지 배운 변환행렬들은 물체가 원점에 있을때를 기준으로 배웠지만 실제 게임에서는 게임세상 안에 각자의 좌표에서 변환이 일어날것입니다.
이렇게 인게임에서 위치를 정하고, 스케일을 정하고, 회전을 정하고 이렇게 로컬스페이스에서 월드로 변환을 한번 해줘야 합니다. 이걸 World변환이라고 합니다. 
벌써 변환이 한번 일어났습니다. 

- View변환
그러면 월드 변환만하면 끝인가 하면 그렇지 않습니다. 다음으로 게임세상에는 카메라가 있을겁니다. 유니티에서는 기본적으로 카메라가 있고 만약 없다면 만들어 주면 되겠습니다. 
카메라라는 오브젝트도 역시 로컬스페이스가 있었고 로컬스페이스에서 월드스페이스로 변환을 하였을 것 입니다. 
왜 뜬금없이 카메라 이야기를 하고 있는가 하면 우리가 게임엔진에서 보고 있는 시점으로 게임의 화면이 출력되는것이 아니라 카메라의 시점으로 본 장면을 2D평면 픽셀들로 변환시켜서 
출력해준다고 몇번 이야기 했었습니다. 여기서 카메라 시점이라고 하면 카메라 오브젝트가 위치해있는 곳을 0, 0, 0이라고 간주하고 카메라가 바라보고 있는 곳을 z축이라고 하는 좌표계에서 
물체들을 인식한다는 이야기 입니다.
이렇게 카메라가 보고있는 장면을 카메라 스페이스라고도 하고 view스페이스라고도 합니다. 이 view 스페이스로 변환하느것을 view변환이라고 합니다.

- 투영
모든 오브젝트들은 결국 World 스페이스로 한번, View 스페이스로 또 한번 변환이 일어나야 합니다.
그러면 여러 과정을 거쳐 View스페이스 변환까지 오면 끝인가 하면 그것도 아닙니다. 다음 단계는 투영 단계가 있습니다.
카메라 스페이스를 기준으로 오브젝트들의 좌표를 변환한것이 끝이 아니라 카메라는 촬영 거리와 범위가 있습니다. 이 촬영거리 안에 있는 오브젝트들을 
각자의 위치와 깊이에 따라 2D 화면으로 압축해서 그리는 투영 단계를 거칩니다. 이때 촬영거리는 조절 할 수 있습니다.
만약 플레이어 오브젝트가 카메라와 동떨어진 위치에 존재한다고 하면 카메라 스페이스에서 좌표는 가지고 있을겁니다. 하지만 카메라의 촬영 범위밖에 있는 플레이어 오브젝트는 화면에 나오지 않습니다.
이렇게 카메라 촬영 범위내에 있는 물체들을 추리고 각 비율에 맞춰서 한 장면으로 압축하는걸 투영(Projection)한다고 하고 그것을 플릿 스페이스(?)라고 합니다.

(투영 좌표계는 이전에 약간 배웠던 적이 있습니다. 베이가 사진의 깊이를 설정해서 어떤 순서로 곂쳐보이는지를 실습했었습니다. 투영은 결국 비율이기 때문에 투영좌표계는 
좌하단 끝의 좌표가 (-1, -1)이고 우상단 끝의 좌표가 (1, 1)인 좌표내로 범위 안의 물체들을 비율대로 잘 압축시켜 표현하는것 이었습니다.)

- 뷰포트
투영 단계 다음으로 마지막 단계가 남았는데 viewport스페이스라고 합니다. 투영한 이미지를 화면에 출력하는 단계입니다.
투영좌표계는 -1에서 1사이로 비율로 표현되어있는걸 우리 화면에서는 해상도에 따라 600 x 800 같은 화면에 비율로 잘 출력하도록 변환하는것입니다.
최종적으로 그려질 화면이 나타나는데 그걸 스크린 스페이스, 윈도우 스페이스라고도 부릅니다.


이런 여러가지 과정들이 이뤄지는데 다시 처음부터 정리하자면 
<오브젝트의 로컬스페이스> -> <인게임의 월드스페이스로 변환> -> <카메라의 View스페이스로 변환> -> <카메라의 촬영범위안에 있는 오브젝트를 투영해서 플릿 스페이스로 변환>
-> <투영된 오브젝트들을 표현할 화면 해상도에 맞추어서 스크린 스페이스, 윈도우 스페이스 변환>

Local -> World -> View -> Projection -> Screen

이렇게 자꾸 반복해서 설명하는 이유는 워낙 중요해서입니다. 

로컬 좌표는 모델러분들이 만들어주는 기본 좌표라고 볼 수 있고 0, 0, 0에서 부터 다양한 형태의 오브젝트들이 모델링 될것입니다. 
월드 행렬을 이용해서 인게임에 배치를 해주는데 물체마다 배치될 위치와 각도에 적절히 배치될것입니다. 그러다 보니 월드 행렬은 물체마다 독립적으로 따로따로 있습니다.
카메라도 로컬스페이스에 존재 하다가 카메라의 월드행렬에 의해 인게임에 배치될겁니다. 그리고 카메라가 원점이 View 행렬을 만들어줍니다.
카메라가 바라보는 방향이 z축이 되는 새로운 좌표계를 가지고 좌표계변환을 해주게 됩니다.
View 스페이스에서의 오브젝트들 중 카메라의 범위 내에 있는 오브젝트를 비율에 맞추어 투영하게 되는 Projection이 일어나고(이 경우는 원근투영이고, 직교투영의 경우는 비율상관없이 본래 크기대로 
투영됩니다.)이 때는 결과 이미지를 -1 에서 1사이의 비율로 나타내게 됩니다.
최종적으로 윈도우 해상도에 맞는 비율의 픽셀을 계산해서 출력하게 해주는 스크린 변환이 일어납니다.

- 수학
그러면 위에서 배운 개념들을 수학적으로 다시 알아 보겠습니다.

(1) Local Space (Model Space)
이제 오브젝트의 기본 좌표계인 로컬 스페이스를 수학적으로 해석해보겠습니다. 이때 알아야 할 점은 오브젝트가 바라보고 있는 방향이 z축이라는 것입니다.
그리고 이전 시간에 알아본 좌표계 변환 행렬이 있습니다. 이것은 사실 만능 공식이라고 볼 수 있습니다 어떤 좌표계에서 다른 좌표계로 넘어가기 위한 만능 공식이라고 볼 수 있는겁니다.
(x, y ,z, 1)  *  Ux  Uy  Uz 0	
 	    Vx  Vy  Vz  0
 	    Wx Wy Wz 0
 	    Qx Qy Qz   1

유니티기준으로는 왼손 좌표계를 사용하고 있기때문에 오브젝트의 오른쪽을 위에서는 U라고 표현했고 윗 방향을 V, 오브젝트가 바라보고 있는 방향을 W라고 표현했습니다.
그런데 이 UVW가 햇갈릴 수 있기 때문에 보통 많이 사용하는 표현은 U벡터를 Right벡터, V벡터를 Up벡터, W벡터를 Look벡터라고 많이 말합니다. 이름이 직관적입니다.

	    Ux  Uy  Uz 0	
 	    Vx  Vy  Vz  0
 	    Wx Wy Wz 0
 	    Qx Qy Qz   1
다시 이 변환 행렬이 의미하는 바를 복습해보자면 4행의 Qx, Qy, Qz는 좌표를 이야기 하는것이었습니다. A좌표계에서 B좌표계로 변환이 되었다면 B좌표계기준에서의 원점A의 좌표를 말하는것이었습니다.
그리고 U,V,W 즉 Right, Up, Look은 B좌표계를 기준으로한 A좌표계의 단위 벡터들을 이야기 하고 있는겁니다.

(2) World Space
이제 로컬스페이스에서 월드 스페이스로 변환을 하고 싶은데 이 때 사용되는 행렬을 World행렬이라고 하고 당연히 월드 스페이스 에서 로컬스페이스로 돌아 갈 수도 있는데 이때는 
World 행렬의 역행렬을 연산해주면 됩니다.

이중 월드행렬은 (x, y, z, 1) 이라는 좌표를 가진 오브젝트에 곱할 행렬인데 그 결과물이 월드스페이스에서의 좌표가 되었다 는 결과를 원하는겁니다.
그럼 월드 행렬도 결국 좌표계 변환 행렬이기 때문에 
(x, y ,z, 1)  *  Right.x  Right.y  Right.z 0	
 	      Up.x      Up.y     Up.z  0
 	    Look.x    Look.y   Look.z 0
 	    Pos.x      Pos.y    Pos.z   1

여기서 pos 성분은 오브젝트의 좌표정보를 나타내는 것일것입니다.
다음으로 Right, Up, Look성분들은 로컬스페이스에서의 오브젝트를 월드스페이스 관점으로 봤을때의 값이 들어가야합니다. 
값들을 구하려고 로컬 좌표계와 월드에서의 크기, 각도, 위치를 고려해 행렬을 계산하는 방법도 있고, 
아니면 우선 오브젝트가 월드 스페이스의 0, 0, 0에 스케일도 1, 회전도 안한 상태로 생성되었다 치고 S,R,T 순서로 연산을 했더니 임의의 오브젝트가 있어야 할 위치에 가 있게되었다고 
할 수 있습니다. 
그러면 기저벡터(x,y,z축방향의 단위벡터)가 어떻게 변했는지를 구하는 방법, S,R,T를 구하는 방법이 있는데 직관적으로는 SRT가 좀더 쉬워보입니다.
행렬은 결합법칙이 성립하므로 Scale행렬, Rotation행렬, Tranlation행렬을 미리 곱해놓은 결과물이 월드행렬이 될것입니다.

한가지 알아야 할 점은 어찌어찌 해서 월드 변환 행렬을 구했다고 했을때, Position, Rotation, Scale 정보를 모를때 역으로 구할 수도 있어야 합니다.
행렬의 어느 부분이 무엇을 의미하는지를 알면 행렬에서 정보를 역으로 구할 수 있습니다. 
(유니티에서는 월드 변환 행렬을 모델 변환 행렬이라고도 부릅니다.)

(3) View Space

다음 변환인 View 스페이스, 카메라 스페이스 변환에 대해 알아보겠습니다.

일단 카메라는 비록 메쉬는 가지고 있지 않지만 일종의 오브젝트라고 볼 수 있습니다. 카메라도 로컬 스페이스의 0, 0, 0에 존재 할것이고 Right, Up, Look 벡터를 가지고 있고 
그중 Look벡터 방향으로 화면을 담고 있을 겁니다.
그래서 이 카메라도 월드 스페이스로 변환을 할것인데 이때 만약 카메라가 월드 스페이스의 원점에 생성되어서 촬영을 한다면 변환 없이 그대로 사용해도 됩니다.

하지만 보통은 카메라가 항상 월드 스페이스의 원점과 일치하고 축도 일치하는 경우는 잘없고 카메라만의 축과 위치를 가질것인데 만약 월드 원점에서 카메라가 오른쪽으로 가면 
화면에서 오브젝트들은 왼쪽으록 갈것이고, 카메라가 왼쪽으로 가면 오브젝트들은 오른쪽으로 갈 것입니다. 
즉 카메라의 위치, 축을 원점으로한 카메라 스페이스 관점에서 월드를 보고 있을것입니다. 
왜 자꾸 같은 내용을 반복해서 설명하냐면, 사실 이걸 어떻게 분석하느냐에 따라 여러가지 방법이 존재 할 수 있습니다.

첫번째 방법은, 카메라의 좌표가 0,0,0 원점이고 카메라가 보는 방향이 z축이 되게 변환을 한다고 했습니다. 이말은 어떻게 생각하면 카메라의 로컬스페이스의 상태와 같습니다.
그러면 생각하기에 따라 '카메라의 로컬스페이스로 모든 오브젝트, 월드를 끌고 들어온다고도 볼 수 있습니다.'
여기서 카메라를 월드에 배치하기위한 행렬이 월드 행렬이었습니다. 그리고 다시 로컬 스페이스로 돌아오려면 월드 행렬의 역행렬을 구하면 되었습니다. 
이 월드 행렬의 역행렬이 어쩌면 View 스페이스 변환 행렬의 열쇠가 될 수도 있습니다.

두번째 방법, 
그런데 로컬스페이스는 오브젝트 하나만의 공간인데 다른 오브젝트들을 끌고 들어오는게 말이 되냐 라고 하는 생각도 들 수 있습니다. 
표현이 로컬스페이스로 끌고 들어 온다는 것일뿐이고, View 스페이스 변환은 카메라가 촬영하는 방향이 있다는 점에서 비유를 든겁니다. 
예를들어 월드스페이스에서 카메라가 오른쪽으로 이동하면 찍히던 오브젝트는 왼쪽으로 움직인다고 했습니다. 그러면 카메라가 고정되어있고 오브젝트가 왼쪽으로 이동하는것과 같은 셈입니다.
또 카메라가 왼쪽으로 자전해서 찍히던 오브젝트가 오른쪽으로 공전하듯이 보이는데 이것도 카메라를 고정하고 오브젝트가 공전하다고도 볼 수 있습니다.
즉, '카메라는 가만히 있고 오브젝트가 움직이는' 식으로 해석 할 수도 있습니다.

그러면 이 두가지 방법
1 - 오브젝트들을 카메라의 월드 변환 행렬의 역행렬을 이용해 카메라의 로컬스페이스로 끌어들이는 해석
2 - 카메라는 월드스페이스에 고정되어 있고 오브젝트들을 카메라 기준으로 움직이는 해석
여기에 카메라의 위치, 축이 월드 스페이스와 일치한다면 따로 변환할 필요가 없다는 아이디어를 추가하면


View 스페이스는 카메라를 기준으로 하는 좌표계이고 카메라의 입장에서 다른 오브젝트는 카메라의 로컬스페이스에서 본다고 할 수 있고 카메라의 월드 변환 행렬의 역행렬을 구하면 
View변환 행렬을 구할 수 있게 됩니다.
 
또는 좀 더 직관적으로 카메라는 가만히 있고 물체를 역으로 이동시키는 방법론으로 보면 카메라가 어느방향으로 이동하는대신 오브젝트가 반대로 움직인다고 보면 카메라의 Translation의 역행렬을 
물체들에게 해준다고 볼 수 있고 카메라의 회전도 마찬가지로 카메라에 연산할 Rotation을 오브젝트에 역행렬로 연산한다고 볼 수 있습니다.
이방법에서 유의 할 점은 역행렬들을 연산할 순서가 S,R,T 순서그대로가 아닌 T의 역행렬 * R의 역행렬 이렇게 반대가 되야 합니다.
이걸 식으로 나타내면 어떻게 표현해야 할지를 생각해보겠습니다. 
Right.x  Right.y  Right.z 0	
  Up.x      Up.y     Up.z  0
Look.x    Look.y   Look.z 0
Pos.x      Pos.y    Pos.z   1
우선 카메라 변환, View 스페이스 변환에서는 오브젝트들의 Scale은 바뀔이유가 없기 때문에 Rotation과 Translation만 보면 됩니다. 그러면 위의 행렬에서는 pos 요소들은 Translation을 담당하는
요소들이고 Right, Up, Look은 Rotation을 담당하는 요소들이라고 나눠서 볼 수 있습니다. 그래서 Rotation행렬과 Traslation 행렬로 나눠서 해석 할수 있는데 
먼저 Rotation행렬은 Pos요소들이 제거된 행렬일겁니다. 그러면 남은 Rotation행렬은 기저벡터로 이루어진 행렬이기때문에 직교행렬의 조건을 만족합니다. 카메라를 기준으로 회전을 했다고 해도 
자기들끼리는 수직인건 변함이 없을겁니다. 그래서 직교행렬인 Rotation행렬은 각 행끼리를 내적을 해도 항상 0이 나온다는 특징이 있습니다.
그리고 직교행렬인 상태에서의 역행렬 구하기는 굉장히 단순한데 행렬의 transpos와 일치합니다. 트랜스포즈는 행렬의 원소들의 행과 열을 뒤바꾼것입니다. 
Rotation 행렬 -> Right.x  Right.y  Right.z  0	Rotation행렬의 역행렬    Right.x   Up.x   Look.x   0
- 직교행렬          Up.x      Up.y     Up.z    0 	- 직교행렬의 역행렬은    Right.y   Up.y   Look.y   0
	         Look.x    Look.y   Look.z  0	   Transpos	        Right.x   Up.z   Look.z   0
		0         0           0     1                                           0         0        0      1	

Traslation의 역행렬은 간단합니다. Transration은 이동한 벡터라고 할수 있고 벡터의 역행렬은 모든 원소에 - 를 붙여주면 됩니다. 
Translation 역행렬  1   0   0   0
	          0   1   0   0
                       0   0   1   0
                      -x  -y  -z   1
이렇게 구한 T의 역행렬, R의 역행렬을 곱하면 View 스페이스 변환 행렬입니다. 카메라의 (-x, -y, -z, 1)이라는 4번째 행은 어떻게 보면 벡터라고 볼수 있고 R행렬의 열도 벡터라고 볼 수 있으니 곱하면 내적입니다.
(T^-1) * (R^-1) =	Right.x   Up.x   Look.x   0
	          	 Right.y   Up.y   Look.y   0
 		 Right.x   Up.z   Look.z   0
		-x·Right  -y·Up   -z·Look  1

이렇게 구한 View변환 행렬이나 카메라의 월드 변환 행렬을 역행렬로 구한 행렬이나 결국 결과는 같을것입니다.

-  (View 변환행렬) = (카메라의 World 변환행렬)^-1 = (카메라의 Rotation 성분과 Translation성분)^-1 = (T^-1)(R^-1)


* 추가 
위의 방법들 외에 또한가지 View 변환행렬 구하는 방법이 있습니다.
C++에서 지원하는 함수인데 

XMMATRIX XM_CALLCONV XMMatrixLookAtLH (FXMVECTOR EyePosition, FXMVECTOR FocusPosition, FXMVECTOR UpDirection);
이런 시그니처를 가진 함수인데 인자들의 설명을 보면 EyePosition은 카메라의 위치를 뜻하고, FocusPosition은 focal point(초점)의 위치, 
UpDirection은 카메라의 Up Dierction(보통 0.0f, 1.0f, 0.0f라고 합니다.)
반환하는 내용은 World Space 에서 View Space로 변환하는 View Matirx를 반환하다고 되어있습니다.

그러면 이 함수는 갑자기 뜬금없이 등장했는지, 이전에 배웠던 내용들과 어떤 관련이 있는지를 보겠습니다.
함수의 동작원리는 먼저 첫번째 인자로 입력해주는 EyePosition은 카메라의 좌표라고 했습니다. FocusPosition은 그 카메라가 주시하고 있는 임의의 점을 말합니다. 카메라가 있으면 찍고 있는 방향이 있을겁니다.
그리고 마지막 인자로 UpDirection을 입력하는데 여기서 말하는 Up은 카메라의 실질적인 Up벡터가 아니라 임의로 정해주는 대략적인 Up벡터를 넣어줍니다.

실제 동작으로 첫번째 Eye에서 Focus로 가는 벡터가 하나 만들어집니다. 카메라 좌표계에서 카메라가 바라보는 방향이 Look벡터라고 했었습니다. 이런 카메라 좌표계의 기저 벡터중 하나인 Look벡터를 
Eye와 Focus를 이은 벡터를 단위벡터로 변환하면 구할 수 있는겁니다. 이제 나머지 Right벡터와 Up벡터를 구하면 됩니다.
다음으로 구할 기저벡터는 Right 벡터인데 먼저 구했던 Look벡터와 함수의 세번째 인자로 넣어준 임의의 UpDirection을 가지고 구할겁니다. 
Look과 UpDirection을 가지고 평면을 만들고 그 평면에 수직한 벡터를 구하면 Right벡터가 됩니다. 즉 Look벡터와 UpDirection벡터의 외적에 수직인 단위 벡터를 구하면 되겠습니다.
이렇게 구한 Look벡터와 Right벡터를 다시 외적해서 수직인 벡터를 구하면 실질적인 카메라의 Up벡터도 구해줄 수 있습니다.

함수로 구한 카메라의 실제 Look, Right, Up 벡터를 가지고 ViewMatrix를 반환해줍니다.
 Right.x   Up.x   Look.x   0
 Right.y   Up.y   Look.y   0
 Right.x   Up.z   Look.z   0
-x·Right  -y·Up   -z·Look  1