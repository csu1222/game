
    GPU와 렌더링 파이프라인에 대한 개론


시작에 앞서 이전 시간의 복습을 다시 해보겠습니다.
게임을 만드는것이 영화를 찍는것과 비슷하다고 했습니다. 
영화와 다른점은 광원이나 빛반사, 물리 효과 같은것들이 실제현상으로 알아서 일어나는데에 비해
게임에서는 전부 하나하나 수학적 계산을 해서 구현해야한다는 겁니다.

당연하게도 게임 화면의 픽셀 하나하나 다 계산하는건 말이 안될 겁니다. 오브젝트가 움직이면 게임 화면에서는 그 움직임을 계산해 2D평면상 픽셀의 색을 
알맞게 변경하면 될것입니다. 


움직임은 게임내의 필드에서의 오브젝트의 움직임 그리고 그걸 찍고있는 일종의 카메라가 출력한 평면화면으로 이루어지는데
오브젝트가 3D공간에서 움직인 경로를 수학적으로 잘 계산해서 카메라가 평면상에 적절하게 움직여줄 것입니다.

그리고 게임에서의 모든 오브젝트들은 대부분 삼각형으로 이루어져 있습니다. 꼭 삼각형이어야 하는건 아닌데 어떤 약속 같은겁니다.
정육면체같은 오브젝트도 한면이 두개의 삼각형을 합쳐서 사각형을 표현하고 이 사각형이 여섯개 모여서 정육면체를 표현합니다.
오브젝트의 움직임을 좌표로 나타내야 하는데 이 삼각형들의 꼭지점 좌표들을 계산해서 연속적으로 움직이게끔 합니다.

게다가 하나의 오브젝트만 있는것이 아니라 앞뒤로 나란히 있다면 카메라는 앞의 오브젝트가 가린 만큼을 표현해야합니다. 
즉, 좌표를 계산하고 오브젝트간의 위치까지 계산해서 평면상 모니터에 색깔을 입혀줘야 하겠습니다.


어찌저찌 해서 모든 삼각형의 꼭지점의 좌표들의 움직임과 광원에 따른 색변화들을 계산하는 수식을 알아내서 화면에 표시해준다고 해봅시다.
하지만 수식만 안다고 해서 다 되지는 않을것입니다. 보통 게임에는 수만은 캐릭터와 물체들과 배경과 투사체같은 것이 있을건데 이 모든 오브젝트들의 좌표와
색을 조절하는것 뿐만아니라 초당 수십번을 계속해서 갱신해줘야 할 것입니다. 분명히 사람이 할수 있는 일은 아닙니다.

게임이라는 영화 감독으로써 화면을 표현하는것뿐만 아니라 여러가지 규칙들도 영화감독의 역할입니다. 대화, 전투, 길찾기 등등의 규칙들 말입니다. 

기쁜소식으로 자본주의에서는 어려운 일들은 모두 외주를 맞길수 있을것입니다. 게임에서도 그래픽적인 작업들은 GPU에거 맡기고 규칙같은 계산은 CPU에게 맡기면 될것입니다.


cpu와 gpu의 차이점에 대해 간단하게 알아보면 

cpu의 경우 고오급 인력이라고 생각을 하면됩니다. 복잡한 연산을 잘하고 뛰어난 기억력을 가지고 있습니다. ALU라고 하는 실제 계산을 담당하는 부분이 갯수가 많지 않는다는걸 알수 있습니다.
개개인은 뛰어난 소수 입력 집단이라고 볼 수 있습니다.
서류작업이나 게임이나 여러 작업들에 전부 관여하는게 CPU입니다. 어떤 연산이 이후의 연산에 영향을 주고 연산을 이어나가는 작업을 담당합니다.

gpu는 각 부품들의 성능은 떨어지지만 엄청난 갯수의 ALU가 모여있습니다. 계산기같이 단순계산만은 정말 잘할수 있는 것입니다. 사람이 많은 인력사무소라고 할수 있겠습니다.
복잡한 계산능력이 필요없지만 많은 양의 작업을 처리해내는데 특화되어있습니다.
서로 연관이 없는 작업들을 병렬로 처리를 합니다. 대표적으로 암호학, 인공지능, 비트코인채굴 같은 것입니다. 여러 연산이 서로에게 영향을 주지 않는 연산(경우의 수 같은)걸 담당합니다.


다시 게임으로 돌아가서 얘기해보면

gpu가 그래픽을 맡는게 왜 좋은가? 그래픽적으로 각 오브젝트들은 일단 서로에게 영향을 주지않는 것들이고 이런 작업을 계산하는데 cpu를 쓰기보다는 gpu가 더 적절하게 일을 할 수 있을것입니다.
이름에서부터 알수 있듯이 그래픽스 처리를 하기위한 부품입니다. 모니터에 출력될 각 픽셀들을 병렬적으로 계산하는데 능합니다. 

그래도 gpu가 메모리 정보들을 토대로 화면을 만들기 위한 단계를 렌더링 파이프라인이라고 합니다. 굉장히 여러가지 개념들로 이루어져 있는데 앞으로 하나씩 알아가 보겠습니다.

간략하게 알아보면
1) input-Assembler : 정점 정보를 전달하는 단계 
2) Vertex Shader : 소위 VS의 약자 input-Assembler가 넘겨준 정점 정보를 기반으로 계산이들어간다 , 요약하면 정점 변환을 해준다.
3) Hull Shader, Tessellator, Domain Shader : DirectX11 에서 추가된 단계 , 새로운 정점들을 생성할때 사용
4) Geometry Shader : DirectX10 에서 추가된 정점 추가 단계
5) Rasterizer : 좌표, 색들이 계산된 정점들을 가지고 픽셀로 적절히 삼각형을 표현 단계 
6) Pixel Shader : 만들어진 삼각형들을 마지막으로 색상변경해주는 단계
7) Output-Merger : 마무리 단계


마지막으로 cpu와 gpu사이에서 데이터를 주고받으면서 게임 화면을 만들것입니다. 그런데 gpu도 각 제조사마다 사양이 다를텐데 각 부품마다 다시 규칙을세우는거는 
비효율적일 겁니다. 그래서 마이크로 소프트에서 DirectX 라는 gpu 전용 라이브러리를 배포 하고 gpu제조사가 DirectX의 사양에 맞춰 만들게 됩니다.


