

        29. 직교 투영


바로 이전에 배운 쿼터니언의 적용은 일단 나중으로 미루고 먼저 직교투영에 대해 배워보겠습니다. 

직교투영은 원근투영과 함께 투영 정책중 하나라고 했습니다. 

예전에 그래픽스 파이프라인의 행렬의 변환에 대한 얘기를 하면서 로컬 -> 월드 -> 뷰 -> 프로젝션 -> 스크린 순으로 행렬 변환을 해주었습니다.
이중에 뷰 스페이스에서 프로젝션 스페이스로 넘어갈때 물체와 카메라 사이의 거리 z 값을 가지고 비율로써 투영을 했었습니다. 이게 원근 투영입니다. 

그런데 모든걸 다 원근 투영으로 만들수는 없고 우리가 UI를 만들때는 직교투영을 가지고 만들겁니다.

- UI 에 대해
UI에 대해 알아보겠습니다. 3D 게임에서 UI (User Interface) 는 2D UI 와 3D UI 가 있습니다. 
3D UI 의 경우는 쉽게 말해서 지금까지 3D 게임에 배치한던 게임 오브젝트처럼 메쉬같은걸로 만들어 게임에 배치를 하고 카메라가 바라보는 각도나 거리에 따라 
커질 수도 있고 작아질 수도 있습니다. FPS 게임에서 핑을 찍는것 같은 UI 가 예시입니다. 
이런 경우에는 UI 이긴 하지만 기존에 만들던대로 그대로 원근 투영법으로 만들면 됩니다. 

반면 2D UI 의 경우 예를들어 롤의 초상화와 스킬창, 아이템창 같은것이나 와우의 단축키들 같은 UI 입니다. 카메라가 어떻게 움직이든 이 UI 는 화면에 항상 고정적인 위치에
출력이 됩니다. 그래서 UI의 크기를 화면에 고정적으로 위치하도록 만드는 투영법이 직교 투영 입니다. 

원근투영과 직교투영의 차이점은 원근 투영은 투영이 될 공간인 카메라의 촬영범위가 절두체(사각 뿔 에서 윗부분이 잘린 형태) 의 투영될 화면부터 점점 넓어지는 형태이고,
직교 투영은 투영될 화면에서 넓어지지 않고 거의 큐브가 직사각형이 된것처럼 평탄한 투영 공간을 가지고 있습니다. 

이 의미는 어떤 물체이건간에 깊이 값이 물체의 투영크기에 별 영향을 주지 않고 그저 어떤 물체가 앞에 있는지만 판별하는 용도로 깊이 값이 사용될것입니다.

이 원리는 비교적 단순하기 때문에 직접 만드는 것도 비교적 단순 할것입니다. 

- 직교투영 수학적 접근

투영된 결과물은 윈도우 창의 넓이와 높이만큼을 일치 시켜줄 것인데 넓이를 width 줄여서 w, 높이를 height 줄여서 h 라고 하겠습니다. 
보통 투영될 화면크기를 윈도우와 일치시키고 시작을 합니다. 한가운데의 점 O 가 있고 화면위의 임의의 점(x,y) 라는 좌표를 가지고 있는점을 표현할때 이 정점을 좌표변환을 해줘서 
최종적으로 -1 ~ 1 사이의 가로 세로 0 ~ 1 사이의 깊의의 투영좌표계로 변환을 해줘야 한다는건 변함이 없습니다.

예를들어 지금 우리가 만들고 있는 프로그램이 800 x 600 이니까 w = 800 , h = 600 이라고 해보겠습니다.
투영전 화면의 원점에서 오른쪽 끝까지의 길이가 w 의 절반인 w/2 일것이고 위쪽으로는 h/2 일것입니다. 그러면 오른쪽 위 모서리의 경우 좌표가 (w/2, h/2) 인데 이게 
변환이 되면 (1,1) 이되도록 하면 되는것입니다.

어떻게 하면 비율을 맞춰줄 수 있을지 궁리를 해보면 임의의 점 (x,y) 에서 화면의 크기가 800 x 600 이었으니까 이 화면의 오른쪽 위 끝의 점의 좌표가 원점기준으로 (400, 300)
이라는 이야기고 이게 투영 변환을 한 결과가 (1, 1) 이어야 한다는 말입니다. 그러면 이 경우에는 변환전 좌표의 각 x,y 값에다가 w/2 , h/2 를 나눠주면 변환이 된다는 말이 됩니다.
w/2, h/2 를 나눠준다는 다르게 표현하면 2/w, 2/h 를 곱해준다도 될것입니다.
z 값 같은 경우에는 조금더 까다롭긴 한데 카메라 촬영 범위에는 near와 far 라는 최소 거리, 최대 거리 개념이 있습니다. z 값이 뷰 스페이스에서 near 와 far 사이에 있을때 
이게 0 ~ 1 사이의 깊이 값으로 나와야 하니까 
 z ->  (z/(f-n)) - (n/(f-n)) 이렇게 계산해야 합니다. 
얼핏 보기에는 복잡해보이는데 z 값에 n 을 대입하게 되면 0이라는 값이 나오고 f를 대입하게 되면 1이라는 값이 나옵니다. 각각 최소, 최대 거리를 나타내고 있으니까 잘 맞는것입니다.

최종적으로 위의 원리를 이용해서 변환 행렬을 만들어 주면 이렇게 됩니다. 
    2/w    0     0    0
     0    2/h    0    0
     0     0  1/(f-n) 0 
     0     0 -n/(f-n) 1 
이렇게 결과가 생각보다 간편합니다. 

원근 투영의 변환 행렬은 z 값 거리에 따라 물체의 크기인 x,y 값도 달라져야하고 화면비율인 w/h 에 따라 x 값도 보정해야 하고 카메라의 촬영하는 시야 각도 pov 에따라 다시 
x,y 값을 보정해야 하고 가장 큰 이유는 x,y를 z 로 나눠야 하는데 이게 하나의 행렬로 처리가 되지 않기때문에 z값을 w 위치에 보전하고 레스터라이즈 단계에서 한번더 전체를 w 값으로 
나눠주는 연산을 해야 했습니다.

직교행렬은 이런것 없이 그저 화면 넓이, 높이, near, far 만 신경쓰면 되는 쉬운 행렬이 만들어 집니다. 
그리고 이 행렬을 코드에서 직접 만들수도 있지만 이미 만들어져있는 함수들이 다 있습니다.

또 한가지 눈여겨 볼 점은 직교 투영에서의 카메라는 pov 시야각이라는 것이 없습니다. 그냥 w,h,n,f 네가지 정보를 가지고 있습니다.

- 직교 투영 코드 적용 

1) 셰이더 확장자 수정 
오랜만에 비쥬얼 스튜디오를 실행했습니다. 오늘의 주제인 직교투영을 구현하기에 앞서 우선 정리할 것이 있는데 

셰이더 파일들을 처음에 만들때 그냥 추천 해주는 대로 확장자를 hlsli 로 만들었습니다. 우리가 CPP 코드를 작성할때 헤더 파일과 CPP 파일을 나눠서 관리하듯이 
셰이더도 마찬가지로 관리하는데 hlsli 는 셰이더의 헤더 파일같은 역할을 하는게 맞습니다. 지금 우리 코드에서는 params.hlsli 는 헤더 파일 처럼 사용하기 때문에 용도에 맞지만 
다른 셰이더 파일을 사실 맨뒤의 i 를 때줘야 맞습니다.

그리고 셰이더의 확장자를 정리하는것에 대한 장점이 있는데 지금까지 처럼 hlsli 확장자로 셰이더를 관리하면 셰이더 코드에 오타가 나도 빌드를 하면 아무 에러없이 빌드가 되버립니다. 
에러가 안뜬다고 좋아할게 아니라 컴파일러가 잡을 에러를 내가 직접 잡아야 하는것입니다. 근데 이것을 hlsl 이나 fx 같은걸로 바꿔주면 비쥬얼 스튜디오에서 셰이더 코드도 인식해서 
같이 체크를 해주게 됩니다. 이런 오타나 에러를 잡아주지 않는 IDE 는 사실 그냥 메모장과 다름없을것입니다.

그래서 조금 늦은 감이 있지만 셰이더 확장자를 정리 해줄건데 확장자를 hlsl 도 되고 fx 도 인식을 하니까 둘중 하나로 바꿔줄겁니다. (여기서는 fx로 하겠습니다.)
셰이더 코드 중에 서로를 불러오고 있는 부분도 꼼꼼히 수정해주었습니다. 

이러고 속성으로 가면 맨밑에 어떤 내용이 추가 되야 하는데 안되어있습니다. 셰이더 파일들을 프로젝트에서 지웠다가 다시 추가 해주니 정상적으로 나오고 있습니다.
HLSL 컴파일러 라는 속성이 추가 되었습니다. 
이 속성중에 셰이더 모델을 골라주는 부분이 있는데 지금 우리는 5.0을 사용하고 있으니 골라주었습니다.
빌드를 해보면 'main': entrypoint not found 라는 에러 메세지가 뜹니다. HLSL 의 셰이더 형식을 fx로 골라준 다음 다시 빌드를 했습니다. 

다시 에러메세지가 뜹니다. unrecognized identifier 'LightColor' 
이건 utils.fx 에서 CalculateLightColor 라는 셰이더 함수를 만들어 줄때 반환 타입으로 LightColor 라는 우리가 만든 타입을 반환하는데 이 LightColor 가 무었인지 모르고 
있어서 뜨는 메세지입니다. utils 에도 params.fx 를 include 해주면 됩니다.
이러면 이제 빌드 성공 했습니다. 

셰이더 확장자를 바꾼걸 CPP 코드쪽에도 수정을 해줘야 합니다. ctrl + f 로 hlsli 를 찾아서 모두 fx로 바꿔 줍니다.

이렇게 간단한 셰이더 파일 확장자 정리를 해봤는데 
오늘의 주제가 셰이더 파일이 아니었습니다. 본격적으로 오늘의 주제의 실습으로 들어가보겠습니다. 

2) 직교 투영 실습
직교 투영이 사용되는 부분이 UI 가 대표적이라고 했었습니다. 실습도 UI를 만들어보면서 UI에 직교투영을 적용해보는 방햐으로 가면 좋을 것 같습니다. 

어떤 방식으로 원근투영과 직교투영을 한번에 적용 시키는지를 생각해보면 카메라 자체를 하나더 만들어 한 카메라는 원근투영, 다른 한 카메라는 직교투영을 적용시킨다음 
카메라가 렌더링한 두 결과물을 합쳐서 표현하는 방법으로 해볼겁니다. 

두 카메라를 사용해서 UI를 적용하려면 원근투영 카메라는 UI를 제외한 나머지 게임 오브젝트들을 투영해야 하고 직교투영 카메라는 UI만을 투영해야하는데 
카메라에게 이 오브젝트가 UI 인지 아닌지를 어떻게 구별하냐면 '레이어' 라는 개념을 둔다고 합니다. 
게임오브젝트마다 레이어를 가지고 있을거고 카메라가 자기가 찍을 레이어를 알면 해당하는 레이어의 게임 오브젝트만을 찍어줍니다. 

2-1) 레이어 
유니티에서는 참고로 레이어가 32개가 있습니다. 그렇기 때문에 우리 프로젝트에서도 32개의 레이어를 두겠습니다. 위치는 SceneManager.h 의 클래스 선언부 위쪽에 enum으로 
정해주겠습니다. 
(SceneManager.h)
enum
{
	MAX_LAYER = 32,
};

그런데 이 32개의 레이어들을 부르거나 체크할때 레이어1, 레이어2... 같이 숫자로만 붙여서 관리하면 해당하는 레이어가 무슨 용도인지 알기 어렵습니다. 
비슷한 용도의 게임 오브젝트들을 한 레이어로 모아서 관리할것이기 때문입니다. 

이런 이유로 각 레이어에 이름을 붙여줄건데 enum class 로 하나씩 이름을 지어줘도 괜찮겠지만 하나의 레이어 마다 스트링 하나씩을 매핑해줄겁니다.
왜 enum class 로 만들지 않는가는 지금 만드는건 게임엔진이고 나중에 진짜 게임을 만드는것은 클라이언드 단에서 해줄 일인데 
게임 컨텐츠에 따라 어떻게 활용할지를 아직 모르고 있기 때문에 지금 enum class 로 다 만들어 주진 않을겁니다.

레이어를 SceneManager 에다가 만들어 줄겁니다. 사실 SceneManager 에서 레이어를 관리하는게 좀 어색하긴하지만 이번시간의 실습에 잠깐 사용하기 위해 임시적으로 이곳에 
만들어 줍니다. 

SceneManager
{
// 멤버 변수
private:
	shared_ptr<Scene> _activeScene;

	array<wstring, MAX_LAYER> _layerNames;
	map<wstring, uint8> _layerIndex;
}

array 로 배열을 만들어 주고 있는데 타입은 wstring 문자열이고 배열의 크기는 enum으로 만들었던 MAX_LAYER = 32 만큼의 배열을 만들어 줬습니다. 이름은 _layerNames 입니다.

그리고 그 밑에 map 을 만들어 주고 있습니다. map은 키와 밸류가 페어로 된 데이터를 담는 방법이었습니다. 
map 의 key 는 문자열인데 _layerNames 의 원소들인 레이어의 이름이 key가 되고 각 이름에 매칭되는 uint8 은 만들 레이어의 인덱스를 알려줍니다. 이름은 _layerIndex 입니다. 

이 _layerNames, _layerIndex 두개로 레이어에 이름을 붙혀주고 그 이름으로 레이어의 인덱스를 알수 있습니다. 

다음으로 이 레이어를 활용할 함수들을 만들어 줍니다. 

SceneManager
{
        // 멤버 함수
public:
	void SetLayerName(uint8 index, const wstring& name);
	const wstring& IndexToLayerName(uint8 index) { return _layerNames[index]; }
	uint8 LayerNameToIndex(const wstring& name);
}

각 함수의 용도는 
SetLayerName 인덱스로 사용할 uint8 과 이름으로 사용할 문자열을 받아서 해당 인덱스에 이름을 설정해주는 함수
IndexToLayerName 인덱스로 사용할 uint8 을 받아서 해당하는 인덱스의 이름을 _layerNames[index] 로 리턴하는 함수 
LayerNameToIndex 이름으로 사용하고 있는 문자열을 받아서 그 문자열을 키로 가지고 있는 map 원소의 밸류인 uint8 을 리턴하는 함수

SetLayerName 과 LayerNameToIndex 의 구현부입니다. 

void SceneManager::SetLayerName(uint8 index, const wstring& name)
{
	// 기존 데이터 삭제
	const wstring& prevName = _layerNames[index];
	_layerIndex.erase(prevName);

	_layerNames[index] = name;
	_layerIndex[name] = index;
}

uint8 SceneManager::LayerNameToIndex(const wstring& name)
{
	auto findIt = _layerIndex.find(name);
	if (findIt == _layerIndex.end())
		return 0;

	return findIt->second;
}

코드는 간단한데 SetLayerName 은 인자로 받은 index의 해당하는 _layerNames 을 prevName 변수로 만들어서 _layerIndex 의 키로 prevName 을 사용해서 지워줍니다. 
해당 인덱스를 가진 map 원소가 있으면 갱신하기 위함입니다. 그다음을 인덱스와 이름을 맵핑해서 _layerIndex, _layerNames 를 각각 채워주고 있습니다. 

LayerNameToIndex는 map 에서 원하는 원소의 밸류를 가져오기 위한 코드인데 인자로 받은 이름과 일치하는 키를 가지고 있는지를 find로 찾아주고 있고 그 이터레이터가 
만약 end 와 같다 즉 없다면 0을 리턴하고 아니라면 if 문을 빠져나와서 찾은 이터레이터의 second를 리턴합니다. map은 각각의 원소가 pair로 첫번째가 키 두번째가 밸류입니다.

SceneManager 에서 레이어들을 세팅하고 들고 있게 되었는데 다음으로 할 일은 각 게임오브젝트들이 자기가 어떤 레이어에 속해있는지를 알고 있어야 하기에 
GameObject 클래스를 보겠습니다.

GameObject 
{
private:
        uint8 _layerIndex = 0;
}
기본적으로 0번 레이어로 설정해놓았는데 레이어를 들고 있는 방법이 생각보다 아주 단순하다는걸 알 수 있습니다. 이렇게 만들어주면 한 게임 오브젝트는 한번에 하나의 레이어만 
들고 있을수 있습니다.

그리고 이 레이어 인덱스를 가져오고 설정할 멤버 함수를 만들어 줬습니다. 
GameObject
{
	void SetLayerIndex(uint8 layer) { _layerIndex = layer; }
	uint8 GetLayerIndex() { return _layerIndex; }
}
이러면 어떤 게임 오브젝트이건간에 자신의 레이어를 설정할 수 있고(Set) 자신의 레이어가 무엇인지 알수 있습니다. (Get)
게임 오브젝트들이 레이어 정보를 들고 있을때 이제 카메라가 이 레이어 정보에 따라 찍을 오브젝트인지 걸러 낼 수 있어야 합니다. 

그래서 카메라 클래스로 가보겠습니다.
카메라는 거꾸로 찍어줄 게임 오브젝트가 어떤 레이어에 있는지를 알면 됩니다. 그런데 게임 오브젝트는 하나의 레이어만 들고 있는것에 비해 
카메라는 꼭 하나의 레이어만 들고 있어야 하는것은 아닙니다. 예를 들어 카메라 하나가 여러게의 레이어들을 한번에 찍을 수 도 있습니다.

그렇기 때문에 카메라에서 레이어는 비트 플레그로 관리할것입니다. 
Camera
{
pirvate:
	uint32 _cullingMask = 0;
}
멤버 변수에 컬링 마스크 라는 이름으로 만들어 줬습니다. 실제로 유니티에서도 이 카메라에서 관리하는 레이어를 같은 이름으로 사용하고 있다고 합니다. 
그러면 이 컬링 마스크라는것이 어떤 원리인지를 알아보겠습니다. 

프로그래머용 계산기를 보면 우리가 만든 컬링 마스크는 32비트 짜리로 만들었었으니 DWORD 로 비트계산기를 설정하면 이제 32 개의 0 들이 나열되어 있을겁니다. 
이 32개의 비트를 어떻게 해석하는지는 우리 마음인데 이걸 int 로 해석하면 정수가 되는것이고 float 로 계산하면 실수가 되는겁니다. 
지금은 이 비트들을 각 자리수의 레이어들이라고 해석하고 각 비트가 해당하는 레이어를 컬링 해야 할지 아닐지를 얘기하는겁니다. 
예를들어 실습에서 UI 레이어를 1번으로 사용할것인데 어떤 카메라의 1번 인덱스에 해당하는 비트가 켜져있으면 이 카메라는 UI를 찍지 않겠다는 의미입니다. 

하여튼 이런 컬링 마스크를 가지고 카메라에서 레이어를 관리 해줄것인데 이 컬링 마스크를 사용하기 위한 헬퍼 함수들도 만들어 주겠습니다.
Camera
{
public:
	void SetCullingMaskLayerOnOff(uint8 layer, bool on)
	{
		if (on)
			_cullingMask |= (1 << layer);
		else
			_cullingMask &= ~(1 << layer);
	}

	void SetCullingMaskAll() { SetCullingMask(UINT32_MAX); }
	void SetCullingMask(uint32 mask) { _cullingMask = mask; }
	bool IsCulled(uint8 layer) { return (_cullingMask & (1 << layer)) != 0; }
}
SetCullingMask 부터 보면 변수로 만들어 뒀던 _cullingMask를 인지로 받은 uint32 로 바꿔주고 있습니다. 
그리고 SetCullingMaskAll은 SetCullingMask의 인자로 UINT32_MAX 를 줘서 호출하는 함수입니다. UINT32_MAX는 32 비트중에 가장큰 숫자이므로 모든 비트들이 켜져 있습니다.

특정 비트만 활성하고 싶다면 SetCullingMaskLayerOnOff 함수를 사용하면 되는데 인자로 받는것은 어떤 레이어를 킬것인가와 킬것인지 끌것인지를 bool로 받아줍니다. 
방법은 비트플레그 연산인데 _cullingMask 에게 |= 를 해주고 있습니다. 뜻은 or 입니다. 원래의 _cullingMask 의 비트와 키고 싶은 레이어의 비트를 비교해서 켜져 있지 않다면 
켜줍니다. 레이어를 골라주는 방법은 비트 1 을 일단 키고나서 쉬프트를 인자로 받은 layer 만큼 해줍니다. 이 비트와 _cullingMask 를 or 해주면 해당 비트가 켜집니다. 
반대로 끌때는 해당 레이어의 ~ (NOT) 을 해주고 &= 로 AND 를 해주면 해당 비트를 꺼줄수 있습니다. 

이렇게 _cullingMask 를 설정하는 함수들을 사용하고 난 다음 컬링이 될지를 판별해주는 함수인 IsCulled 함수가 있습니다. 인자로는 uint8 layer 를 받고 있습니다. 
_cullingMask 와 layer 만큼 왼쪽으로 쉬프트한 1 비트를 & 하고 그 값이 0이 아닌지를 판별합니다. 

다음은 이번시간의 주제인 직교투영에 관련된 코드입니다. 현재 카메라 클래스는 자신의 타입을 PROJECTION_TYPE _type = PROJECTION_TYPE::PERSPECTIVE;
이렇게 고정적으로 PERSPECTIVE 원근 투영으로만 들고 있었는데 이번에 직교투영과 원근투영 둘중 하나를 설정할수 있도록 헬퍼 함수를 만들겠습니다. 
Camera
{
public:
	void SetProjectionType(PROJECTION_TYPE type) { _type = type; }
	PROJECTION_TYPE GetProjectionType() { return _type; }
}
아주 간단한 Get, Set 함수입니다. 

이제 컬링을 구현하겠습니다. 컬링은 이전에 프러스텀 컬링을 적용하면서 추가한 기능입니다. 이 기능은 Camera::Render 에서 작동하고 있었습니다. 
Render 함수 안에서 Scene 안의 게임오브젝트를 순회하면서 프러스텀 컬링을 할지를 체크해주고 있습니다. 이 프러스텀 컬링 부분이 무겁기 때문에 
그전에 먼저 레이어로 컬링을 해주겠습니다. 
Camera::Render
{
		if (IsCulled(gameObject->GetLayerIndex()))
			continue;	
}
간단한 코드입니다. 이미 게임 오브젝트에 만들어놨던 GetLayerIndex 함수를 이용하였습니다. 가져온 레이어 인덱스가 현재 카메라가 찍을 레이어인지 if 해주고 있습니다. 

또 한가지 Camera 에서 살펴볼것은 Camera::FinalUpdate 부분인데 이전에 Camera를 원근투영 기본으로 만들면서 스킵했던 부분인데 
카메라의 투영 타입이 ORTHOGRAPHINC 일 때 프로젝션 변환 행렬을 만드는 코드를 보겠습니다. 
_matProjection = ::XMMatrixOrthographicLH(width * _scale, height * _scale, _near, _far);

원근 투영 변환 행렬을 만들기 위해 필요한 인자가 fov, width/height, near, far 인 반면 직교 투영에서는 width, height, near, far 인것은 
위의 수학적 증명에서 알아 봤던대로 입니다.

지금 카메라에서 업데이트하는 _matView, _matProjection 행렬들은 외부의 객체에서도 사용하기 쉽도록 임시적으로 static 변수 S_MatView, S_MatProjection 을 만들어서 
사용하고 있습니다. 그리고 이 스태틱 행렬들을 Camera::FinalUpdate 에서 갱신해주고 있는데 
각 카메라 객체마다 갱신되는 일반 멤버 변수들과 달리 스태틱 멤버 변수들은 카메라 객체가 여러개 있을시에 마지막에 갱신된 변환 행렬이 적용되어 버립니다. 
그래서 이 스태틱 변수들을 갱신하는 위치를 옮겨주겠습니다. 
어디로 이동하냐면 Camera::Render 의 맨 윗부분으로 옮겼습니다. 카메라 마다 행렬을 갱신을 다 하고 난 후에 렌더링을 시작하는 시점에 각각 변환행렬을 스태틱에 담아서 실행합니다.

이렇게 카메라 코드까지 완료되었고 

다음은 물체들을 하나씩 만들어 보겠습니다. 지금은 스카이박스와 큐브만 하나 있는데 레이어를 적용시키고 직교투영을 적용시키키위해서는 물체 하나로는 실험을 못합니다.

물체를 만드는 부분은 SceneManager::LoadTestScene 이었습니다.
우선 LoadTestScene 에 들어오는 순간에 레이어를 설정해주겠습니다. 
SceneManager::LoadTestScene
{
#pragma region LayerMask
	SetLayerName(0, L"Default");
	SetLayerName(1, L"UI");
#pragma endregion
}

이전에 만들었던 카메라 오브젝트에서 추가할 코드가 있습니다. 테스트에서 기존 카메라는 원근 투영으로만 물체를 찍고 싶고 UI는 찍기 싫습니다. 그래서 

		uint8 layerIndex = GET_SINGLE(SceneManager)->LayerNameToIndex(L"UI");
		camera->GetCamera()->SetCullingMaskLayerOnOff(layerIndex, true); // UI는 안 찍음
이런식으로 uint8 layerIndex 라는 스택내 변수를 만들어서 SceneManager 에서 먼저 만들었던 LayerNameToIndex 로 레이어 이름을 주고 인덱스를 저장합니다. 
그 후 카메라의 SetCullingMaskLayerOnOff 함수로 만들었던 layerIndex 와 true 를 인자로 줘서 UI를 컬링하겠다고 설정했습니다.

다음으로 원래 있던 카메라 말고 UI를 촬영할 카메라를 하나더 만들어줘야합니다. 
#pragma region UI_Camera
	{
		shared_ptr<GameObject> camera = make_shared<GameObject>();
		camera->SetName(L"Orthographic_Camera");
		camera->AddComponent(make_shared<Transform>());
		camera->AddComponent(make_shared<Camera>()); // Near=1, Far=1000, 800*600
		camera->GetTransform()->SetLocalPosition(Vec3(0.f, 0.f, 0.f));
		camera->GetCamera()->SetProjectionType(PROJECTION_TYPE::ORTHOGRAPHIC);
		uint8 layerIndex = GET_SINGLE(SceneManager)->LayerNameToIndex(L"UI");
		camera->GetCamera()->SetCullingMaskAll(); // 다 끄고
		camera->GetCamera()->SetCullingMaskLayerOnOff(layerIndex, false); // UI만 찍음
		scene->AddGameObject(camera);
	}
#pragma endregion

게임오브젝트 객체를 생성하고난 다음 Object 클래스 부터 상속받은 이름짓는 함수 SetName입니다. 컴포넌트로 트랜스폼과 카메라를 추가해줬습니다. 
SetLocalPosition 으로 로컬 포지션을 설정해주었고 
기본카메라와 다르게 SetProjectionType 으로 ORTHOGRAPHIC 직교 투영으로 투영 타입을 설정해주었습니다.
이 UI 카메라는 UI만 찍고 싶기 때문에 SetCullingMaskAll 로 모든 비트를 켜준다음 UI에 해당하는 레이어 인덱스만 off 해줘서 UI 만 찍도록 해주었습니다. 

지금처럼 카메라를 두개를 만들었는데 신기하게도 결과물은 두 카메라가 렌더링한게 잘 합쳐져서 나오게 될겁니다. 

UI 오브젝트를 만들기 전에 정리할 코드가 있습니다. 
셰이더와 텍스쳐를 초기화 해주는 부분입니다. 이 코드들은 각각의 객체를 생성하고 초기화하는 과정이 있습니다. 그런데 이 부분은 기본적으로 묶어서 처리해도 되는 부분입니다.
각 객체를 make_shared 로 설정하는것이 아니라 ResourceManager 로 로딩하도록 수정하겠습니다. 그리고 셰이더도 매번 만들어줄 필요없이 공통적으로 활용하는 셰이더가 있습니다.
지금까지 만들었던 셰이더들은 내장셰이더, 항상 들고 있어야할 셰이더라고 할 수 있습니다. 
그래서 이 것들은 특별히 한번에 다 들고 있도록 
Resources 클래스로 가보면 
Resources
{
public:
	void init();	
private:
	void CreateDefaultShader();
}
이렇게 함수 두개를 만들어 줄건데 init 함수에서는 그냥 밑의 함수인 CreateDefaultShader 를 실행하는 기능만 들어있습니다.
void Resources::Init()
{
	CreateDefaultShader();
}
CreateDefaultShader 의 구현부는 이렇습니다.
void Resources::CreateDefaultShader()
{
	// Skybox
	{
		ShaderInfo info =
		{
			RASTERIZER_TYPE::CULL_NONE,
			DEPTH_STENCIL_TYPE::LESS_EQUAL
		};

		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->Init(L"..\\Resources\\Shader\\skybox.fx", info);
		Add<Shader>(L"Skybox", shader);
	}

	// Forward (Forward)
	{
		ShaderInfo info =
		{
		};

		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->Init(L"..\\Resources\\Shader\\forward.fx", info);
		Add<Shader>(L"Forward", shader);
	}
}
스카이박스와 포워드 부분으로 나뉘는데 포워드가 뭐냐면 우리가 처음부터 사용하던 default.fx 입니다. 다음시간 내용이긴 한데 이번시간에 이름을 forward로 바꿔주었습니다. 

스카이박스에서 ShaderInfo 를 만들고 포워드에서는 빈 상태로 두고 있습니다. 

이런 함수들을 만들어두면 Resources.init() 을 하게되면 미리 셰이더들을 만들어 둔 다음 필요에따라 가져다가 쓰면 되겠습니다.
그러면 이 리소스 초기화를 어디서 해주냐면 엔진 클래스의 Init 함수에서 해주겠습니다. 
Engine::Init 안에 타이머와 인풋 초기화 해주는 부분 다음에 리소스도 초기화 해주고 인클루드도 해주었습니다. 

이렇게 까지 셰이더를 정리 했으니까 다시 SceneManager 로 돌아가보면 셰이더를 사용하는 게임오브젝트 중에 스카이박스 오브젝트를 예로 들어서 
이전에는 셰이더를 로딩하는데 이런 코드를 사용했었습니다.
			shared_ptr<Shader> shader = make_shared<Shader>();
			shader->Init(L"..\\Resources\\Shader\\skybox.fx",
				{ RASTERIZER_TYPE::CULL_NONE, DEPTH_STENCIL_TYPE::LESS_EQUAL });
이 코드가 오늘 한 정리로 이렇게 바뀝니다. 

			shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Skybox");
이렇게 셰이더를 게임오브젝트를 만들때마다 새로 생성,초기화를 해줄 필요없이 프로그램 시작할때 로딩해놨던걸 가져다 사용하면 되게끔 수정하였습니다. 

텍스쳐도 비슷하게 만들어 줄겁니다. 

			shared_ptr<Texture> texture = GET_SINGLE(Resources)->Load<Texture>(L"Sky01", L"..\\Resources\\Texture\\Sky01.jpg");
이런 결과물이 나오게 만들어 주겠습니다. 

이 코드에서 Resources 의 Load를 해주고 있는데 코드는 이렇습니다. 
template<typename T>
inline shared_ptr<T> Resources::Load(const wstring& key, const wstring& path)
{
	OBJECT_TYPE objectType = GetObjectType<T>();
	KeyObjMap& keyObjMap = _resources[static_cast<uint8>(objectType)];

	auto findIt = keyObjMap.find(key);
	if (findIt != keyObjMap.end())
		return static_pointer_cast<T>(findIt->second);

	shared_ptr<T> object = make_shared<T>();
	object->Load(path);
	keyObjMap[key] = object;

	return object;
}
템플릿을 이용한 함수라서 Inline 함수로 만들었는데 해석해보면 인자로는 key 와 path 라는 문자열 두개를 받고있습니다. 
내용으로 들어가서는 Load 함수를 실행할때 준 타입을 템플릿으로 받아서 해당 타입의 GetObjectType 함수를 호출합니다. 이 함수는 Object 클래스에서 관리하고 있는 
enum class 인데 Object를 상속 받는 클래스들에 번호를 매긴겁니다. 그래서 해당 타입의 오브젝트 타입을 objectType 이라는 변수에 받았습니다. 
다음 keyObjMap 변수는 Resources 클래스에서 선언한 using 문법인데 Object 객체를 값으로 삼는 map을 줄여서 부르기 위한 것입니다. 
	using KeyObjMap = std::map<wstring/*key*/, shared_ptr<Object>>;
변수에는 _resources 라는 배열의 원소를 꺼내오고 있습니다. _resources 는 keyObjMap 타입을 OBJECT_TYPE의 갯수만큼 들고 있는 배열인데 각 map은 같은 타입의 오브젝트를 
각각 key, 이름을 붙여서 관리하고 있습니다. 
std find 함수로 map에 인자로 받은 key 에 해당하는 내용물이 있는지를 체크해서 있다면 그걸 반환하고 없다면 새로 만들어서 반환하고 있습니다. 
이때 새로 만드는 함수가 object->Load(path) 함수인데 지금 수정하려는 Texture 클래스에서는 그 역할을 Init 함수가 해주고 있습니다. 
이 Init 함수를 Object 부터 상속받은 Load 함수로 오버라이드 해주겠습니다. 
Texture 
{
	void Init(const wstring& path);
	에서 
	virtual void Load(const wstring& path) override;
	로 수정
}
잊지말고 Init의 구현부도 이름을 Load 로 바꿔줘야합니다.

다시 결과물을 보면 
			shared_ptr<Texture> texture = GET_SINGLE(Resources)->Load<Texture>(L"Sky01", L"..\\Resources\\Texture\\Sky01.jpg");
수정한 결과로 프로그램에서 Sky01 이라는 이름의 Texture 를 처음 로드한다면 생성해서 Resources 의 _resources 변수에도 추가해주고 반환까지 해주게 되고 
이미 한번 같은 이름의 오브젝트가 로드 되었었다면 _resources 에서 바로 가져와 반환해주게 됩니다. 

이렇게 스카이 박스의 코드를 수정했고 또 하나더 있던 게임오브젝트인 큐브도 코드를 수정해야합니다. 

큐브가 사용할 셰이더는 Forward 셰이더를 사용할것이기 때문에 기존의 셰이더를 생성 초기화 해주던 코드 대신 밑의 코드로 수정해줍니다.
			shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Forward");
그리고 큐브의 텍스쳐는 두개를 사용하고 있었습니다. 일반 색상 텍스쳐와 노멀 값을 설정해줄 노멀 텍스쳐, 이 경우에는 Load를 두개를 해줘서 각각 설정 해주겠습니다 .
			shared_ptr<Texture> texture = GET_SINGLE(Resources)->Load<Texture>(L"Leather", L"..\\Resources\\Texture\\Leather.jpg");
			shared_ptr<Texture> texture2 = GET_SINGLE(Resources)->Load<Texture>(L"Leather_Normal", L"..\\Resources\\Texture\\Leather_Normal.jpg");

이렇게 앞으로 만들 오브젝트들을 좀더 편하게 만들기 위해 수정을 해주었고 

이번 시간 테스트를 하기위한 오브젝트를 만들기 시작해보겠습니다.

#pragma region UI_Test
	{
		shared_ptr<GameObject> sphere = make_shared<GameObject>();
		sphere->SetLayerIndex(GET_SINGLE(SceneManager)->LayerNameToIndex(L"UI")); // UI
		sphere->AddComponent(make_shared<Transform>());
		sphere->GetTransform()->SetLocalScale(Vec3(100.f, 100.f, 100.f));
		sphere->GetTransform()->SetLocalPosition(Vec3(0, 0, 500.f));
		shared_ptr<MeshRenderer> meshRenderer = make_shared<MeshRenderer>();
		{
			shared_ptr<Mesh> mesh = GET_SINGLE(Resources)->LoadRectangleMesh();
			meshRenderer->SetMesh(mesh);
		}
		{
			shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Forward");
			shared_ptr<Texture> texture = GET_SINGLE(Resources)->Load<Texture>(L"Leather", L"..\\Resources\\Texture\\Leather.jpg");
			shared_ptr<Material> material = make_shared<Material>();
			material->SetShader(shader);
			material->SetTexture(0, texture);
			meshRenderer->SetMaterial(material);
		}
		sphere->AddComponent(meshRenderer);
		scene->AddGameObject(sphere);
	}
#pragma endregion

이 UI 테스트 오브젝트의 이름이 sphere인 이유는 이전에 만들던 구 오브젝트의 코드를 복사한것이기 때문입니다. 
차례대로 보면 레이어 인덱스를 UI 로 설정해주고 트랜스폼 컴포넌트 추가후 로컬 스케일과 포지션을 설정해주는데 이때 로컬 포지션의 z 값을 500을 주는이유는 
카메라의 기본 near가 1 far 가 1000 인데 그냥 이 사이의 값 아무거나 넣은겁니다. 메쉬의 경우는 처음보는 메쉬를 로드해주고 있는데 UI의 메쉬를 그냥 큐브로 해도 되겠지만 
직교투영의 특성상 큐브 메쉬라도 화면에 출력되는것은 사각형뿐일것입니다. 그러면 괜히 연산능력을 낭비하는 것이기 때문에 UI 용으로 사각형 평면의 메쉬를 만들어 줄겁니다. 
셰이더는 포워드 셰이더를 가져왔고 텍스쳐도 큐브가 사용하던 Leather 텍스쳐를 그대로 사용했습니다. 

LoadRectangleMesh 는 로드 큐브 함수와 거의 같은데 큐브의 앞면만 가져온것이라고 생각하면 됩니다. 사실 우리 프로젝트에서 맨처음 만들었던 메쉬가 이 사각형 메쉬 였었죠

이제 프로그램을 빌드, 실행 해보면 정중앙에 사각형 UI가 출력되고 뒤쪽으로 기존의 큐브 오브젝트가 생성되는걸 볼 수 있습니다. 카메라를 움직여도 UI 는 그대로 화면 중앙에
있습니다. 

/*
에러
프로그램이 실행은 되는데 강의의 결과처럼 되지 않고 약간 그래픽이 깨진 Leather 아주 가까이 크게 있습니다. 
*/

오늘의 내용중에 재밌는 부분은 카메라를 여러개 만드는 부분입니다. 별로 많은 코드를 추가한것도 아닌데 자연스럽게 카메라가 추가 되었습니다. 

카메라를 렌더링 해주는 코드가 어디 있냐면 Scene::Render 에 있습니다. 이 코드를 보면 	
void Scene::Render()
{
	PushLightData();

	for (auto& gameObject : _gameObjects)
	{
		if (gameObject->GetCamera() == nullptr)
			continue;

		gameObject->GetCamera()->Render();
	}
}
라이트 데이터를 푸시 해주고 카메라를 렌더링 해주는데 씬이 가지고 있는 모든 게임 오브젝트를 순회하면서 카메라 컴포넌트가 있다면 렌더를 해주고 있습니다. 
딱히 카메라 하나만 찾아서 렌더링 해주는게 아니라 모든 게임오브젝트를 체크해주고 있는걸 볼 수 있습니다. 
그럼 Camera->Render() 함수를 따라가보면 오늘 수정한 부분도 포함되어있는데 각각의 게임오브젝트가 자신만의 _matView 와 _matProjection 을 들고 있다가 
자신이 Render 할때 스태틱 매트릭스 함수에 담아서 컬링 체크까지 하고 렌더링을 해줍니다. 
그런데 결국 이렇게 물체들을 합쳐서 그려줄 수 있는 이유는 화면을 그려주는 버퍼가 
SwapChain 의 rtvBuffer 이기때문인데 한 프레임에 화면에 출력할 모든 물체들을 스왑체인에서 렌더타겟뷰에 전부 그려주고 두개를 번갈아가면서 그려주고 있기 때문에 
도화지가 하나에 그려주고 있듯이 되는겁니다. 
그래서 여러개의 카메라가 동시에 찍어도 한프레임내 에서는 결국 하나의 렌더타겟뷰에 그려지기 때문에 한꺼번에 출력되는겁니다.