

	13. 벡터


이번시간에 배울 벡터는 게임프로그래머라면 클라이언트, 서버 가릴것 없이 손과발이 되어줄 만큼 중요한 개념입니다. 

그리고 C++에서 배웠던 std::vector와는 전혀 다른 개념입니다. std::vector는 동적 배열을 말하는 것이고 
이번시간의 벡터는 수학, 물리 쪽에서 말하는 벡터를 뜻합니다. 

# 벡터의 필요성
본격적인 벡터에 들어가기 전에 이게 왜 필요한지 부터 알아보도록 하겠습니다. 벡터를 배우기 전부터 1,2,3 또는 3.14f 같은 수를 잘 사용하고 있었습니다. 
이런 고정된 수를 벡터의 반대개념인 스칼라 라고 합니다. 이 스칼라는 고정된 숫자, 혹은 고정된 크기 정보만 전달할수 있습니다.

그런데 고정된 값만을 전달하면 아쉬운 상황이 있을수 있는데요 
가정을 해보겠습니다. x축, y축, 원점O로 이루어진 2차원 좌표가 있습니다. 여기서 임의의 두점 A, B 이 두점사이의 거리는 5 라고 하겠습니다.

이때 5라는 정보를 스칼라값으로 전달하면 A와 B의 거리라는 것을 표현하니까 나름 의미있는 정보일수 있습니다.
그러면 우선 A라는 점과 5라는 스칼라값을 주면 B라는 점이 어디있는지 알수 있을까요? 알 수 없을것입니다. 점 A와 거리만 주어졌으면 A를중심으로 5라는거리에 있는 점들중 어느것이 B인지 알 수 없습니다.
스칼라만으로는 표현할수 있는 정보에 한계가 있어서 벡터라는 개념이 필요해 진것 입니다.

#벡터의 개념
삼각함수는 오래된 개념인 반면 벡터는 비교적 얼마 되지 않았습니다. 100 ~ 200년정도 되었다고 합니다. 
벡터란 수학, 물리, 공학에서 크기와 방향을 갖춘 양 이라고 합니다. 그래프에서 표현할때는 화살표모양의 선분으로 표현합니다. 
방향을 가지고 있다는점이 중요한데 A에서 B까지의 값을 벡터로 가지고 있다면, 어느 동떨어진 좌표C에 똑같은 벡터값을 줘서 평행한 선분을 만들수 있을것입니다.

벡터를 표현하는 방법은 이 메모장에서는 표현하기 어렵지만 A와 B를 잇는 벡터는 AB위에 오른쪽을 가리키는 화살표가 옵니다. (여기서는 그냥 벡터AB 이런식으로 표기하겠습니다.)

벡터가 내부적으로 가지고 있어야할 성분은x값과 y값입니다. 각각의 값으로 어느정도를 이동하라는 의미로 알수 있습니다.
벡터AB에서 x,y성분을 어떻게 알수 있는가 하면 점A,B의 x성분, y성분을 서로 빼주면 벡터의 x,y성분을 알수 있습니다.
즉 목적지 좌표에서 시작점 좌표를 빼주면 벡터의 성분값을 알수 있겠습니다. 
이렇게 벡터의 기본 개념에 대해 배웠습니다.

# 벡터의 성질
벡터AB를 벡터V와 같다고 해보겠습니다. 그러면 이 벡터V는 A에서 B로 가는 방향과 크기를 나타내는 양 이었지만 일단 만들어지고 난 다음에는 A와 B로부터 독립되어서 
어느방향으로 어느크기만큼 간다는 정보만 들고 있게됩니다.

(1) 벡터의 덧셈
> 벡터V1 과 벡터V2가 있다고 해보겠습니다. 이 두 벡터를 더하면 어떻게 될지를 알고 싶습니다. 
사실 어렵게 생각할 필요없이 각 벡터의 성분들을 각각 더해주면 됩니다. 벡터마다 (x, y)성분을 가지고 있을것인데 x끼리 더해주고 y끼리도 더해주면 됩니다.
수치적으로는 이렇고 기하학적으로 보면 재밌는 성질이 보입니다. 
벡터가 한번 만들어지고 나서는 어느 점에서 시작하는지는 상관없어진다고 했었습니다. 
벡터V1+벡터V2는 좌표상으로 아무곳에서나 벡터V1을 그리고 끝나는 지점에서 다시 벡터V2를 그려서 벡터V1의 시작점과 벡터V2의 도착점을 잇는 벡터를 만들면 이 벡터가 벡터V1+벡터V2입니다.

(2) 벡터의 뺄셈
> 벡터V1 - 벡터V2는 벡터V1 + (-벡터V2)라고도 표현할 수 있을겁니다. 벡터의 부호가 바뀌면 성분들의 부호도 전부 바꿔주면 되는데 기하학적으로 보면 벡터의 방향이 반대로 뒤집히게 됩니다. 
결국 벡터V1에 방향이 뒤집힌 벡터V2를 더해주면 벡터의 뺄셈이 되겠습니다.

벡터의 덧셈, 뺄셈을 하였으니 곱셈, 나눗셈은 어떤가 궁금해지지만 벡터사이의 곱셈, 나눗셈은 존재하지 않습니다. 
그러나 벡터와 스칼라사이의 곱셈, 나눗셈은 또 존재 합니다.

(3) 벡터와 스칼라사이의 곱셈과 나눗셈
> 벡터에 스칼라 값을 곱하거나 나누려면 벡터의 각 요소에 스칼라만큼 연산을 해주면 되는데 기하학적으로는 벡터V에 3을 곱한다면 원래와 같은 방향으로 크기만 3배 커진 벡터로 표현됩니다.
나눗셈도 마찬가지로 같은방향으로 나눈만큼 크기가 작아지는겁니다.

(4) 교환법칙, 결합법칙
> 벡터V1 + 벡터V2 + 벡터V3 라는 식이 있을때 결합법칙은 3개 이상의 수를 연산할때 어떤 순서로 연산을 해도 결과 값이 똑같다는 법칙입니다.
기하학적으로도 세 백터를 합할때 어떤 순서로 더하던지 경로의 차이는 있지만 결과값은 똑같이 나옵니다. 
결합법칙 : (벡터V1 + 벡터V2) + 벡터V3 = 벡터V1 + (벡터V2 + 벡터V3) 
교환법칙은 무슨 말인가 하면 두 벡터를 더할때 서로 자리를 바꿔도 결과 값이 같다는 이야깁니다. 
교환법칙 : 벡터V1 + 벡터V2 = 벡터V2 + 벡터V1
(벡터에게 교환법칙 결합법칙이 적용되는건 생각해보면 일반적인 이야기입니다. 벡터의 덧셈과 뺄셈이 각 성분끼리의 덧셈뺄셈이라고 하였고 각 성분은 그냥 실수 입니다.)

(5) 벡터의 크기
>가정으로 좌표위의 점A는 (1, 2), B는 (4, 6)이라는 위치에 있습니다. A로부터 B까지의 벡터AB는 크기가 5입니다. 이럴때 이 벡터의 크기는 어떻게 구하는 것 일까요?
기하학적으로보면 밑변3, 높이4, 빗변5 인 직각삼각형을 보는것과 같습니다. 보는 즉시 피타고라스의 정리가 떠오릅니다.
2차원에서는 이렇게 쉽게 구할 수 있었는데 우리가 게임을 만들면서 볼 벡터는 3차원의 벡터입니다. 3차원의 벡터는 어떻게 크기를 구할지 한번 보겠습니다.
3차원을 표현하기위해서 x축, y축, z축으로 이루어진 공간에서 어떤 점A가 있다고 했을때 원점에서 A까지의 벡터OA를 구하려면, 방법은 피타고라스의 정리를 두번 사용하는것입니다. 
x성분,y성분으로 한번 피타고라스로 값을 구하고 그 구한 값과 z축성분으로 다시 피타고라스 정리를 사용하면 3차원에서 벡터의 크기를 구할 수 있습니다.
이걸 수식으로 표현하면 x성분 y성분을 대상으로 구한 빗변의 길이는 x^2+y^2의 루트입니다. 이것과 z성분의 빗변의 길이는 x^2+y^2+z^2의 루트가 되겠습니다.

(6) 단위 벡터
>2차원에서 점A와 B의 x성분 차이가 3, y성분 차이가 4이고 벡터AB의 크기는 5 라고 하겠습니다.
이때 점A,B가 그냥 점이 아니라 A는 플레이어, B는 몬스터라고 해보겠습니다. 게임에서 언제나 플레이어가 몬스터에게 갈때 순간이동으로 한번에 가는것은 아닐것이고 
플레이어만의 이동속도가 있을것입니다. 프레임마다 벡터만큼 플레이어가 움직인다고 했을때 플레이어의 이동속도가 1이라면 방향은 그대로고, 크기가 1로 해줘야 프레임당 1의 속도록 이동할것입니다.
이렇게 방향은그대로고 , 크기가 1인 벡터를 단위 벡터라고 합니다.
그러면 단위 벡터는 어떻게 추출하는가 하면 벡터의 각성분에 크기 만큼을 나눠주면 됩니다. 
예를들어 위에서 말한 (3, 4)성분을 가진 벡터는 크기가 5였으니깐 (3/5, 4/5) 성분을 가진 벡터가 단위 벡터가 되는겁니다.
수식적으로 보면 x/(x^2+y^2)의 루트 성분과 y/(x^2+y^2)의 루트를 피타고라스 정리로 계산해야 하는데 각각 제곱해서 더해주면 분모와 분자가 똑같이 떨어져 1이 됩니다.
이 단위벡터를 만드는걸 Nomalize라고 하는데 유니티나 언리얼이나 모두 이 Nomalize가 포함되어 있을것입니다. 참고로 벡터의 크기를 구하는걸 Magnitude나, size라고 부릅니다.

여기까지가 벡터의 성질이라고 하겠습니다.


# 벡터의 내적, 외적

벡터를 그대로도 사용할 수 있지만 특수 연산들을 미리 구해놓고 거기에 의미를 부여해서 사용할 수 있는데 그것들이 내적과 외적입니다.

(1) 내적 
> 삼각형ABO가 있다고 해보겠습니다. 점O의 각도를 X라고 하고 벡터OA를 벡터a, 벡터OB를 벡터b라고 부르겠습니다.  
벡터a·벡터b 이 벡터들을 내적한다는 의미입니다. 일반 실수에서는 이렇게 1·2 는 두 숫자를 곱한다는 의미이지만 벡터에서는 내적의 의미입니다.
벡터 내적의 특이한점은 벡터는 방향과 크기를 둘다 가지고 있는 양이지만, 벡터의 내적의 값은 스칼라 값입니다.
벡터의 내적을 구하는 식은 다음과 같습니다. 
|벡터a|*|벡터b|*cosX (여기서 |벡터a|라는 건 벡터의 크기만 추출한다는 의미입니다)
거기에 더해 이 식을 풀어 보다 보면 내적은 이렇게도 볼 수 있습니다. 
벡터a의 x성분 * 벡터b의 x성분 + 벡터a의 y성분 * 벡터b의 y성분 = |벡터a|*|벡터b|*cosX
(자세한 내용은 벡터 내적 공식 증명을 찾아보기)
어쨋든 내적을 구하는 공식이 두 버전이 나오는데 컴퓨터에서 코사인 값을 구하는게 시간이 더 걸리기 때문에 일반적으로는 각 성분을 곱해서 더하는 버전을 주로 사용할 것 입니다.
- 내적의 의미
여기서 끝내면 이게 어디에 쓰는지 실감하지 못할것입니다. 게임을 만드는데 이 내적이 무슨 의미인가를 알아야겠습니다.
쉐이더에서 그림자를 계산할때 직교투영이란 것을 구하는데 두 벡터 a,b 가 있고 벡터a의 도착점에서 벡터 b에 수선으로 내려오는 빛이 있어 그 그림자를 구하고 싶을때 
벡터a의 수선까지의 직각삼각형의 밑변을 구하면 되는데 그 값은 벡터a*cos(벡터a와 벡터b의 각도) 입니다. 
그런데 코사인을 계산하는게 시간이 좀 걸린다고 했었습니다. 이럴때 내적을 활용하면 벡터들의 각 성분을 곱한것을 서로 더한 값이
|a||b|cos(a,b각도) 라고 했었습니다. 이값에 벡터b의 크기를 나눠주면 더욱 빠른 시간으로 원하던 |a|*cos(a,b각도)를 구할 수 있게 됩니다.
또 다른 예를 들어보자면 
두 벡터의 사이 각을 가지고 무언가 하고 싶을때도 사용될것입니다. 
벡터a와 벡터b사이의 각도를 모른다고 했을때 그 각도가 예각이냐, 둔각이냐에 따라 달라지는 컨텐츠가 필요하다고 해보겠습니다. 
(도적이 캐릭터의 등뒤에서 공격하는가, 앞에서 공격하는가 하는 판정 같은)
그럴때 일단 두 벡터a,b의 내적을 하면 ax*bx + ay*by = |a||b|cosX 이 값이 양수 인지, 음수인지를 가지고 판정을 내릴 수 있습니다.
코사인의 성질이 0부터 파이*1/2 까지는 양수로 나오고, 파이*1/2부터 파이*3/2 까지는 음수로 나오는 성질이 있습니다.
만약 내적 값이 0이 나온다면 그 의미는 두 벡터사이의 각도가 정확히 90도 라는 이야기도 됩니다. 이렇게 내적을 했을 뿐인데 여러가지 정보를 유추할 수 있습니다.
즉, 내적은 ax*bx+ay*by = |a||b|cosX 라는 두가지 해석 방법이 있다는 점을 이용해서 앞의 버전으로 쉽게 값을 구하고 뒤의 버전이 벡터사이의 각도와 연관되어있다는 점을 가지고 유용하게 사용할 수 있습니다.
엔진이나 라이브러리에서 Dot이라는 함수로 제공됩니다.

(2) 외적
> 외적도 내적과 비슷하고 공식 자체는 단순합니다. 하지만 공식 자체가 중요한것은 아니고 그 공식에서 얻을수 있는 정보가 중요한것입니다.
외적은 벡터a×벡터b로 표현을 하는데 스칼라값에서는 곱셈이지만 벡터에서는 외적을 뜻합니다. 
일단 공식은 
벡터a×b = |a||b|sinX*벡터c (X는 두 벡터사이의 각도) ( 벡터c는 a와 b 둘 모두에 수직인 단위 벡터)
이게 무슨 말인가 하면 
외적은 2차원이아니라 3차원에서 의미가 있습니다. 그리고 벡터 c가 위와 아래 어느 방향으로 가는지는 좌표계에 따라다릅니다. 왼손 좌표계, 오른손 좌표계로 손의 모양에 따라 방향이 달라집니다.
내적의 경우는 값이 스칼라였지만 외적은 내적의 값과 비슷한 스칼라 값에 벡터를 곱한 벡터값입니다.
외적도 내적처럼 좀더 계산이 용이한 버전이 더 있긴 있습니다. 외적의 값이 3차원의 벡터 이다 보니깐 3자리 성분으로 나타나는데, 
(AyBz - AzBy , AxBz - AzBx , AxBy - AyBx) 이런식입니다. 이런 공식이 있긴 하지만 외울 필요는 없을것입니다. 모두 프로그램에서 함술로 제공해줄것 이기 때문입니다
보통 cross라는 이름의 함수로 외적을 제공해줍니다.
- 외적의 의미
외적이 무엇인지는 알았는데 그래서 어떤 의미인지가 중요합니다.
여기서 중요한 특징은 내적과는 다르게 외적은 교환 법칙이 성립되지 않는다는 큰 특징이 있습니다.
내적의 경우 결과값이 스칼라 이다 보니깐 교환법칙이 성립했었는데 외적은 중간 까지는 스칼라 값이지만 마지막에 방향을 가리키는 단위 벡터를 곱해주기 때문에 교환법칙이 성립되지 않습니다.
같은 좌표계라면 두 벡터를 교환하면 방향이 정반대로 바뀌게 됩니다.
내적에서 각도정보를 추출해 낼 수 있었다면 외적에서는 이 단위 벡터가 중요합니다. 두 벡터 모두에 수직하는 방향값과 그 방향이 위,아래 어디를 가리키고 있는지 에 대한 정보들입니다.
외적으로 구할수 있는 정보들의 예로 법선 벡터를 들 수 있습니다.
법선이란 어떤 곡선이나 물체에 접하는 접선에 수직하는 직선 및 곡면위에 접하는 접평면에 수직인 직선입니다.
두 벡터로 표현한 평면이 있고 거기에 수직인 벡터값이 필요할때가 오는데 이것을 수학적으로 법선을 구하는 식은 복잡하고 어렵습니다. 그때 이 벡터의 외적을 사용하면 되겠습니다.
외적으로 나온 벡터를 정규화(Nomalize)를 해서 법선 단위 벡터를 추출 할 수 있을 겁니다. 이 법선 자체가 가장 중요하게 사용되는 성질이고,
외적의 순서에 따라 방향이 바뀐다는 성질도 사용됩니다. 어떤 식이냐 하면 어떤 삼각형ABO가 있을때 임의의 점X가 삼각형ABO안에 있는지 외부에 있는지를 판별할때 사용됩니다.
벡터OA, 벡터OB, 벡터OX를 만들고 , 벡터OA×벡터OX 와 벡터OX×벡터OB의 방향이 같다면 삼각형 내부에 있는것이고 다르다면 삼각형 외부에 있는것 입니다. 
게임으로 예시를 들면 스킬 아이콘이 쿨타임돌때 시계방향으로 돌면서 어두운 곳과 밝은 곳이 있을겁니다. 그때 밝은 곳의 픽셀들은 기준 선안에 있고 어두운 부분은 기준선 밖에 있는걸로 
판단을해서 밝은곳과 어두운곳을 나누는 것입니다.
(외적에서 꼭 기억해야 할 점 외적은 교환법칙이 성립되지 않고 외적한 순서에 따라 방향이 정반대로 나온다, 내적과는 달리 외적은 벡터값이다.)


# 벡터 결론, 활용

벡터의 핵심은 크기, 방향을 동시에 가지고 있는 양이라는 것입니다.
벡터에 대한 개념, 성질, 외적, 내적을 배우고 하는방법도 알았지만 전부 우리가 사용할 라이브러리나 엔진에 다 마련되어있을것입니다.
이것이 일단 첫번째 결론이고,

벡터가 수학, 공학, 물리에서 사용될때는 위의 의미가 맞지만(기하벡터) 게임에서 사용될때는 또하나의 의미가 있습니다.

3차원 벡터가x, y, z 값을 가지고 있는 것을 활용해 게임 월드내에 오브젝트의 위치를 가리킬때 새로운 struct를 파서 관리하는게 아닌 그냥 벡터를 사용하는 방법이 있습니다. 
(위치벡터)
이렇게 위치벡터로 사용할때는 원래의 의미처럼 크기와 방향을 가지고 있는 양이라고 보기에는 애매합니다. 물론 원점을 기준으로 방향과 크기를 가지고있다고 할 수 도 있지만 그런식으로 사용되지는 않습니다.

그래서 유니티나, 언리얼이건 좌표를 벡터로 표현하고 있습니다. 

이런 두가지 용법을 잘 구별을 해서 사용해야 합니다.
3차원 벡터 Vec3 = pos 라는 변수로 위치벡터를 사용하다가 또다른 Vec3를 더해준다면 두번째 등장한 Vec3는 기하벡터의 의미로 사용된다고 해석해야 할것입니다.
 