

        31. Deferred Renderring


이전 시간에 했던 렌더 타겟에 관한 수정에 이어서 디퍼드 렌더링 방식을 배워보고 구현해볼겁니다. 

디퍼드 렌더링이란 한번에 그리는게 아니라 중간 과정을 둬서 중간과정에서 조립해서 만들겠다는게 디퍼드 렌더링입니다. 
여기서 말한 중간과정을 만드는것이 이전 시간 렌더 타겟 강의 에서 했던것입니다. 

이전 강의의 결과물은 구체 하나와 상단에 3가지 G_BUFFER 를 출력했었습니다. 포지션, 노멀, 컬러 였는데 
오늘은 거기에 더해서 빛연산까지 더한 diffuse light, specular light 가 추가 될겁니다. 


생각해볼만한 점이 있는데 지금처럼 포지션, 노멀, 컬러는 중간 버퍼 G_BUFFER 에 넘겨줬었는데 여기서 어떻게 빛연산을 다시 해줄지가 고민입니다. 

복습으로 포워드 렌더링 파이프라인을 다시 떠올려 보겠습니다. 
IA (Input Assembler) 단계에서 Vertex Buffer, Index Buffer, Topology Buffer(기본 구성 평면이 삼각형인지 사각형인지) 정보들을 받아서 다음으로 넘겨줍니다. 
다음으로 여러 셰이더 들이 있지만 실습 프로젝트에서는 Vertex Shader 와 Pixel Shader 를 주로 사용하고 있었습니다. 
이중에 픽셀 셰이더를 보면 레스터라이저 단계에서 보간해준 픽셀들마다 색을 정해주는데 이때 빛연산도 같이 해서 색을 정해줍니다. 그런데 이때 빛연산을 하는 코드는 
지금까지 그냥 해당 씬에 들어있는 광원들을 전부 for 문을 돌면서 지금 계산하고 있는 픽셀과 연관이 있는지를 체크 해주고 있습니다. 

디렉셔널 라이트 는 그나마 게임 월드 전체에 비추는 빛이기 때문에 이해가 가지만 포인트 라이트나 스포트 라이트 같은 경우는 빛의 각도, 거리에 따라 계산하는 물체와 관계가 없을 수 있습니다. 
그래도 포워드 렌더링 방식에서는 그걸 미리 알 수 없기 때문에 모든 빛 오브젝트를 순회해야 한다는 문제점이 있었습니다.

그래서 디퍼드 렌더링에서는 물체를 그릴때 빛을 찾아서 연산을 하는게 아니라 빛을 그릴때 빛이 물체를 찾아서 그리게 됩니다. 
무슨 말장난인지 잘 안 와닿을수 있는데 엄청난 차이가 있습니다. 
이전시간에 만든 G_BUFFER 라는 중간 버퍼에 정보들을 남겨 놨었습니다.
그리고 빛 오브젝트도 어떤 별도의 방법으로 렌더링 되는게 아니라 똑같이 렌더링 파이프라인을 따라서 렌더링 됩니다 IA 단계에서 Vertex, Index, Topology 를 넘겨주고 Vertex Shader 에서 
메쉬를 만들어 주는데 이때 일반 오브젝트와 달리 빛오브젝트는 메쉬의 겉에 색을 입히거나 텍스쳐를 입히는 대신 그 범위가지고 빛이 닿는 범위로 사용합니다. 
이걸 Volume Mesh 라고 합니다. 

이 빛 오브젝트가 픽셀 셰이더까지 간다음 볼륨 메쉬 안의 각 픽셀들을 하나씩 전부 색을 입히는게 아니라 각 픽셀과 G_BUFFER 에 있는 포지션 값과 곂치는지를 확인하고 곂친다면 해당 픽셀에 
색을 입혀줍니다. 이게 빛에 물체를 찾아서 그린다는 말의 의미입니다. 
재밌는게 현실에서도 물체를 보려면 빛이 반사된 물체가 보이는 것인데 닮은것 같습니다. 

빛의 종류에 따라 볼륨 메쉬가 다른데 포인트 라이트 는 최종 렌더 타겟에서 원 형태로 잡힐것이고 디렉셔널 라이트의 경우 화면 전체를 가리는 Rectangle 로 볼륨메쉬를 주면 될것같습니다. 
마치 우리가 프로젝트 시작할떄 다른 스페이스 변환을 거치지 않고 직접 투영 좌표계를 화면에 출력했던것 같습니다. 


- 코드 

이전 시간의 결과물을 보면 UI 메쉬들에 출력한 텍스쳐들이나 화면 중앙에 출력된 까만 큐브가 이상합니다. 
UI 들은 빛연산을 하기전의 텍스쳐들이라 이걸 포워드 텍스쳐로 출력하면 빛의 영향을 받아서 그려주는데  ambient 값만으로 물체를 그려줘야 하기때문에 거의 안보이는 상태입니다.
이걸 해결하기 위해 UI 텍스쳐 전용의 셰이더를 하나 만들어 줄것이고  
그리고 큐브 메쉬가 까맣게 출력되는 이유는 지금 이 큐브는 디퍼드 셰이더를 사용해서 표현한겁니다. 그리고 실질적으로 그려달라고 포워드 셰이더로 넘겨준 적이 없습니다.
그래서 큐브는 UI가 아닌 상태로 되어있고 포워드 셰이더를 촬영하는 카메라는 UI 레이어를 찍는 카메라이고 그래서 사실상 이 큐브는 그려진 적도 없습니다. 
충격적이게도 큐브는 그려진 적이 없다는걸 알게 됐습니다. 그런데 그려진적이 없다는데 왜 검은 영역이 마치 거기에 큐브가 있는듯이 보이는걸까요 ?

왜냐면 깊이 텍스쳐를 계속 공유해서 사용하기 때문입니다. 
메인 카메라와 UI 카메라 둘중에 메인카메라가 디퍼드 셰이더를 오브젝트를 찍는데 아직 디퍼드를 사용하는 오브젝트들은 그려주지도 않았지만 깊이 텍스쳐는 쓰여져있고 
아무것도 그려져 있지 않은 공간이 가진 깊이 값이 스카이 박스보다 앞에 있기때문에 해당 공간은 스카이박스가 그려지지않고 배경색인 검은색으로 표현되고 있는겁니다.

추가로 이상한점 한가지더 있는 것이 Scene::Render 의 구조가 이상한데 게임 오브젝트를 돌때마다 카메라 마다 디퍼드 한번 포워드 한번씩 렌더링 해주고 있습니다.
이런 방식이 아니라 메인카메라만 디퍼드를 한번 실행하고 나머지 카메라는 렌더 포워드를 실행하도록 해줘야 합니다.

본격적으로 코드를 수정 해볼건데 코드가 이리저리 엮여 있어서 수정할 부분이 많습니다. 

일단은 셰이더 파일부터 수정을 하고 거꾸로 타고 올라가 보도록 하겠습니다.

1) 셰이더 파일 
1-1. params.fx
셰이더에서 사용할 파라미터를 관리하는 셰이더 파일입니다. 
이중에 MATERIAL_PARAMS 에서 g_int 5개, g_float 5개, g_tex_on (텍스쳐 슬롯에 텍스쳐가 있는지를 알기위한 파라미터) 5개 를 가지고 있었습니다. 
여기에 새로운 파라미터를 추가해줄건데 float 2개짜리 g_vec2 를 0번 부터 3번까지 4개를 만들어 주겠습니다.
float 두개 짜리 데이터가 은근히 많이 쓰일겁니다. 지금처럼 새로 만들지 않고 먼저 있던 float용 파라미터를 2개 사용할 수도 있지만 이왕이면 연관된 float 두개를 묶어서 관리할 수 
있는 float2 타입 벡터를 사용했습니다.

그리고 이전에 LightInfo 나 LightColor 같은 struct 들은 16바이트를 딱딱 맞춰줬었는데 (셰이더의 정책에의해) 
지금 고치던 MATERIAL_PARAMS 은 내용물을 괜히 5개씩 만들어서 비효율적 입니다. 그래서 종류마다 4개씩으로 맞춰주겠습니다.

1-2. forward.fx
다음으로 포워드셰이더로 가서 텍스쳐 전용 셰이더를 만들어 보겠습니다. 
텍스쳐 전용 셰이더를 만들건데 왜 포워드로 왔냐면 지금까지 포워드에서 VS_Main, PS_Main 같이 메인함수로만 이용해서 사용하고 있었습니다. 
실제로 Shader.cpp 코드를 보면 초기화를 할때 셰이더 경로를 받고 그 경로의 셰이더 파일에서 "PS_Main", "PS_Main" 함수를 불러오는 하드 코딩을 하고 있습니다.

그래서 비슷한 역할을 하는 셰이더는 한 파일에 같이 밀어 넣는 방법도 있습니다. 즉 오늘 만들 텍스쳐용 셰이더는 그냥 forward.fx 에 만들어 줄겁니다.
셰이더 파일을 너무 많이 늘리는것도 좀 불편합니다. 

PS_Main 아래에 추가할 텍스쳐용 셰이더 코드는 이렇습니다. 
// [Texture Shader]
// g_tex_0 : Output Texture
// AlphaBlend : true
struct VS_TEX_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;
};

struct VS_TEX_OUT
{
    float4 pos : SV_Position;
    float2 uv : TEXCOORD;
};

VS_TEX_OUT VS_Tex(VS_TEX_IN input)
{
    VS_TEX_OUT output = (VS_TEX_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), g_matWVP);
    output.uv = input.uv;

    return output;
}

float4 PS_Tex(VS_TEX_OUT input) : SV_Target
{
    float4 color = float4(1.f, 1.f, 1.f, 1.f);
    if (g_tex_on_0)
        color = g_tex_0.Sample(g_sam_0, input.uv);

    return color;
}
이 코드는 물체가 빛의 영향을 받지 않고 그냥 그대로 그리도록 하는 역할을 합니다. UI 텍스쳐가 까맣게 나온이유가 빛연산이 개입되서 였으니까 이젠 
빛계산없이도 잘 나올겁니다.
텍스쳐용 셰이더 함수는 VS_Tex, PS_Tex 로 이름이 바뀐걸 알수 있습니다. 나중에 Shader.cpp 도 수정을해서 추가해줄겁니다.
코드의 내용은 단순합니다. VS_Tex 는 인풋으로 들어온 정점에 마지막에 w 값 1.f 를 추가해서 WVP 스페이스 변환 행렬을 계산해준다음 아웃풋으로 넘겨주고 
PS_Tex 에서는 받은 픽셀들에 색을 입혀줄건데 이 물체가 텍스쳐를 가지고 있는지를 체크하고 있다면 해당 텍스쳐의 셈플러와 input.uv 좌표를 매핑해서 색을 입혀주고 
리턴합니다. 셰이더를 처음 배울때 빛연산을 안배웠을때 이렇게 했던거 같은데 그 방법을 다시 사용하고 있는겁니다.

1-3. lighting.fx
다음으로 중요한 셰이더인 lighting 셰이더를 추가 해주겠습니다.
Shader 파일이 담겨져 있는 폴더를 열고 아무 셰이더(여기서는 forward.fx)를 복사해서 이름을 lighting으로 바꾸고 프로젝트에 추가 해주었습니다. 
#ifndef _LIGHTING_FX_
#define _LIGHTING_FX_

#include "params.fx"
#include "utils.fx"

#endif
내용은 다 날리고 여기부터 시작하겠습니다.
라이팅 셰이더도 아까 전의 포워드 셰이더 처럼 라이팅과 관련된 온갖 기능, 함수들을 가지고 있을겁니다.
원래의 포워드 처럼 메인 두개로 이루어진게 아니라 다양한 세트로 이루어 질 것인데 
다만 버텍스 셰이더와 픽셀 셰이더에 사용될 구조체는 곂치게 됩니다.
VS_IN , VS_OUT 은 float3 position , float2 uv 를 가지고 있는 struct 이고 
PS_OUT 은 float4 diffuse, float4 specular 를 가지고 있는 struct 입니다. 그런데 이 PS_OUT은 타겟 0번, 1번으로 세팅되어있는데 
디퓨즈 와 스펙큘러 정보도 중간 렌더 타겟에서 가지고 있을 예정입니다. 그 중간 결과물을 여기에 보내주고 있는 것 입니다.

그리고 디렉셔널 라이트와 포인트 라이트는 셰이더가 다릅니다. 
우선 디렉셔널 라이트를 보겠습니다.
// [Directional Light]
// g_int_0 : Light index
// g_tex_0 : Position RT
// g_tex_1 : Normal RT
// Mesh : Rectangle

VS_OUT VS_DirLight(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos * 2.f, 1.f);
    output.uv = input.uv;

    return output;
}

PS_OUT PS_DirLight(VS_OUT input)
{
    PS_OUT output = (PS_OUT)0;

    float3 viewPos = g_tex_0.Sample(g_sam_0, input.uv).xyz;
    if (viewPos.z <= 0.f)
        clip(-1);

    float3 viewNormal = g_tex_1.Sample(g_sam_0, input.uv).xyz;

    LightColor color = CalculateLightColor(g_int_0, viewNormal, viewPos);
    output.diffuse = color.diffuse + color.ambient;
    output.specular = color.specular;

    return output;
}
디렉셔널 라이트는 g_int_0 에 내가 어떤 빛에 해당하는지 인덱스를 받고 있는데 이게 어디 있던 내용인지를 떠올려보면 
params.fx 에서 
cbuffer GLOBAL_PARAMS : register(b0)
{
    int         g_lightCount;
    float3      g_lightPadding;
    LightInfo   g_light[50];
}
이런 파라미터를 가지고 있었는데 여기서 g_light 라는 배열의 인덱스를 말합니다. 예를 들어 g_light[0].lightType 이 0 이면 디렉셔널 라이트 입니다. 
이걸 판별해서 연산해주는 부분은 utils.fx 의 CalculateLightColor 안에 있습니다.
다음으로 포지션과 노멀에 관련된 렌더타겟을 g_tex_0, 1 으로 받아 주고 있습니다. 그리고 디렉셔널 라이트의 영역 볼륨 메쉬는 Rectangle 로 화면 전체를 채우는 
사각형입니다.

VS_DirLight 를 보면 결과물이 될 output 에다가  output.pos = float4(input.pos * 2.f, 1.f); 를 해주고 있습니다. input은 디렉셔널 라이트의 볼륨메쉬를 
말하는데 왜 2를 곱해주고 있냐면 우리가 Rectangle 을 Resources 에 만들때 크기를 1로 만들기 위해서 중앙으로 부터 0.5 씩의 거리를 두고 사각형을 만들었습니다. 
하지만 지금 VS_DirLight에서는 -1 에서 1 사이로 표현되는게 투영좌표계에서 전체 화면이었습니다. 그래서 2씩 곱해서 크기를 맞춰주었습니다.
(지금은 여러 스페이스 변환말고 그냥 직접 투영좌표계를 때려 박아주고 있습니다.) 왜 화면전체로 볼륨메쉬로 잡냐면 디렉셔널 라이트는 따로 영역이 있다기 보다는 
월드 전체를 비추는 용도이기 때문입니다.

다음은 PS_DirLight 입니다. g_tex_0, g_tex_1 에 각각 포지션과 노멀 정보가 들어 있었습니다. 
각각의 Sample 메소드에 input.uv 를 줘서 해당 픽셀에 물체가 있는지를 체크하고 각각 viewNormal, viewPos 에 샘플러를 담아주고 
viewPos 는 한번더 체크를 해주는데 viewPos.z 값이 0 보다 작거나 같으면 clip(-1) 을 해줍니다. 일단 조건부터 보면 view 스페이스에서 Position 은 카메라를 
원점으로 한 스페이스의 포지션 이기 때문에 z 값이 0 과 같거나 작다면 카메라와 곂쳐있거나 뒤에 있다는 뜻이 되고 이때 더이상 함수를 진행하지 않고 
리턴을 하겠다는 의미로 clip(-1) 이 호출된겁니다. clip 함수에 음수를 준다면 그 시점에서 함수를 빠져 나오는 기능이 있다고 합니다. 

체크를 한 후 viewNormal 도 g_tex_1 에서 구해주고 빛연산을 해주는 함수 CalculateLightColor로 픽셀의 색을 계산해줍니다.
이렇게 디렉셔널 라이트는 되었고 

다음으로 포인트 라이트 셰이더 함수를 만들어 주겠습니다.

// [Point Light]
// g_int_0 : Light index
// g_tex_0 : Position RT
// g_tex_1 : Normal RT
// g_vec2_0 : RenderTarget Resolution
// Mesh : Sphere

VS_OUT VS_PointLight(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), g_matWVP);
    output.uv = input.uv;

    return output;
}

PS_OUT PS_PointLight(VS_OUT input)
{
    PS_OUT output = (PS_OUT)0;

    // input.pos = SV_Position = Screen 좌표
    float2 uv = float2(input.pos.x / g_vec2_0.x, input.pos.y / g_vec2_0.y);
    float3 viewPos = g_tex_0.Sample(g_sam_0, uv).xyz;
    if (viewPos.z <= 0.f)
        clip(-1);

    int lightIndex = g_int_0;
    float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
    float distance = length(viewPos - viewLightPos);
    if (distance > g_light[lightIndex].range)
        clip(-1);

    float3 viewNormal = g_tex_1.Sample(g_sam_0, uv).xyz;

    LightColor color = CalculateLightColor(g_int_0, viewNormal, viewPos);

    output.diffuse = color.diffuse + color.ambient;
    output.specular = color.specular;

    return output;
}

아까와 다른점 부터 살펴보자면 일단 포인트 라이트의 볼륨 메쉬는 Sphere 입니다.
 그러다 보니까 VS_PointLight 에서 디렉셔널 처럼 화면 전체를 표시하는게 아니라서 
input.pos 에 2.f 만 곱해서 넘겨주던 디렉셔널 라이트와 다르게 input.pos에 g_matWVP 를 전부 곱해서 넘겨주고 있습니다. uv 는 그대로 넘겨줍니다.

PS_PointLight 를 보기 전에 먼저 여기서 처음 말하지만 light.fx 의 struct 를 만들때 VS_IN 의 pos는 POSITION 으로 해줬고 
VS_OUT 의 pos 는 SV_Position 으로 해놨었습니다. 이건 System Value Position 이라는 뜻인데 이러면 
VS_PointLight 에서 output.pos 로 g_matWVP 를 곱해준 input.pos 가 곧이 곧대로 넘어가는게 아니라 클립스페이스 좌표계로 표현이 될것이고 
레스터라이저 단계 등등을 거쳐서 -1 ~ 1 사이의 값으로 변환이 된다음 PS_PointLight 의 input 으로 넘어가게 됩니다.
즉 PS_PointLight 에서 input.pos = SV_Position = Screen 좌표계 상태로 넘어옵니다. 
Screen 좌표계는 -1 ~ 1 사이의 값으로 표현되었던 Projection 좌표계에서 화면의 Viewport 의 화면비에 따라 각 픽셀의 좌표로 표현되는 
픽셀 좌표계 입니다. 

그런 input.pos 를 가지고 float2 uv 로 만들어 주고 있는데 (uv 좌표계는 맨 왼쪽위의 모서리가 (0,0) 이었고 (1,1) 까지 범위를 가지는 좌표계였습니다.)
float2 uv = float2(input.pos.x / g_vec2_0.x, input.pos.y / g_vec2_0.y);
이 코드에서 g_vec2_0 에 담기는 정보는 RenderTarget Resolution 입니다. 렌더 타겟의 해상도라는 의미인데 
각각 input.pos.x 와 g_vec2_0.x , input.pos.y 와 g_vec2_0.y 를 나눠주면 화면에 0에서 1 사이의 값으로 계산되어 uv 좌표계로 사용할 수 있게됩니다.

이렇게 구한 uv로 해당 텍스쳐 위치에 물체가 있는지를 체크해주게 됩니다.

다음의 코드는 어떤 일을 하고 있냐면 이제 포인트 라이트의 범위를 2D 로 영역을 잡고 또 2D 에서 게임 오브젝트가 포인트 라이트의 볼륨 메쉬 안에 위치한다는걸 
알았는데 그렇다고 해도 진짜 이 물체가 빛의 영역에 들어와 있다고 생각하기 이릅니다. 
무슨 말이냐면 지금은 screen 좌표계이기 때문에 평면에서 곂친다 하더라도 빛과 물체가 3D 월드 스페이스에서는 z값의 차이가 충분히 멀다면 평면에서 곂쳐도 
빛이 닿지 않을 수 있습니다.

그래서 물체와 빛사이의 거리를 테스트 하기위한 코드가 이 부분입니다.
    int lightIndex = g_int_0;
    float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
    float distance = length(viewPos - viewLightPos);
    if (distance > g_light[lightIndex].range)
        clip(-1);
라이트 인덱스가 몇번인지를 lightIndex 를 받고 이 인덱스를 가지고 g_light[lightIndex].position.xyz 로 지금 빛의 포지션을 가져왔는데 이때의 포지션은 
월드 좌표계에서의 포지션입니다. 거기에 View 변환 행렬을 곱해서 viewLightPos 를 만들었습니다. 
다음으로 viewPos 는 지금 연산하고 있는 픽셀에 있던 물체 viewPos 와  광원 viewLightPos 사이의 거리를 계산을 한다음  
그 distance 가 lange 보다 크다면 생략 clip(-1) 을 해줍니다.

여기까지 통과 했다면 그제서야 지금 픽셀의 색을 계산해야 겠다고 알고 노멀 값을 만들고 CalculateLightColor 를 해주고 있습니다.
    float3 viewNormal = g_tex_1.Sample(g_sam_0, uv).xyz;

    LightColor color = CalculateLightColor(g_int_0, viewNormal, viewPos);

    output.diffuse = color.diffuse + color.ambient;
    output.specular = color.specular;

이게 끝이 아니라 이렇게 계산한 빛들을 한곳에 모아서 그려줄 파이널 셰이더가 있습니다.
// [Final]
// g_tex_0 : Diffuse Color Target
// g_tex_1 : Diffuse Light Target
// g_tex_2 : Specular Light Target
// Mesh : Rectangle

VS_OUT VS_Final(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos * 2.f, 1.f);
    output.uv = input.uv;

    return output;
}

float4 PS_Final(VS_OUT input) : SV_Target
{
    float4 output = (float4)0;

    float4 lightPower = g_tex_1.Sample(g_sam_0, input.uv);
    if (lightPower.x == 0.f && lightPower.y == 0.f && lightPower.z == 0.f)
        clip(-1);

    float4 color = g_tex_0.Sample(g_sam_0, input.uv);
    float4 specular = g_tex_2.Sample(g_sam_0, input.uv);

    output = (color * lightPower) + specular;
    return output;
}
사용되는 메쉬는 화면 전체에 그려줄것이기 때문에 Rectangle 이고 g_tex 0,1,2 번에다가 디퓨즈 컬러, 디퓨트 라이트, 스펙큘러 라이트를 받아서 계산해주게 됩니다.

VS_Final 에서는 input.pos 를 디렉셔널과 마찬가지로 Projection 좌표계 형태로 계산해주고 있습니다.

PS_Final 을 보면 먼저 lightPower 라는 rhtdp g_tex_1 을 계산해봤더니 애당초 빛을 안받는 곳이었다면 스킵 clip(-1) 을 해주고 있습니다.
그게 아니고 빛을 받는 곳이라면 그때 color, specular 를 꺼내서 output에 계산해주고 있습니다.

셰이더 코드는 이렇게 수정이 되었고 이제 이 셰이더가 동작하게끔 CPP 코드들을 수정해보겠습니다.



2) Shader (CPP 코드)

우선 Shader.h 파일에서 가장위에 있던 SHADER_TYPE 이라는 enum class 의 내용에서 DEFERRED, FORWARD 외에 LIGHTING 타입을 추가 해주었습니다.
enum class SHADER_TYPE : uint8
{
	DEFERRED,
	FORWARD,
	LIGHTING,
};

그리고 DEPTH_STENCIL_TYPE 에도 추가할 내용이 있습니다. 라이팅에서 깊이 테스트 와 깊이 기록을 할것인지 안할 것인지 이런 옵션이 필요하게 될것입니다.
이전 시간의 결과물이 화면 가운데에 까맣게 처리된 것도 이 깊이 버퍼 옵션에 대한 내용입니다.
enum class DEPTH_STENCIL_TYPE : uint8
{
	LESS,
	LESS_EQUAL,
	GREATER,
	GREATER_EQUAL,
	NO_DEPTH_TEST, // 깊이 테스트(X) + 깊이 기록(O)
	NO_DEPTH_TEST_NO_WRITE, // 깊이 테스트(X) + 깊이 기록(X)
	LESS_NO_WRITE, // 깊이 테스트(O) + 깊이 기록(X)
};

마지막으로 추가되 내용은 BLEND_TYPE 이라는 enum class 가 추가됩니다. 블랜드 타입은 픽셀 셰이더에서 계산한 결과물이랑 렌더 타겟 텍스쳐에 있는 결과물이랑 
어떻게 혼합할지를 얘기 하고 있는것인지 그냥 덮어 쓸것인지, 아니면 1:1 로 섞어줄것인지 아니면 알파 블랜드 라고 알파라는 투명도를 이용한 혼합을 해줄것인지를 
골라주게 됩니다. 
enum class BLEND_TYPE : uint8
{
	DEFAULT,
	ALPHA_BLEND,
	ONE_TO_ONE_BLEND,
	END,
};

블랜드 타입을 ShaderInfo 에도 추가 해줘야 합니다.
struct ShaderInfo
{
	SHADER_TYPE shaderType = SHADER_TYPE::FORWARD;
	RASTERIZER_TYPE rasterizerType = RASTERIZER_TYPE::CULL_BACK;
	DEPTH_STENCIL_TYPE depthStencilType = DEPTH_STENCIL_TYPE::LESS;
	BLEND_TYPE blendType = BLEND_TYPE::DEFAULT; 
	D3D12_PRIMITIVE_TOPOLOGY_TYPE topologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
};

이지 Shader class 로 들어가서 
Shader::Init 에서 인자로 path 와 ShaderInfo 를 받고 있었는데 거기에 추가로 VS_Main, PS_Main 을 인자로 받아서 선택 할 수 있게끔 변경 해줄것입니다.
	void Init(const wstring& path, ShaderInfo info = ShaderInfo(), const string& vs = "VS_Main", const string& ps = "PS_Main");
ShaderInfo 도 따로 설정하지 않으면 기본값을 사용하는것처럼 VS_Main, PS_Main 도 따로 설정하지 않으면 기존대로 사용될것입니다. 
이때 wstring 이 아니라 string 타입으로 해놓은것은 다른 멤버 변수중에 CreateShader 같은 함수들도 string 을 사용하고 있기 때문입니다. 

이제 헤더에서는 수정할것이 없고 구현부 cpp 파일로 넘어가겠습니다. 

cpp 에서는 방금 수정했던 Init 함수를 고쳐줘야합니다. 
먼저 인자 부분을 수정해주고 받은 인자는 Init 함수 안에서 CreateVertexShader, CreatePixelShader 의 인자로 사용되는데 그부분도 바꿔주었습니다.
void Shader::Init(const wstring& path, ShaderInfo info, const string& vs, const string& ps)
{
	_info = info;

	CreateVertexShader(path, vs, "vs_5_0");
	CreatePixelShader(path, ps, "ps_5_0");
// 생략 

이어서 고칠 부분은 shaderType 에 따라 switch case 를 해주는 부분입니다. 
	case SHADER_TYPE::LIGHTING:
		_pipelineDesc.NumRenderTargets = 2;
		_pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		_pipelineDesc.RTVFormats[1] = DXGI_FORMAT_R8G8B8A8_UNORM;
		break;  

이 부분 외에도 depthStencilType 도 수정한 내용을 추가합니다. 
	case DEPTH_STENCIL_TYPE::NO_DEPTH_TEST:
		_pipelineDesc.DepthStencilState.DepthEnable = FALSE;
		_pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
		break;
	case DEPTH_STENCIL_TYPE::NO_DEPTH_TEST_NO_WRITE:
		_pipelineDesc.DepthStencilState.DepthEnable = FALSE;
		_pipelineDesc.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
		break;
	case DEPTH_STENCIL_TYPE::LESS_NO_WRITE:
		_pipelineDesc.DepthStencilState.DepthEnable = TRUE;
		_pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
		_pipelineDesc.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
		break;

DEPTH_STENCIL_TYPE::NO_DEPTH_TEST 의 경우 DepthEnable 을 FALSE 로 해줬는데 의미는 기존에 어떤 dsv 가 있던간에 상관하지 않겠다는 의미이고 
NO_DEPTH_TEST_NO_WRITE 는 심지어 내가 지금 적고 있는 깊이도 적지 않을 것이라는 의미입니다.

여기까지는 기존의 내용의 추가이고 
아예 새로 추가된 옵션이 있었습니다. 블랜드 관련 부분인데요
	D3D12_RENDER_TARGET_BLEND_DESC& rt = _pipelineDesc.BlendState.RenderTarget[0];

	// SrcBlend = Pixel Shader
	// DestBlend = Render Target
	switch (info.blendType)
	{
	case BLEND_TYPE::DEFAULT:
		rt.BlendEnable = FALSE;
		rt.LogicOpEnable = FALSE;
		rt.SrcBlend = D3D12_BLEND_ONE;
		rt.DestBlend = D3D12_BLEND_ZERO;
		break;
	case BLEND_TYPE::ALPHA_BLEND:
		rt.BlendEnable = TRUE;
		rt.LogicOpEnable = FALSE;
		rt.SrcBlend = D3D12_BLEND_SRC_ALPHA;
		rt.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
		break;
	case BLEND_TYPE::ONE_TO_ONE_BLEND:
		rt.BlendEnable = TRUE;
		rt.LogicOpEnable = FALSE;
		rt.SrcBlend = D3D12_BLEND_ONE;
		rt.DestBlend = D3D12_BLEND_ONE;
		break;
	}

참고로 _pipelineDesc 에서 블랜드 설정을 _pipelineDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT); 이렇게 디폴트로 해줬었습니다.

	D3D12_RENDER_TARGET_BLEND_DESC& rt = _pipelineDesc.BlendState.RenderTarget[0];
이 코드를 한번 보면 _pipelineDesc.BlendState.RenderTarget[0] 을 D3D12_RENDER_TARGET_BLEND_DESC 의 참조 타입 rt 에 담아주고 있습니다. 
BlendState 라는것이 무엇인지를 따라 f12 로 따라 들어가보면 그래픽 파이프라인 스테이트 데스크립션 의 멤버중 하나인데 타입은 D3D12_BLEND_DESC 인데 
이것도 따라 들어가보면
typedef struct D3D12_BLEND_DESC
    {
    BOOL AlphaToCoverageEnable;
    BOOL IndependentBlendEnable;
    D3D12_RENDER_TARGET_BLEND_DESC RenderTarget[ 8 ];
    } 	D3D12_BLEND_DESC;
이런 구조체가 나옵니다. 이중 세번째 멤버인 RenderTarger 이라는 배열을 보면 그 타입이 rt의 타입입니다.
마이크로 소프트 문서를 찾아보면 IndependentBlendEnable 를 false로 설정 했을때는 RenderTarget 이 0 번 슬롯만 사용가능하다고 합니다.
애당초 DX12 에서 렌더링 파이프라인으로 넘겨줄 수 있는 렌더타겟이 8개 이기 때문에 8개 짜리 배열인건데 
IndependentBlendEnable 을 false 로 설정해서 굳이 8개의 렌더 타겟을 따로 설정할 필요가 없을때 맨앞의 0번 인덱스의 렌더타겟만 설정하는 것입니다.

그런데 _pipelineDesc.BlendState 를 CD3DX12_BLEND_DESC(D3D12_DEFAULT); 디폴트로 설정했었는데 디폴트의 상태는 
AlphaToCoverageEnable, IndependentBlendEnable 둘다 False 인 상태입니다. 그래서 rt 에서는 RenderTarget 을 하나만 사용합니다.

중요한 부분은 blendType 에 따라 설정하는 부분인데 BlendEnable, LogicOpEnable, SrcBlend, DestBlend 네 옵션을 설정해주고 있습니다. 
BlendEnable 은 아예 섞어주겠다 안섞어주겠다는 걸 고르는 부분입니다. 여기서 True 로 설정하면 SrcBlend, DestBlend 에서 어떻게 섞어줄지를 정하고 있는 부분입니다.
예시로 이부분을 보면 
	case BLEND_TYPE::DEFAULT:
		rt.BlendEnable = FALSE;
		rt.LogicOpEnable = FALSE;
		rt.SrcBlend = D3D12_BLEND_ONE;
		rt.DestBlend = D3D12_BLEND_ZERO;
BlendEnable false 로 섞어주지 않겠다는 뜻이고 SrcBlend, DestBlend 의 옵션을 검색해보면 D3D12_BLEND_ONE 은 (1,1,1,1) D3D12_BLEND_ZERO 는 (0,0,0,0) 비율로 
섞는다는 의미인데 즉 src 만 사용하고 섞지 않습니다. 

이번에는 ALPHA_BLEND 타입을 보면 
	case BLEND_TYPE::ALPHA_BLEND:
		rt.BlendEnable = TRUE;
		rt.LogicOpEnable = FALSE;
		rt.SrcBlend = D3D12_BLEND_SRC_ALPHA;
		rt.DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
BlendEnable 이 True 로 섞어줄것인데 블랜드 옵션이 D3D12_BLEND_SRC_ALPHA, D3D12_BLEND_INV_SRC_ALPHA 입니다. 
각각 어떤 의미냐면 D3D12_BLEND_SRC_ALPHA는 각 픽셀의 flaot4 가 (R,G,B,A) 였는데 이중 네번째 원소인 A 가 Alpha 값을 의미하고 앞의 RGB 를 Alpha 값만큼을 사용한다는 의미고 
D3D12_BLEND_INV_SRC_ALPHA 는 반대로 1 - A 값만큼을 섞어 준다는 의미입니다.

ONE_TO_ONE_BLEND 타입의 경우 D3D12_BLEND_ONE을 두개를 사용하고 있는데 1 : 1 비율로 섞어준다는 의미가 됩니다.

여기서 SrcBlend는 픽셀 셰이더에서 만들어준 색상이고 DestBlend 는 렌더타겟에 있던 색상인데 이 둘을 어떤 방식으로 섞어주느냐에 대한 이야기 였습니다.



3) RenderTargetGroup 

다음은 렌더 타겟을 보겠습니다.
이전에는 렌더 타겟은 두종류 SWAP_CHAIN 과 G_BUFFER 를 사용하고 있었는데 이번시간에 추가한 LIGHTING 타입도 추가해줍니다.
enum class RENDER_TARGET_GROUP_TYPE : uint8
{
	SWAP_CHAIN, // BACK_BUFFER, FRONT_BUFFER
	G_BUFFER, // POSITION, NORMAL, COLOR
	LIGHTING, // DIFFUSE LIGHT, SPECULAR LIGHT
	END,
};
이렇게 LIGHTING 에서는 디퓨즈 라이트, 스펙큘러 라이트 두가지를 가지고 있을겁니다.
거기에 더해서 그룹 멤버 카운트를 담고 있는 enum 에	RENDER_TARGET_LIGHTING_GROUP_MEMBER_COUNT = 2 라고 추가도 해주었습니다.

더이상 RenderTargetGroup 의 코드를 수정할게 없지만 이 렌더 타겟 그룹을 생성하고 있는 곳이 Engine 클래스였습니다. 
Engine::CreateRenderTargetGroup 에서 렌더 타겟 그룹을 만들어 주고 있는데 지금 추가한 LIGHTING 때문에 _rtGroups 라는 Engine 멤버 변수인 배열의 크기가 늘었고
LIGHTING 도 구현부에 추가해 줘야 겠습니다.
Engine::CreateRenderTargetGroup
	// Lighting Group
	{
		vector<RenderTarget> rtVec(RENDER_TARGET_LIGHTING_GROUP_MEMBER_COUNT);

		rtVec[0].target = GET_SINGLE(Resources)->CreateTexture(L"DiffuseLightTarget",
			DXGI_FORMAT_R8G8B8A8_UNORM, _window.width, _window.height,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
			D3D12_HEAP_FLAG_NONE, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);

		rtVec[1].target = GET_SINGLE(Resources)->CreateTexture(L"SpecularLightTarget",
			DXGI_FORMAT_R8G8B8A8_UNORM, _window.width, _window.height,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
			D3D12_HEAP_FLAG_NONE, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);

		_rtGroups[static_cast<uint8>(RENDER_TARGET_GROUP_TYPE::LIGHTING)] = make_shared<RenderTargetGroup>();
		_rtGroups[static_cast<uint8>(RENDER_TARGET_GROUP_TYPE::LIGHTING)]->Create(RENDER_TARGET_GROUP_TYPE::LIGHTING, rtVec, dsTexture);
	}
렌더타겟 벡터는 두개 짜리 각각 이름을 DiffuseLightTarget, SpecularLightTarget 으로 지었고 인자도 넣어주었습니다.



4) SceneManager
다음으로 고쳐볼 클래스는 SceneManager 입니다. 
그 중에서도 SceneManager::LoadTestScene 인데 만들었던 오브젝트들을 순서대로 보면 메인 카메라, UI 카메라, 스카이 박스는 딱히 건드릴 부분이 없을것 같아 스킵을 하고 
큐브 부터 광원 오브젝트 까지를 수정을 할것입니다. 

먼저 큐브 를 보면
#pragma region Object // 변경점
	{
		shared_ptr<GameObject> obj = make_shared<GameObject>();
		{
			shared_ptr<Mesh> sphereMesh = GET_SINGLE(Resources)->LoadSphereMesh();
			meshRenderer->SetMesh(sphereMesh);
		}
	}
#pragma endregion
이름을 Object 라는 이름으로 바꿨고 메쉬를 큐브에서 Sphere 로 변경했습니다 네모보다는 구가 빛의 영향을 크게 받을 수 있을것입니다.

UI_Test 의 변경점은 
#pragma region UI_Test // 변경점
	for (int32 i = 0; i < 5; i++)
	{
		{
			shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Texture");

			shared_ptr<Texture> texture;
			if (i < 3)
				texture = GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->GetRTTexture(i);
			else
				texture = GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::LIGHTING)->GetRTTexture(i - 3);

	}
#pragma endregion

일단 5개를 만들어 줄것이고 로컬 포지션은 그대로 띄엄띄엄 둘것이고 달라지는 부분은 셰이더를 끌고 올때 Texture 라는 이름의 셰이더를 가져다 쓰는데 
사실 이부분이 의문인게 이번 강의에서 Texture 전용 셰이더는 forward.fx 안에 같이 적어 놓았는데 이걸 어떻게 Texture 라는 이름으로 불러 올 수 있는지 
모르겠습니다.(영상뒤쪽에서 말씀이 지금 SceneManager 다음 차례로 Resources 로 가서 만들어 줄것이라고 합니다.)

하여튼 다음은 UI 오브젝트중 처음 3개는 G_BUFFER 의 텍스쳐를 나머지 2개는 LIGHTING 의 텍스쳐를 가져다가 그려줄겁니다.

마지막으로 빛 오브젝트는 세가지 타입의 빛을 모두 만들어 주겠습니다. 
#pragma region Directional Light
	{
		shared_ptr<GameObject> light = make_shared<GameObject>();
		light->AddComponent(make_shared<Transform>());
		//light->GetTransform()->SetLocalPosition(Vec3(0.f, 150.f, 150.f));
		light->AddComponent(make_shared<Light>());
		light->GetLight()->SetLightDirection(Vec3(0, 0, 1.f));
		light->GetLight()->SetLightType(LIGHT_TYPE::DIRECTIONAL_LIGHT);
		light->GetLight()->SetDiffuse(Vec3(1.f, 0.f, 0.f));
		light->GetLight()->SetAmbient(Vec3(0.1f, 0.1f, 0.1f));
		light->GetLight()->SetSpecular(Vec3(0.2f, 0.2f, 0.2f));

		scene->AddGameObject(light);
	}
#pragma endregion

#pragma region Point Light
	{
		shared_ptr<GameObject> light = make_shared<GameObject>();
		light->AddComponent(make_shared<Transform>());
		light->GetTransform()->SetLocalPosition(Vec3(0.f, 100.f, 150.f));
		light->AddComponent(make_shared<Light>());
		//light->GetLight()->SetLightDirection(Vec3(-1.f, -1.f, 0));
		light->GetLight()->SetLightType(LIGHT_TYPE::POINT_LIGHT);
		light->GetLight()->SetDiffuse(Vec3(0.0f, 0.5f, 0.0f));
		light->GetLight()->SetAmbient(Vec3(0.0f, 0.3f, 0.0f));
		light->GetLight()->SetSpecular(Vec3(0.0f, 0.3f, 0.0f));
		light->GetLight()->SetLightRange(200.f);

		scene->AddGameObject(light);
	}
#pragma endregion

#pragma region Spot Light
	{
		shared_ptr<GameObject> light = make_shared<GameObject>();
		light->AddComponent(make_shared<Transform>());
		light->GetTransform()->SetLocalPosition(Vec3(75.f, 0.f, 150.f));
		light->AddComponent(make_shared<Light>());
		light->GetLight()->SetLightDirection(Vec3(-1.f, 0, 0));
		light->GetLight()->SetLightType(LIGHT_TYPE::SPOT_LIGHT);
		light->GetLight()->SetDiffuse(Vec3(0.0f, 0.f, 0.5f));
		light->GetLight()->SetAmbient(Vec3(0.0f, 0.0f, 0.1f));
		light->GetLight()->SetSpecular(Vec3(0.0f, 0.0f, 0.1f));
		light->GetLight()->SetLightRange(200.f);
		light->GetLight()->SetLightAngle(3.14f / 2);

		scene->AddGameObject(light);
	}
#pragma endregion

각각 빨간색 초록색 파란색으로 나눠서 만들어 줬습니다.


5) Resources

예전에 자주 사용하는 기본 셰이더를 만드는 CreateDefaultShader 라는 함수를 만들었었습니다. skybox, deferred, forward 셰이더를 만들었었는데
거기에 추가로 Texture, DirLight, PointLight,Final 기본 셰이더를 추가해줄겁니다. 
Texture 셰이더만드는 코드를 예로 들어보겠습니다. 
	// Texture (Forward)
	{
		ShaderInfo info =
		{
			SHADER_TYPE::FORWARD,
			RASTERIZER_TYPE::CULL_NONE,
			DEPTH_STENCIL_TYPE::NO_DEPTH_TEST_NO_WRITE
		};

		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->Init(L"..\\Resources\\Shader\\forward.fx", info, "VS_Tex", "PS_Tex");
		Add<Shader>(L"Texture", shader);
	}
포워드 셰이더와 다른점은 RASTERIZER_TYPE 과 DEPTH_STENCIL_TYPE 의 옵션이 다릅니다. 이 셰이더는 UI 에 입힐 텍스쳐이기 때문에 빛의 영향도 받지 않을것이고 
깊이 영향도 받지 않도록 설정해주었습니다.
포워드와 중요한 차이점은 Init을 할때 세번째 네번째 인자를 직접 주고 있습니다. 인자로 주는 VS_Tex, PS_Tex 는 forward.fx 안에 같이 넣어놓은 Texture 용 셰이더 입니다.
경로는 forward 인데 그 안에 사용할 셰이더 함수를 지정함으로써 텍스쳐용 셰이더의 기능을 얻을 수 있었습니다.

DirLight 셰이더도 코드를 보겠습니다.
	// DirLight
	{
		ShaderInfo info =
		{
			SHADER_TYPE::LIGHTING,
			RASTERIZER_TYPE::CULL_NONE,
			DEPTH_STENCIL_TYPE::NO_DEPTH_TEST_NO_WRITE,
			BLEND_TYPE::ONE_TO_ONE_BLEND
		};

		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->Init(L"..\\Resources\\Shader\\lighting.fx", info, "VS_DirLight", "PS_DirLight");
		Add<Shader>(L"DirLight", shader);
	}
SHADER_TYPE 이 LIGHTING 입니다. 그리고 RASTERIZER_TYPE 이 CULL_NONE 인데 그 이유는 빛은 빛이 비추는 영역을 볼륨메쉬로 생성하고 그 범위에 물체가 있는지를 
체크한다고 했습니다. 지금 하는 DirLight는 화면 전체를 범위로 하니까 괜찮은데 좀있다 나올 PointLight 같은 경우에는 볼륨메쉬가 구 인데 
그 범위 안에 카메라가 있다고 했을때 카메라 뒤로 넘어가는 범위는 괜히 CULL 옵션이 역순으로 되어있다고 판단이 되서 걸러지는 상황이 생길수 있습니다. 
그걸 방지하기 위해서 그냥 CULL을 하지 않도록 옵션을 설정 했습니다. 그리고 Init 에서도 lighting.fx 에서 DirLight 함수들을 설정했습니다.

PointLight 는 DirLight 에서 Init 할때 사용할 함수만 PointLight 용 함수로 설정해주면됩니다.

최종적으로 조립할 Final 셰이더는 이렇습니다.
	// Final
	{
		ShaderInfo info =
		{
			SHADER_TYPE::LIGHTING,
			RASTERIZER_TYPE::CULL_BACK,
			DEPTH_STENCIL_TYPE::NO_DEPTH_TEST_NO_WRITE,
		};

		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->Init(L"..\\Resources\\Shader\\lighting.fx", info, "VS_Final", "PS_Final");
		Add<Shader>(L"Final", shader);
	}
얘는 조립에 사용할 VS_Final, PS_Final 을 넣어주고 딱히 어려운것은 없습니다. 


거기에 더해서 또 자주 사용하는 Material 도 기본 생성 함수를 만들어 줄겁니다. 이 CreateDefaultMaterial 함수는 Resources::Init 에서 CreateDefaultShader 다음으로 
실행해줄것입니다. 먼저 만든 디폴트 셰이더를 가져다가 Material 을 만들어서 셰이더를 추가한후 반환하는 함수입니다. 
종류는 skybox, DirLight, PointLight, Final 이 있습니다.

이들의 구현부는 이것이 기본입니다. 

void Resources::CreateDefaultMaterial()
{
	// Skybox
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Skybox");
		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);
		Add<Material>(L"Skybox", material);
	}
원하는 용도의 셰이더 리소스를 가져다가 변수를 만들고 새로 생성한 Material 에 shader 를 세팅후 Resources::Add 로 리소스를 생성합니다. 
스카이 박스는 이렇게 끝인데 
빛 관렬 Material 은 여기서 더 추가 되는게 SetTexture 가 추가 됩니다. 

Dir Light 에 대한 Material 은 이렇습니다. 스카이박스와 다른점인 SetTexture 로 주는 텍스쳐들은 Engine에서 RenderTargetGroup 을 생성할때 만들어 줬던 텍스쳐 
리소스들 입니다. 그리고 포지션 타겟, 노멀 타겟을 세팅할때 앞의 0과 1 은 등록할 슬롯을 말하는건데 지금같은 순서로 넣어줘야하는 이유는 이번 강의 코드 처음에 만들었던 
셰이더 파일들이 지금과 같은 슬롯 순서로 되어 있기 때문입니다.
	// DirLight
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"DirLight");
		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);
		material->SetTexture(0, GET_SINGLE(Resources)->Get<Texture>(L"PositionTarget"));
		material->SetTexture(1, GET_SINGLE(Resources)->Get<Texture>(L"NormalTarget"));
		Add<Material>(L"DirLight", material);
	}

다음 PointLight 은 DirLight 에서 차이점이 조금 있는데 윈도우의 해상도를 넘겨주기 위해 
		const WindowInfo& window = GEngine->GetWindow();
		Vec2 resolution = { static_cast<float>(window.width), static_cast<float>(window.height) };
이렇게 resolution 에 프로그램 창의 너비 높이를 받아주고 있고 Material 에 넘겨줄때는 
		material->SetVec2(0, resolution);
이렇게 넘겨줍니다 이 이외에는 DirLight 와 똑같습니다. 
그런데 아직 Material 에는 SetVec2 라는 멤버가 아직 없기 때문에 이것도 구현해주겠습니다.

그전에 Final 의 Material 생성 코드는 SetTexture 를 3개를 해주는데 슬롯 순서대로 DiffuseTarget, DiffuseLightTarget, SpecularLightTarget 로 세팅해주면 됩니다.

6) Material

Resources::CreateDefaultMaterial  의 PointLight 에 있던 SetVec2 멤버를 추가해주겠습니다.

그전에 마테리얼에서 관리하던 enum이 마테리얼 멤버 갯수를 관리하고 있었는데요 이부분도 이번강의 코드 시작할때 수정했던 params.fx 의 파라미터 용량을 모두 16 바이트로 
맞추기 위해 4개씩으로 수정했던걸 여기서도 수정해주겠습니다. 하는김에 오늘 추가되는것도 해주겠습니다.
enum
{
	MATERIAL_INT_COUNT = 4,
	MATERIAL_FLOAT_COUNT = 4,
	MATERIAL_TEXTURE_COUNT = 4,
	MATERIAL_VECTOR2_COUNT = 4
};
그리고 struct MaterialParams 에도 추가해줍니다.
struct MaterialParams
{
	void SetInt(uint8 index, int32 value) { intParams[index] = value; }
	void SetFloat(uint8 index, float value) { floatParams[index] = value; }
	void SetTexOn(uint8 index, int32 value) { texOnParams[index] = value; }
	void SetVec2(uint8 index, Vec2 value) { vec2Params[index] = value; }

	array<int32, MATERIAL_INT_COUNT> intParams;
	array<float, MATERIAL_FLOAT_COUNT> floatParams;
	array<int32, MATERIAL_TEXTURE_COUNT> texOnParams;
	array<Vec2, MATERIAL_VECTOR2_COUNT> vec2Params;
};

클래스 내용도 보면 public 으로 
	void SetVec2(uint8 index, Vec2 value) { _params.SetVec2(index, value); }
이 멤버 함수도 추가해주면 들고 있던 _params 에 Vec2 도 추가해주게 됩니다.

이렇게 마테리얼도 완료 했고 

다음은 SceneManager 에서 만들어준 오브젝트들을 렌더링 할 차례입니다.

7) Scene::Render 

렌더링을 하는 부분이 어딘지 잘 생각 해보면 Engine::Render 에서 _cmdQueue->RenderBegin 과 RenderEnd 사이에서 GET_SINGLE(SceneManager)->Render()로 렌더링을 하고 있었고
SceneManager->Render() { if(_activeScene) _activeScene->Render();} 
를 해줍니다. 즉 Scene에서 렌더링을 해줍니다.

Scene->Render() 의 대략적인 내용은 순서대로 PushLightData() , 후면 버퍼 인덱스 가져오기 , 엔진에서 렌더타겟그룹을 가져오고 후면버퍼의 렌더타겟을 클리어 해줌,
이렇게 스왑체인 그룹을 초기화 후 다시 엔진의 렌더타겟그룹에서 G_BUFFER 를 초기화함
다음은 Scene 이 가지고 있는 _gameObjects 를 for문 돌면서 카메라 컴포넌트가 있는지를 체크 없다면 continue 
카메라 컴포넌트를 가지고 있다면 SortGameObject 로 카메라에 포착된 게임오브젝트들의 셰이더가 Deferred 인지 Forward 인지를 분류해서 각각의 vec에 넣어둡니다.
이제 엔진에서 G_BUFFER 렌더타겟그룹을 OMSetRenderTargets() 를 해주고 카메라의 Render_Deferred() 를 해줍니다. 다음으로 SWAP_CHAIN 렌더타겟그룹을 OMSetRenderTargets
해주고 카메라 Render_Forward() 를 해주고 있었습니다. 

이 방식에서 변경을 해줄 것인데 지금은 모든 카메라를 디퍼드 포워드 렌더를 전부 해주고 있었는데 바뀔 내용은 메인 카메라만 디퍼드 렌더를 해주고 
나머지 카메라에 대해서만 포워드 렌더를 해주게 바꿀 것입니다. 

유니티 같은 경우에도 메인카메라 만 인지를 해서 그 카메라만 디퍼드 렌더링을 해주고 있는데 우리 엔진에서도 비슷하게 구현을 하고 싶습니다.
그러기 위해서 카메라와 빛을 따로 관리를 해주도록 하겠습니다.

Scene 에서 가지고 있던 멤버 변수는 
	vector<shared_ptr<GameObject>>		_gameObjects;
뿐이었지만 거기에 더해서 따로 
	vector<shared_ptr<class Camera>>	_cameras;
	vector<shared_ptr<class Light>>		_lights;
를 추가로 가지고 있도록 해줄겁니다.

이 오브젝트들을 분류를 해주려면 Scene->AddGameObject 에서 지금까지는 그냥 푸시 벡 게임오브젝트만 해주고 있었지만 
void Scene::AddGameObject(shared_ptr<GameObject> gameObject)
{
	_gameObjects.push_back(gameObject);
}

지금 부터는 추가 될때 게임 오브젝트가 가지고 있는 컴포넌트를 체크해서 각각 알맞는 vector 에 들어가도록 해주겠습니다.
void Scene::AddGameObject(shared_ptr<GameObject> gameObject)
{
	if (gameObject->GetCamera() != nullptr)
	{
		_cameras.push_back(gameObject->GetCamera());
	}
	else if (gameObject->GetLight() != nullptr)
	{
		_lights.push_back(gameObject->GetLight());
	}

	_gameObjects.push_back(gameObject);
}
원래는 여기에 더해서 카메라 컴포넌트와 라이트 컴포넌트를 동시에 가지고 있는 잘 없는 상황을 예외처리해줘야 하는데 일단은 그냥 넘어가겠습니다.

여기에 또한가지 RemoveGameObject 에서도 지금까지 그냥 지울 오브젝트를 _gameObjects 에서 find , erase 해주고 있었는데 
이제 분류가 3개로 늘어났으니 조건문으로 잘 분류해서 지워줘야 겠습니다.
void Scene::RemoveGameObject(shared_ptr<GameObject> gameObject)
{
	if (gameObject->GetCamera())
	{
		auto findIt = std::find(_cameras.begin(), _cameras.end(), gameObject->GetCamera());
		if (findIt != _cameras.end())
			_cameras.erase(findIt);
	}
	else if (gameObject->GetLight())
	{
		auto findIt = std::find(_lights.begin(), _lights.end(), gameObject->GetLight());
		if (findIt != _lights.end())
			_lights.erase(findIt);
	}

	auto findIt = std::find(_gameObjects.begin(), _gameObjects.end(), gameObject);
	if (findIt != _gameObjects.end())
		_gameObjects.erase(findIt);
}

빛도 따로관리하게 되면서 Scene::PushLightData 의 코드도 손을 봐야합니다. 지금까지 _gameObjects 에서 light 컴포넌트가 있는 오브젝트들을
lightParams 에 하나씩 빛 정보를 추가해주고 있었는데 빛 오브젝트들을 모아 놓았으니 거기서 가져오도록 수정을 해줍니다.
void Scene::PushLightData()
{
	LightParams lightParams = {};
	for (auto& light : _lights)
	{
		const LightInfo& lightInfo = light->GetLightInfo();
		//TODO
		lightParams.lights[lightParams.lightCount] = lightInfo;
		lightParams.lightCount++;
	}
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::GLOBAL)->SetGlobalData(&lightParams, sizeof(lightParams));
}
좀더 간편해졌습니다. //TODO 위치에는 나중에 추가할 코드가 있다면 추가해주겠습니다.


이렇게 수정을 해주면 카메라는 _cameras 에 빛은 _lights 에 모여있을것이니 이 캐싱된값을 이용해가지고 편하게 만들수가 있을것입니다.

이제 본격적으로 Scene::Render 를 고쳐보겠습니다.
PushLightData, 스왑 체인 그룹 초기화, 디퍼드 그룹 초기화 까지 그대로 해준다음 추가로 LIGHTING 그룹도 초기화를 해줍니다.
다음으로 디퍼드 그룹 (G_BUFFER 그룹) 을 OMSetRenderTargets 을 해주고 메인카메라를 특정한다음 메인 카메라만 Render_Deferred와 Render_Forward 를 해주고 
메인 이외의 카메라는 Render_Forward 만 해주도록 하겠습니다.
	// Deferred OMSet
	GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->OMSetRenderTargets();

	shared_ptr<Camera> mainCamera = _cameras[0];
	mainCamera->SortGameObject();
	mainCamera->Render_Deferred();

	RenderLights();
	RenderFinal();

	mainCamera->Render_Forward();

	for (auto& camera : _cameras)
	{
		if (camera == mainCamera)
			continue;

		camera->SortGameObject();
		camera->Render_Forward();
	}
위의 코드를 보면 메인카메라는 _cameras 의 첫번째 원소를 메인 카메라라고 특정을 하고 있습니다. 우리가 정한 겁니다. 
이 코드에서 새로운 멤버 함수가 보입니다. RenderLight() RenderFinal() 인데 Lighting 과 관련된 렌더링을 해주고 최종적으로 취합하는 함수입니다. 
여기까지 실행이 되면 빛에 의해서 보이는 모든 물체들을 그려주게 될것이고 

RenderLight() RenderFinal() 를 추가 해주겠습니다.
void Scene::RenderLights()
{
	GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::LIGHTING)->OMSetRenderTargets();

	// 광원을 그린다.
	for (auto& light : _lights)
	{
		light->Render();
	}
}

void Scene::RenderFinal()
{
	// Swapchain OMSet
	int8 backIndex = GEngine->GetSwapChain()->GetBackBufferIndex();
	GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::SWAP_CHAIN)->OMSetRenderTargets(1, backIndex);

	GET_SINGLE(Resources)->Get<Material>(L"Final")->PushData();
	GET_SINGLE(Resources)->Get<Mesh>(L"Rectangle")->Render();
}

위의 Render 에서는 G_BUFFER 만 OMSetRenderTargets 을 해주고 있었는데 이 부분들에서 Lighting 과 SWAP_CHAIN 도 OMSetRenderTargets 을 해줍니다. 
RenderLight를 보면 LIGHTING 을 OMSet 해주고 _lights 를 순회해주며 Light 객체들을 Render 해주고 있습니다. 그런데 우리는 아직 Light 클래스에 Render 함수를 만든적이 없죠

RenderFinal 에서는 후면 버퍼 인덱스를 가져와서 스왑체인 OMSet 해주면서 인덱스도 같이 넣어 줬습니다. 그러고는 Final Material 을 가졍와서 PushData 와 
Rectangle Mesh Render 도 해줍니다.

아직 준비가 덜된 코드가 있습니다. RenderFinal 에서 light->Render 를 아직 만들어 주지 않았고 그리고 광원 자체도 자신이 몇번째 광원인지를 알아야될것입니다. 

먼저 PushLightData 에서 //TODO 로 미뤄뒀던 부분에서 광원의 인덱스를 설정해줄것입니다.
		light->SetLightIndex(lightParams.lightCount);
하지만 SetLightIndex 라는 함수도 아직 Light 클래스 내에 없습니다. 
그래서 SetLightIndex 에서 자신이 몇번째 빛인지 알고 Render를 하게 되면 될것입니다.

8) Light 
이번에 추가되는 멤버 변수는 자신의 인덱스 번호, 자신의 볼륨 메쉬, Light 셰이더에 인자를 넘겨주고 싶을때 사용할 마테리얼 을 추가 해줍니다.
	int8 _lightIndex = -1;
	shared_ptr<class Mesh> _volumeMesh;
	shared_ptr<class Material> _lightMaterial;

SetLightIndex 는 간편하게 인자로 받은 int8 을 _lightIndex 에 넣어주는 코드입니다.
	void SetLightIndex(int8 index) { _lightIndex = index; }

그리고 void SetLightType(LIGHT_TYPE type) 이라는 자신의 타입을 설정하는 함수가 있었는데 이제는 빛 타입에 따라 설정할 데이터가 많아졌기 때문에 
cpp 파일쪽으로 구현부를 옮겨서 수정을 해줄겁니다.
void Light::SetLightType(LIGHT_TYPE type)
{
	_lightInfo.lightType = static_cast<int32>(type);

	switch (type)
	{
	case LIGHT_TYPE::DIRECTIONAL_LIGHT:
		_volumeMesh = GET_SINGLE(Resources)->Get<Mesh>(L"Rectangle");
		_lightMaterial = GET_SINGLE(Resources)->Get<Material>(L"DirLight");
		break;
	case LIGHT_TYPE::POINT_LIGHT:
		_volumeMesh = GET_SINGLE(Resources)->Get<Mesh>(L"Sphere");
		_lightMaterial = GET_SINGLE(Resources)->Get<Material>(L"PointLight");
		break;
	case LIGHT_TYPE::SPOT_LIGHT:
		_volumeMesh = GET_SINGLE(Resources)->Get<Mesh>(L"Sphere");
		_lightMaterial = GET_SINGLE(Resources)->Get<Material>(L"PointLight");
		break;
	}
}
기존의 기능이었던 _lightInfo.lightType 을 설정해주고 나서 자신의 타입에 따라 _volumeMesh 와 _lightMaterial 을 설정해줍니다. 
스포트 라이트 같은경우 메쉬를 원뿔 모양의 메쉬를 다시 만들어서 최적화 해줄 수도 있지만 지금은 Resources 에서 만들어 주지 않았습니다.

이제 Light::Render 차례입니다. 
void Light::Render()
{
	assert(_lightIndex >= 0);

	GetTransform()->PushData();

	_lightMaterial->SetInt(0, _lightIndex);
	_lightMaterial->PushData();

	switch (static_cast<LIGHT_TYPE>(_lightInfo.lightType))
	{
	case LIGHT_TYPE::POINT_LIGHT:
	case LIGHT_TYPE::SPOT_LIGHT:
		float scale = 2 * _lightInfo.range;
		GetTransform()->SetLocalScale(Vec3(scale, scale, scale));
		break;
	}

	_volumeMesh->Render();
}
assert 로 _lightIndex 를 체크하고 나서 Transform 의 PushData 를 해주고 있습니다. 이제부터 Light 오브젝트들은 _volumeMesh 를 가지고 자신의 영역을 표시 하고 있을겁니다.
이 영역의 범위가 빛 오브젝트의 위치로부터 시작 될것이니깐 트랜스폼 정보를 푸시 해주고 있습니다.
다음으로 _lightMaterial에 SetInt 로 0번 슬롯에 자신의 인덱스 정보를 넣어부고 푸시 합니다.

그리고 나서 현재 빛 오브젝트의 타입을 switch case 로 포인트 이거나 스포트 라면 x,y,z scale 을 자신의 range 의 두배로 설정해주고 있습니다. 
왜 그러냐면 range는 빛 오브젝트의 중심으로 부터 영향을 받는 범위가 되는데 이것은 즉 볼륨 메쉬의 반지름이 됩니다. 그래서 각각 x,y,z 축 을 지름만큼의 크기로 설정해주고 있습니다.
마지막으로 _volumeMesh 를 렌더 해줍니다.


여기까지 한다음 빌드후 실행 해보면 실행이 됩니다. 
하지만 지금 상태에서 카메라로 오브젝트를 경계쪽으로 찍히게끔 옮기면 오브젝트와 렌더 타겟들이 지직거리면서 출력이 이상하게 됩니다. 
왜 이러냐면 우리가 스왑체인에서 두개의 버퍼를 번갈아 사용하면서 화면을 그리고 있었고 이걸 더블 버퍼링이라고 했었습니다.
이걸 사용하는 이유와 이 지직 거리는게 발생하는 이유가 비슷합니다. 

더블 버퍼링은 매 프레임마다 화면을 그려줄때 현재 출력하고 있는 버퍼에 그대로 다음 프레임을 그려주면 이전 프레임 화면의 잔성이 남고 지직거리는 걸 방지하기위해 
현재 프레임은 전면 버퍼에 그려주고 다음 프레임을 그려줄 후면 버퍼는 보이지 않게 뒤에서 그려서 다 완성이 된후에 화면에 출력해주는 기술입니다. 

즉, 현재 프로그램이 지직거리는 이유와 더블 버퍼링을 사용하는 이유가 비슷하다면 현재 프로그램이 현재 프레임의 화면과 다음 프레임의 화면을 동시에 출력하거나 
하나의 버퍼를 가지고 출력하고 있기 때문이란 말입니다.
지금 텍스쳐를 렌더링 하는 용도와 GPU에서 다음 프레임을 그려주는 용도가 곂치고 있습니다.

결국은 이 G_BUFFER 나 LIGHTING 의 렌더타겟그룹 의 텍스쳐들을 렌더 타겟용도로 활용을 하면서 동시에 텍스쳐(리소스) 용도로 활용하는걸 동시에 하지 않게끔 
중간에 끊어줄 필요가 있다는 말이고 그러기 위해서는 중간에 배리어를 둬서 한번 끊어줘야 겠습니다.

배리어는 이전에 스왑체인을 알아볼때 나왔던 개념인데 

9) RenderTargetGroup

배리어는 렌더타겟그룹 안에 추가해줄겁니다.

class RenderTargetGroup
{
public:
// 생략

	void WaitTargetToResource();
	void WaitResourceToTarget();

private:
	D3D12_RESOURCE_BARRIER			_targetToResource[8];
	D3D12_RESOURCE_BARRIER			_resourceToTarget[8];
};
리소스 배리어 변수 두개 를 만들었는데 각각 8개 짜리 배열로 되어있고 _targetToResource 렌더타겟에서 리소스로 넘어갈때 치는 배리어고 
_resourceToTarget 는 반대로 리소스에서 렌더 타겟으로 넘어갈때 치는 배리어입니다.

그리고 이것들을 지원하기 위한 Wait 함수도 만들어주겠습니다. 구현부는 이렇습니다. 
void RenderTargetGroup::WaitTargetToResource()
{
	CMD_LIST->ResourceBarrier(_rtCount, _targetToResource);
}

void RenderTargetGroup::WaitResourceToTarget()
{
	CMD_LIST->ResourceBarrier(_rtCount, _resourceToTarget);
}
각자 어디서 어디로 넘어갈때 _rtCount 갯수에 맞게 렌더 타겟을 기다려주는 배리어를 치는 함수인거고 

아직 배리어 자체를 만들지 않았는데 만들어 주는 위치는 
RenderTargetGroup::Create 함수에서 입니다. 
Create 에서 렌더 타겟 뷰를 DEVICE 로 CoptDescriptor 해준 다음 에 이 코드가 들어갑니다.
	for (int i = 0; i < _rtCount; ++i)
	{
		_targetToResource[i] = CD3DX12_RESOURCE_BARRIER::Transition(_rtVec[i].target->GetTex2D().Get(),
			D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COMMON);

		_resourceToTarget[i] = CD3DX12_RESOURCE_BARRIER::Transition(_rtVec[i].target->GetTex2D().Get(),
			D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_RENDER_TARGET);
	}
CD3DX12_RESOURCE_BARRIER::Transition 을 해주고 있는데 이 메소드는 이전에 CommandQueue::RenderBegin, CommandQueue::RenderEnd 에서 사용햇었습니다. 
그때는 RenderBegin 에서 인자로 후면 버퍼를 주고 Present(출력용도) 에서 Render Target(그려줄 용도) 으로 트랜지션(전환) 했다가  
RenderEnd 에서 Render Target 에서 다시 Present 로 전환해줍니다. 
렌더링을 시작할때의 후면버퍼는 방금까지 전면 버퍼였어써 Present 로 출력용으로 사용하고 있었던걸 렌더링 시작하면서 그려줄 용도로 전환하고 
렌더링 끝날때는 그려줄거 다 그려줬으니 전면버퍼로 가서 출력할 준비로 Present로 다시 전환한것입니다.

이 원리와 비슷하게 지금 배리어도 렌더 타겟 용도와 스테이트 커먼 용도가 왔다 갔다 하고 있는겁니다.
_rtCount 의 크기 만큼 배리어 변수들 각각의 _rtVec 의 인덱스들을 담이주고 있습니다.

그러면 이제 이 배리어들을 어디에서 누가 사용하게 될것인지를 생각해보겠습니다. 
배리어가 필요한 경우는 실제로 화면에 그려지는 렌더 타겟들에게 필요할것이기 때문에 G_BUFFER 와 LIGHTING 의 렌더 타겟들에게 필요할것같습니다.
스왑체인같은 경우는 기존에 사용하던대로 자신이 사용하던걸 그대로 사용할것입니다.

사용할 위치는 RenderTargetGroup::ClearRenderTargetView 인데 이 함수가 두가지 버전이 있었습니다. 인자로 인덱스를 주는 버전과 인자없이 들고있는 _rtCount 를 가지고 
하는 버전입니다. 이중에 인덱스를 인자로 주는 버전은 스왑체인 타입의 렌더 타겟 그룹을 초기화 할때 사용됩니다. 인자인 인덱스가 후면버퍼의 인덱스를 줄것입니다. 
그러면 인자가 없는 버전이 우리가 지금 추가하려는 배리어의 대상입니다. 
void RenderTargetGroup::ClearRenderTargetView()
{
	WaitResourceToTarget();

	for (uint32 i = 0; i < _rtCount; i++)
	{
		D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = CD3DX12_CPU_DESCRIPTOR_HANDLE(_rtvHeapBegin, i * _rtvHeapSize);
		CMD_LIST->ClearRenderTargetView(rtvHandle, _rtVec[i].clearColor, 0, nullptr);
	}

	CMD_LIST->ClearDepthStencilView(_dsvHeapBegin, D3D12_CLEAR_FLAG_DEPTH, 1.f, 0, 0, nullptr);
}
이 함수에서는 렌더 타겟을 싹 밀어줄건데 시작하기 전에 D3D12_RESOURCE_STATE_COMMON 이었던 버퍼를 렌더 타겟 용도로 전환해주는 배리어를 실행한 후에 Clear 를 진행 해주겠습니다.

12) Scene::Render
다음으로 ClearRenderTargetView 가 실행되던 코드는 Scene::Render 에서 실행되고 있었습니다. 

Render 가 실행되면 빛 데이터를 푸시 해주고 세가지 타입 스왑체인, G_BUFFER, LIGHTING 의 렌더 타겟 그룹들을 Clear 해주고 있는데 이 Clear 코드 안에 
배리어를 실행해줬고 그 결과 그려줄 용도로 전환된 상태에서 그려줄 것을 다 그려준 때에 이제 다시 렌더 타겟 상태에서 D3D12_RESOURCE_STATE_COMMON 으로 전환을 해주겠습니다.
	mainCamera->SortGameObject();
	mainCamera->Render_Deferred();
	GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->WaitTargetToResource();
Render_Deferred 를 한 다음에 G_BUFFER 의 타겟에서 리소스로 배리어를 실행해주고 

	RenderLights();
	GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::LIGHTING)->WaitTargetToResource();
RenderLight 가 된 뒤에는 LIGHTING 의 타겟에서 리소스로 배리어를 실행 해주었습니다.


13) 디버그 
여기까지 하고 다 되었나 해서 빌드하고 실행을 해보면 에러 메세지가 많이 발생하게 되는데 에러메세지는 상태가 맞지 않다고 하는데 
이게 어느 부분에서 비롯된 에러인지 살펴보면 Texture::Create 에서 발생한 에러 입니다.
	if (resFlags & D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)
	{
		resourceStates = D3D12_RESOURCE_STATES::D3D12_RESOURCE_STATE_DEPTH_WRITE;
		optimizedClearValue = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_D32_FLOAT, 1.0f, 0);
	}
	else if (resFlags & D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET)
	{
		resourceStates = D3D12_RESOURCE_STATES::D3D12_RESOURCE_STATE_RENDER_TARGET;
		float arrFloat[4] = { clearColor.x, clearColor.y, clearColor.z, clearColor.w };
		optimizedClearValue = CD3DX12_CLEAR_VALUE(format, arrFloat);
	}
resFlags 라는건 Create 의 인자중에 D3D12_RESOURCE_FLAGS resFlags 입니다. 만들 2D 텍스쳐의 플래그를 정할 인자인데 이 인자가 뎁스 스텐실 이었다면 윗쪽 코드가
렌더 타겟 플래그 였다면 아랫쪽 코드가 실행되는데 
여기서 resourceStates 를 D3D12_RESOURCE_STATES::D3D12_RESOURCE_STATE_RENDER_TARGET; 로 바로 설정해주고 있습니다.
그런데 지금 만든 배리어는 처음에 실행될때 ClearRenderTargetView 를 해주면서 WaitResourceToTarget 부터 실행해주고 있습니다. 이 함수는 
D3D12_RESOURCE_STATE_COMMON 에서 D3D12_RESOURCE_STATE_RENDER_TARGET 으로 전환해주는 코드였기 때문에 처음 텍스쳐의 플래그가 
D3D12_RESOURCE_STATE_COMMON 이어야 했던겁니다.
해당 부분을 수정해주겠습니다.



14) 마무리 

이제는 빌드한후 실행 해보면 지직거리는 현상이 없어져 있습니다. 

이번시간의 핵심은 디퍼드 렌더링 이라는 방법을 아는것입니다. 
이전까지의 포워드 렌더링 방법은 렌더링 파이프라인에서 모든 계산을 끝내고 한번에 최종 렌더타겟에 출력을 해주는 방법으로 
중간 데이터의 손실이 많고 빛의 연산때 모든 빛을 한번씩 체크해줘야 한다는 단점이 있던 방법을 보완하는것이 

디퍼드 렌더링 이었습니다. 디퍼드 렌더링은 렌더링 파이프라인에서 모든 빛연산까지 하던걸 하지 않고 최종 렌더 타겟과 픽셀셰이더 사이에 중간 렌더 타겟을 하나 만들어서
중간에 저장할 데이터들을 저장해두고 그 데이터를 이용해서 빛연산을 필요한 만큼을 걸러서 하게 하고 소실되는 데이터를 저장해두는 방법입니다. 

G_BUFFER 라는 중간 버퍼에 포지션, 노멀, 컬러 를 저장해두었었습니다. 

거기에 더해 이번에 물체에서 빛을 인식하는 렌더링 방법에서 빛이 물체를 인식하는 방법으로도 바꾼점이 있습니다. 