

        25. Frustum Culling



이번 시간에 배울 개념인 Frustum Culling 한국어 번역으로는 절두체 컬링이라고 합니다.
Culling 이라는 용어가 이번에도 등장했습니다. 이전 시간에서 Cull Back, Cull Front 라고 해서 Rasterize 단계에서 어떤 방향으로 정점들이 나열되어 있는지에 따라
표현을 해주는지 안해주는지를 결정하는 개념이었습니다. cull 이라는 단어는 무시하다 추려내다 라는 의미가 있어서 culling 의 범위에 해당되면 정점들이 무시되는겁니다.

그럼 이번 시간의 주제인 Frustum Culling 도 최적화 기법중에 하나인데요
어떤 의미이냐면 카메라의 Direction이 있을것이고 Direction 부터 Pov 만큼의 각도를 가지고 사각뿔 형태의 범위가 있을것이고 거기에 관측 최대거리인 Far, 최소거리인 Near 가 있을겁니다.
그리고 게임 월드내에 수만은 오브젝트들이 있고 카메라는 그중 범위에 들어오는것만 촬영하고 있을때 이 범위안에 들어오는것 외에는 Culling을 해버리는 기법입니다. 
딱 게임화면을 출력하는데 필요한 오브젝트만 연산을 하면되기 때문에 게임의 성능을 끌어올리기위해서는 중요한 기법입니다.
절두체 라는 단어가 사각뿔에서 꼭대기가 없는 입체 도형을 말합니다.

지금까지의 우리 프로그램에서는 이 단계가 없이 게임 오브젝트가 MeshRenderer 를 들고 있기만해도 셰이더 쪽에 넘겨줘서 Graphics Pipeline 을 따라 렌더링을 해줬습니다. 심지어 
그 단계가 짧지도 않았습니다. 인풋 어셈블러로 데이터를 받아서 버텍스 셰이더로 정점 변환을 해주고 레스터라이즈 단계에서 정점들을 잇는 범위에 픽셀들을 확보, 보간작업까지 해서 
픽셀 셰이더 단계에 각 픽셀의 색상을 정해주는 과정을 거쳐서 렌더링 했습니다. 그리고 이렇게 렌더링을 한다음 카메라 밖에 있다는걸 알고나서 그릴 필요가 없구나 하고 있는건데 
애초에 카메라 범위에 없어서 렌더링 조차 안하는것과 많은 차이가 있습니다. 거기에 실제 게임에서는 카메라 밖의 물체들이 한두개가 아닌 엄청난 양일것이니까 더합니다.
그림을 그리는 작업을 GPU에 넘겨주고 있는데 이 셰이더 뿐만아니라 여러 데이터도 같이 넘겨주는데 텍스쳐나 정점 데이터나 마테리얼 같은 것들을 넘겨주다 보니 GPU에서는 이 
데이터들을 교체하는 작업이 일어나면서 시간이 걸립니다.

그렇기 때문에 처음 CPU 단계부터 그릴것과 안그려도 되는것을 구별해서 GPU로 넘겨주면 성능적으로 큰 향상이 있을겁니다. 그렇다 보니 이 기술은 실제 서비스에서는 무조건 들어가야하는
기술입니다. 

이 Frustum Culling 을 DirectX12 에서도 함수로 지원하기는 하지만 이번시간에 수학식으로도 알아보고 간단하게 직접 구현해 보기도 할겁니다.

- 수학 

이제 이론에 들어갈건데 Frustum Culling 에 들어가기 전에 수학의 기초중에 평면에 대한 기초를 알아보겠습니다. 

평면을 만족시키는 식이 하나 있는데
ax + by + cz + d = 0  입니다. 
 a,b,c,d 라는 상수가 있고 x,y,z 라는 미지수가 있을때  상수들이 정해지면 그에 맞는 평면이 있고 x,y,z 에 값을 넣어서 0이 되는 점들이 한 평면위에 있다는 말입니다.
무조건 이 식을 만족해야 한 평면위에 있는겁니다. 

이 식에서 특이한 규칙성이 발견되는데 x,y,z 좌표계가 있습니다. 이중에 a,b,c 와 d 사이의 어떤 기하학적 관계가 보입니다.
우선 노멀벡터가 뭔지 알고 있습니다. 어떤 평면에 수직하는 벡터를 말하는거였습니다. 
그리고 그 노멀벡터의 좌표가 (a, b, c) 입니다. 평면의 방정식의 상수 a,b,c가 맞습니다. 하지만 이 (a,b,c) 라는 벡터의 크기가 1이라는 보장은 없으니까 Normalize 를 해줘야 합니다.
남은 d 는 어떤 연관성이 있냐면 좌표계의 원점에서 평면까지의 거리와 연관성이 있습니다.

수학적 증명을 해보겠습니다. 평면위의 두점이 A, B 가 있다고 하겠습니다. 각 점의 좌표는 A = (X,Y,Z) 이고 B = (X',Y',Z') 라고 하겠습니다.
이때 (a,b,c) 라는 벡터가 노멀벡터가 맞다면 벡터AB·벡터n 의 값이 0이 나와야합니다.
벡터AB 의 성분은 점A 에서 점B 까지 가는 벡터이니까 벡터AB = (X'-X, Y'-Y, Z'-Z) 이고 벡터n = (a,b,c) 입니다.
벡터AB·벡터n 의 값을 구해줄건데 내적의 값이 벡터의 크기값들 의 곱과 코사인 값을 곱한것말고도 한가지 더 있었습니다. 
각 x, y, z 각자의 성분끼리 곱한걸 그 세값을 한번에 더해주면 그게 내적의 값이었습니다. 

        a(X'-X) + b(Y'-Y) + c(Z'-Z)  = (aX'+bY'+cZ') - (aX+bY+cZ) 
이렇게 전개할수 있습니다. 그런데 점 A와 B는 그냥 점이 아니라 평면위의 점이었습니다. 그러면 평면의 방정식 ax + by + cz + d = 0 이어야 합니다. 
각 괄호를 평면의 방정식을 이용해 치환하면 
(-d) - (-d) 가 되서 0이라는 값이 나옵니다.

이런 과정을 통해서 평면위의 임의의점 A,B 를 가지고 평면의 방정식에서의 각 미지수 앞의 상수들을 벡터로 만들면 n = (a, b, c) 노멀 벡터가 된다는걸 증명했습니다.


다음은 d 가 원점에서 평면까지의 거리라는의미를 수학적으로 증명해보겠습니다. 일단 다시 상황을 보면 
평면의 방정식 :  ax + by + cz + d = 0 
이런 평면의 방정식이 있고 이 평면이 있는 좌표계의 원점을 O 라고 하겠습니다. 그리고 이 평면의 수직인 벡터 n = (a, b, c) 가 있습니다.
또 평면위의 임의의 점 M = (X,Y,Z) 라는게 있다고 하겠습니다.

이런 상황에서 원점 O 에서 평면위의 임의의점 M 까지의 벡터 OM 이 있고 이 OM을 평면의 수직인 벡터 n 과 내적을 해보겠습니다.

        OM·n = aX + bY + cZ    

이런 값이 나옵니다. 이 식은 평면의 방정식에서 똑같이 있습니다 결국 OM·n + d 가 평면의 방정식입니다. 
그런데 여기서 OM·n 의 의미가 수식적이 아니라 기하학적인 관점에서 무슨의미인지를 보면 원점에서 평면까지 수직인 선분의 길이 입니다. 
왜냐하면 내적을 구하는 방법이 코사인을 이용해서 구하는 방법이 있었습니다. 
 |OM|*|n|*cosθ 인데 여기서 n은 단위벡터 라서 사라지고 |OM|*cosθ 입니다. |OM|은 원점에서 평면위의 점까지의 선분의 길이였고 cosθ 에 곱해주면 이제 
선분OM을 빗변으로하는 직각삼각형의 밑변길이가 나옵니다.

정리해보면 
 aX+bY+cZ+d = (OM·n)+d = (원점에서 평면까지의 직선거리) + d = 0 
입니다. 
즉, 원점에서 평면까지의 거리는 -d 입니다.

이 원리를 좀더 응용해보면 평면위의 점 M이 아니라 평면보다 원점에 더 가까운 어느 곳에 있는점 M' 이 있다고 했을때 OM'·n 을 또 구할수 있습니다. 
그 값은 평면과 직각이긴하지만 길이가 더 짧은 값이 나올겁니다. 즉 음수가 나올겁니다. 
반대로 원점에서 평면보다 더 먼지점의 점을 노멀벡터와 내적을하면 양수가 나옵니다. 이렇게 어떤 점을 노멀벡터와의 내적값으로 평면보다 멀리있는지, 가까이 있는지를 판별할 수 있습니다.

이렇게 평면의 방정식과 그 속성들 노멀벡터와 평면과의 거리에 대해 증명으로 알아봤습니다. 

그러면 이 내용들이 오늘의 주제인 Frustum Culling 과 어떤 상관이 있나를 보겠습니다.
카메라의 촬영범위 밖의 물체는 연산하지 않는다는 기술이었는데 카메라의 촬영범위는 절두체 라고 했습니다. 사각뿔에서 꼭대기가 잘린 입체도형이었습니다. 
그러면 이 절두체를 이루는 면이 6개가 있을건데 이 각각의 면의 노멀벡터를 구한다고 하겠습니다. 이때 노멀벡터들은 절두체의 밖을 향하는 방향이어야 합니다. 
이러면 각각 평면에 대해 계산을 할 수 있을겁니다.
게임 월드위의 모든 오브젝트를 이루는 정점들은 사실 모두 월드 스페이스의 원점에서 정점의 좌표까지의 벡터라고도 볼수 있습니다. 이 정점들과 절두체의 노멀벡터들을 내적하면 
이제 각 정점들이 절두체 안에 있는지, 즉 카메라의 촬영범위안에 있는지를 판별할 수 있습니다. 모든 노멀 벡터들에 대해 내적의 값이 음수인 물체는 촬영범위 안에 있다고 볼 수
있겠습니다.
이렇게 일단은 어떤 점이 절두체 안에 있는지를 판별할 수 있습니다. 어떤점이 절두체의 여섯면에 대해 노멀벡터와 내적 체크를 해서 하나라도 통과 못한다면 절두체 밖에 있는 점
인겁니다.

물론 지금까지 얘기한것은 점 하나를 가지고 애기한겁니다. 실제 게임에서는 게임오브젝트가 점하나는 아닐것이고 자신만의 볼륨을 가지고 있을겁니다. 
그렇다는것은 게임오브젝트가 촬영범위 안에 있다는걸 판별하기 위해서는 점하나 가지고는 부족하고 이 오브젝트의 부피를 표현할수 있는 수단이 필요합니다. 박스 형태로 
판별을 한다거나 하는데 지금 단계에서는 부피를 만드는 방법에 대해서는 아직 배우지 않았기 때문에 
이번시간에는 구를 이용한 판벌을 해줄겁니다. 구에서는 Radius 반지름을 가지고 있을것이고  어떤 점이 범위에 들어왔냐를 판별할때 이 반지름 만큼을 너그럽게 봐줄겁니다. 
수식으로 표현하면 
        ax+by+cz+d = r 
이러면 현재 점이 절두체의 평면으로부터 r 만큼 떨어져 있다는 말이 됩니다. 이걸 미만이나 초과로 판별하면 r 만큼의 여유를 둔 셈입니다.

또 한가지 생각해볼점이 있습니다. 절두체를 이루는 평면 자체를 어떻게 만들어야 하는가 인데 
평면을 구하는 방법은 어떤 점 3개를 알고 있다면 3 점이 포함된 평면을 알수 있습니다.
그러면 절두체를 이루는 평면들 위에 있는 점 세개씩을 어떻게들 알아내면 되는데 지금 이 판별은 월드 스페이스를 기준으로 하고 있으니까 월드 기준으로 좌표값들을 알아내면 됩니다.
절두체 자체가 카메라의 촬영범위라고 했습니다. 
그러면 이걸 가장 쉽게 구할수 있는 방법은 투영 단계부터 거꾸로 거슬러 올라가면서 구하는 방법입니다. 
사실 이게 무슨 말인지 모르겠습니다. 자세히 알아보면 프로젝션 변환 단계를 보면 각 정점들을 -1 ~ 1 사이의 범위로 x랑 y를 표현하고 있었고 깊이는 0 ~ 1 사이로 표현하고 있었던게
투영 좌표계였습니다. 그런데 이게 촬영범위를 쫙 땡겨서 투영한 상태이니까 이게 Frustum 이라는걸 알 수 있습니다. 결국 프로젝션 스페이스에서 촬영범위의 각 정점의 좌표를 알고 
있는 겁니다.
이 촬영범위의 각 정점을 알고 있다면 프로젝션에서 뷰 스페이스로 변환을하고 다시 월드 스페이스로 변환을 한다면 우리가 구하려 했던 월드 스페이스에서의 Frustum 의 각 정점을 
알수 있다는 이야기가 됩니다.
프로젝션에서 월드까지 어떻게 되돌아 가는가? 그냥 스페이스 변환 행렬들의 역행렬을 차례대로 곱해주면 될겁니다.

나중에 코드로 표현할때는 프로젝션의 각 정점들에 0 ~ 7 까지의 번호를 매겨 관리해줄겁니다. 개인이 마음대로 정해도 되지만 강의에서 햇갈릴수 있기도 하니까 따라해보겠습니다. 
육면체의 앞쪽면의 왼쪽 위 정점부터 0 다음은 시계방향으로 1,2,3 이라고 번호를 매기고 육면체의 뒷면 왼쪽위부터 시계방향으로 다시 4,5,6,7 이라고 번호를 매겼습니다.
이 각 정점의 번호를 유의해야하는데 왜냐면 각 정점들을 이어서 평면을 만들고 그 평면의 노말 벡터를 구해줘야하는데 노말벡터들이 절두체의 밖을 향하도록 해야 했습니다. 
그래서 평면을 구할때 정점들의 순서에 유의해야합니다. 세점을 넣으면 평면을 구해주는 함수를 사용할건데 세점을 시계방향으로 넣느냐 반시계방향으로 넣느냐에 따라 
노멀 벡터의 방향이 정반대가 될겁니다.


- 코드 

코드로 구현할 시간입니다. 먼저 Frustum 이라는 클래스를 만들어 줄건데 Utils 필터에 만들지 Component 필터에 만들지 고민이 되는데 
Frustum 자체가 컴포넌트는 아니긴하지만 Camera가 사용할 부품이니까 컴포넌트 필터에 만들어 주었습니다.

헤더 파일에 먼저 enum PLANE_TYPE 을 만들어 주었습니다. 
enum PLANE_TYPE : uint8
{
	PLANE_FRONT,
	PLANE_BACK,
	PLANE_UP,
	PLANE_DOWN,
	PLANE_LEFT,
	PLANE_RIGHT,

	PLANE_END
};
이렇게 각 평면들을 숫자를매겨 관리를하고 
클래스의 내용은 FinalUpdate 때 업데이트할 오버로드 함수 하나 ContainSphere 라는 함수 하나와 각 평면들을 배열로 가지고 있는 _planes 라는 배열 멤버변수를 가지고 있을겁니다.
class Frustum
{
public:
	void FinalUpdate();
	bool ContainsSphere(const Vec3& pos, float radius);

private:
	array<Vec4, PLANE_END> _planes;
};

이제 구현부를 보기위해 CPP 파일의 내용을 보면 
우선 카메라 컴포넌트를 사용할것이기 때문에 #include "Camera.h" 를 해줍니다. 
먼더 FinalUpdate 함수의 구현부입니다.
void Frustum::FinalUpdate()
{
	Matrix matViewInv = Camera::S_MatView.Invert();
	Matrix matProjectionInv = Camera::S_MatProjection.Invert();
	Matrix matInv = matProjectionInv * matViewInv;

	vector<Vec3> worldPos =
	{
		::XMVector3TransformCoord(Vec3(-1.f, 1.f, 0.f), matInv),
		::XMVector3TransformCoord(Vec3(1.f, 1.f, 0.f), matInv),
		::XMVector3TransformCoord(Vec3(1.f, -1.f, 0.f), matInv),
		::XMVector3TransformCoord(Vec3(-1.f, -1.f, 0.f), matInv),
		::XMVector3TransformCoord(Vec3(-1.f, 1.f, 1.f), matInv),
		::XMVector3TransformCoord(Vec3(1.f, 1.f, 1.f), matInv),
		::XMVector3TransformCoord(Vec3(1.f, -1.f, 1.f), matInv),
		::XMVector3TransformCoord(Vec3(-1.f, -1.f, 1.f), matInv)
	};

	_planes[PLANE_FRONT] = ::XMPlaneFromPoints(worldPos[0], worldPos[1], worldPos[2]); // CW
	_planes[PLANE_BACK] = ::XMPlaneFromPoints(worldPos[4], worldPos[7], worldPos[5]); // CCW
	_planes[PLANE_UP] = ::XMPlaneFromPoints(worldPos[4], worldPos[5], worldPos[1]); // CW
	_planes[PLANE_DOWN] = ::XMPlaneFromPoints(worldPos[7], worldPos[3], worldPos[6]); // CCW
	_planes[PLANE_LEFT] = ::XMPlaneFromPoints(worldPos[4], worldPos[0], worldPos[7]); // CW
	_planes[PLANE_RIGHT] = ::XMPlaneFromPoints(worldPos[5], worldPos[6], worldPos[1]); // CCW
}
조금 길어 보이는데 _planes의 내용물을 채우는 코드입니다. 
윗줄 부터 보면 View 의 역행렬과 Projection의 역행렬을 구해주고 있습니다. 위의 이론부분에서 투영좌표계의 정점들을 월드 스페이스 까지 거슬러 올라가기 위해 역행렬들이 
필요했던걸 가져오는겁니다. 그리고 두 스페이스를 한번에 변환하기위해 matInv 로 미리 순서에 맞춰 곱해주고 있습니다.

다음으로 worldPos 라는 Vector 안에 투영좌표계의 각 정점들을 matInv 와 곱해서 월드 스페이스 까지 거슬러올라가 담아주고 있습니다.
이때 사용하는 함수가 XMVector3TransformCoord 인데 이 함수는 지정된 행렬로 3D 벡터를 변환하여 결과를 다시 w = 1로 해주는 함수입니다.
첫번째 인자인 Vec3 의 벡터에 마직막에 w 를 1로 하나더 늘려서 세팅해준다음 뒤의 행렬에 곱해주는 함수입니다.
왜 w를 1로 설정해주는 함수를 사용해야 하는지를 알아보겠습니다. 
뷰 스페이스에서 프로젝션 스페이스로 변환하는 행렬을 연산하게되면 그게 바로 프로젝션 좌표계는 아니었습니다. 동차 클립 좌표계라고 w에 z 값을 담아두고 여기에 
레스터라이즈 단계에서 각정점에 모든 원소에 w 에 담겨있는 z 로 나눠줘야 그게 진짜 프로젝션 변환이었습니다. 
그래서 투영 스페이스의 에서 클립 스페이스로 넘어가기 쉽게 하기위해 사용하는 함수였습니다.
결국 XMVector3TransformCoord 가 하는 역할은 Vec3 벡터에 w 값을 1로 설정해주고 변환해주는 역할이었습니다. 

결과적으로 월드 스페이스 기준으로 카메라의 촬영범위의 각 정점들을 worldPos 에 순서대로 담았습니다. 
이때 정점들의 순서는 위에서 말한 순서대로 담았습니다.

마지막으로 _planes 에 각 인덱스에 XMPlaneFromPoints 라는 함수로 세점을 인자로 넣어서 평면을 구해 담아주고있습니다.
이 XMPlaneFromPoints 함수는 궁금하니까 뜯어 보겠습니다. 
함수 내에서 받은 세개의 점을 가지고 두개의 벡터를 만들어 주고 있습니다. 두번째 점에서 첫번째 점으로 가는 벡터 하나, 세번째 점에서 첫번째 점으로 가는 벡터 하나를 
만들고 있습니다.
다음으로 두 벡터를 Cross (외적) 을 하고 있습니다. 그 값을 N이라는 벡터 변수에 담아주고 있습니다. 다음 코드에서 N을 Normalize 해서 단위 벡터로 만들어 주고 있습니다.
그리고 D라는 벡터 변수에 N과 첫번째 점을 내적한 값을 담아주고 - 를 곱해줍니다.
이부분은 두 벡터의 내적한 결과물과 평면의 방정식을 보았을때 내적 값은 -d 였는데 여기에 - 를 곱해서 d 자체값을 구한것입니다.
이렇게 N 과 D 를 구하면 N은 a,b,c 값을 가지고 있을것이고 D는 d 자체이기 때문에 평면의 방정식을 구할수 있을겁니다.

이걸 Result 라는 변수에 담아서 리턴을 해줄건데 연산하고 있던 벡터들이 Vec4이기 때문에 차례대로 (a, b, c, d) 를 리턴할수 있을겁니다. 
그런데 이부분에 어떤 함수가 있는데
XMVECTOR Result = XMVectorSelect(D, N, g_XMSelect1110.v);
이런 코드입니다. 이때 사용하는 XMVectorSelect 함수인데 내용은 
XMVectorSelect : 두 입력 벡터 간에 구성 요소별 선택을 수행하고 결과 벡터를 반환합니다.
인자로 준 D와 N 에서 구성요소를 골라 조합한 벡터를 반환한다는 이야깁니다. N 에서 1,2,3 번째 요소들이 a,b,c 이고 D 에서도 네번째 요소가 d 이니까 
이걸 하나의 벡터로 만들어 준다는 이야깁니다.

이걸 _planes 에 담아주는데 각 원소 마다 주석으로 CW(Clockwise), CCW(CounterClockwise) 라고 표시 되어 있는데 각면의 노멀벡터가 촬영범위의 밖을 향하도록 해주기 위해 
정점들의 순서를 맞춰 연산해주고 있습니다.

이 함수가 FinalUpdate 시점에 실행되는 이유는 Camera 의 S_MatView 와 S_MatProjection 이 매 프레임 바뀌기 때문에 바뀐 행렬을 가져와서 Frustum 도 매 프레임 계산해주고 있습니다.


다음은 ContainSphere 함수로 구의 형태로 판별을 해주는 함수입니다. 내용은 이렇습니다.
bool Frustum::ContainsSphere(const Vec3& pos, float radius)
{
	for (const Vec4& plane : _planes)
	{
		// n = (a, b, c)
		Vec3 normal = Vec3(plane.x, plane.y, plane.z);

		// ax + by + cz + d > radius
		if (normal.Dot(pos) + plane.w > radius)
			return false;
	}

	return true;
}
해석하면 위에서 알아봤던 이론과 같습니다.먼저 인자는 어떤 Vec3인 점과 점으로 부터의 원의 반지름 radius 를 인자로 받아주고 있습니다.
_planes 의 각 원소를 const Vec4& plane 변수에 받아주면서 for문을 돌아줍니다. 노말 벡터를 (a,b,c) 로 받아주고 
if 문에서 노멀과 pos 의 내적값 즉 ax + by + cz + d 를 radius 와 비교해서 크면 false 를 반환하고 모두 통과한다면 true를 반환하는 함수입니다.

* 참고로 BoundingFrustum 이라는 DirectX12 에서 지원하는 스트럭트가 있는데 이걸 이용하게 되면 이 안에 위에서 만든 Contain 함수가 종류별로 있는걸 알 수 있습니다. 
박스, 구 , 지향상자 등의 형태의 체크를 할수 있습니다. 
이 스트럭트를 지금 사용하지 않은 이유는 두가지라고 합니다. 
첫번째 수학적 연산을 테스트 해보기 위해서도 있고 
두번째로 이 BoundingFrustum 라는 스트럭트가 받아주는 내용중에 달라지는 부분이 있습니다.회전을 Quaternion 으로 받아주고 있는데 이 쿼터니언 이라는 개념을 아직 배우지 않은 
부분도 있습니다. 나중에 쿼터니언의 개념을 배운뒤에는 이미 만들어져있는 BoundingFrustum 를 이용해서 만드는것도 좋은 방법일겁니다.

이렇게 Frustum 클래스를 완성했고 이걸 어디에서 사용하나면 Camera 클래스에서 사용할겁니다. 딱 카메라에서만 사용할것이기 다른곳에 위치할 필요는 없을것 같습니다.


Camera 클래스 입니다. 우선 헤더에 이번에 만든 Frustum 클래스를 include 해주고 Frustum 객체를 그냥 직접 멤버 변수로 받아줍니다.
	Frustum _frustum;
그리고 Camera:FinalUpdate 에서 
	S_MatView = _matView;
	S_MatProjection = _matProjection;
해준 부분 다음에 이어서 _frustum.FinalUpdate(); 를 해줍니다.
	S_MatView = _matView;
	S_MatProjection = _matProjection;

	_frustum.FinalUpdate();

다음으로 Camera::Render 함수로 가서 지금은 지금 활성화된 씬의 게임오브젝트들을 하나씩 MeshRenderer 가 있는지 체크해서 있다면 모조리 렌더링 해주고 있었는데 
이걸 _frustum.ContainSphere() 로 True인 오브젝트만 그려주도록 조건을 하나 더 걸어줄겁니다. 
이때 주의해야할점은 모든 오브젝트에 대해 이 체크를 해주는게 아니라 제외 해야할 오브젝트도 있습니다. 예를들어 스카이박스 같은경우는 항상 렌더링 해줘야합니다.

그래서 게임 오브젝트에 Frustum Culling을 적용해야 할지 안해야 할지를 한번더 판별해주기 위해서 
GameObject 클래스에 기능을 추가 하겠습니다. 간단하게 _checkFrustum 이라는 불리언 변수를 기본 true로 들고 있게 해주고 
이 값을 가져오는 Get함수 세팅해줄 Set 함수도 추가해주겠습니다.

class GameObject
{
public:
        (생략)
	void SetCheckFrustum(bool checkFrustum) { _checkFrustum = checkFrustum; }
	bool GetCheckFrustum() { return _checkFrustum; }
private:
        (생략)
	bool _checkFrustum = true;

} 

이렇게 게임오브젝트에 프러스텀을 들고 있게 하면 카메라에서 이 게임 오브젝트가 Frustum Culling 을 적용해야할지를 판별하기 쉬워집니다.
그래서 Camera::Render 에서 게임오브젝트의 _checkFrustum이 True인지를 체크하는 코드입니다.

        if (gameObject->GetCheckFrustum())
        {
                if (_frustum.ContainsSphere(
                        gameObject->GetTransform()->GetWorldPosition(),
                        gameObject->GetTransform()->GetBoundingSphereRadius()) == false)
                {
                        continue;
                }
        }
두번째 if 문의 의미는 프러스텀의 구형태의 범위가 Frustum 안에 있는지를 판별해줄건데 게임오브젝트의 월드 포지션과, 구형 충돌 범위를 인자로 넘겨줘서 이게 
false 라면 다음으로 넘어가라 라는 의미입니다. _frustum.ContainSphere 라는 함수가 bool 을 반환하는 함수니까 이렇게 체크해줄 수 있습니다.

이제 GetBoundingSphereRadius 를 만들어줘야 합니다. 
트랜스폼 클래스에서 이걸 테스트 하기 쉽게 구현하기 위해 고민을 해야하는데 조금 애매하긴합니다. 
왜냐하면 어떤 물체가 있을때 실제 그 영역 자체가 얼마인지를 알기가 힘들기 때문입니다.그래서 지금은 임시값으로 radius를 만들어 줄것인데 
나중에 Bounding Box 나 다른걸 만들때 제대로 고민해볼 문제입니다. 
일반적으로 물체를 만들때 처음 크기를 1로 만들고 난다음 Scale을 이용해 그 물체의 크기를 뻥튀기 하는 경우가 많다보니까 잠시 물체의 Scale을 이용해서 BoundingSphere를 
구해보겠습니다.
class GetTransform
{
	// TEMP
	float GetBoundingSphereRadius() { return max(max(_localScale.x, _localScale.y), _localScale.z); }
}
max 라는 함수는 두 인자중에 큰것을 골라주는 함수인데 이 물체의 x,y,z 스케일중에 큰것을 골라주기 위해 max 를 두번 해주고 있습니다.
물론 이렇게 만들면 부정확할수 있습니다. 예를들어 플레이어 애니메이션이 적용되서 움직일수도 있고 아니면 기본 크기 자체가 1이 아닐수 있습니다. 
이건 나중에 다시 생각해봐야 하겠습니다. 지금은 오늘의 주제인 Frustum Culling을 체크해보기위해 임시적으로 만들었습니다.

이제 Camera::Render 에서 추가한 코드가 완성되었고 ContainSphere 체크를 통과한 오브젝트들만 Render될것입니다. 

그런데 예외가 있었습니다. 스카이박스 같은경우는 언제든지 렌더링 되어야 했는데 이걸 처리해주기 위해 SceneManager::LoadTestScene 으로 가서 스카이박스 오브젝트를 보겠습니다.
		skybox->SetCheckFrustum(false);
스카이박스를 만드는 부분에 이 코드를 넣어주면 상위 클래스인 GameObject 의 _checkFrustum 이 False가 될겁니다. 그러면 Camera::Render 에서 Frustum 체크의 첫번째 if에서
바로 다음으로 넘어가 Render가 됩니다.


그러면 이번시간의 테스트를 해보겠습니다. 어떻게 테스트를 해야할지 생각해보니 오늘의 내용은 카메라 범위 내에 없는 물체를 렌더링 하지 않고 무시하는 기법이었습니다. 그런데 
우리 프로젝트의 물체는 큐브, 카메라, 빛, 스카이박스였습니다. 이중에 Frustum Culling 에 해당되는 오브젝트는 큐브뿐입니다. 그런데 원래도 물체는 카메라 범위 밖으로 나가면 
어짜피 보이지 않는 상태인데 어떻게 증명할수 있을까요 
방법은 카메라 클래스에서 아까 ContainSphere를 체크하는부분에 continue 에 중단점을 걸고 디버깅실행을 하면 됩니다. 
그러면 카메라에 찍히고 있던 큐브를 카메라를 움직여서 카메라 밖으로 내보내면 continue 코드에 걸려서 중단이 됩니다 이렇게 되면 테스트 성공입니다. 

이 기법은 지금의 큐브하나뿐인 프로그램에서는 효과가 미미하지만 실제 게임에서는 수많은 오브젝트들이 있을것이기 때문에 매우 큰 효과를 발휘할겁니다.