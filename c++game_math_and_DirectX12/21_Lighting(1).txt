

        21. Lighting (조명) - 개론


// 필요성
게임뿐만 아니라 촬영현장에서도 조명의 중요도는 대단히 높습니다. 그때 연출하고 싶은 장면의 분위기에 따라 조명을 적절히 써야 합니다.

게임이라는 것은 결국 이용자가 모니터를 통해 보는 2D화면입니다. 가상의 세계에서는 물체들이 3D로 존재하고 있을 테지만 표현자체는 2D로 관측됩니다.
그럼에서 평면으로 보는 화면을 입체적으로 받아들일수 있는것이 명암의 표현 덕분입니다. 
그래서 원근법, 명암 두가지가 잘 표현되면 평면도 입체같이 볼 수 있습니다.

예시로 유니티에서 카메라가 큐브를 찍고 있다고 했을 때 사실 조명이 있어야 이 큐브를 관측할 수 있습니다. 
현실에서도 빛이 있어야 물체에 반사되어 카메라에 찍히는것과 같은 이치 입니다.

이전시간까지는 우리 쉐이더 파일에 이런 조명을 계산하는 내용을 담지 않고 있었기 때문에 물체들이 모든 면이 밝은 상태 였습니다.
그런데 빛의 개념이 들어가기 시작하면 경우에 따라 밝게 보일 수도 있고 아니면 어둡게 보일 수도 있게 됩니다.

// 종류
게임에서 주로 사용되는 조명은 세가지가 있는데 
1) Directional Light - 이 조명은 마치 태양같은 조명인데 조명 오브젝트가 어디로 옮겨도 상관없이 일정 방향에서 월드를 계속 비추고 있는 조명입니다.
2) Point Light - 조명 오브젝트가 위치에 있고 그 조명을 원점으로 구 형태의 범위에 빛을 비추는 조명입니다. 빛의 방향은 조명과 비춰지는 물체와의 각도에 따라 다르고 
                조명에서 멀수로 받는 광량도 줄어듭니다. 횃불 같은 조명이라고 볼 수 있습니다.
3) Spot Light - 무대같은데서 들어본듯한 스포트 라이트입니다. 이름그대로 어떤 지점을 집중적으로 비춰주는 조명입니다. 손전등으로 활용할 수 있는 조명입니다.

이렇게 세가지 조명에 대해 개념을 알아 봤는데 이후에 어떻게 구현이 되는지도 알아볼 겁니다.

// 이론
이제 조명 Lighting 이 왜 필요한지에 대해 알아봤으니까 다음으로는 이 조명을 어떻게 수학적으로 구현할지를 알아보겠습니다.

뭘 해야 할지 예시로 알아보겠습니다. 게임세상에 어떤 캐릭터가 위치해 있다고 하고 거기에 디렉셔널 라이트가 비추고 있다고 해보겠습니다. 
그러면 빛을 받고 있는 캐릭터는 그 캐릭터를 이루고 있는 모든 픽셀마다 빛에 의해 어떤 색상을 가지고 있어야 할 지를 알아야 합니다.

이런 상황이라면 어떻게 구현해야 할지 막막해 집니다. 실제 물리를 생각하고 모든 조명들을 연산하려면 컴퓨터가 따라가지 못합니다. 대신 약식으로 빛이 비춰지는 캐릭터에 
대한 빛만 계산해서 색상을 구현해도 어느정도 비슷한 효과가 나오는걸 알 수 있었다는 경험을 얻었습니다.
지금 배우는 조명은 사실 과도기라고 할 수 있는게 더욱 고급 조명 기법으로 레이트레이싱이라는 기법은 실제 빛단위로 시뮬레이팅해서 조명을 표현하는 기법도 있습니다.
그래도 아직까지 완벽한 레이트레이싱을 적용한 게임은 없다고 합니다.

조명에 대해 이해하기 위해 알아야 할 세가지 키워드가 있습니다. 
· diffuse   (난반사 광)
· ambient   (환경 광)
· specular  (정반사 광)
이 세가지 특징을 빛이 가지고 있다고 가정을 하고 진행할겁니다.

그리고 쉬운 가정을 위해 빛은 디렉셔널 라이트로 일정방향으로 저 멀리서 비추고 있다고 하겠습니다. 
그리고 또 하나의 가정은 어떤 물체이건 간에 어떤 물체의 어떤 점의 좌표에서 노멀이라는 값을 구할 수 있다고 하겠습니다.
이 노멀이 빛의 연산에 중요한 역할을 하게 됩니다.
(이때 노멀이 무엇이냐면 물체의 어떤 좌표와 접하는 평면이 있고 그 평면에 수직된 단위 벡터를 노멀이라고 합니다.
그리고 이전 시간에 정점 데이터중 노멀과 탄젠트를 추가해 줬는데 그때의 노멀이 지금 이 노멀을 이야기 하는겁니다.
탄젠트는 좌표와 접하는 평면에 속한 것, 그리고 탄젠트와 노말 둘 모두에 수직한 벡터를 바이노멀이라고 합니다.)

물체를 이루는 각 점들이 어떤 색상을 가지고 있는지를 구하는게 목표였습니다. 
색이라고 하면 결국 R,G,B 의 배합인데 만약 어떤 점의 색상이 R:1, G:0, B:0 이라고 하면 순수한 붉은색입니다. 여기에 빛이 적용된다는 말이 어떤 의미냐면 
RGB 각각의 값에 어떤 값이 곱해지게 되는데 예를 들어 빨간 점이 빛을 많이 받지 못해서 각 RGB에 0.5를 곱해주게되면 RGB값이 이렇게 될겁니다.
R:0.5, G:0, B:0 빨간색이긴한데 어두운 빨간색이 됩니다. 

결국 여기서 원래 색에 곱해주는 0.5 라는 값을 구하는 부분이 조명을 구현하는 부분입니다.
그런데 어떤 한가지 기준으로만 이 값을 구하면 빛표현이 부자연스럽기 때문에 위에서 말한 세가지 특징을 통해 밝기 값을 구하는것 이라고 합니다.

다음으로 오브젝트의 어떤 좌표를 구했고 이 좌표에 대한 색상을 구하고 있다고 가정을 해보겠습니다. 어떤 물체이건 간에 모든 Mesh는 정점들로 이루어져 있다는걸 알고 있습니다.
그리고 그 정점에 대한 좌표 변환을 하는게 정점 쉐이더 Vertex Shader 단계에서 그 코드를 넣어 놨습니다. 여기서 각 좌표에 대해 변환을 해줘라 라는 역할을 Vertex Shader 에서
하는 일이고 
그래서 Vertex Shader 까지 끝났다고 하면 그 각 세부적인 좌표를 Pixel Shader 로 넘겼었습니다. 정점에 대한 연산까지는 하고 그 다음 정점을 이은 삼각형 안에 있는 픽셀들에 대한
변환을 담당하는 것이 Pixel Shader 입니다. 그래서 픽셀 쉐이더는 모든 픽셀에 대해 다 호출이 되는 함수라고 볼 수 있는겁니다.
그래서 색상에 대한 연산을 결국 픽셀 쉐이더에서 하는것이고 빛의 연산도 마찬가지로 픽셀 쉐이더에서 한다고 할수 있습니다.


이제 이런 가정에서 어떤 오브젝트에 대한 한 점, 픽셀에 대한 계산을 시작 해보겠습니다. 
조명은 처음에 가정하기를 디렉셔널 라이트라고 가정을 했었습니다. 딱히 위치는 상관없이 저 무한대 멀리서 일정한 방향으로 빛을 쏴주고 있는 상태입니다.
이 빛이 들어오는 각도를 Light니까 단위 벡터L 이라고 하겠습니다.
이런 상황에서 빛의 세가지 특징중 diffuse 난반사광이 하고 싶은 이야기가 무엇이냐면 이 물체가 빛을 어떻게 받아들이냐를 얘기하고 있습니다.
어떤 말이냐면 이 물체의 어떤 픽셀에서 Normal 을 구할 수 있었습니다. 그 노멀을 단위 벡터N 이라고 하겠습니다. 여기서 빛이 해당 점에 어떤 각도로 들어오고 있는가를 말합니다.
빛이 직각으로 들어와서 온전히 빛을 받는가 아니면 비스듬하게 들어와서 빛을 다 받지 못하는가입니다. 
이걸 람베르트 코사인 법칙이라고 부르는데요 벡터L과 벡터N 사이의 각도 θ가 있을텐데 온전히 빛을 받았을때의 밝기에 cosθ를 곱해준 만큼만 적용된다는게 diffuse의 핵심입니다.

다르게 설명해보면 만약 어떤 픽셀에 들어온 diffuse 값 이 RGB 기준으로 0.5, 0.5, 0.5 라고 했을때 빛이 수직으로 딱 들어왔다면 이 값을 그대로 적용되어서 RGB에 그대로 곱합니다.
하지만 만약에 빛이 좀 비스듬히 받았다 만약 θ = 60도 였다면 1/2이 곱해져서 RGB에 0.25 씩 밖에 못받는 상태가 됩니다. 
즉 빛도 자기 자신만의 값이 있는데 그것을 빛의 입사각에 따라 온전히 받느냐 아니냐가 갈리는겁니다.
- diffuse 에서 중요한것 : 해당 픽셀의 노멀과 빛이 들어오는 각도θ 의 cosθ 값

그래서 빛을 계산하는데 처음으로 알아야 하는것은 빛이 들어오는 각도와 노멀사이의 각도를 아는게 첫번째 미션이라고 할 수 있습니다. 
그런데 그냥 L 과 N 사이의 각도를 구하면 안됩니다. L은 픽셀로 들어오는 방향의 벡터이기 때문에 - 를 곱해줘야 원하는 각도를 구할수 있습니다. 
이렇게 벡터N 과 -벡터L 을 내적을 해보면 
N·(-L) = |N|*|L|*cosθ  
이런 값이 나오는데 여기서 N과 L은 단위 벡터이다보니 앞의 벡터들의 절대값은 무시하고 그냥 cosθ 값이 나온다는 신기한 결과가 나옵니다. 굳이 θ값을 구하지 않고 
바로 cosθ를 구해도 상관없기 때문에 더욱 간편합니다. 
diffuse 값 구하기 : N·(-L) = |N|*|L|*cosθ 로 구한다

빛의 두번째 특징 ambient 환경광 에 대해 말해보겠습니다. 
가정으로 어느 공간에 책상이 있고 그 위에 광원이 있어서 위에서 책상에게 빛을 비추고 있다고 하겠습니다. 이럴때 책상 밑은 어떨까요 diffuse를 적용해서 
책상의 윗면만 직접 빛을 받고 책상밑은 빛을 받지 못하니까 칠흑같이 어두울까요? 실생활에서 보면 그렇지 않죠. 실생활에서는 책상밑이 분명 어둡기는 하지만 
어느정도 보이기는 합니다. 그렇다고 빛이 광원에서 휘어져 들어와 책상밑을 히트해서 보인다는것은 아니지만 일단 어렴풋이 보이긴 한다는걸 알고있습니다.

실생활에서 어떤 원리로 이런 현상이 발생하냐면 일단 빛은 물체에 부딛힌 다음 사라지는게 아닙니다. 표면에서 다시 반사됩니다. 그런데 현실에서의 대부분의 물체의 
표면은 자세히 보면 대단히 거칠어서 빛이 난반사가 일어납니다. 그 난반사 된 빛은 다시 다른 물체에 부딫혀서 책상및으로 어느정도 도달하게 되서 
책상밑이 어렴풋이 보이게 되는겁니다.

이런 원리를 게임에서 정말 똑같이 구현해서 물체의 표면을 구현하고 빛의 난반사를 구현해서 직사광을 받지 못하는 부분을 구현하는것은 엄청난 난이도이고 그런 로직을 
게임에 적용시킬 하드웨어가 있지도 않을겁니다. 
그래서 게임에서는 그냥 빛을 받지 못하는 부분도 일정량의 밝기를 보장해주는 방식으로 구현합니다.
ambient 성분이 0.1, 0.1, 0.1 이렇게 있다면 이 성분은 빛이 어디에서 비추던 픽셀의 RGB 값에 항상 포함되게 되는겁니다.
ambient 의 값 = 설정한 값만큼 상수로 RGB에 더해주는 방식

빛의 세번쨰 특징 specular 정반사광 입니다.
가정은 diffuse 때와 비슷한데 어떤 물체의 한 좌표의 빛계산을 할때 
그 좌표에 접하는 평면이 있고 그 평면에 수직하는 단위 벡터N 이 있습니다. 그리고 디렉셔널 라이트로부터 들어오는 빛의 각도를 가진 단위 벡터L이 있고 
또 N과 L 사이의 각도 θ 가 있습니다. 여기까지가 diffuse에서의 가정이었습니다. 
여기에 더해지는 가정은 L의 입사각과 똑같은 각도로 반사되는 반사광 단위 벡터R 이 있습니다.

이런 가정일때 한가지 더 고려해야 하는것이 있습니다. 바로 카메라인데 게임에서는 게임월드가 있고 카메라가 있어서 카메라기준으로 보는 게임월드를 평면으로 투영해서 
출력하는것이었습니다. 
위의 가정에서 만약 우연히 R이 카메라에 수직으로 들어온다고 하면 어떻게 표현될까요 실제로 그런 상황이었다면 광원의 눈부심이 그대로 눈에 들어올겁니다.

이번에는 좀 다르게 카메라가 R을 곧바로 받지 않고 비스듬히 받을때는 어떨까요 가정이 더 필요한데 카메라가 어떤 좌표를 보고 있을때의 단위벡터를 C라고 하겠습니다. 
그러면 R과 C사이의 각도 θ' 가 나올텐데 이 θ'가 0이라면 반사광을 곧바로 받는것이고 아니라면 비스듬하게 받는겁니다. 이 θ' 값이 커지면 커질수록 좌표의 specular 성분값은
점차 줄어들겁니다.

이 내용을 코드로 표현하려면 수학적으로 설명할수 있어야 할겁니다. 일단 우리가 아는 것 부터 생각해보면 노멀 벡터는 이미 알고 있습니다. 쉐이더에 넣어놨었죠
빛이 들어오는 벡터도 알고 있습니다. 빛의 성분 자체가 Light 컴포넌트에 설정되어 있을것이기 때문에 알고 있는거구요 

다음으로 반사되는 빛의 벡터R을 구해야 하는데 그 방법은 N·(-L) = |N|*|L|*cosθ 이라는 식을 통해 L과 N 사이의 cosθ 를 구했었습니다. 여기서 
좌표에 접하는 평면을 x축이라고 보고 노멀벡터를 y축이라고 본다면 cosθ 는 -L의 y성분이 됩니다. (단위벡터이다보니 단위원에서의 원리를 적용가능합니다.)
그냥 L의 성분이 (a, b) 라고 하면 -L은 (-a, -b) 일테고 cosθ 는 -b 입니다. 이럴때 L의 y성분에 cosθ 값을 두번 더하면 (a, -b)가 되는데 이 값은 x축 반전이되는 값이기도 
합니다. 이 x축 반전된 벡터가 사실 반사광 R이라고 할 수 있습니다. 
-L과 N의 내적을 L에 두번 더하던지 아니면 L 과 N의 내적을 두번 빼던지 두가지 방법중 하나로 어쨋건 벡터R의 값을 구할수 있습니다.

여기까지 N,L,R 벡터들을 알 수 있습니다. 이제 카메라와 좌표사이의 벡터를 구해야하는데 계산될 좌표는 픽셀 쉐이더에서 이미 알고있습니다.
Vertex Shader 단계에서 정점에 대한 좌표를 넘겨주고 Rasterize 단계에서 정점사이의 평균값으로 각 픽셀을 계산하고 Pixel Shader 단계에서 각 픽셀들의 좌표를 가지고 
색을 계산하는데 여기에서 이미 그 좌표를 알고 있다는 얘기입니다. 일단 이 좌표를 pos라고 하겠습니다. 그리고 카메라의 좌표를 어떻게든 쉐이더에 넘겨줄 수 있습니다. 
constant Buffer를 통해서건 쉐이더에 넘겨 줄 수 있으니깐 이 카메라 좌표와 pos 사이의 벡터를 구해 normalize 하면 단위 벡터C 를 구할 수 있습니다.

이렇게 구한 R과 C 사이의 cosθ 가 나올겁니다. 이값을 이용해서 specular 성분까지 구해줄 수 있습니다.
specular 구하는 법 : 주어진 N,L,pos, 카메라 좌표값을 이용해서 R과 C 를 구해서 내적으로 값을 구한다

정리
diffuse 값 구하기 : N·(-L) = |N|*|L|*cosθ 로 구한다
ambient 의 값 : 설정한 값만큼 상수로 RGB에 더해주는 방식
specular 구하는 법 : 주어진 N,L,pos, 카메라 좌표값을 이용해서 R과 C 를 구해서 내적으로 값을 구한다

처음 배울때는 어렵게 느껴질 수 있지만 다시 천천히 보면 생각보다 어렵지않고 그보다 각 빛의 세가지 특징들이 어떤 의미인지를 알고 있는게 더욱 중요합니다.

이렇게 빛의 세가지 특징 및 개론을 알아보았는데 


또 한가지 알아볼점이 각 빛마다 diffuse, ambient, specular 세가지 성분을 가지고 있다고 했는데 그것은 변함이 없습니다.
그렇지만 빛의 종류가 한가지만 있던것은 아니었습니다. 지금까지 예시로 들고 있던 빛은 디렉셔널 라이트 로 저멀리서 일정한 방향으로 비추는 빛이었습니다.
나머지 빛은 어떻게 다르냐 하면 포인트 라이트는 어떤 빛이었냐면 빛 오브젝트가 어떤 좌표에 있을것이고 그 좌표를 기준으로 모든 방향으로 빛이 방사되는 형태의 빛이었습니다.
그래서 빛의 좌표와 물체의 좌표를 가지고 입사광 벡터를 구한다는 점 그리고 포인트 라이트의 범위를 벗어나면 빛을 못받는다는 점이 디렉셔널 라이트와의 차이점입니다.
이런점에서 알수있는것은 빛마다 넣어주는 데이터가 조금씩 다르다는걸 알 수 있는데 나중에 Light 컴포넌트를 구현한다고 해도 세가지 타입으로 구현이 될겁니다.

디렉셔널 타입의 빛은 벡터L, 빛의 방향만 알고 있으면 되는것이고 이 빛의 방향을 그냥 빛 물체의 Transform Look 성분을 그대로 사용하는 경우도 많다고 합니다.

포인트 타입의 빛은 우선 알아야 하는 정보가 광원의 위치, pos와 빛이 닿는 최대범위가 기본적으로 들고 있어야 하는 정보입니다.

마지막으로 스포트 라이트가 가지고 있어야 할 정보들은 위치정보, 빛의 방향, 빛이 닿는 최대범위, 빛의 투사각도가 필요합니다. 생각보다 필요한 정보들이 많네요

추가적으로 빛의 세기에 대해서도 말해볼 것이 있는데 디렉셔널 라이트는 마치 태양같은 역할을 하는 광원이기때문에 어디서든 빛의 세기가 일정한데,
포인트 라이트같은 경우는 광원과 가까우면 빛의 세기가 온전히 적용되고 광원에서 멀어질수로 빛의 세기가 줄어드는 특징도 가지고 있을 겁니다. 그렇지 않으면 포인트 라이트의 
영역까지는 환하다가 영역 밖으로 가면 뚝 어두워지게 표현될겁니다. 자연스러운 그라데이션을 표현하기위한 특징입니다. 
스포트 라이트도 역시나 거리에 따라 빛의 세기가 줄어들게 표현하지만 같은 깊이에 있는 물체들은 같은 밝기로 표현하는게 좀더 자연스럽습니다.

빛의 세기나 범위를 구현하는것에 포인트 라이트는 조금 쉬운 편인데 빛의 좌표와 물체의 좌표사이의 거리를 계산해서 거리에따라 빛의 세기를 조절하고 범위를 넘어가면 제외하면 
되었습니다. 

스포트라이트의 경우는 단순히 물체와의 거리를 가지고는 안되고 빛의 범위 내에 물체의 좌표가 있느냐 없느냐 부터 알아야합니다.
우선 스포트라이트의 위치를 LightPos 라고 알고 있을겁니다 그리고 물체의 위치 좌표를 pos 라고 하고 빛으로 부터 물체까지의 벡터를 A 라고 하겠습니다. 이 A는 단위벡터로 
전환하지 않은상태입니다. 즉 pos 좌표에서 LightPos의 좌표를 뺀것입니다. 그리고 스포트 라이트도 빛의 방향 벡터인 L을 가지고 있는데 
A·L = |A|*|L|*cosθ 이렇게 내적을 해주면 결국 L은 단위 벡터이다 보니 |A|*cosθ 가 나오는데 이게 무슨 의미가 있냐면 
|A|를 빗변으로 삼은 직각 삼각형의 밑변의 길이가  |A|*cosθ 입니다. 이값과 스포트라이트의 빛이 닿는 범위를 비교해서 이 물체가 빛을 받는지 안받는지를 판별할 수 있습니다.
이방법은 1차적으로 물체가 빛이 닿는 거리 내에 들어오는지를 알 수 있고 다음은 빛이 비추는 각도 내에 들어오는지를 다시 계산해야합니다. 이것도 |A|*cosθ 에서 θ 값을 구할수 
있는데 이걸 빛의 각도와 비교해서 결과를 알 수 있습니다.

이렇게 빛의 종류, 성분들 그리고 각 빛을 어떤방법으로 구할수 있는지에 대해 알아봤습니다.