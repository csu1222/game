

        26. Quaternion


쿼터니언 우리말로는 사원수라고 합니다. 

사원수의 의미는 
수학에서 사원수(四元數, 영어: quaternion 쿼터니언) 또는 해밀턴 수(영어: Hamilton number)는 복소수를 확장해 만든 수 체계이다. 네 개의 실수 성분을 가지며, 
덧셈과 곱셈의 결합법칙 및 덧셈의 교환법칙을 만족시키지만 곱셈의 교환법칙은 성립하지 않는다.
라고 합니다.

어려운 개념인데 게임엔진을 이해하기위해 한번 집고 넘어가면 좋은 주제 입니다. 


        - 일단 쿼터니언의 왜 필요한지부터를 보겠습니다.

유니티 엔진을 예로 들겠습니다. 기본 월드를 생성하고 원점에 큐브 오브젝트가 있습니다. 

쿼터니언은 회전과 관련있는 값입니다. 그러면 기존에 이미 회전을 잘 하고 있었는데 왜 새로운 회전이 필요한지가 궁금합니다.

기존에 사용하던 회전방식을 오일러 방식이라고 하는데 이 방식은 x축 y축 z축 에 대한 각도를 하나씩 갖고 있을겁니다. 참고로 여기서는 호도법이 아니라 360도 법을 사용합니다.
여기서 각 축이 가리키는 방향이 있는데 Right, Up, Look 이라고 부릅니다.
x축 회전을 예로들면 말그대로 x축을 축으로 삼아 회전하는겁니다. y축 회전, z축 회전도 각각 잘 돌아갑니다. 
그러면 이렇게 잘 돌아가는 회전 방법이 있는데 새로운 회전 방법인 쿼터니언이 필요한지 의아합니다.

문제가 발생하는 상황이 무엇이냐면 각 회전들이 결합을 할때 문제가 생깁니다.
큐브를 x축으로 90 도 회전을 시킨상태에서 y축 값을 변경해보면 y축 회전이 아닌 z축 회전을 하고 있습니다. 반면 z축 회전은 잘 적용되고 있습니다.
심지어 이상태에서 수치를 조작해서 회전시키는게 아닌 그래픽적인 큐브의 회전 축을 잡고 회전시킬때 y축 회전을 하면 x축 회전값이 변경되고 y축, z축 값이 -90도로 변경되어 버립니다.
이게 딱 유니티에서 짐벌락 현상이 일어나고 있는겁니다. 

짐벌락 현상이란 3 축중 하나의 축이 먹통이 되는 현상이라고 간단히 볼 수 있고 또 다른 설명은 같은 방향으로 오브젝트의 두 회전축이 곂치는 현상이라고도 합니다.

그러면 왜 각 축 하나씩 사용할때는 문제없이 작동하다가 두개 이상의 축을 같이 사용하면 이런 짐벌락 현상이 왜 일어나는지가 궁금합니다. 

쉽게 풀어서 설명해보자면 엔진상에서 x축을 먼저 90도 값을 주고 z축에 15도 값을 준다고 해서 이게 실제로 순차적으로 x ,z 순으로 적용된다는 말이 아닙니다.
Rotaion 값을 주는것은 한꺼번에 일어나는 작업이라고 생각해야합니다. 어떤 축의 값을 먼저 입력했건간에 한꺼번에 입력한걸로 친다는겁니다.

어떤 엔진이던간에 내부적으로 각도를 수정한걸 합치는 코드가 존재할겁니다.
예를 들어 우리가 만들고 있는 게임엔진 코드를 보면 
void Transform::FinalUpdate()
{
	Matrix matScale = Matrix::CreateScale(_localScale);
	Matrix matRotation = Matrix::CreateRotationX(_localRotation.x);
	matRotation *= Matrix::CreateRotationY(_localRotation.y);
	matRotation *= Matrix::CreateRotationZ(_localRotation.z);
	Matrix matTranslation = Matrix::CreateTranslation(_localPosition);
        (생략)

이런 식인데 우리 엔진에서는 로테이션은 x,y,z 순서로 곱해주고 있습니다. 유니티 같은 경우에는 z, x, y 순서로 적용해주고 있습니다.
그리고 이럴때 항상 두번째 축에 해당하는 축이 문제를 발생시킵니다.

유니티에서의 순서대로라면 z축 회전한값에 x축 회전값 그 다음으로 y축 회전값을 곱해주고 있을겁니다. 중요한것은 이 각각의 값이 독립적인것이 아니라는겁니다.
어떤 축을 움직이면 그에 따라 다른 축도 영향을 받습니다. 

그러면 위에서 본 짐벌락 현상을 다시 보겠습니다. 유니티에서 한 실험이었는데 유니티는 z,x,y 순으로 로테이션이 적용된다고 했습니다. 
x축 회전을 90도 했을때 x축보다 먼저 적용되는것이 z축 회전이기 때문에 z 회전축은 가만히 있는상태에서 x축 회전이 90도 적용되면 y 회전축이 z 회전축에 일치하게 됩니다.
이렇게 되면 두 축이 곂치면서 축 하나가 소실되는 문제가 생깁니다.

예시로 이 상황을 Rotaion 이 아니라 Transition 이라고 쳐보겠습니다. 물론 트랜지션에서는 축의 소실이 일어나지는 않지만 비유를 들어보자면 
어떤 큐브를 x,y,z 순서로 이동을 시킨다고 가정하는데 왠지는 모르겠지만 한곳으로 이동하면 다른 축들이 변화를 한다고 가정을 해보겠습니다. 거기서 
x, y 방향으로 어느정도 움직이니 z 방향이 x방향과 일치해버린다고 했을때 그때 부터는 z축 방향으로 더이상 움직일수 없게 될겁니다.
트랜지션으로 무리하게 비유를 해봤습니다. 

로테이션에서는 더 자연스럽게 어떤 축 방향으로 회전하면 다른 축들도 영향을 받아 회전하게 되는데 그때 운이 나쁘게 축이 곂치는 상황이 생기면 그때 축이 하나가 사라집니다.

그래서 이 짐벌럭 현상은 오일러 방식의 회전에서 두번째 연산되는 축이 문제가 되서 발생한다는걸 알았습니다.

이 설명으로 충분히 이해되지 않을수 있는데 이걸 유튜브영상으로 더 잘 이해할 수 있습니다. (https://www.youtube.com/watch?v=zc8b2Jo7mno)
짐벌럭 현상을 코드상으로 이해되지 않을때 그래픽적으로 이해시켜주는 영상입니다.

짐벌럭 현상은 게임에서만 발생하는 문제는 아니고 항공이나 우주선 같은 기술에서도 문제가 되는 현상입니다. 
이 현상의 임시 해결법으로는 회전을 연산하는 순서를 바꾸는 방법이 있습니다. 그러나 이 방법도 금방 한계가 생깁니다. 어떻게 바꾸든 세 축중 두번째 연산되는 축은 계속 문제가 
될것이기 때문입니다.

지금까지 오일러 방식이라는 보기 쉽고 간단한 방법으로 로테이션을 구현 했습니다. 유니티에서도 툴에서 보기에는 오일러 방식으로 관리하고 있는것 같지만 내부적으로는 
쿼터니언으로 관리하고 있습니다.


- 쿼터니언 수학적 설명

바로 쿼터니언 내용으로 들어가지는 않고 기초라고 할 수 있는 복소수 부터 알아보겠습니다.

고등학교때 배우는 복소수의 기본식은 이렇습니다. 

        Z = a + bi

여기서 a, b, i 같은 키워드가 나오는데 a, b 는 이전에 다루던것과 같이 일상적으로 다루는 숫자들을 말합니다. 
그런데 i 같은 경우는 특이한 수인데 실제로 존재하지 않는 가상의 수 '허수'단위 라고 합니다. 위의 식에서 b에 i가 곱해지면서 bi는 실제하지 않는수 허수가 됩니다. 
식에서 a 부분이 Real number 실수부 라고 하고 bi 부분이 imaginary number 허수부 라고 부릅니다.

그러면 i라는 숫자가 왜 허수인가 어떻게 존재하지 않는가에 대해 알아보겠습니다. 
i의 성질중에 i의 제곱은 -1이 나오는 성질이 있는데 
        i^2 = -1 
우리가 알기로는 어떤 수이던간에 자신을 두번곱하면 항상 양수가 나온다고 알고 있는데 그런수가 아닌 가상의 수인겁니다. 

그래서 실수부와 허수부를 + 로 연결해 놓은 수를 복소수 영어로는 Complex Number 라고 합니다.

텍스트로 어렵지만 복소수를 기하학적으로 표현해보겠습니다. 
우선 복소 평면이라는 좌표계가 있습니다. 일반 평면이 아닌 x 축은 실수부를 나타내고 y 축은 허수부를 나타냅니다. 
여기에 a라는 실수부 값과 b라는 허수부 값만큼의 위치에 점을 찍어서 이 점을 Z 라고 하겠습니다. 이때 복소 평면의 원점O에서 Z 까지를 벡터처럼 표현할수 있는데 
OZ의 길이를 r이라고 하겠습니다. OZ와 x축사이의 각도를 θ 라고 했을때 Z의 x 성분값은 r*cosθ , y 성분값은 r*sinθ 입니다. 
이러면 r과 r*cosθ, r*sinθ 이렇게 직각 삼각형을 이루기 때문에 피타고라스의 정리도 적용해 볼수 있을겁니다.
        |Z| = |a+bi| = √(a²+b²)
이런 공식이 성립합니다. 
복소수는 실수부와 허수부가 같이 있는 수인데 여기서 허수는 실제로 있는 수가 아닌 상상의 수인데도 실수만으로 허수의 크기를 표현할 수 있습니다.

복소수의 또 한가지 성질중에 켤래 복소수라는게 있습니다. 
        Z* = a - bi
켤래복소수는 별건 아니고 복소수의 허수부에 마이너스를 곱해준게 켤래 복소수입니다.

또 복소수도 사칙연산이 가능합니다.
- 덧셈, 뺄셈 : 복소수의 덧,뺄셈은 간단한데 실수부는 실수부끼리, 허수부는 허수부끼리 연산해줍니다. 
        (a+bi)±(c+di) = (a±c)+i(b±d)
- 곱셈 : 일반 실수처럼 모든 원소끼리 연산을 해줍니다. 복소수 덧셈뺄셈 처럼 실수부 허수부 나눠서 연산하지 않습니다. 다만 허수단위 i² 은 -1 이라는 성질이 있었습니다.
        (a+bi)(c+di) = ac+adi+bci+bdi² = (ac-bd)+i(ad+bc)
- 나눗셈 : 복소수의 나눗셈은 실수처럼 바로 나눠줄 수는 없고 어떤 도우미가 필요합니다. 
        (a+bi)/(c+di) = (a+bi)/(c+di) * (c-di)/(c-di) // 뒷부분은 결국 1이기 때문에 가능 그리고 분모에 복소수와 켤래복소수의 곱입니다. 
        = ((a+bi)(c-di))/(c²+d²) = ((ac+bd)+i(bc-ad))/(c²+d²)

복소수의 또다른 특징이 있는데 어떤 복소수에 켤래 복소수를 곱해주게 되면 a²+b² 이 나옵니다.
        ZZ* = (a+bi)(a-bi) = a² -abi + abi -b²i² = a² + b²
이런 결과에서 또 한가지 연관성을 볼수 있는데 |Z| 의 값이 √(a²+b²)이었습니다.
즉,     ZZ* = |Z|²

여기까지 복소수의 기초중에 기초를 배웠는데 갑자기 배운 이 복소수가 왜 필요한지가 의문이 들 수 있습니다.
그래서 복소수를 어떻게 응용하는지 왜 사용하는지를 알아보겠습니다.

/*
참고로 지금이나 위에서와 같이 어떤점까지의 벡터의 크기와 각도를 가지고 표현하는것을 극좌표계라고 합니다. 
좌표계에 x성분 y성분으로 표현하는 (x,y) 방식도 좋지만 어떤 점을 크기와 방향으로 표현하는 극좌표계로 표현하는것도 어느 부분에서는 유용할것입니다.
*/

복소 평면 위에 Z1이라는 점이 있고 원점에서 Z1 까지의 벡터와 그 각도를 θ1 이라고 하겠습니다.
Z1 의 크기를 r1 이라고 했을때 밑과 같이 표현할 수 있을겁니다. 
Z1 = r1(cosθ1 + isinθ1)

또다른 복소수 Z2가 있고 원점에서 Z2 까지의 크기를 r2 그 각도를 θ2 라고 할때 이런 식이 나옵니다.
Z2 = r2(cosθ2 + isinθ2)

여기서 왠지 모르겠지만 Z1 에 Z2를 곱하였습니다.
Z1Z2 = r1r2(cosθ1*cosθ2 + icosθ1isinθ2 + isinθ1icosθ2 - sinθ1sinθ2) 이 식을 이제 실수부와 허수부로 묶어보겠습니다.
  = r1r2((cosθ1cosθ2 - sinθ1sinθ2) + i(cosθ1sinθ2 + sinθ1cosθ2))
이렇게 전개 됩니다. 이중에 (cosθ1cosθ2 - sinθ1sinθ2) 이부분과 (cosθ1sinθ2 + sinθ1cosθ2) 이부분은 공교롭게도 코사인 덧셈 법칙에서 본 식입니다. 
코사인 덧셈법칙을 적용해서 치환해보면 이렇습니다.
  = r1r2(cos(θ1+θ2) + isin(θ1+θ2))

이렇게 식을 유도한 상황에서 한가지 가정을 더하겠습니다. Z2 의 크기인 r2 가 사실 1이었다고 해보겠습니다. 그럼 위의 식에서 r2는 생략 가능해집니다.
        r1(cos(θ1+θ2) + isin(θ1+θ2))
여기서 얻을 수 있는 결론이 뭐냐면 Z1 이라는 것이 2차원 벡터를 표현한다고 생각 해보고 거기에 곱해주는 Z2는 크기가 1짜리인 벡터 즉 단위 벡터입니다.
이렇게 가정한 Z1 과 Z2 를 곱하니 결과가 크기는 그대로고 각도만 θ1 + θ2 로 바뀐 값이 튀어나오게 됩니다.
이걸 다르게 말하자면 Z1 이 θ2 각도 만큼 '회전'을 했다고도 볼수 있겠습니다.

정리하면 어떤 복소수로된 벡터에 단위 복소수 벡터를 곱해주니까 회전을 한다는 것입니다.

이런식으로 전혀 연관성이 없을 것 같은 복소수를 가지고 벡터의 회전에 적용할 효과를 발견할수 있었습니다.
이 복소수를 벡터의 회전에 사용할수 있는 이유는 단위허수 i의 제곱이 -1 이라는 원리가 가장 중요한 원리였습니다.

추가로 한가지더 유용한 내용이 있는데 복소수를 행렬로도 표현할 수 있습니다. 

        a + bi  ->  a -b
                    b  a 
어떻게 해서 이렇게 표현할 수 있는지를 생각해보면 복소수의 기본형태인 a + bi 에서 a에는 사실 1이 곱해져있다고도 볼 수 있을겁니다. 
 a*1 + b*i 인겁니다. 여기서 1은 실수의 단위, i는 허수의 단위라고도 볼수 있습니다. 실수 단위 E, 허수 단위 I 일때 이 단위들의 행렬을 구할수 있을겁니다. 
 E =  1  0
      0  1
 
 I =  0 -1
     -1  0

어떤 복소수가 1이라고 했을때 행렬로 표현하면 E 라는것이고 i라고 했을때의 행렬은 I인 겁니다.
복소수라고 해서 항상 a + bi 형태를 하고 있는것은 아닌겁니다. 실수부 허수부 둘중하나가 0이어서 한쪽만 존재한다고 해도 복소수 입니다.

복소수를 행렬로 표현하는 방법과 복소수를 극좌표계로 표현한 방법을 같이 봐 보겠습니다. 
복소수의 크기 r 이 1이고 각도가 θ 일때 실수부 값은 cosθ 허수부 값은 sinθ 입니다. 이걸 행렬로 표현하면 이렇습니다. 
   cosθ -sinθ
   sinθ  cosθ
이 결과를 보면 이전에 회전 행렬을 만들때 보았던 형태와 비슷합니다. 
이렇게 복소수는 회전과 연관되어 있다는걸 행렬로 다시 확인한것 같습니다.

복소수에 대한 결론은 복소수를 이용해서 2D 회전을 표현할 수 있었습니다. 
그리고 a + bi 라는 2차원 식을 가지고 2D 회전을 표현할수 있었으니까 우리가 만드는 3D 세상은 어떻게 표현해야 할지가 두번째문제가 되었습니다.

복소수처럼 허수 i 하나를 사용해서 2차원 회전을 표현하는것을 보고 i 말고 하나더 추가해서 표현하면 3차원 회전도 표현할수 있지 않을까 라는 생각들을 하고 있었습니다.
  a + bi + cj 같은 형태이지 않을까 생각을 하다가 1870 년대에 해밀턴이라는 사람이 발견한 방법이 3개를 사용하는게 아니라 4개를 사용해야 한다는걸 발견했습니다. 
 a + bi + cj + dk 여기서도 a는 실수부 이지만 bi,cj,dk 부분은 가상의 숫자라고 보면 됩니다. 이 방법이 복소수와 2차원 회전과 마찬가지로 3차원에서의 회전을 쉽게 
 표현할수 있다는걸 알아냈는데 이 방법이 이번 시간의 주제인 Quaternion (사원수) 입니다.
복소수 -> 2차원 회전 
Quaternion -> 3차원 회전

꼭 쿼터니언이 3차원 회전만을 뜻한다는것은 아니지만 게임에서 3차원 회전을 표현할때 유용하게 쓰이는것은 맞습니다.
그리고 이 쿼터니언을 활용하면 오일러방싱에서 나타난 짐벌락 현상도 해소할수 있고 행렬로 표현하던것보다 더 간단하게 표현할수 있습니다.