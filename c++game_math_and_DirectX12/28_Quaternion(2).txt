

        28. Quaternion (2)



이어서 쿼터니언이 어떻게 3차원 회전을 표현하는가에 대해 배워보겠습니다.

본격적으로 쿼터니언에 들어가기 전에 사전 지식이 필요합니다. 


- 회전 공식
먼저 일반적인 회전 공식에 대한 내용입니다. 

a라는 축이 있고 a축의 어느 점에서 부터 시작한 벡터V 가 있습니다. 그리고 이 V가 a축을 기준으로 회전을 한 결과를 V' 라고 하겠습니다.

이때 V' 이 어떤 공식으로 만들수 있는지를 알아볼겁니다. 

축 a는 단위벡터 즉 크기가 1인 벡터라고 하겠습니다. 그리고 V가 회전한 각도를 θ 라고 표현하겠습니다.

이 상황에서 먼저 구해볼것은  회전하는 대상인 V와 회전할 주체인 a라는 축을 기준으로 하면 이 두 벡터사이의 평면이 하나 나옵니다. 
그리고 그 평면을 기준으로 a라는 벡터에 수직인 벡터 V⫠a 가 구할수 있습니다. 
참고로 V⫠a 를 수식으로 구하고 싶다고 하면 벡터의 성질을 이용해서 벡터 V 에 V,a 평면에 수직하게끔 어떤 벡터를 더해주면 나올겁니다. 나중에 자세히 알아볼겁니다.

그러면 회전을 한다는게 어떤 의미인지 알아보면 지금 구한 V⫠a 를 빙 돌려서 θ 만큼 돌아가는 것이고 V' 의 성질은 여러가지 벡터를 더해서 얻을수 있습니다.
a축 방향에 크기는 V 의 크기 만큼인 어떤 벡터 V∥a 에다가 V가 V⫠a 에 수직하게 내려온 벡터를 θ 만큼 회전한 벡터를 더하면 됩니다. 
말이 어려운데 기하학적으로 그리면 더욱 쉽습니다.

결과적으로 V' 이라는 벡터가 어떤 성분들의 합으로 이루어 져있는지를 보면
    V' = V∥a + V⫠a*cosθ + (a×V)sinθ

이 식을 유도하기 위해 알아야 할 내용을 더 보겠습니다. 

회전할 대상인 V의 성분중에 V⫠a 크기 성분을 구합니다. V와 a 사이의 각도를 α 라고 했을때 |V|sinα 가 V의 꼭지점에서 a까지의 거리를 나타내고 이 길이가 V⫠a 의 크기입니다.

그러면 회전한 벡터인 V' 의 V'⫠a 의 길이도 |V|sinα 인걸 알수 있습니다.

또다른 벡터 하나를 구해줄겁니다. a×V a와 V에 동시에 수직인 벡터입니다. 외적이라고도 하는데 이 외적된 벡터의 크기를 구하는 식은 
 두 벡터의 크기에 sin(두 벡터 사이의 각도) 입니다.
위의 경우에 적용하면  |a||V|sinα 인데 여기서 a는 단위벡터였기때문에 계산을 생략할 수 있습니다. 즉 
a×V = |V|sinα 입니다. 
이식에 따르면 V⫠a 의 크기와 a×V 의 크기가 같습니다.

V'를 유도하는 식
V' = V∥a + V⫠a*cosθ + (a×V)sinθ
에서 세가지 벡터를 구해서 더하면 되는데 

첫번째 부분 V∥a 는 구하기가 쉬울겁니다. V 의 성분중에 a축에 수직으로 내려온 점 까지의 길이를 구해주면 되는데 
이걸 수식으로 표현하면 (V·a)a 이렇게 표현되고 V 랑 a 를 내적해주고 있습니다. 내적의 크기 공식이 |V||a|cosα 인데 여기서 a는 단위 벡터이기 때문에 생략하면 
|V|cosα 입니다. 이 구한 크기에 방향벡터인 a 를 곱해줘서 (|V|cosα)a 입니다.

두번째 성분인 V⫠a*cosθ 가 뜻하는 부분은 V⫠a 가 θ 만큼 회전한 V⫠a' 의 성분중에 V⫠a 에 수직으로 내려온 크기를 말합니다.
이 부분을 V⫠a 의 크기가 |V|cosα 인걸 활용해서 구할수도 있지만 지금은 (V - (V·a)a)cosθ 라는 수식으로 구해주겠습니다. 이 수식은 회전의 대상 벡터 V 에서 (V·a)a 를 
빼주고 그 벡터의 cosθ를 해준 수식입니다. 여기서 (V - (V·a)a) 부분을 잘 해석하면 V 에서 V∥a 를 빼준것과 마찬가지입니다. 즉 V⫠a = (V - (V·a)a) 입니다. 

세번째 성분 (a×V)sinθ 은 어떤 의미이냐면 V' 의 성분중에 a×V 방향쪽으로 향하는 성분을 말합니다. 이 성분은 a×V 의 크기 |V|sinα 전체가 아닌 일정 부분만 원합니다.
이 성분을 구하려면 V⫠a' 의 끝 부분에서 a×V 벡터로 수직해 내려온 선분 을 그으면 그 선분과 V⫠a' 사이의 각도가 θ가 됩니다. V⫠a'sinθ 가 되는데 V⫠a 의 크기와 a×V 크기가 같고 
향하는 방향은 a×V 쪽을 향해야 하기 때문에 (a×V)sinθ 이 됩니다.

이렇게 구한 세 성분은 a축 방향 성분(V∥a), V⫠a 방향 성분(V⫠a*cosθ), a×V 방향 성분((a×V)sinθ) 을 더하면 V' 가 됩니다.
이 수식을 전개하면 이렇습니다.
V' = V∥a + V⫠a*cosθ + (a×V)sinθ = Vcosθ + (V·a)a(1-cosθ) + (a×V)sinθ
이렇게 전개 되지만 이렇구나 정도 알고 있으면 되고 달달 외우고 있어야 할 필요는 없습니다. 

여기 까지 워밍업으로 3차원 회전 공식을 알아 봤습니다. 


- 그래서 쿼터니언이란?

쿼터니언을 CPP 코드에서는 재밌게도 일반 벡터와 마찬가지로 Vec4(x,y,z,w) 처럼 관리하고 있습니다. 

복소수에서 실수부와 허수부를 따로 관리했던것처럼 쿼터니언도 실수부(스칼라부,w) 허수부(벡터부,(x,y,z))로 관리해주고 있습니다.
허수부인 x,y,z에 각각의 허수 i,j,k 를 곱해줄겁니다.

    q = xi + yj + zk + w

그리고 이 표현을 매번 사용하는건 조금 길기 때문에 줄여서 
(V,S) 라고 표현하기도 합니다. 여기서 V는 벡터(x,y,z) 를 말하고 S는 스칼라를 말합니다. 
엄밀히 말하면 쿼터니언이 벡터는 아니니까 이렇게 표현하는게 이상하다고 느낄수 있습니다. 그래도 실제 벡터가 아니고 x,y,z 를 묶어서 그렇게 표현한다고 알면 되겠습니다.
복소수와의 약간의 차이가 있는데 허수부를 묶어서 표현한다, 그리고 실수부를 뒤쪽에 표현한다가 있는데 실수부를 뒤에 표현하는것은 우리가 사용할 게임프로그래밍에서 
Vec4 와 편하게 사용하기위한 형태입니다. 반드시 이렇게 해야한다는 것은 아닙니다.

중요한 내용중 하나는 i,j,k 는 어떤 의미인지를 알아보면 복소수같은 경우 i² 을 하게 되면 -1 이라는 값이 나오고 허수였던 i가 실수 쪽으로 넘어오게 되는 느낌이었습니다.
여기서 쿼터니언의 ijk 에 대한 성질을 알아 보겠습니다. 
    i² = j² = k² = -1
    ij = -ji = k
    jk = -kj = i
    ki = -ik = j
이런 성질이 있습니다. 제곱을 한다는것은 똑같은데 자기들중 두개씩 곱하게 되면 나머지 하나로 변환이 된다는 특징도 있습니다.
이 성질을 모두 외우고 있기는 힘드니까 외우는 요령이 있는데 i,j,k 순서일때 -> 방향으로 두개씩 곱하면 그냥 나머지 하나가 튀어나오고 
<- 방향으로 두개씩 곱하면 나머지 하나에 -를 곱해서 나온다고 생각하면 됩니다.

쿼터니언도 복소수와 마찬가지로 여러가지 특성이 있습니다. 
쿼터니언의 켤래는 q* = (-V,S)  입니다. 허수부에 -를 곱해주고 있습니다.

쿼터니언의 크기도 복소수와 비슷합니다. 
 |q| = √(qq*) = √(|V|²+S²) = √(x²+y²+z²+w²)

그리고 쿼터니언의 역 에 대해 알아볼것인데 쿼터니언과 쿼터니언의 역을 곱하면 1이 나온다고 합니다. 
    qq¯¹ = 1
마치 역함수처럼 쿼터니언의 역을 구할수 있다는 이야기입니다. 그래서 쿼터니언의 역을 구하는 수식을 써보면 
    q¯¹ = 1/q = (1/q)(q*/q*) = (-V+S)/(V²+S²)
그런데 왜 굳이 쿼터니언의 역을 수식으로 표현해보았는가 하면 만약에 쿼터니언 q가 단위 쿼터니언이었다 하면 즉, q의 크기가 1 이라면 
q¯¹ 의 분모인 (V²+S²) 가 1이기 때문에 q¯¹ = -V+S = q* 이라는 의미가 됩니다. 

(q가 단위 쿼터니언일때)  q¯¹ = q*

마지막으로 증명은 하지 않을것이지만 쿼터니언끼리 곱한 값에 켤래를 구해주면 각각 쿼터니언의 켤래를 순서를 바꿔 곱한 값과 같습니다. 
    (q1 × q2)* = q2* × q1*


이렇게 쿼터니언의 여러가지 성질에 대해 알아보고 있는데 
사실 아직까지 쿼터니언의 곱에 대해 알아보지 않았습니다. 그래서 이어서 살펴볼 내용은 쿼터니언의 곱입니다.

q1 과 q2 가 각각 정의 되어있다고 하겠습니다.
q1 = x1i + y1j + z1k + w1 = (V1, S1)
q2 = x2i + y2j + z1k + w2 = (V2, S2)

이런 상황에서 q1과 q2 두 쿼터니언을 곱해주면 별로 어려울것은 없지만 식이 난잡해집니다.

q1 × q2 = (x1w2 + y1z2 + z1y2 + w1x2)i + (y1w2 + z1x2 + w1y2 + x1z2)j + (z1w2 + w1z2 + x1y2 + y1x2)k + (w1w2 - x1x2 - y1y2 - z1z2)

이런식이 나온 원리는 위에서 나온 성질을 적용해서 노가다를 하면 나옵니다.
    i² = j² = k² = -1
    ij = -ji = k
    jk = -kj = i
    ki = -ik = j
그리고 이렇게 쿼터니언의 원소들을 쭈욱 나열한 형태도 있지만 (V,S) 형식으로 간추려서 표현하면 이렇습니다. 

q1 × q2 = ((V1 × V2) + (S1 × V2) + (S2 × V1) , S1 × S2 - V1⋅V2)
이게 어떻게 표현되는지는 스칼라와 벡터의 곱, 스칼라 끼리의 곱, 벡터끼리의 외적, 벡터 끼리의 내적의 식을 활용하면 됩니다. 

/*
여기서 잠깐 나중에 필요해질 벡터의 삼중곱에 대해 알아보고 가겠습니다. 결론만 보면 
 벡터a, 벡터b, 벡터c 가 있을때  abc = b(a·c) - c(a·b)
입니다. 증명 방법으로 가장 단순하게 직접 손으로 계산해보는 방법이 있습니다. 
*/


- 쿼터니언과 벡터 , 회전 

이제 진짜 메인 내용인 쿼터니언과 벡터사이의 어떤 관계가 있는지를 알아보겠습니다.

우리가 게임세상에서 사용하는 3차원 벡터를 V 라고 하고 V가 회전한 결과를 V' 라고 하겠습니다.
변환 대상인 V의 쿼터니언 Vq 을 (V, 0) 이라고 표현할겁니다. 게임세상의 벡터는 x,y,z 세가지 값이 유효하고 마지막값은 없어도 되기때문인데 
이 형태의 쿼터니언을 순수 쿼터니언(Pure quaternion) 이라고 합니다.

그리고 변환을 담당할 쿼터니언을 q 라고 놓을것이고 q는 아직까지 어떤 죄표인지 모르니까 일반적인 q = xi + yj + zk + w 와 (u, w)라고 표현하겠습니다. 참고로 이 q 는 크기가 1인 단위 쿼터니언
이라는 성질을 가지고 있을겁니다.

쿼터니언으로 3차원 벡터의 변환, 회전을 시키는 식을 샌드위치 프로덕트라고 하는데 변환대상의 앞뒤로 변환 쿼터니언과 쿼터니언의 역을 곱해줍니다. 
그런데 이때 변환 쿼터니언 q 의 크기가 1이기 때문에 q¯¹ 과 q* 가 같습니다. 
    V' = qVq¯¹ = qVq*
이 쿼터니언들 사이의 곱을 간략하게 전개 해보면 
    = (u, w)(V, 0)(-u, w)
이고 이 식을 하나씩 전개 해나가야 합니다. 우선 뒤의 두 쿼터니언 부터 쿼터니언의 곱 공식을 이용해 전개 해봤습니다. 
    = (u, w)(-V × u + wV, V·u) 
첫번째 전개는 그나마 좀 쉬웠지만 두번째로도 전개를 해야 합니다. 매우 복잡해지기 때문에 전개를 실수부와 허수부를 나눠서 전개 해보려고 합니다. 
먼저 실수부를 전개하는 식은 S1S2 - V·u 라는 공식이 있었는데 이식을 적용하면 다음과 같이 될것입니다.
(실수부)  = (w × V·u) - (u·(-V × u + wV)) = u·(V × u) = 0
이때 wVu 가 상쇄 되어서 정리가 됩니다. 그리고 V와 u의 내적은 둘모두에게 수직인 벡터가 나올것이고 u와 수직인 벡터를 내적을 하게되면 항상 0이 나오기 때문에 
실수부의 값은 0이 됩니다.
즉, V의 회전한 상태인 V' 도 실수부는 0 인 순수 쿼터니언입니다. 그나마 간단하게 정리 되었습니다. 

이제 허수부를 전개해볼 차례입니다.
(허수부) = - u × V × u + w(u × V) + w(-V × u + wV) + (V·u)u 
이중 앞의 - u × V × u 부분을 벡터의 삼중곱 공식을 사용해서 다시 전개 해보았습니다. 
 = -V(u·u) + u(u·v) + w(u × V) + -w V × u + w²V + (V·u)u 
이제 정리를 해보겠습니다. 이때 w(u × V) + -w V × u 부분에서 u와 V의 외적 순서가 반대입니다. 외적의 순서가 반대라면 - 를 곱해서 치환해 줄수 있는걸 생각하면서 
정리해보면 
= w²V + 2w(u × V) + 2u(u·v) -V(u·u)  = (w² - u·u)V +2u(u·u) + 2w(u × V)

이제 허수부와 실수부를 합쳐서 표현하면 이렇습니다. 

    V' = ((w² - u·u)V +2u(u·v) + 2w(u × V) , 0)

결과가 나오기는 했는데 이 식이 어떤 의미인지를 아직 잘 모르겠습니다. 분석을 해보겠습니다.

위의 V' 의 수식에서 시작을 해볼것인데 먼저 지금 예시에서 변환 쿼터니언인 q 는 크기가 1인 단위 쿼터니언이라고 했습니다. 
 q = (u, w)
이 q를 가로축이 실수부고 세로축이 허수부인 어떤 좌표계가 있다고 했을때 극좌표계로 표현하면 w = cosθ 이고 u = sinθ 일것입니다. 물론 이것은 2차원에서 쉽게 표현한 것이고
u 는 x,y,z 3차원 벡터이기 때문에 3차원을 대표를 뽑아서 한 축으로 앞축시키는 방식으로 뽑아보도록 하겠습니다.
u 가 자신만의 방향과 크기를 가지고 있는 벡터일것인데 u의 방향을 가진 크기가 1인 단위 벡터 n을 만들어서 u의 크기만큼을 n에 곱해서 다시 u를 만들어 줄 수 있을겁니다.
그리고 sinθ 라는 크기가 n에 곱해줄 크기인겁니다. 
u = sinθ × n

애당초 우리가 쿼터니언의 크기를 구할때는 |q| = √(x²+y²+z²+w²) 이렇게 구하는 방법에서 x,y,z 따로 w 따로 계산하고 있는 느낌입니다.
그래서 x,y,z 에 해당하는 u를 sinθ × n 라고 표현해보고 있는겁니다. 

그래서 u = sinθ × n 이고 w = cosθ 라는 표현으로 계산을 해보려고 합니다.
이 내용을 V' 계산식에 적용하면 이런 식이 됩니다. (c 는 cosθ, s 는 sinθ) (앞부분의 u·u = s²n·n 인데 n이라는 단위 벡터끼리 내적하게되면 1이라는 스칼라 값이 나오기 때문에 생략)

V' = ((w² - u·u)V +2u(u·v) + 2w(u × V) , 0) = ((c²-s²)V + 2((s)n·V)(s)n + 2c(s)(n × V), 0)
   = ((c²-s²)V + 2s²(n·V)n + 2cs(n × V), 0)

여기서 이제 삼각함수 공식을 사용할것입니다. 코사인 덧셈 법칙에서 더하는 각도가 둘다 θ일때를 보면 
    cos²θ - sin²θ = cos(2θ)
    2cosθsinθ = sin(2θ)
    cos(2θ) = 1 - 2sin²θ
이 법칙을 이용해서 전개하고 있던 V'를 다시 치환해서 정리해봤습니다. 
V' = cos(2θ)V + (1 - cos(2θ))(n·V)n + sin(2θ)(n × V)

이렇게 어렵게 구한 V' 전개식을 보면 이전시간에 배웠던 회전 공식과 닯아 있습니다. (V' = Vcosθ + (V·a)a(1-cosθ) + (a×V)sinθ 회전공식이었습니다.)

결론입니다. 
회전하고 싶은 각도를 θ 이고 단위 벡터 a 가 있습니다.
회전할 쿼터니언 q = (sin(θ/2)a , cos(θ/2)) 
이 q를 회전할 대상인 V에 샌드위치 프로덕트를 해줍니다. 
V' = qVq*  이것이 쿼터니언을 이용한 회전입니다.

여기에 더해서 회전을할때 q 하나만 하는것이 아닌 두가지의 회전을 같이 한다고 했을때 q1, q2 로 표현해보면
V' = (q2q1)V(q1*q2*)
입니다. 그런데 아까 배웠던 쿼터니언의 성질중에 (q1q2)* = q2*q1* 이라는 성질이 있던걸 적용하면 
V' = (q2q1)V(q2q1)*
이 되겠습니다. 
이런 여러 쿼터니언 회전을 통해 x축, y축, z축 회전을 해줄수 있을겁니다. 이렇게 원하는 쿼터니언들을 미리 곱해놓고 회전행렬로 사용할 수 있습니다.


- 쿼터니언에 대한 디테일
이렇게 쿼터니언의 회전에 대한 가장 핵심적인 부분을 알아봤고 이제 디테일한 부분을 알아볼것입니다.

쿼터니언의 장점은 짐벌락 현상을 해결 할 수 있고, 행렬을 이용한 연산보다 속도가 빠릅니다. 
(쿼터니언이 행렬보다 속도가 빠른 이유는 행렬의 경우 3×3 이나 4×4 의 행렬의 경우 float가 9개 혹은 16개가 필요한데 쿼터니언의 경우 4개의 float가 필요합니다.)

그럼에도 불구하고 행렬을 아예 사용하지 않을수는 없습니다. 우리가 셰이더에게 데이터를 넘겨줄때는 행렬로 변환해야하는데 

그래서 다음 주제는 쿼터니언과 행렬의 변환에 대한 내용입니다.
일단 시작은 쿼터니언 공식중에 삼각함수로 치환되기 전의 식에서 시작하겠습니다. 

    V' = ((w² - u·u)V +2u(u·v) + 2w(u × V) , 0)

이번 상황에서는 쿼터니언 q 의 성분은 허수부 벡터 b 와 실수부 c 로 이루어 져있습니다. q 의 크기는 1 인 단위 쿼터니언입니다. 
    q = (b, c)    ,  |q| = 1
이 상태에서 위의 식을 다시 쓰겠습니다. 
    qVq* = ((c² - b²)V + 2(b · V)b + 2c(b × V), 0)

이제 이 식을 행렬화 해줄 것인데 어려운 방법이 아니라 한 부분 마다 행렬화 해서 표현해주겠습니다. 
    c²-b²   0    0              2bx²  2bxby  2bxbz          0   -2cbz  2cby
=     0   c²-b²  0      × V +  2bxby   2by²  2bybz  × V +  2cbz   0   -2cbx   × V
      0     0  c²-b²           2bxbz  2bybz   2bz²        -2cby  2cbx   0  
첫번째 행렬은 V라는 벡터의 성분들인 Vx,Vy,Vz 에 각각 곱해주는 행렬이고 세번째 행렬은 벡터b와 벡터v의 외적공식을 표현한후에 앞에 2c 라는 스칼라 값을 붙여주고 있습니다. 
두번째 행렬이 좀 복잡한데 괄호안의 b · V 은 x,y,z 각각 서로 곱한다음 더해주는  내적공식이 적용되고 그 값은 스칼라 값이 나올겁니다. 거기에 다시 2b 라는 벡터를 곱해주고 있습니다.
이부분은 천천히 해보면 되는 부분이고 크게 중요하지 않은 부분이기 때문에 자세한 증명은 생략할것입니다.

그 다음 이 세 부분을 합쳐줄겁니다. 행렬의 덧셈은 각각의 위치에 있는 원소들끼리 더해주면 되었습니다. 
세 행렬들의 대각선 부분을 더해주는데 대표적으로 1행 1열을 보면 
    c²-b² + 2bx² 입니다. 
여기서 쿼터니언 q는 단위 쿼터니언이었기때문에 쿼터니언의 크기를 구하는식 q = √(|b|²+c²) = 1 이고 1에 제곱을 해도 1이기 때문에 루트를 벗겨서 
b² + c² = 1 에서 양변에 -2b² 을 더해주면 c²-b² = 1-2b² 이 유도 됩니다. 위의 식에 대입해보겠습니다. 
1-2b² + 2bx² 
여기서 다시 b² 이란 각 원소들을 제곱해서 더해준 값이므로 
1 -2(bx²+by²+bz²) + 2bx² = 1 -2by² -2bz² 입니다.  이 풀이를 대각선의 원소들에게 모두 적용 시킬수 있습니다. 

대각선 성분들이 아닌 부분을 계산해보면 먼저 다시 벡터 b는 (x,y,z) 로 이루어진 벡터이고 c는 w 를 가지고 있는 실수입니다. 
대표로 1 행 2열의 성분을 예로 들어서 각 성분을 합치면 이렇게 됩니다. 
2bxby - 2cbz  이때 각 x,y,z 앞의 b 를 생략 할 수 있고 c는 w 로 치횐이 됩니다. 정리하면 
2bxby - 2cbz = 2(xy - wz) 이렇게 정리 할 수 있습니다. 대각선 성분들도 비슷하게 변환 할 수 있습니다. 
결과적으로 쿼터니언을 행렬로 변환한것을 M(q) 라고 한다면 
    qVq* = M(q)V 라고 할수 있는데 
이 M(q) 는 위의 행렬의 합으로 정리하면 이렇습니다. 
        1-2y²-2z²  2(xy-wz)  2(xz+wy)
M(q) =  2(xy+wz)  1-2x²-2z²  2(yz-wx)
        2(xz-wy)   2(yz-wx) 1-2x²-2y²

이렇게 쿼터니언과 행렬사이의 변환에 대해 간략하게 알아 봤습니다. 
그런데 이제 거꾸로 되는 상황도 있을겁니다. 지금은 쿼터니언을 아는 상태에서 행렬을 뱉어주는 상황이었고 거꾸로 행렬을 아는데 쿼터니언을 뱉어야 하는 상황도 있을겁니다.

거꾸로 위에서 구한 행렬에서 쿼터니언을 유도하는 연습을 해보겠습니다. 
        1-2y²-2z²  2(xy-wz)  2(xz+wy)
M(q) =  2(xy+wz)  1-2x²-2z²  2(yz-wx)
        2(xz-wy)   2(yz-wx) 1-2x²-2y²
이 행렬을 받기는 할텐데 지금처럼 쿼터니언이 어떻게 계산되서 각 값을 가지고 있는지는 모르고 계산이 된 결과물만 각 위치에 있을겁니다. 
        M00 M01 M02
M(q) =  M10 M11 M12     이런 식 일 겁니다.
        M20 M21 M22
이번 목표는 이 결과 값에서 q 의 x,y,z,w 값을 찾는것이 목표입니다.

먼저 왠지 모르게 대각선의 원소들을 모두 더해보겠습니다. 
M00 + M11 + M22 = 3-4(x²+y²+z²)  
이런 식이 나오는데 우리가 구하고싶은 쿼터니언 q 자체가 단위 쿼터니언이었습니다. 단위 쿼터니언의 크기를 구하는 식을 보면 
 |q|² = x²+y²+z²+w² = 1² 
 입니다. 여기서 w² 을 반대 항으로 넘기면 x²+y²+z² = 1-w² 이 될겁니다. 대각선 요소들의 합 공식에 대입하면 이렇게 됩니다.  
 M00 + M11 + M22 = 3-4(x²+y²+z²) = 3 - 4(1 - w²) = 4w² - 1
 이제 w 를 구하도록 이리저리 넘기면 이렇게 되겠습니다. 
 w = ±√((M00+M11+M22+1)/4) = ±(1/2)√(M00+M11+M44+1)
 이러면 w 값이 +일수도 있고 -일수도 있는 상황인데 지금 첫번째 선택은 딱히 상관이 없습니다. 약간 이상하게 들릴수도 있는데 
최종 쿼터니언 Q가 양수나 음수나 상관없는 이유가  Q = (x,y,z,w)  , -Q = (-x-y,-z,-w) 인데 쿼터니언변환한 행렬을 보면 서로 곱해져서 어짜피 -가 전부 상쇄됩니다.
즉 똑같은 회전행렬을 쿼터니언으로 표현할때는 음수 양수 두가지 다 가능합니다.
그래서 처음에 w가 음수인지 양수인지를 한번 정하면 나머지 원소들 x,y,z 도 부호가 w 를 따라 가면되겠습니다.

이제 나머지 x,y,z 값을 구할것인데 행렬의 나머지 부분을 이리 저리 조합해가면서 이런 식을 만들었습니다. 
M21 - M12 = 4wx   
M02 - M20 = 4wy
M10 - M01 = 4wz
이런 묘한 결과가 나오고 여기서 각각 x,y,z 를 얻도록 항을 정리하였습니다. 
x = (M21-M12)/4w
y = (M02-M20)/4w
z = (M10-M01)/4w

이렇게 x,y,z,w 를 구해봤는데 이렇게 하나의 케이스만 구해보는것은 작업을 하면 살짝 문제가 있습니다. 
어떤 경우이냐면 만약에 w가 엄청 작은 수라고 해보겠습니다. 그러면 float 특성상 w가 작을수록 오차가 점점 커질것입니다. 회전을 할때는 이 오차를 관리해줘야 하니까 
항상 w를 나눠주지는 않을거고 가장 오차가 적게 나는 방법을 찾아보겠습니다.

 M00 - M11 - M22 + 1 = 4x²
-M00 + M11 - M22 + 1 = 4y²
-M00 - M11 + M22 + 1 = 4z²

이런 신기한 값이 나오는 방법이 있는데 이 경우에도 x,y,z 자체를 구해줄때 부호가 양수일수도 있고 음수일수도 있을건데 하나를 멋대로 지정해주는것은 괜찮지만 
모든 값들을 각각 임의로 지정해줄 수는 없습니다. w 로 나눠서 구하는 방법에서는 w의 부호를 하나 골라주면 w의 부호에 따라 나머지가 골라졌던것이지만 지금공식에서는 
세 미지수들이 제곱으로 되어있기때문에 부호를 완전히 알 수 없습니다. 

그러면 어떻게 해야 할지를 생각해보면 우리가 w 로 나눴던 공식처럼 이리저리 찾아보면 x로 나누는 공식도 있을것이고 y,z 로 나누는 공식도 있을겁니다.

이때 M00 를 다시 살펴보면 M00 = 1 - 2y² -2z² 이었습니다. 그리고 단위 쿼터니언이기 때문에 w² = 1 -x² -y² -z² = w² + x² - 1  = - y² - z² 입니다. 
즉, 이걸 치환하면 M00 = 1 + 2(w² + x² -1) = -1 + 2w² + 2x²
입니다. 이런 정리를 M11, M22 에게도 적용하고 나서 정리해보면 
2x² = M00 - 2w² + 1
2y² = M11 - 2w² + 1
2z² = M22 - 2w² + 1
이라고 정리가 됩니다. 
그러면 다음으로 눈여겨 볼것은 x,y,z 중에서 누가 가장 큰 값을 가지고 있을까가 궁금한데 뒤에 - 2w² + 1 부분은 셋다 똑같기 때문에 맨앞에 부분이 x,y,z 의 크기에 
결정적인 관련이 있을겁니다. 그리고 우리는 행렬의 성분들의 값을 알기때문에 M00, M11, M22 중에 어떤 게 가장 큰지를 알수있고 그래서 이 x,y,z 중에 가장 큰것을 
알면 가장 큰값으로 나눠주려고 합니다. 그래야 가장 오차가 적은 방법이 될것이기 때문입니다.

여기서 가정으로 x 가 가장 큰값이라고 해본다면 이제 x 를 부호를 골라주게 될겁니다. 하나만 골라주면 나머지 값들은 따라오기때문입니다.
M00 - M11 - M22 + 1 = 4x² 이 식을 가져다가 x 값을 구하면 
x = ±(1/2)√(M00-M11-M22+1) 
이고 이제 w로 연산 해줬던것 처럼 나머지를 구해줄 수 있을겁니다. 이 경우에는 이렇게 될것입니다. 
y = (M10+M01)/4x
z = (M02+M20)/4x
w = (M21-M12)/4x

여기서 알 수 있는것은 w 를 이용해서 구하는것이 무조건 안되는것이 아니라 x,y,z,w 중에 그나마 가장 큰 값을 가지고 계산해야 오차를 최대한 줄일 수 있을것이라는 겁니다.

실질적을 쿼터니언을 사용하는 코드를 보면 단일 공식으로 되어있는게 아니라 x,y,z,w 중에 어떤 값이 가장큰지 if else 문으로 골라준다음 그 결과에 따라 조금씩 공식이 
달라지고 있다는것을 알 수 있을겁니다.