

		18. Projection, Screen 변환 행렬


이전시간에 이어서 남은 게임에서의 변환 행렬들을 알아보겠습니다.


# Projection 스페이스 변환 행렬

지금까지 3D월드에서 오브젝트사이의 상대적인 좌표와 크기, 방향등을 변환하는 작업을 하였습니다. 마지막으로 한 View변환 행렬은 카메라를 원점으로 둔 좌표계에서 다른 오브젝트들은 어떤 좌표에 
어느 방향으로 존재하는가를 변환 했습니다. 

이번에 배울 Projection 스페이스 변환 행렬은 View스페이스에 있는 오브젝트중 카메라의 촬영 범위에 들어오는 오브젝트를 추려서 3D세상이 아닌 2D로 압축해서 표현하게 됩니다.
다른 말로 투영 단계라고 합니다. 이때 투영 정책을 어떻게 할것이냐에 따라 원근투영인지, 직교투영인지 등을 정할 수 있을겁니다. 

지금은 기본이 되는 원근 투영을 기준으로 배워보겠습니다.
일단 세로로 y축 가로로 z축이 되는 그래프가 있다고 해보겠습니다. 이때 가로가 x축이 아닌 z축인데, 카메라를 기준으로하는 View 스페이스 였다보니 z축은 커질수록 카메라로 부터 멀어지는 깊이 값이 됩니다.
이 그래프에 z값이 증가할수록 y값이 +, - 양쪽으로 커지는 삼각형을 그려보아습니다. 그 삼각형의 가장 큰 z값을 가진 선분을 far 라고 하고 원점과 far 사이의 어느점에 z축과 수직하는 선분 하나를 더 그어서 
near라고 부르겠습니다. 
near와 far의 의미는 카메라의 촬영되는 범위중 가장 가까운 곳을 near 가장 먼 곳을 far라고 볼 수 있습니다. 
그러면 최종적으로 상이 맺히는 곳은 near일 수도 있지만 원점과 near사이의 어딘가에 맺히게 됩니다. 지금은 편의상 z값이 1인곳에 상이 맺힌다고 하겠습니다.
Projection 변환의 값이 비율로 반환될것이기때문에 계산하기 쉽도록 1이라는 곳에 맺힌다고 쳤습니다. 이때의 y값도 +1에서 -1이라고 하겠습니다.
z값과 y값이 1로 같으면 tan값이 45이고 삼각형이 위아래로 있기 때문에 원점에서의 각도가 90도인 직각삼각형이라는걸 알 수 있습니다.
이 각도를 fov(field of view)라고 하고 카메라가 찍을 수 있는 각도입니다. 보통은 60도 정도로 세팅하지만 지금은 계산 편의상으로 90도로 잡았습니다.

용어정리를 끝내고 다시 View변환 다음 단계로 와서 Projection 변환에서 이루고 싶은 것이 무었인지 생각해 보면
예전에 투영 좌표계라는걸 배웠습니다. (-1,-1)에서 (1, 1)사이의 영역안에 비율대로 상을 맺는 것입니다. 그리고 추가로 0에서1사이의 깊이 값도 있었습니다.

이때 카메라의 촬영 영역안 어딘가에 (x, y, z, 1)이라는 좌표에 물체가 하나 있었다고 해보겠습니다.
이 물체가 투영될때는 물체의 원래크기, 그리고 z값(거리)가 있어서 거리가 멀면 투영될때는 비례해서 작아보이는게 원근 투영입니다.

지금 예시에서는 투영되는 지점의 z값이 1이니깐 1(투영지점) : (물체가 투영될 좌표) = (물체가 실제 위치한 z값) : (물체의 좌표) 일겁니다.
이 비례식을 이용해서 변환을 하면 될것 같은데 마침 투영지점이 1이다 보니
X(변환된x값) = x / z
Y(변환된y값) = y / z

이게 투영변환의 끝이면 간단하겠지만 고려해야 할 점이 더 있습니다. 
변환행렬은 Projection 변환에서 끝이 아니라 결국은 Screen 변환을 거치게 됩니다. -1에서 1까지의 정사각형안에 비율로써 물체들을 투영한 것을 Screen 변환에서 
화면의 비율대로 다시 변환을 할건데 화면은 항상 정사각형 모양이 아닐겁니다. 오히려 직사각형일 가능성이 높습니다. 
그럴때 World의 정사각형 물체가 있다고 해보겠습니다. View변환과 Projection 변환을 거쳐서 정사각형 모양 그대로 투영이 됐습니다. 이 물체를 Screen 변환을 하면 직사각형의 화면비에 맞추어
직사각형 물체로 표현하는게 맞을까요? 

이 문제를 해결하기위해 Projection 변환때 화면의 비율을 미리 고려해서 x좌표에 조정을 해줍니다.
이 비율을 일반으로 r이라고 표현을합니다. (Ratio) r = width / height  ( 예시. 800x600 사이즈라면 800 / 600 = 1.3정도)이렇게 구한 r을 X값에 나눠줍니다.
X = x / z * r 
Y = y / z

이렇게만 끝내기는 좀 아쉬운게 사실 지금 지금 fov가 90도 이고 투영되는 상이 딱 z값이 1인 곳에 맺히는 상황이기 때문입니다. 
그러면 만약 fov가 90이상인 각도 D라고 해보겠습니다. 그러면 원래 각도 90도에서 찍히던 영역보다 더 넓은 영역을 커버하게 될것이고 Projection 변환 결과로는 원래 오브젝트들이 더욱 쪼그라 들어 보이는
결과가 나올것입니다. 어떻게 구현할지를 잘 생각해 보면 pov가 D였던거 90도로 찍고 있었던 것 처럼 보정을 해주면 됩니다.
우리가 화면비로 늘어날껄 생각해서 X를 미리 보정했던걸 생각하면 계산 편의상 항상 90도로 찍을것이라고 생각을 하고 보정을 해주면 될것 같습니다.
pov를 보정하는 방법은 일단 D/2가 z축에서 직각삼각형을 만들었을때 각도 일겁니다. 그러면 z값이 1인곳에 상이 맺힌다면 높이는 tan(D/2)입니다. 그러면 오브젝트들의 X Y값들에 
tan(D/2)씩을 나눠주면 pov가 90일때의 투영된 상이라고 볼 수 있을겁니다.
X = x / (z * r * tan(D/2)) 
Y = x / (z * tan(D/2))
이 위의 식이 Projection 변환 행렬의 주요 부품이라고 볼 수 있겠습니다.

이제 행렬을 만들어야 하는데 
지금까지는 벡터에 어떤 행렬 하나를 곱해서 원하는 변환을 해왔는데 행렬 하나로 원하는 결과를 얻기 위해서는 선형식이어야 합니다. 선형식이란 미지수가 1개인 식을 말하는데 
y = ax +b 와 같은 형태를 말합니다. 하지만 우리는 X  = x / (z * r * (tan(D/2)) 같은 결과를 원합니다. 여기서는 미지수 가 x, z 두개 입니다. 그래서 하나의 행렬로는 원하는 결과를 얻지 못합니다. 
생각해보면 당연한것이 카메라의 촬영범위의 물체들은 각각의 깊이(z값)을 가지고 있을것인데 하나의 행렬로 그 물체들 전부를 설명할 수 없을겁니다.

그래서 x,y 값을 변환하고 z값은 일단 그대로 두는 행렬을 먼저 만들겠습니다. x값에는 r과 tan(D/2)를 나눠줄 것이고 y값에는 tan(D/2)만 나눠주면 됩니다.
1 / (r * tan(D/2))         0          0   0
        0              1/(tan(D/2)    0   0
        0                    0          1    0
        0                    0           0   0
이 임시 행렬을 (x, y, z, 1) 벡터에 연산하면 ( x /(r*tan(D/2), y/tan(D/2), z, 1) 이 나올겁니다.
이제 여기에 z값을 나눠주는 행렬을 사용해 연산하면 ( x/(z*r*tan(D/2) , y/(z*tan(D/2)), 1, 1) 로 우리가 원하던 값이 나오게 될겁니다.

이 벡터가 끝은 아니고 또 할 일이 있습니다. 처음 설명했던 Projection 변환의 결과물은 (-1, -1)에서 (1, 1)사이에 표현되고 각 물체들은 0에서 1 사이의 깊이 값을 가지고 있어서 
DepthStencilView같은 걸로 표현이 됩니다. 
이 0 에서 1 사이의 깊이값을 3번째 속성으로 만들어주어야합니다. 그런데 3번째 자리 z값의 자리는 z값을 보존하고 있어야하는데 0~1의 깊이값을 또 들고 있을수가 없습니다.
그래서 z의 값을 놀고있는 w의 위치에 보존을 하도록하겠습니다.
1 / (r * tan(D/2))         0            0    0
        0              1/(tan(D/2)      0    0
        0                    0          1    1
        0                    0          0    0
이렇게 행렬을 조작하면 w자리에 z값을 저장해놓을 수 있습니다.

이제 깊이값을 구해야 합니다.
1 / (r * tan(D/2))         0            0    0
        0              1/(tan(D/2)      0    0
        0                    0          A    1
        0                    0          B    0
3열의 A와 B를 이용해서 구할겁니다. 왜 값이 두개나 필요하냐면 결국 우리가 구하고 싶은 깊이값은 0에서 1사이의 값입니다. 
카메라의 촬영범위중 가장 가까운 z값이 near라고 했었고, 가장 먼 Z값이 far라고 했었습니다. 물체의 위치가 near와 일치한다면 깊이는 0일것이고, far와 일치한다면 1일것입니다. 

(x, y, z, 1)벡터를 위 행렬에 곱해보면 (x/(r*tan(D/2)), y/tan(D/2), Az + B, z) 이렇게 될겁니다. 
이 값이 Projection Space의 결과물 이라고 할 수 있습니다. 이 벡터를 Rasterize에게 넘겨주면 4번째 원소 z로 나머지를 전부 나눠 줍니다. 
( x/(z*r*tan(D/2) , y/(z*tan(D/2)), A + B/z, 1) 이 상태가 물체를 투영했을때 비율의 상태가 될겁니다.

이 벡터에서 깊이 값을 역으로 유추할 수 있을것 같습니다. 그러니까 어떤 함수 G(z) = A + B/z 인데 이게 깊이 값이어야 한다는 겁니다. 
또 두가지 힌트가 있었습니다. near는0이고 far는 1이라는 값을 가진다고 했었습니다. 
즉, G(near) = A + B/near = 0 이어야 하고 G(far) = A + B/far = 1 이어야 합니다.
G(near) 식에서 B를 추출해보면 B = -A*near입니다. 이 B값을 G(far)에 대입해보겠습니다.
G(far) = A - A*near / far = 1 이라는걸 알 수 있습니다. 이걸 A로 묶어보겠습니다. 
G(far) = A((f - near)/far) = 1 그러면 이제 A를 추출해 낼 수 있습니다. A = far / (far - near) 라는걸 알 수 있었습니다. 다시 B도 제대로 구할 수 있습니다.

A = far / (far - near)
B = -(far * near) / (far - near)
이 값들을 위의 행렬에 넣어주면 Projection 변환 행렬이 완성이 되었다고 할 수 있습니다.

1 / (r * tan(D/2))         0                  0                   0
        0              1/(tan(D/2)            0                   0
        0                    0          far/(far-near)            1
        0                    0          -(far*near)/(far-near)    0

이 행렬을 다시 복기 해보면 x값에 r을 나눠주는이유는 나중에 화면을 출력할때 화면의 비율에 따라 x가 변하지 않도록 미리 나눠주는것이고, x, y에 공통적으로 나눠준 
tan(D/2)는 D가 pov인데 카메라의 촬영각도가 항상 90도는 아닐것이니깐 촬영각도에 따라 x와 y값이 늘거나 줄지 않도록 미리 나눠놓은겁니다. 
4열의 w값을 0 0 0 1이 아닌 0 0 1 0 으로 넣어준 이유는 물체의 z값을 저장 해놓기 위해서인데 이때 저장한 z값은 Rasterize에서 모든 요소들에 나눠질겁니다. 
이유는 물체가 카메라로 부터 z만큼 떨어져 있을 텐데 그만큼의 비율로 상에 맺히기 위해 z를 나눠줍니다.
3열의 의미는 투영한 물체들이 가지고 있어야할 3번째 요소인 깊이를 계산하기위한 값입니다.

이렇게 Projection변환 행렬을 알아봤습니다. 지금까지 배운 World, View, Projection 변환행렬들을 미리 곱해두고 (WVP) 우리가 변환할 물체의 로컬스페이스 좌표에 한번에 곱해주면 
원하는 결과가 나오게됩니다.



# Screen 변환 행렬 

마지막으로 출력할 창의 해상도에 따라 변환하는 Screen 변환 행렬을 배우면 변환행렬을 마칩니다. 

우선 이전 까지 했던 W V P 변환행렬로 연산을하게 되면 물체의 위치벡터 값들이 -1에서 1사이 깊이는 0 에서 1사이의 값으로 나오게 됩니다.

Screen 변환에대해 이전에 설명할때 예시로 800 x 600의 화면 전체에 뿌려서 화면을 채운다고 했지만 사실 항상 그렇지는 않습니다.
Viewport라는 곳의 화면을 출력한다고 하는데 Viewport는 이전 DirectX에서 WindowsInfo를 설정할때 잠깐 다룬적이 있습니다.
Viewport의 의미는 렌더링을 할 화면의 사각 영역이라고 할 수 있습니다. 전체화면에서 어느 사각 영역을 찝어서 VP(Viewport)라고 할 수 있습니다.
물론 게임은 화면의 일부영역만 사용하는 경우 보다 화면 전체를 사용하는 경우가 더 많겠지만.
일단 식을 세울때는 일부영역만 사용한다는 식을 세우고 나중에 이걸로 전체화면을 다 사용하던지 할것입니다. 

우선 VP의 좌상단 좌표를 알아야 합니다. (Left, Top) 이라고 표현해보겠습니다. 참고로 화면의 좌표는 800 x 600 해상도에서 화면 가장 Left Top이 (0, 0)이고 우측으로 갈 수 록 
x값이 커지고 아래로 갈 수 록 y값이 커져서 가장 오른쪽 아래의 좌표는 (800, 600) 입니다.

이제 변환을 하는 방법을 알아볼건데 우선 VP의 width와 height가 있을겁니다. 그리고 시작 좌표인(Left, Top)도 있다고 했습니다. 
이럴때 Projection변환을 거친 벡터의 x, y값은 -1에서 1사이의 값을 가지고 있다고 햇습니다. 이 값을 Screen Space로 표현하려면 결국 비율로 표현하면 됩니다. 
렌더링할 물체가 (x1, y1, z1)이라고 치면 x1은 -1에서 1사이의 값을 가지고 있을겁니다. 이걸 Screen으로 표현하려면 (x1 + 1)/2 를해주면 -1이엇던 부분을 절대값 같이 변환한것이 되고
이 값은 VP의 가로 비율에 물체가 있다는 뜻입니다. 그래서 width를 곱해주면 되겠습니다. 정리해보면 
X를 변환을 거친 값이라고 하겠습니다.

X = Left + ((x1+1)/2)w      // width를 w라고 하겠습니다.
Y = Top + ((1-y1)/2)h      // height를 h라고 하겠습니다.

X,Y에 각각 Left, Top을 더해주는건 시작좌표를 설정하는 부분이고 또 Y에서  (1-y1) 인 이유는 화면에서 y값은 아래로 내려갈수록 커지는 값이지만 좌표의 
y값은 커질수록 위로 올라갑니다. 그래서 역으로 1에서 y를 빼줍니다.

이제 x와 y값은 구했으니 z값도 구해볼것입니다.
VP를 설정할때 width와 height를 설정하듯이 깊이의 범위를 설정 할 수 있습니다. (Viewport의 MinDepth, MaxDepth)
Projection에서 깊이를 0에서 1사이의 값으로 설정했었는데 대부분 이 0에서1 범위를 그대로 사용하지만 간혹 Viewport의 범위를 조정할때가 있습니다. 
왜 따로 Min Max를 설정할까요? 대부분은 그냥 사용하지만 따로 설정하는경우는 Viewport가 한개가 아니라 두개 이상일때 먼저 그려진 VP가 0.5에서 1사이의 깊이를가진다고 하고 
두번째 그려질 VP는 0 부터 0.5까지의 깊이를 가진다고 하면 두 VP가 곂칠때 두번째 그려지는 VP가 항상 위쪽으로 표시가 될것입니다. 
그래서 변환될 Z값은 이렇게 수식으로 나타낼 수 있습니다 
Z = Min + z(Max-Min) 

이것을 행렬로 표현하자면 

   w/2          0         0     0
    0         -h/2        0     0
    0           0      Max-Min  0 
(w/2)+Left  (h/2)+Top    Min    1


이렇게 배웠던 World , View, Projection, Screen 변환을 통해 로컬스페이스에 있는 오브젝트를 윈도우 화면의 좌표까지 변환해서 해당 픽셀에 맞는 색들을 표현하면 되겠습니다.