

	7 . Depth Stencil View


 이제 우리가 슬슬 3D 물체를 띄울 준비를 해야 하기 때문에 거기에 거의 100% 등장할 필수 부품 하나를 준비하려고 합니다.

Depth Stencil View가 Renderring Pipeline에서 어느 위치에 있는지를 확인해 보겠습니다. 
파이프라인의 첫단계에서 Input Assembler를 하면서 Vertex Buffer와 Index Buffer를 건내주었고 다음 단계의 Vertex Shader등 쉐이더 작업을 하면서 필요한 인자들을 
Descriptor table 이나 Root Descriptor, Root Constant 방식으로 넘겨주었습니다. 이후 파이프라인 거의 마지막 단계의 Output merge 에서 Engine을 만들면서 맨 처음 배웠던
Renderring Target View 와 오늘의 주제인 Depth Stencil View를 가지고 무언가를 하고 있습니다. 

여기서 다시 우리의 목표를 세워보면 게임을 만들면서 가상3D공간에 배치했던 오브젝트나 캐릭터나 배경같은 걸 게임 화면 시점 (카메라라고 합니다)에서 그걸 봤을때의 
모습을 유저의 화면이라는 2D 그래픽으로 표현하고 싶은겁니다. 그런데 이 작업을 하는데에 CPU혼자 처리하기엔 비교적 간단한 계산의 양이 너무 많기에 GPU라는 그래픽 전문 부품에게 
도움을 요청하고 있습니다. 

3D 가상공간을 카메라로 보고있는 영역만큼을 어떻게든 2D그래픽으로 만들어서 화면에 출력한다고 했는데 
여기서 중요한 점은 카메라라는 한 점의 시점으로 가상공간을 보고 있기때문에 카메라를 기준으로 멀수록 넓어지는 좌표계 카메라 좌표계인 상태입니다. 
이 카메라 좌표계에서 투영 좌표계로 변환 해줍니다. 
( 투영 좌표계가 무엇인지, 왜 변환을 해야하는지 자세히 알아보는건 다음으로 미루고 일단 따라가 보겠습니다. )

자세히는 아니더라도 간단한 논리적으로 이해 해보려고 합니다. 
예시로 지금까지 만든 중간결과물 ( 사각형 메쉬에 베이가 텍스쳐를 매핑한것 ) 이 화면의 중앙에 위치하고 있는데 이 메쉬가 사실 큐브형태라고 했을때, 
이 큐브가 얼마나 떨어져 있는지 맞춰보라고 하면 맞출수가 없습니다. 2d 에서는 거리에 대한 정보가 없고 가로 세로 길이, 그리고 이미지의 대한 정보만 있을 뿐입니다.

카메라 좌표계 에서 우리 베이가가 코앞에 있어도, 아니면 저 멀리 있어도 보이는 비율만 같다면 우리는 알 수 없습니다. 
가상공간이나 실제세계는 3D라도 카메라 혹은 우리의 눈이나 받아들이는 정보는 2D라는 것입니다.
가까이 서있는 사람과 충분히 멀리있는 코끼리가 있다면 우리눈에는 둘의 크기가 똑같아 보인다는 이야기 입니다.

거리에 따라 사람과 코끼리가 비슷한 크기로 보이는 카메라 좌표계에서 거리는 상관하지 않고 눈에 보이는 비율로만 이야기 하겠다는 투영좌표계입니다.

즉, 투영이라는 말은 가상 3D공간의 물체들이 화면에 딱 밀착하면서 표현되는 그걸 투영이라고 합니다.

투영은 물체와의 거리 혹은 깊이에따른 물체 크기의 왜곡이 생기지 않는다는 특징도 있지만 만약 같은 크기의 물체가 여럿 곂쳐있는걸 투영한다면 맨앞의 물체이후로는 화면에 
표현할수 없다는 특징도 있습니다.
그래도 투영에 깊이 좌표가 있습니다. 투영좌표계에서는 표현은 안되지만 정보로는 가지고 있습니다.

지금 배운 이 투영좌표계를 우리 실습에서 이미 사용하고 있었습니다. 화면 중앙을 기준으로 좌, 위 쪽으로는 -1.f 까지 우, 밑으로는 +1.f 까지의 범위로 좌표를 지정하고 있었습니다. 
거기에 3번째 좌표로 0.5f값을 주지만 실습에는 아무런 티가 나지 않았던것이 세번째 좌표가 깊이값이고 투영 좌표계에서는 값으로만 있는 것이기 때문이었습니다.

우리 목표는 3D게임인 만큼 투영좌표계만으로는 안됩니다. 3D를 표현하기에 적절하지 않기 때문에 적절한 방법으로 변환해야하는데 그것이 Depth Stecil View입니다.

그래서 오늘 해볼것은 지난시간에 그린 그림을 두개 그릴건데 두 그림의 깊이를 다르게 했을때 그림을 그려줄 상황이 다르게 되겠습니다.

깊이좌표라는게 0부터 1까지 있다고 하는데 그러면 만약 0보다 작은 깊이값이나 1을 넘어가는 깊이값을 주면 어떻게 될지 궁금할 수 있습니다. 
그때는 사실 Pipeline에서 Depth Stencil View까지 안가고 Resterizer 단계에서 범위를 벗어나는 좌표는 아예 걸러서 표현을 하지 않습니다. 이 래스터화 단계의 기능이 사실 하나 더 있던것이죠


#
다시 Depth Stencil View, ( Depth Buffer )라는게 무엇이냐
3D 그래픽을 우리 화면 2D로 표현하려고 깊이를 추적하기 위해 화면과 정확히 일치하는 사이즈의 버퍼를 만들고 예시로는 간단히 3 by 3픽셀로 만들지만, 실제 화면은 800 X 600픽셀 같이 
훨씬많은 픽셀들로 이루어져 있을것입니다.

이 3X3의 크기를 가진 좌표들은 우리가 표현할 가상3D공간의 물체중 화면의 각 픽셀간에 가장 가까운 깊이를 나타냅니다. 만약 픽셀에 해당하는 위치에 오브젝트가 없다면 기본 최대값인 1.0f로 
나타냅니다.

만약 3 X 3 의 크기의 버퍼를 가진 화면과 그릴 3D 물체가 있을때 물체가 화면 정중앙 깊이는 0.7정도에 있다면 3 X 3버퍼는 각 픽셀마다 최대 깊이 까지 물체가 있는지 체크하다가 
정중앙에 물체가 있다는걸 감지하면 화면에 그려주고, 버퍼의 가운데 2, 2 위치에 0.7이라는 값을 넣게 됩니다. 
그 정중앙에 있는 물체 뒤에 다른 물체가 있다고 해도 이제 버퍼는 갱신되지도 않고 화면에 출력되지도 않을 것입니다. 앞의 물체에게 가려졌다는걸 표현하기 위해서입니다.
이게 기본적인 깊이 버퍼를 사용하는 로직이라고 볼 수 있는데

항상 0f부터 1.0f 까지의 깊이를 표현해야한다는것은 아닌데 설정을 통해 0 부터 0.5까지만 체크해서 그려준다던가 아니면 맨 뒤 1.0 에 해당하는 픽셀만 표현할 수도 있습니다.

이런 깊이 버퍼 (Depth Buffer)를 사용해 체크하면서 렌더링 파이프라인 마지막에 이 오브젝트를 화면에 출력할 건지 마지막으로 걸러주는 역할을 합니다.

이제 오늘의 주제인 Depth Stencil View에서 Depth라는 용어는 알았는데 Stencil이라는 용어가 하나더 등장했습니다.
이 스텐실은 좀 더 고급기법인데 그래픽스에서 말고 그냥 스텐실의 의미는
스텐실 : 판에 구멍을 뚫고 여기에 잉크를 통과시켜서 찍어내는 공판화의 기법중 하나. 
라고 합니다.
왜 갑자기 깊이 버퍼이야기를 하다가 미술 용어 이야기가 나오느냐? 지금 사용할 기법은 아니긴한데 
고급 기법에서는 깊이버퍼에서 각 픽셀마다 깊이 값만이 아니라 스텐실 값도 같이 들고 있을 수 있습니다. 이 버퍼를 깊이 용도로만 사용 할것이라고 하면 
각 픽셀이 4바이트 짜리 float하나의 크기를 넣어주는데 만약 옵션으로 스텐실 값 까지 들고 있게 하고 싶으면 float를 4바이트가 아닌 3바이트로 줄여서 사용을 하고 나머지 1바이트에 스텐실 값을 
가지게 합니다.(스텐실 값은 0 ~ 255 사이의 수를 가지게 되겠죠 1 바이트니까)

스텐실 값이란 강의에서는 설정한 스텐실값과 같은 값을 가진 픽셀에만 추가적인 작업(색칠같은)걸 하는 값이라고 하고 ,
구글링한 결과는 스텐실 버퍼란 판화가 위에서 아래로 찍어낸 그림인것처럼 가장 얕은 깊이 버퍼를 가진 픽셀만 출력하고 그 뒤로는 출력하지 않는 것 이라고도 합니다.

아직 확실히 감이 오진 않지만, 지금 단계에서는 스텐실 기법은 다루지 않을 것이고 이름이 Depth Stencil View이긴하지만 Depth View, Depth Buffer라고 불러도 될정도로 
깊이에 대해서만 다룰것입니다.
# 

	코드 

시작 하기 전에 간단한 테스트를 하나 해봣습니다. 위에서 깊이값이 0이하거나 1을 넘어가면 출력이 안된다고 한걸 확인하기 위해 우리가 그리던 메쉬의 깊이값을 1.5f로 전부 수정후 
실행해보면 실제로 출력이 안되었습니다.

이제 오늘 우리의 결과물은 삼각형 두개를 만들고 깊이의 차이를 주어서 앞에 있는 삼각형이 뒤의 삼각형을 가리는지 테스트 해보고 싶습니다.
이전 삼각형 두개로 사각형을 만들고 , 베이가 텍스쳐를 만드는 실습에서 SetTransform 값을 모두 0으로 해주었었는데 이걸 다시 사용할 겁니다. 
메쉬는 하나지만 각각 상수버퍼를 줘서 깊이 차이를 주고 싶습니다.

default.hlsli 파일에서 output.pos에 offset을 더해줘서 transform으로 들어오는 값을 pos에 더해주겠습니다. 
그러고 Game에서 Render를 하고 있었으니깐 메쉬를 하나 더 추가해서 transform 값의 x좌표, y좌표에 0.25씩 더해주었습니다. 이러면 한가운대의 베이가하나와약간 왼쪽 위의 베이가 하나가 더 생길것입니다.

실행해보면 왼쪽위의 베이가가 가운데의 베이가를 덮고 있는데 이건 렌더링 순서때문에 덮어 씌워진것이지 깊이에 따라 연산된 것은 아닙니다.

오늘 목적은 이 두 베이가에게 깊이값을 줘서 좀더 얕은 베이가가 위로 출력이 되게하는것이 목표입니다.

지금의 깊이 값은 쉐이더 파일에서는 정점 값을 준게 그대로 설정되고 이후 transform값을 더해준게 깊이 값입니다. 
나중에 게임수학을 배우록 복잡한 행렬 연산을 할때는 다르겠지만 지금은 그렇습니다.

# DepthStencilBuffer 클래스
코드로 들어가서 DepthStencilBuffer라는 클래스를 Engine필터 아래에 만들어 주겠습니다.
프라이빗 멤버 변수로 버퍼와 그 버퍼를 묘사하는 힙과 핸들, 그리고 포멧이란걸 가지고 있습니다.

(이전에 SwapChain에서는 RenderTargetBuffer를 두개를 만들어 줬었습니다. 그래야만 전면 후면 왔다 갔다 하면서 화면을 번갈아 출력해줄것입니다. 
반면 DepthStencilView는 DepthStencilViewBuffer를 하나만 만들어줍니다. 어짜피 이걸 가지고 화면을 출력하는게 아니고 이걸로 연산할때 활용하라고 사용하는 용도이기 때문입니다.)

퍼블릭 멤버 함수는 Init, GetDSVCpuHandle, GetDSVFormat이렇게 3개를 가지고 있습니다.

아까 부터 나오는 포멧은 무었이냐면 위에서 설명할때 Depth와 Stencil을 같이 사용하면 Depth 3바이트, Stencil 1바이트로 나눠서 사용할 수도 있고 Depth 용도로만 사용하면 4바이트로 사용할 수 있다고 
했었습니다. 그 용도를 정하는게 포멧 입니다.


Init 함수의 매개변수로 WindowInfo 와 format을 받아주는데 선언부에서 바로 기본값으로 DXGI_FORMAT_D32_FLOAT 이렇게 초기화 해주고 있는데 D(Depth)의 용도로 32비트를 사용하겠다는 의미입니다.
만약 스텐실 용도로도 사용하고 싶다면  DXGI_FORMAT_D24_UNORM_S8_UINT 라는 포멧도 있습니다.

지금은 Depth용도로만 사용할 것이니 따로 변수로 안가지고 있어도 되지만 나중에 언젠간 다른 용도로도 사용할 수도 있으니깐 변수로 들고 있습니다.
이제 첫번째 매개변수였던 Window 정보는 왜 받고 있냐면 위의 설명에서 깊이 값을 계산 해줄때 출력된 픽셀마다 계산을 한다고 했습니다. 그래서 프로그램의 창 크기를 알아야 하기 때문에 
Window정보를 받고 있습니다.

구현부 첫줄에서 인자로 받은 format을 그대로 _dsvFormat으로 초기화 해주고 그밑으로는 다른 클래스의 구현부에서 많이 본 형태로 
DEVICE->CreateCommittedResource의 옵션들을 채워줄 변수들을 설정하고 있습니다. 
heapProperty를 default로 설정하고, desc를 이전에는 Buffer로 설정했는데 여기서는 Tex2D로 설정해주었습니다.
( 대부분 기본값을 사용할건데 필수적으로 줘야할 인자들 _dsvFormat, window.width, window.height를 주고있습니다.)
desc의 Flag를 Depth_Stencil 용도로 사용할것이라고 설정 해주었습니다.

이때 처음보는 값인 optimizedClearValue라는게 있는데 이게 무었이냐면 매 프레임마다 Depth value를 1.0f로 밀어줘야하는데(아무것도 없는상태가 1.0f이기 때문)
그때 이 ClearValue를 주게 되면 이 작업이 더욱 빨라지는겁니다.
D3D12_CLEAR_VALUE optimizedClearValue = CD3DX12_CLEAR_VALUE(_dsvFormat, 1.0f, 0);
여기서 1.0f라는 값이 매 프레임마다 초기화할 깊이 값입니다.

이런 값들을 CreateCommittedResource로 _dsvBuffer에 초기화 해주고 있습니다.

버퍼를 만들었으니 그 버퍼를 묘사하는 view를 만들어 줘야합니다. DirectX12에서는 view가 하나만 있더라도 Heap을 만들어 담아야합니다.
하던대로 빈 heap을 만들고 담을 Descriptor의 갯수와, Flag와 Type( 여기서는 DSV) 을 설정해줍니다.

이 Desc를 _dsvHeap에다가
DEVICE->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&_dsvHeap));
을 해주어서 Heap을 만들고 
_dsvHandle = _dsvHeap->GetCPUDescriptorHandleForHeapStart();
로heap의 주소를 handle로 받아주고 
DEVICE->CreateDepthStencilView(_dsvBuffer.Get(), nullptr, _dsvHandle);
으로 버퍼를 묘사한 view를 handle의 주소에 넣어줍니다.

이렇게 만든 DepthStencilBuffer 클래스를 잊지말고 Engine클래스에 include와 초기화를 해주겠습니다.

그리고 DepthStencilBuffer가 window 정보를 받고있는데 우리 코드에 ResizeWindow 라고 윈도우 사이즈를 바꾸는 함수가 있습니다. 이때 윈도우 정보가 변경되기 때문에 
DepthStencilBuffer도 다시 초기화 해줘야합니다. 그래서 ResizeWindow함수에 마지막에 다시 DepthStencilBuffer를 초기화 해주었습니다.
이떄 또 한가지 유의점이 있는데요 이 프로그램이 신나게 전역으로 가져다 쓰는 통에 ResizeWindow가 될 당시 DepthStencilBuffer를 초기화때 DEVICE도 사용하는데 
DEVICE가 생성되기도 전에 사용하려면 당연히 에러가 날것입니다. 그래서 ResizeWindow를 Game::Init의 맨 아래 쪽으로 이동 시켜주었습니다.

이렇게 클래스를 생성하기만 하면 끝이 아니라 프로그램의 실행부에 묶어주어야하는데요
그 부분은 CommandQueue::RenderBegin에서 할수 있습니다. 
RenderBegin의 가장 아래코드에는 OMSetRenderTargets 라는 함수가 실행되고 있는데요 커서를 가져다 대서 함수의 마지막 인자를 보면 받는 인자 자체가 
DepthStencilDescriptor를 받고 있습니다. 
DepthStencilDescriptor를 가리키는 핸들을 가져오기위해 
D3D12_CPU_DESCRIPTOR_HANDLE depthStencilView = GEngine->GetDepthStencilBuffer()->GetDSVCpuHandle();
로 받아주고 
_cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, &depthStencilView);
이렇게 마지막 함수인자로 건내주겠습니다. 
그리고 매 프래임이 끝날때마다 Depth를 초기화해준다고 해준다고 했었는데 그 함수도 추가해주겠습니다.
_cmdList->ClearDepthStencilView(depthStencilView, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);

여기서도 끝이 아니고 Shader클래스로 가야합니다. 지금까지 객체를 생성하고 코드에 묶어주기 까지는 했지만 받은 DepthBuffer를 어떻게 사용해야 하는지 묘사를 하지 않았습니다.
Shader클래스의 구현부로 가보면 지금까지는 모르기 때문에 그냥 넘어간 옵션인데 _pipllineDesc의 요소중 DepthStencilState라는 항목이 있습니다.
이부분을 default값으로 설정해주겠습니다. (DepthStencilState의 디폴트는 깊이는 사용하고 스텐실을 사용하지 않는 상태 입니다.)
DepthStencilState를 활성화 했으니깐 DSVFormat도 _pipelineDesc에 알려줘야합니다.
기억하는대로 
_pipelineDesc.DSVFormat = DXGI_FORMAT_D32_FLOAT; 로 설정해줘도 되지만
GEngine->GetDepthStencilBuffer()->GetDSVFormat()으로 꺼내 와도 되겠습니다.

이렇게 모든 준비가 끝났습니다. 혹시 잊은게 없나 빌드를 해보니 통과가 됩니다.

이제 Game::Update로 돌아가서 
각 베이가에게 줄 인자들을 보면 깊이 값을 추가하지 않았기 때문에 두 베이가의 깊이는 둘다 0.5f값입니다. 여기서 Transform의 세번째 인자값이 깊이 값이니 
두 깊이를 바꿔가면서 실행해보면 더 깊이가 얕은 베이가가 앞으로 나오는걸 확인할 수 있습니다.


