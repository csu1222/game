	
	Constant Buffer


이전시간에 우여곡절 끝에 알록달록한 게이밍 삼각형 하나를 띄울 수 있었습니다. 

이번 시간에 하고 싶은건 이 삼각형이 약간 위쪽에 위치한다거나, 색상을 변경하고 싶습니다. 

우리가 넘겨준 정점들을 이전에 만든 default.hlsli라는 쉐이더 파일이 거의 아무것도 안하고 그냥 출력해준것이라면 이런 쉐이더 파일로 어떤 명령을 추가해 

삼각형을 움직이기도 하고 색을 바꾸기도 할수 있을것입니다.

쉐이더 문법이 사용하던 C계열 언어의 문법과 비슷하게 생겨서 함수처럼 인자를 offset으로 하나를 더 받아서 이 offset을 output에 더해줘서 어떻게 할 수 있지 않을까?
라는 생각이 들 수 있지만, 그렇게 되지는 않습니다.

DirectX12 Randerring Pipeline이라는 검색으로 구글의 이미지를 찾아보면 마이크로 소프트의 자료가 있는데, 렌더링 파이프라인에서 input assembler부터 시작해 
쭈욱 렌더링 과정들이 있고, 이 중에 input assembler에서 넘겨줄 수 있는 데이터 들이 아무거나 되는건 아니고 정해져 있습니다. 특정 vertex나 index의 buffer view를 넘겨주는 것이고

다른 정보들은 이런저런 수단으로 다른 단계에서 넘겨줘야합니다. 이 정보들도 그냥 넘겨 줄 수는 없고 이전 시간에 배운 root signature 일종의 계약서라고 했는데 이 개념과 연관이 있습니다.

그럼 다시 RootSignature가 어떻게 서명이 되는지를 이해 하려면 결국 GPU의 구조에 대해서 알아야합니다. 


그래서 이전에 잠깐 알아 봤던 CPU와 GPU의 메모리 차이에 대해 다시 알아보겠습니다.

CPU는 컴퓨터의 연산을 담당하고 있는 부품입니다. 그렇게 매우 성능이 좋은 CPU라도 연산할때 기억해야 할 정보들을 전부 자신이 기억하면서 연산을 하지는 않습니다. 
옆에 기억을 도와줄 메모리들이 있어야 합니다. 

하지만 그 역할을 할 RAM이 CPU와 거리가 물리적으로도 과정상으로도 생각보다 멉니다. CPU와 RAM의 이 거리를 매번 왔다 갔다 하면서 작업을 한다면 속도가 매우 느려질것입니다.

그래서 중간 중간에 조금씩 데이터를 저장해둘 보조 메모리들(cache, register등)을 사용해서 필요한 데이터를 가까이 두고 사용합니다.	

그러면 RAM을 그냥 CPU 바로 옆에 가져다가 쓰면 되지 않을까 하지만, 각각 장단점이 있습니다. 

CPU와의 거리가 멀수록 가격이 싸지고, 저장용량이 커집니다. 반대로 CPU에 가까이 갈 수록 비싸지고, 저장용량이 작아집니다.

GPU도 비슷한 상황입니다. 물론 각 부품들의 내부적으로 구조가 많이 다르겠지만 연산을 담당하는 부품들이 있고 이 부품들도 어딘가에서 리소스를 가져와서 연산을 할것입니다. 

크게 보면 CPU와 CPU저장소의 관계와 GPU와 GPU저장소의 관계는 닮아 있습니다. 

GPU에게 일을 시킬때 그저 몇바이트의 리소스를 주는게 아니라 아예 사진하나를 통째로 건내주면서 렌더링을 하고 픽셀로 변환 하라고 시킬 수도 있습니다. 

GPU -> register -> chche - > GPURAM 순서인 메모리 구조 에서 곧바로 register에 떡하니 사진을 올릴 수는 당연히 없습니다. 

그래픽 RAM에서 사진 리소스를 가지고 있다가 위쪽 으로 조금씩 넘기는 방식일겁니다. 

이런 구조에서 RootSignature는 GPU저장공간중 최상위 register같은 애들을 어떻게 활용할지를 서명하는 것입니다. 
그 GRAM같은 커다란 공간은 어떻게 활용할지 따로 계획을 안해도 공간이 널널하지만, register는 공간도 좁거니와 GPU의 연산과 밀접한 상관 관계가 있기 때문에  정책에 서명을 해줘야 합니다.

우리가 이전시간에 만든 RootSignature는 내용이 거의 없이 디폴트 값으로 만들고 Flags만 입력 조립기를 열어놨습니다. 

마이크로 소프트 공식 문서 RootSignature 란을 보면 지금 제가 만든 아무것도 없는 RootSignature를 empty root signature라고 합니다.
이렇게 비워 놓는게 당연히 유용하진 않겠지만 정말로 간단한 테스트나 아니면 최소의 정점들만 넘기고 싶고 아무 작업도 시키고 싶지 않을때는 이렇게 사용할수 있다고 합니다.

당연하지만 추가로 다른 인자를 줘서 좀더 복잡한 일을 하고자 하면 empty root signature로는 부족합니다.


그럼 이제 좀 다른식으로 서명하는것을 알아봐야 되는데 우선 명령어를 추가 하겠습니다. Resource\\Shader\\default.hlsli 에서 

cbuffer TEST_B0 : register(b0)
{
    float4 offset0;
};

cbuffer TEST_B1 : register(b1)
{
    float4 offset1;
};
를 추가 했습니다. 의미는 콘스턴트 버퍼를 사용할것인데, 레지스터 b0와 b1에 있는걸 사용할것입니다. 근데 밑의 코드에서는 얘를 offset0, offset1로 부르겠다는 의미입니다.
이제 이 offset들을 외부에서 원하는 내용을 넣어준 다음 hlsli파일 내에서 인자로 넣어주는 것 처럼 사용하도록 하면 되겠습니다.

물론 아직 쉐이더 언어 자체에 대해서는 공부 하지 않았기 때문에 그냥 설명하는대로 그렇구나 하고 넘어갈 수 밖에 없습니다.
일단 지금 단계에서는 이렇게 해서 정말 무언가 바뀌는지 연습부터 하겠습니다.

하여튼 다시 root signature를 어떻게 서명해야 하는지 알아보면, API bind slot, root constant, HLSL bind slot 등으로 구성된 'root table'을 만들어 줘야 합니다.

API bind slot 은 외부에서 이 걸 요청할때 몇번 슬롯이 있는지를 가리키는 것 외부에서 보기에 어떤 칸에 이 데이터를 넣어둘지를 합의하는 정보라고 할 수 있습니다.

HLSL bind slot은 레지스터의 이름이라고 보면 되겠습니다. 레지스터에 여러 종류가 있는데 이번시간의 constant (상수)에 관련된 레지스터는 b로 시작하는 이름을 쓰고 
다른 종류의 버퍼에서는 다른 이름의 레지스터를 사용합니다.

root constant 자리에는 이 root table의 내용물이 들어갑니다. root constant는 그 중 상수 타입입니다.
상수 타입 외에, root descriptor, descriptor table이 들어 갈 수 있습니다.

이 root signature라는 것 자체가 계약서같은거라고 몇번을 말했지만 잘 이해를 못하고 있었습니다. 그런데 이런 세부 내용을 배우고 난뒤 다시 설명을 하자면,
HLSL bind slot에 root constant(다른 타입이 올 수 도 있습니다.)라는 타입을 사용하겠다 라고 계약을 하는것입니다.

어느 레지스터를 어느 타입으로 사용하겠다 이지 실제 데이터를 넣는게 아닙니다. 만약 실제로 데이터를 넣겠다면 다른 함수를 이용해서 넣어야 합니다.

API bind slot, root constant, HLSL bind slot 으로 이루어진 root table은 가장 간단한 종류이고 

root descriptor를 사용하는 종류, descriptor table이 들어가는 종류가 있습니다.

root descriptor를 사용하는 root table은 나중에 들어올 데이터가 descriptor(view)라는 것 입니다. 이 레지스터에 어떤 내용물(내용물은 다른 저장소에 있을겁니다.)
이 어디 있는지를 알려주고 있다고 생각할 수 있습니다.

마지막으로 root table을 사용하는 종류는 constant나 descriptor말고 table을 가지고 있는 종류인데 table이 무엇이냐, 정책 이라고 할 수 있는데요
각각 다른 뭉치의 명령? 데이터 들을 감싸고 있는 테이블 두개가 이 시그니쳐에 있다고 했을 때 어떤 테이블을 고르느냐에 따라 어떤 데이터가 활성화되는지를 고르는 것입니다.
root table로 나뉘어진 정책들은 root signature에 전부다 쭉 담겨져 있는건 아니고 각 root table의 포인터 같이 이름으로 signature에 포함되어있고 이게 활성화가 되면 이름이 
가리키는 곳에 자세한 정책들이 있습니다. 
왜 이렇게 해놓았을까 생각해보면 그냥 내용들 전부 한번에 root signature에 적어 놓고 필요에 따라 쓰면 되는게 아닌가 할수 있지만 성능상 그리고 공식 문서에서도 
signature를 무한정 길게 가져갈수 없다고 합니다 64 DWORD 이내로만 사용할 수 있어서 table로 따로 빼서 사용해야합니다.


아직 제대로 감이 오지않는데 지금 말한 내용중 일단 constant buffer에 대해서 알아보도록 하겠습니다.

이제 RootSignature 클래스의 코드로 돌아가서 예전에는 시그니쳐를 그냥 디폴트로 만들기만 했지만 이걸 좀 건드려 볼겁니다.	

RootSignature::Init에 맨위 줄에 

	CD3DX12_ROOT_PARAMETER param[2];
	param[0].InitAsConstantBufferView(0); // 0번 -> b0 -> CBV 
	param[1].InitAsConstantBufferView(1); // 1번 -> b1 -> CBV

이런 코드를 적었는데 이 코드는 param[] 이라는 배열에 아까 알아본 API bind slot 0번과 1번을 GPU 레지스터 b0 과 b1으로 지정해 가지고 있겠다는 의미입니다.
다시 풀어서 얘기하면 
param의 0번슬롯을 b0로 가지고 있겠다 그 용도는 CBV이다. 라는 의미입니다 .

번외로 InitAsConstantBufferView의 인자로 3가지가 올수 있는데 첫번째는 지금 설정한 것처럼 레지스터의 슬롯을 정할수 있고, 
두번째로 오는 인자는 register space로 이건 왠만하면 그럴일이 없지만 만약 HLSL bind slot이 겹쳤을때 또 다른 구별자로 구별할수 있게끔 설정하는겁니다. 
(예시 b0-1, b0-2 처럼 b0에 어쩌다 곂치게 됐을때 사용)
세번째 인자는 중요한데 Shader visibility 입니다. 기본으로 오는 값은 visibility all인데 이게 무슨 말이냐면 
> 렌더링 파이프라인중 인자를 넘겨줄때 각 단계에 들어오는 인자들이 따로 있습니다. 예를 들어 Vertex Shader 단계에 들어오는 인자가 있는데 visibility all이면 이때 들어온 인자가 
이후 단계에서도 가져다 쓸수 있는것이고 아니면 딱 Vertex Shader 단계에서만 사용하고 이후 단계들에서는 소실됩니다. 그래서 이 마지막 인자는 종종 조작할 일이 생길수 있습니다. 

이렇게 파라미터를 만들어 주었으면 signature를 만들때 건내 줘야 겠습니다. 

D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(2, param);

인자 부분에 파라미터의 갯수, 파라미터를 넘겨주었습니다.  (이전에는 이 부분이 그냥 default값으로 아무것도 주지 았았어요)

이제 Root Signature에 Constant Buffer View를 두 슬롯 사용 할것이라고 계약을 했습니다. 

계약은 했지만 어디에서도 사용하고 있진 않습니다. 잊기전에 사용하도록 하겠습니다. 
CommandQueue코드로 가서 RenderBegin 코드 안의 리소스 배리어 위쪽에 넣도록 하겟습니다.

_cmdList->SetGraphicsRootSignature(ROOT_SIGNATURE.Get());

이 코드로 이 서명을 사용하겠다! 라고 선포를 한것입니다.
이것저것 했지만 실질적으로 레지스터에 어떤 데이터를 전달해준것은 아니고 어떻게 하겠다는 계획만 세웠습니다. 	
RootSignature로 계약한 레지스터에 값을 줄때는 실제 렌더링을 할때 인데 지금 저희가 작성한 코드는 Mesh클래스에서 작성한 알록 달록한 삼각형 뿐입니다. 

Mesh::Render로 가서 DrawInstanced를 하기전에 
E
CMD_LIST->SetGraphicsRootConstantBufferView(0, ? ? );

라는 코드를 작성하는데 인자로는 RootParameterIndex, BufferLocation이 옵니다. 이중 첫번째 인자인 RootParameterIndex는 아까 우리가 설정했던 b0, b1 같은 HLSL bind slot을 말하는 겁니다.
두번째 인자는 Constant Buffer의 위치를 넣으면 되겠습니다. 
( 첫번째 인자인 레지스터 슬롯으로 두번째 인자의 위치에 있는 버퍼를 올린다 )

그런데 이전에 할일이 있습니다. SetGraphicsRootConstantBufferView GPU의 그래픽 RAM에 있을 ConstantBuffer를 레지스터의 ConstantBufferView를 이용해 올리는 작업을 하는데 
이 Constant Buffer는 CPU영역의 RAM에 위치해있습니다. 우선 CPU RAM에서 그래픽 RAM으로 Constant Buffer를 옮겨야 하겠습니다.


이런 작업과 비슷한 것을 이미 해본적이 있습니다. 이전 강의에서 Mesh에 삼각형의 버퍼를 그래픽 RAM에 할당하고 리소스를 전송한다음 Render를 할때 커맨트 리스트 안에 넣어서 
삼각형을 만들었었습니다. 

버퍼를 할당하고, 전송하기는 Device에서 동작하였습니다. Device는 CMD_LIST에 들어가지 않고 코드가 즉시 실행되었습니다. (즉시)

버퍼의 리소스를 GPU로 가져가서 작업을 하는 기능은 CMD_LIST에 담아서 RenderEnd때 한번에 실행었습니다. (나중에)

실행시점이 즉시, 나중에 처럼 다른것이 CommandQueue의 특징입니다. 명령들을 매번 즉시 실행하는게 아니라 한번에 모아서 실행하려다 보니 그렇습니다. 
그러면 이런 실행시점이 다른 것이 문제가 되는 경우가 있는데, 
예를들어, 삼각형 두개를 만들었고 1번 삼각형에게는 1만큼 움직이라고 Constant Buffer에 명령을 했다가 다음에 삼각형2가 2만큼 움직이라고 Constant Buffer에 명령을 한다면
즉시 실행할 경우 순서대로 1삼각형이 1만큼, 2삼각형이 2만큼 움직였을 것입니다. 하지만 나중에 실행하려고 명령을 담아두면 1만큼 움직여라가 다음 명령인 2만큼 움직여라로 
덮어씌워지는 경우가 생깁니다.

이런 문제가 꼭 Constant Buffer뿐만이 아니라 CMD_QUEUE를 사용할때 항상 조심해야 하는 것입니다.

데이터가 덮어 씌워지는 문제를 해결하는 방법은 생각하기에 한가지 밖에 안떠오릅니다. 바로 버퍼를 여러개를 만드는 겁니다. 
버퍼 하나로 해결하려고 하지 않고 데이터마다 각각 버퍼를 두어서 덮어씌워지지 않게 하는겁니다.


버퍼를 필요에따라 생성해줄 ConstantBuffer 클래스를 만들었습니다. 이 클래스의 기능은 현재 버퍼를 추적하면서, 다음 데이터를 밀어 넣으면 현재 버퍼는 건드리지 않으면서 
다음 버퍼를 생성해주는 기능을 할것입니다. 가지고 있는 요소는 
private:
	ComPtr<ID3D12Resource>			_cbvBuffer;   		// 그래픽 RAM영역에 만들어질 버퍼들 
	BYTE* 					_mappedBuffer = nullptr;	// Map()으로 CPU영역에서 리소스를 GPU영역으로 넘길 버퍼
	uint32					_elementSize = 0;		//만들어질 버퍼의 크기 
	uint32					_elementCount = 0;	//버퍼들의 갯수

	uint32					_currentIndex = 0;		// 내가 어디까지 사용했는지를 추적하고 있습니다.
이렇게 됩니다. 

함수로는 
public:
	ConstantBuffer()
	~ConstantBuffer()
	Init()
	Clear()
	PushData(int32 rootParamIndex, void* buffer, uint32 size)
	GetGpuVirtualAddress(uint32 index)
private:
	void CreateBuffer();

이렇게 옵니다. 생성자와 소멸자같은경우는 별것은 없고 소멸자에서 이 ConstantBuffer가 소멸될때 그때서야 UnMap을 해줍니다. Mesh때와 다르게 지금은 Map을 계속 열어두고 
리소스를 항상 받아올준비를 하고 있습니다.

다음으로 Init과 CreateBuffer를 같이 만들겠습니다. Init 함수는 내부에서 프라이빗 함수인 CreateBuffer를 호출하는데요 그냥 호출이 아니라 구현부에서 Buffer를 만들어도 되지만 나중에 어떤 변경사항이 생길지 모르니
기능 단위로 분리 해놓았습니다.

Init함수의 내용에서 특이한게 있는데요 상수 버퍼는 256바이트 배수의 크기로 만들어야 한다는겁니다. 이건 개인적으로 정한게 아니라 표준으로 정해진것입니다.
이 규칙을 매번 지켜서 만들기는 힘들수 있습니다. 그래서 보정해주는 코드로 사용합니다. 
	_elementSize = (size + 255) & ~255;
	_elementCount = count;
_elementSize 부분이 보정이 들어가는데 & ~ 255 부분이 생소합니다. 이 기호들은 예전 비트플래그 시간에 배웠었는데 비트상에서 &는 두 비트가 일치하게 1이면 켜 놓는다 이고 ~는 비트를 전부 반전하는것입니다. 즉 
255 는 비트상 0000 1111 인데 ~255를 했으니 1111 0000 이 되고 앞의 size + 255와 &를 하면 뒤의 4비트를 무조건 꺼버리는 효과가 됩니다. 그러면 상위 4비트 부터 켜지고 
0001 0000 부터는 256이 되고 size + 255를 하는이유는 size가 1~ 256까지의 값일때 256바이트의 공간을 할당할수 있게됩니다.

_elementCount는 그냥 인자로 받은 만큼으로 초기화 해주었습니다.

다음으로 CreateBuffer함수 차례인데요 
먼저 BufferSize를 _elementSize * _elementCount로 구해줍니다. 이후 heapProperty(힙의 성질)을 Upload용으로 만들고 Resource Desc를 앞에 구한 BufferSize크기로 만듭니다.
이렇게 만든 이 값들을 가지고 DEVICE->CreateCommittedResource로 GPU의 RAM공간에 메모리를 확보합니다. 여길 가리키는 View를 _cbvBuffer이고 

_cbvBuffer->Map으로 연결을해서 _mappedBuffer를 통해 데이터를 밀어 넣게 됩니다.

다음으로 구현할 함수는 Clear인데요 아주 단순합니다. _currentIndex를 0으로 밀어줍니다.


