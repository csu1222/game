

        32. Compute Shader


- 개론 

컴퓨트 셰이더에 대한 내용을 이야기 하면서 GPGPU(General-Purpose computing on Graphics Processing Units, GPU 상의 범용 계산) 에 대한 이야기도 
같이 할것입니다. 

지금까지 CPU 와 GPU 에 대한 이야기를 하고 있었습니다. DirectX 자체가 CPU에서 GPU에게 일을 시키기 위한 것이었습니다. 

CPU 와 GPU의 차이점은 ALU 라고 하는 산술 논리 장치의 차이가 있습니다 CPU는 ALU 하나하나가 고성능이고 갯수가 몇개 없다면 
GPU는 성능은 떨어지지만 엄청 많은 수의 ALU 를 가지고 있습니다.

왜 이런 이야기부터 시작하느냐 하면 컴퓨트 셰이더라는것이 GPU 에게 범용적인 일을 떠맞기는 기술 이기 때문입니다. 

GPU는 초반부터 게임쪽을 기반으로 성장을 해 나갔었습니다. 그런데 기술이 발전해나가면서 GPU를 그냥 놀리기 아까워진것입니다. 
CPU는 운영체제나 할일이 많은데 GPU는 게임을 하지 않고 있을때 그냥 놀리고 있는것은 낭비인것 같습니다. 
렌더링과 관련되지 않은 일반적인 작업을 떠넘기는 것을 GPGPU 라고 합니다. 

GPGPU 가 더욱 효율적인 상황은 일감이 많고 병렬처리가 될 수 있는 일감일때 GPU 에게 넘겨주는것이 더 나을 수 있습니다. 
병렬처리가 가능하다는 말이 무엇이냐면 어떤 일감이 있는데 이 일감은 한번 작업을 결과물에 다시 작업을 시작하고 그 다음 결과물에 다시 작업을 해야하는 상황일때 
이런 일감은 모든 연산들이 서로 연관을 가지게 되니까 이 일감은 병렬로 처리가 힘들게 됩니다. 

이런 경우가 아니라 일감들이 서로 독립적으로 실행되는 경우가 있을겁니다. 
예를 들면 소수를 찾는 일감이 있다고 해보겠습니다. 여기서 소수란 1 이외의 1과 자신으로 밖에 나눠지지 않는 수를 말합니다. (ex. 2, 3, 5, 7, 11 등등)
아직까지 이 소수를 찾는 공식은 발견되지 않았습니다. 그저 직접 나눠보는 수밖에 없는데 여기서 
만약 1 부터 1000 까지의 숫자중에 소수인 숫자를 찾아야 한다고 해보면 1,2,3,4,5... 의 각각의 숫자가 다른 수와 상관이 없고 그저 자신이 1과 자신으로 나뉘는지 가 소수의 조건이기
때문입니다. 그러면 지금 1부터 1000까지 소수를 찾는 작업은 그냥 각 숫자 1000개를 연산해야하는 작업인겁니다. 
이럴때가 병렬처리가 가능한 작업이라고 할 수 있습니다. 

GPGPU 는 병렬적인 처리에 효율적이라는것을 알았습니다. 그러면 실제 어떤 분야에서 많이 활용되냐면 바로 암호학 쪽 입니다. 
현재 암호학은 방금말한 소수의 경우 처럼 수학적 난제에 기반한 암호가 많기 때문에 암호를 뚫는데도 GPU가 많이 사용합니다. 
비트코인도 마찬가지로 GPU를 활용해서 채굴을 한다고 합니다. 

이제 오늘의 주제인 Compute Shader, GPGPU 가 무엇인지, 어디에 필요한지를 알아 봤으니까 실제 내용을 보겠습니다.

- 이론
지금까지도 DirectX 로 GPU에게 일감을 주고있기는 했습니다. 렌더링 파이프라인이라는 정형화된 과정을 쭉 따라가면서 GPU에 담아뒀던 데이터를 필요할때 가져다 연산도 하고 
렌더링도 하고 했습니다.

렌더링 파이프라인과 같이 IA>VS>(생략)>PS>OM 서로 과정을 따라가는 것과 달리 컴퓨트 셰이더는 그냥 셰이더 하나만 독립적으로 GPU에 일을 시킵니다.
어떻게 보면 지금까지 사용하던 렌더링 파이프라인 보다 간단하다는 의미일 수도 있습니다. 
다만 이걸 코드에서 컴퓨트 셰이더만 호출하게끔 교체해준다고 잘 실행되는것은 아니고 이거에 맞게끔 모든 환경을 맞춰줘야합니다.
그러니까 지금까지 RootDescriptor니 Shader 니 여러 세팅을 다 해줬던걸 다시 컴퓨트 셰이더 버전으로 다시 해줘야힙니다.
귀찮기는 하지만 컴퓨트 셰이더는 유용하게 활용이 될것입니다. 게임에서 이펙트나 애니메이션같은걸 계산할때 CPU 에 많은 부담이 가는데 이럴 경우에 GPU에게도 일감을 나눠 
시키면 부담이 내려갈겁니다. 

그리고 또 한가지 GPGPU를 사용하는 이유가 더 있는데 CPU는 CPU 가까이에서 데이터를 저장해둘 RAM이 있고 GPU에게는 VRAM 이라는 저장공간이 있습니다. 
CPU에서 RAM 사이의 데이터 전송속도가 10GB/s 라고 해보고 GPU에서 VRAM 사이의 데이터 전송속도가 100GB/s 라고 했을때 CPU에서 GPU로의 데이터 전송속도는 1GB/s 정도
라고 할 수 있습니다. 
지금까지는 CPU에서 GPU에 시킬일을 연산을 한다음 그 내용을 GPU에 건내주고 GPU 에서 받은 일감의 도안을 보고 일을 해주고 있었는데 
이 중간에 CPU 에서 GPU 로 데이터를 넘기는 과정이 비교적 많이 느리기 때문에 부담이 많이갑니다. 
그래서 아예 GPU에게 어떤 그림을 그릴지 연산자체도 알아서 하라고 하는것은 보다 빠른 성능을 가져올것입니다.

오늘 할일은 지금 설명한 모든 내용을 고치는것은 아니고 지금까지 만들어온 셰이더의 기능들을 컴퓨트 셰이더 용으로 추가하는 일입니다. 



- 코드 

고칠 코드가 많습니다. 그것도 새로운 코드가 아닌 기존의 코드를 컴퓨트 셰이더 용으로 추가하는 내용입니다. 
작업순서는 실행순서상 마지막인 셰이더 파일부터 만들고 거꾸로 거슬러 올라가면서 작업을 하는 방향으로 가겠습니다. 

1) compute.fx
새로 셰이더 파일을 만들어서 프로젝트에 추가 시켜주었습니다. 내용은 먼저 ifndef 과 params.fx를 include 해주고 시작하겠습니다. 
#ifndef _COMPUTE_FX_
#define _COMPUTE_FX_

#include "params.fx"

#endif
그 다음 코드는 처음보는 타입을 가지고 있는 슬롯입니다. 
RWTexture2D<float4> g_rwtex_0 : register(u0);
레지스터 슬롯을 처음보는 u0 슬롯을 사용하고 있습니다. 
지금까지는 일반적인 버퍼를 사용하던 b0,b1 이나 텍스쳐 버퍼를 사용하던 t0,t1 같은 슬롯을 사용하고 있었는데
새로운 슬롯이 추가 되었습니다. 
u0 는 uav(unordered access view:순서가 지정되지 않은 액세스 뷰)라고 하는데 컴퓨트 셰이더 전용으로 활용하는 전용 레지스터라고 합니다. 일반적인 그래픽 연산에서 사용되지는 않습니다.
 그리고 RWTexture2D(Read Write Texture 2D) 라고 되어있는데 이 스토리지 클래스는 읽기와 쓰기가 가능한데 
그 말은 u0 레지스터에 담은 이 데이터를 셰이더 코드에서 읽을 뿐만아니라 수정도 할 수 있습니다. 지금까지는 레지스터에 받은 텍스쳐들은 읽기 전용으로 사용했지 수정할 수가 없었는데 
이게 된다는 말입니다.
셰이더 코드 자체는 단순합니다. 

// 쓰레드 그룹당 쓰레드 개
// max : 1024 (CS_5.0)
// - 하나의 쓰레드 그룹은 하나의 다중처리기에서 실행
[numthreads(1024, 1, 1)]
void CS_Main(int3 threadIndex : SV_DispatchThreadID)
{
    if (threadIndex.y % 2 == 0)
        g_rwtex_0[threadIndex.xy] = float4(1.f, 0.f, 0.f, 1.f);
    else
        g_rwtex_0[threadIndex.xy] = float4(0.f, 1.f, 0.f, 1.f);
}

#endif

무엇인지 모르겠는 threadIndex 라는 것의 y 값이 2로 나뉘는지 아닌지를 판별해서 하나는 빨간색, 나머지는 초록색으로 설정해주고 있다는걸 알수 있습니다.
그러면 아직 정확히 무엇인지 모르겠는 용어들 numthreads 나 threadIndex , SV_DispatchThreadID 같은 용어가 무슨 뜻인지를 알아보겠습니다. 

그러기 전에 먼저 나중에 컴퓨트 셰이더에서 많이 쓰일 셰이더 메소드인 ID3D12GraphicsCommandList::Dispatch 에 대해 알아보겠습니다. 공식문서를 찾아보니 
이 디스패치라는 메소드는 인자로 ThreadGroupCount x,y,z 라는 삼차원인듯한 인자를 받고 있다고 알 수 있습니다. 

스레드라는것이 무엇일까요 CPU 에서의 스레드란 프로그램을 실행하고 있는 주체 라고 합니다. 
프로그램은 데이터와 메모리 그리고 하나이상의 스레드로 이루어져 있다고 하는데 데이터는 그저 정보이고 메모리는 저장공간일 뿐인데 프로그렘은 이 둘을 활용해서 어떤 일을 해나가야합니다. 
그 이 데이터와 메모리를 가지고 어떤 일을 하는 주체가 스레드 라고 하는것 같습니다. 이 스레드가 하나이상인 프로그램이 멀티스레드 프로세스라고 합니다. 

그런데 GPU 에서의 스레드는 의미가 조금 다릅니다. GPU에서 스레드란 하나의 일감 자체를 말합니다. 
GPU에게는 많은 일감을 몰아줄것인데 이 각각의 일감(스레드)를 격자 형태 그리드로 묶어서 관리를 합니다. 그리고 그 묶은 그리드를 블록이라고 하고 거기에 다시 블록들을 묶어서 관리합니다. 
이 블록을 또 다른 이름으로 스레드 그룹이라고도 합니다. 스레드 그룹을 모아놓을때 2차원으로 모아놓기도 하고 3차원으로 모아놓기도 합니다. 
Dispatch 의 인자라는 ThreadGroupCount x,y,z 라고 하는게 이제 무슨의미인지 알수 있습니다. GPU의 일감들을 모아둔 구조체를 말하는 것이었습니다. 

이 내용과 비슷한게 지금 만든 compute.fx 의 코드에 있습니다. 
[numthreads(1024, 1, 1)]
라는 부분인데 이 hlsl 명령어? 구문? 입니다. 어떤 의미이냐면 컴퓨트 셰이더가 디스패치될 떄 단일 스레드 그룹에서 실행할 스레드 수를 정의 합니다. 
세가지 인자가 각각 x,y,z 값인데 특정 방향으로 스레드 그룹의 크기를 나타내고 스레드 그룹의 총합계는 x,y,z 모두 곱한것만큼의 크기입니다. 그래서 지금 코드에서는 x 축으로 1024 
개의 쓰래드를 실행하도록 
정의하고 있습니다.
이 갯수는 조절이 가능한데 예를 들어 (2,2,2) 크기로 하면 총 스레드 갯수는 8개 일것이고 아니면 1024 개 그대로 두고 (32,32,1) 이라는 형태로 만들수도 있습니다. 
(1024,1,1) 과 (32,32,1) 은 총 갯수는 같지만 차이점도 있습니다. 
CS_Main 안에 들어오는 각각 인자들이 인식하는 번호가 차이가 있게 됩니다.

이부분을 조금 자세히 살펴보자면 아까 GPU의 스레드를 설명하면서 각각 일감들이 스레드이고 이 스레드를 모은 것이 스레드 그룹 혹은 블록 이라고 했는데 이 스레드 그룹을 정의하는것이
 numthreads 입니다. 
그리고 이 스레드 그룹들을 가로 세로 깊이로 어떻게 관리하는지를 Dispatch 가 해주고 있는 겁니다. 

Dispatch 와 numthreads, thread 를 예시로 한번 연습을 해보자면 우선 Dispatch(5,3,2) 로 스레드 그룹들을 블록으로 만들었습니다. 
이러면 스레드 그룹들이 x축으로 5개의 열 y축으로 3개의 행 이걸 2개의층으로 이루어져있습니다.
이 블록에서 (2,1,0) 이라는 좌표의 스레드 그룹을 들여다보면 numthreads 로 (10,8,3) 이라는 크기의 스레드 그룹을 만들면 한 스레드 그룹에 240 개의 스레드가 있을수 있게 됩니다. 
블록 (2,1,0) 좌표에 있는 스레드 그룹안에서 다시 (7,5,0) 좌표의 스레드를 특정했습니다. 그러면 이 스레드는 여러가지 주소 정보를 가지게 됩니다. 
SV_GroupThreadID = (7,5,0)      // 스레드 그룹 안에서의 자신의 id 입니다. 
SV_GroupID = (2,1,0)            // 자신이 속한 스레드 그룹의 ID입니다. 
SV_DispatchThreadID = [(2,1,0)×(10,8,3)] + (7,5,0) = (27,13,0)  // 현재 모든 스레드 중에서 유니크한 아이디를 얻고 싶으면 이렇게 합니다.
이런 다양한 ID 를 얻을수 있습니다.

다시 코드를 봤을때 (1024,1,1) 과 (32,32,1) 의 차이는 좀더 알기쉬움 ID 값을 가진다는 말입니다. 물론 무조건 그래야한다는것은 없지만 지금 우리 프로젝트에서는 이렇게 진행할것입니다. 
그리고 numthreads 에서 x값을 1024 개를 주고 있지만 이후 Dispatch 에서는 y 값이 1024 를 줄것입니다. 결국은 1024×1024 사이즈의 스레드를 관리할것입니다.

또 한가지 CS_Main의 인자에서 int3 threadIndex : SV_DispatchThreadID 로 받아주고있는데 뒤의 SV_DispatchThreadID는 해당스레드의 독자적인 유니크한 아이디라고 했습니다. 
유니크한 아이디를 가져오는이유는 결국에는 이 셰이더의 결과물을 텍스쳐의 색을 바꿔주는 역할을 하고 싶은데 텍스쳐라는것이 결국 800×800 , 1024×1024 같은 2차원 픽셀의 버퍼로
 만들어져 있다고 볼수 있습니다. 
그리고 해당 숫자와 비슷하게 만들어주기 위해 스레드의 구조를 좌표처럼 사용할 수 있도록 1024×1024 로 만들어준것입니다.

if 문 내에서 어떤 일을 하고 있는지 이제 좀 알 수 있는데요 threadIndex의 y 값이 2의 배수인지를 체크하고 있습니다. threadIndex는 numthreads(1024,1,1) 로 설정한 스레드 그룹에서 
각 스레드의 고유한
아이디인 SV_DispatchThreadID 의 y값을 가져오는것과 같은데요 구성되어있는 스레드 중에서 y값이 2의 배수인걸 번갈아가면서 코드를 실행하고 있다는걸 알수 있습니다. 
실행하는코드는 g_rwtex_0 라는 읽기/쓰기 가 되는 텍스쳐에 스레드의 x,y 를 가져와서 좌표로 사용해 색을 y가 2의 배수라면 빨간색, 아니라면 초록색을 색칠해주고 있다는걸 알았습니다.

더 자세한 내용은 더 깊은 GPU 지식이 필요하겠지만 지금은 그럴 필요까지는 없고 일단 이 단계에서 얻어갈 내용은 GPU에서 스레드란 일감 하나하나이고 스레드 그룹을 만드는 것이
 numthreads, 그리고 이 스레드 그룹들을
다시 그리드 형태로 만드는것이 Dispatch 다 라는것을 알고 넘어 가겠습니다.

이제 최종결과물이 어떻게 될지를 간단히 알아 봤고 셰이더 코드는 여기까지 하고 CPP 코드들을 수정해 나가겠습니다. 


2) EnginePch.h

먼저 공용 헤더부터 시작하겠습니다. 

이제부터 SRV 레지스터를 5개만 사용하고 있었는데 앞으로는 더욱 많이 사용하게될것이기 때문에 레지스터를 10개까지 늘려주겠습니다. 
거기에 추가로 UAV(unordered access view) 라는 레지스터를 사용할 수 있도록 enum class 를 추가해주었습니다. 슬롯수는 u0 번 부터 u4 번 까지 5개 입니다.
이 uav 레지스터가 앞으로 컴퓨트 셰이더에서 사용할 레지스터입니다. 

새로운 레지스터를 추가했으니 이전에 사용할 레지스터의 총 갯수나 스왑체인의 버퍼 갯수를 가지고 있던 enum 이 있었는데 이부분도 수정을 해주겠습니다.
enum
{
	SWAP_CHAIN_BUFFER_COUNT = 2,
	CBV_REGISTER_COUNT = CBV_REGISTER::END,
	SRV_REGISTER_COUNT = static_cast<uint8>(SRV_REGISTER::END) - CBV_REGISTER_COUNT,
	CBV_SRV_REGISTER_COUNT = CBV_REGISTER_COUNT + SRV_REGISTER_COUNT,
	UAV_REGISTER_COUNT = static_cast<uint8>(UAV_REGISTER::END) - CBV_SRV_REGISTER_COUNT,
	TOTAL_REGISTER_COUNT = CBV_SRV_REGISTER_COUNT + UAV_REGISTER_COUNT
};
변경점은 원래는 REGISTER_COUNt 라고 관리하던 CBV 와 SRV 의 레지스터 갯수를 더한 걸 더욱 명확히 하기위해 앞에 CBV_SRV_ 를 붙여주었습니다. 
다음으로 이번에 추가한 레지스터인 UAV 를 관리하는 UAV_REGISTER_COUNT와 모든 레지스터의 갯수를 관리하는 TOTAL_REGISTER_COUNT 를 추가했습니다.

EnginePch 는 여기까지이고 다음으로 어떤걸 고쳐야 하는지를 생각해보니 사실상 모든 코드를고쳐야 합니다. 

3) CommandQueue
커맨드 큐의 코드를 잘 보면 초기화를 하면서 queueDesc 의 옵션들을 설정해주는데 이 설정값들은 그래픽스 용도의 옵션들입니다. 
지금부터 추가하려는 컴퓨트 용의 옵션은 따로 설정을 해줘야 하는데 이 설정을 if else 문과 bool 값으로 나눠서 적용시킬 수도 있지만 
코드가 매우 길어지기 때문에 이 프로젝트에서는 CommandQueue 자체를 그래픽스용과 컴퓨트용으로 나눠주려고 합니다. 

지금 사용하던 CommandQueue 클래스 이름 자체를 바꿔 줄것인데요 비주얼 스튜디오 기준으로 바꿀 텍스트를 드래그해서 ctlr + R 을 두번 누르면 현재 프로젝트에서 사용되던 
모든 곳의 텍스트를 수정할 수 있습니다. 
CommandQueue -> GraphicsCommandQueue 라는 이름으로 바꿨습니다. 
그리고 컴퓨트용 커맨드 큐는 ComputeCommandQueue 라는 이름으로 만들어 줄것인데 클래스 파일 자체를 따로 만들지는 않고 CommandQueue.h , .cpp 에 같이 만들어줄것입니다. 
대신 주석 같은걸로 구별을 잘 해놓으면 나중에 구분이 잘 갈것입니다. 

ComputeCommandQueue 의 내용은 아래와 같습니다.
// ************************
// ComputeCommandQueue
// ************************

class ComputeCommandQueue
{
public:
	~ComputeCommandQueue();

	void Init(ComPtr<ID3D12Device> device);
	void WaitSync();
	void FlushComputeCommandQueue();

	ComPtr<ID3D12CommandQueue> GetCmdQueue() { return _cmdQueue; }
	ComPtr<ID3D12GraphicsCommandList> GetComputeCmdList() { return _cmdList; }

private:
	ComPtr<ID3D12CommandQueue>			_cmdQueue;
	ComPtr<ID3D12CommandAllocator>		_cmdAlloc;
	ComPtr<ID3D12GraphicsCommandList>	_cmdList;

	ComPtr<ID3D12Fence>					_fence;
	uint32								_fenceValue = 0;
	HANDLE								_fenceEvent = INVALID_HANDLE_VALUE;
};

내용상으로 원래 사용하던 그래픽스 커맨드 큐와 비슷합니다. Init, WaitSync, FlushResourceCommandQueue 대신 FlushComputeCommandQueue가 있고 GetCmdQueue 와 GetComputeCmdList 도 
있습니다. 다른점은 리소스를 관리하지 않게 되었다는 점인것 같습니다. 


이제 구현부인 cpp 파일의 코드를 보겠습니다. 
// ************************
// ComputeCommandQueue
// ************************

ComputeCommandQueue::~ComputeCommandQueue()
{
	::CloseHandle(_fenceEvent);
}
이부분은 내용이 같습니다. 

void ComputeCommandQueue::Init(ComPtr<ID3D12Device> device)
{
	D3D12_COMMAND_QUEUE_DESC computeQueueDesc = {};
	computeQueueDesc.Type = D3D12_COMMAND_LIST_TYPE_COMPUTE;
	computeQueueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	device->CreateCommandQueue(&computeQueueDesc, IID_PPV_ARGS(&_cmdQueue));

	device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_COMPUTE, IID_PPV_ARGS(&_cmdAlloc));
	device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_COMPUTE, _cmdAlloc.Get(), nullptr, IID_PPV_ARGS(&_cmdList));

	device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&_fence));

	// CreateFence
	// - CPU와 GPU의 동기화 수단으로 쓰인다
	device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&_fence));
	_fenceEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);
}
초기화 함수에서는 다른점이 있는데 그래픽스 커맨드 큐에서는 인자로 디바이스와 스왑체인을 받아주고 있었지만 현재 컴퓨트 커맨드 큐에서는 디바이스만 받고 있습니다. 
그리고 Desc 를 채워주는 옵션들도 조금씩 다른데 computeQueueDesc.Type 이 D3D12_COMMAND_LIST_TYPE_COMPUTE 입니다. 원래는 D3D12_COMMAND_LIST_TYPE_DIRECT 이었습니다. 
이런 인자 하나하나가 달라지기 때문에 별도로 클래스를 파주게 된것입니다. 실질적으로 하는 일은 기존 그래픽스 커맨드 큐와 비슷합니다. 
_cmdQueue에 디바이스로 커맨드 큐를 만들어주고 커맨드 얼로케이터 커맨드 리스트도 적절한 인자를 넣어서 만들어주고 있습니다.
CPU와 GPU를 동기화 시키는 내용은 펜스에 관한 멤버변수들도 만들어줍니다. 

void ComputeCommandQueue::WaitSync()
{
	_fenceValue++;

	_cmdQueue->Signal(_fence.Get(), _fenceValue);

	if (_fence->GetCompletedValue() < _fenceValue)
	{
		_fence->SetEventOnCompletion(_fenceValue, _fenceEvent);
		::WaitForSingleObject(_fenceEvent, INFINITE);
	}
}
이 WaitSync 는 기존과 똑같은 내용입니다. CPU가 GPU 보다 먼저 일이 끝나도 GPU의 작업이 끝날때까지 기다리는 기능이었습니다.


void ComputeCommandQueue::FlushComputeCommandQueue()
{
	_cmdList->Close();

	ID3D12CommandList* cmdListArr[] = { _cmdList.Get() };
	auto t = _countof(cmdListArr);
	_cmdQueue->ExecuteCommandLists(_countof(cmdListArr), cmdListArr);

	WaitSync();

	_cmdAlloc->Reset();
	_cmdList->Reset(_cmdAlloc.Get(), nullptr);

	COMPUTE_CMD_LIST->SetComputeRootSignature(COMPUTE_ROOT_SIGNATURE.Get());
}
이 함수에서는 커맨드 큐의 쌓여있던 명령들을 전부 리셋시켜주는 역할입니다. 그래픽스 와 다른점은 리소스 커맨드 리스트를 초기화 하는게 아닌 
컴퓨트용으로 사용하던 커맨드 리스트를 초기화 하는점입니다.
또 맨 마지막 코드로 COMPUTE_CMD_LIST 라는 #define 을 사용하고 있는데 이 함수가 실행될때 사용할 컴퓨트 커맨드 큐를 따로 호출해줘야 하기 때문입니다. 
이 define 뿐만아니라 Engine에서도 컴퓨트용 커맨드 큐 객체를 만들어 줘야하고 COMPUTE_ROOT_SIGNATURE 라는 루트 시그니쳐도 따로 만들어줄것입니다. 

그러면 #define COMPUTE_CMD_LIST 부터 만들어 줄것인데


4) Engine

먼저 엔진에 클래스를 추가해주겠습니다. 엔진에서 이미 만들어져있던 그래픽스 커맨드 큐는 클래스 이름은 수정이 되었지만 변수이름은 그대로 _cmdQueue 인것을 
확인할 수 있습니다. 여기에 컴퓨트용으로 하나더 만들건데 햇갈리면 안되니까 다시 ctrl + R 두번으로 _graphicsCmdQueue 라고 수정해주겠습니다. 

이제 _computeCmdQueue 도 만들어 주고 Get 하는 함수 부분도 수정해줄것입니다. GetCmdQueue 를 다시 GetGraphicsCmdQueue 로 수정하고 
GetComputeCmdQueue 도 만들어 주었습니다.

이제 정의만 해주는게 아니라 Engine.Init 에서도 초기화를 해줘야 합니다. 
_computeCmdQueue->Init(_device->GetDevice()); 으로 초기화를 해주고 있습니다. 스왑체인이 없는것도 신경써줘야 합니다.

이제 CommandQueue 클래스에서 사용하는 COMPUTE_CMD_LIST 라는 define 을 만들어 주겠습니다. 


5) EnginePch

공용 헤더에서 #define을 주로 모아놓은 곳을 보면 CMD_LIST 와 RESOURCE_CMD_LIST 가 있습니다. CMD_LIST 도 햇갈리지 않게 GRAPHICS_CMD_LIST 로 전부 수정 해주었고 
하다보니까 GraphicsCommandQueue 에서 커맨드 리스트를 가져오는 함수이름이 그냥 GetCmdList 인걸 앞에 또 Grapgics 를 붙여줬습니다. 

#define COMPUTE_CMD_LIST	GEngine->GetComputeCmdQueue()->GetComputeCmdList()

이 매크로도 만들어 줬습니다. 

이제 루트 시그니쳐를 수정해보겠습니다. 


6) RootSignature

루트 시그니쳐를 배웠던게 너무도 오래전이기 때문에 이게 어떤 내용인지 가물가물 합니다. 
다시 떠올려보자면 루트시그니쳐는 어떠한 용도로 GPU를 활용할 것인지 미리 알려주는 계약서 같은 느낌이라고 했습니다. GPU의 레지스터에 어떤용도로 사용할것인지를 알려주었습니다.

이번에는 루트 시그니쳐 클래스 자체가 덩치가 크지 않고 수정할 부분도 그렇게 많지 않으니 기존 있던 클래스 내부에 코드를 추가하는 방법으로 하겠습니다. 

이 클래스의 멤버 변수로는 루트 시그니쳐인 _signature 와 _samplerDesc 가 있었는데 추가할 컴퓨트 루트 시그니쳐는 샘플러가 필요없습니다. 

우선 _signature 를 또 햇갈리지 않게 그래픽스를 붙인 이름으로 전부 수정해주겠습니다. 그리고 이걸 가져오는 함수도 GetGraphicsRootSignature 으로 수정해줍니다. 

_computeRootSignature 도 만들고 GetComputeRootSignature 도 만들어 주었습니다. 

이제 멤버 함수를 볼 차례입니다. 이전까지는 Init 함수와 그 안에서 호출되는 CreateSamplerDesc(), CreateRootSignature() 가 있었습니다. 
이중에 CreateSamplerDesc 는 내용이 별게 없고
	_samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);
이렇게 채워주는 역할 밖에 없었습니다. 이 샘플러 디스크립션은 어짜피 그래픽스 용도로 사용될것이기 때문에 CreateRootSignature 의 안으로 옮겨주겠습니다. 
거기에 더해서 CreateRootSignature 이름을 CreateGraphicsRootSignature로 변경해주었습니다. 

이제 컴퓨트용 생성함수 
	void CreateComputeRootSignature();
를 만들고 Init에도 추가해주었습니다.
구현부도 CPP 파일에 만들어 줬습니다. 여기는 그래픽스때와 정책이 좀 달라지긴 했습니다. 
이전에는 레지스터 슬롯을 b0는 전역으로 사용하고 b1 부터 DescriptorTable 로 사용하기도 했지만 
컴퓨트에서는 이 슬롯들을 어떻게 사용할것이라는걸 정하지 않았기 때문에 그냥 평범하게 전부 DescriptorTable 로 만들었습니다.

void RootSignature::CreateComputeRootSignature()
{
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, CBV_REGISTER_COUNT, 0), // b0~b4
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, SRV_REGISTER_COUNT, 0), // t0~t9
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_UAV, UAV_REGISTER_COUNT, 0), // u0~u4
	};

	CD3DX12_ROOT_PARAMETER param[1];
	param[0].InitAsDescriptorTable(_countof(ranges), ranges);   // 레지스터 전부 DescriptorTable 로 설정

	D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(_countof(param), param);
	sigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_NONE;             // 이부분의 플레그 설정도 그래픽스와 다른데 그래픽스 때는 플래그가 D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT
                                                                // 으로 IA 단계에서 인풋된 데이터를 조립하는걸 허락한다고 했었는데 
                                                                // 여기서는 그럴 필요가 없기 때문에 FLAG_NONE 으로 설정되었습니다.
	ComPtr<ID3DBlob> blobSignature;
	ComPtr<ID3DBlob> blobError;
	::D3D12SerializeRootSignature(&sigDesc, D3D_ROOT_SIGNATURE_VERSION_1, &blobSignature, &blobError);
	DEVICE->CreateRootSignature(0, blobSignature->GetBufferPointer(), blobSignature->GetBufferSize(), IID_PPV_ARGS(&_computeRootSignature));

	COMPUTE_CMD_LIST->SetComputeRootSignature(_computeRootSignature.Get());
}

이제 루트 시그니쳐도 수정이 되었습니다. 
커맨드 큐에서 또하나의 매크로인 COMPUTE_ROOT_SIGNATURE 도 EnginePch 에 만들어주겠습니다.


7) EnginePch
#define ROOT_SIGNATURE  를 #define GRAPHICS_ROOT_SIGNATURE 로 변경
그리고 
#define COMPUTE_ROOT_SIGNATURE		GEngine->GetRootSignature()->GetComputeRootSignature()
도 추가했습니다.

이렇게 해서 커맨드 큐, 엔진, 루트 시그니쳐 까지 수정이 완료되었습니다. 


8) TableDescriptorHeap
이 클래스도 오랜만입니다. 내용은 GPU의 레지스터에 사용할 내용을 그냥 고정으로 담아놓는 Constant Buffer View 가 있었고 지금 나온 TableDescriptorHeap 의 
경우 레지스터 슬롯에 어떤 데이터를 사용할지 고정해놓은게 아니라
어느 Descriptor 들을 모아놓은 Heap을 Table을 레지스터에 담아서 필요한 Table을 가져다 사용하도록 해놓은겁니다. 이러면 필요에 따른 Table을 바꿔 가면서 
사용할 수 있어서 레지스터의 용량을 아낄 수 있습니다. 

좀 전에 수정했던 RootSignature 에서 그래픽스, 컴퓨트 두 루트 시그니쳐 모두 슬롯을 IsAsDescriptorTable 이라고 설정을 해놓았는데 이 부분을 쉽게 채워넣기
 위해서 현재 TableDescriptorHeap 이라는 클래스를 만들었었습니다. 
하지만 이 클래스 역시 정책이 갈라지게 될것입니다. 그래픽스와 컴퓨트가 사용하는 정책이 다르기 때문입니다. 
이 클래스는 커맨드 큐 때와 같이 별도의 클래스를 만드는 방법으로 구현 해주겠습니다. 

먼저 기존의 TableDescriptorHeap 이라는 클래스의 이름을 구분하기 쉽게 GraphicsDescriptorHeap 이라고 전부 바꿔주겠습니다. 

다음으로 ComputeDescriptorHeap 을 밑에 만들어 주겠습니다. 

// ************************
// ComputeDescriptorHeap
// ************************

class ComputeDescriptorHeap
{
public:
	void Init();

	void SetCBV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, CBV_REGISTER reg);
	void SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg);
	void SetUAV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, UAV_REGISTER reg);		// 그래픽스에서 없던 UAV레지스터입니다.

	void CommitTable();

	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(CBV_REGISTER reg);
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(SRV_REGISTER reg);
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(UAV_REGISTER reg);

private:
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(uint8 reg);

private: 
	ComPtr<ID3D12DescriptorHeap> _descHeap;
	uint64						_handleSize = 0;
};

아직까지는 이 ComputeDescriptorHeap 을 한개 짜리로 관리할지 여러개 짜리로 관리할지 정하지 않았어서 일단은 테스트하기 편하도록 한개짜리
group 에 관련한 내용들을 빼주었습니다. 

구현부의 경우에는 Init의 인자가 없어졌는데 기존에는 Count 라는 인자를 DescriptorHeap 을 Count 갯수만큼 공간을 확보하였는데 
	desc.NumDescriptors = count * (CBV_SRV_REGISTER_COUNT - 1);  // b0 는 전역이기 때문
지금 컴퓨트버전에서는 배수가 없어졌고 또 UAV 레지스터 까지 포함해서 크기를 결정하고 있습니다. 
	desc.NumDescriptors = TOTAL_REGISTER_COUNT;

그리고 또 차이점이 CommitTable 함수들인데 원래의 그래픽스 버전의 경우 필요한 CBV,SRV 들을 Set합수를 때린 다음 마지막으로 CommitTable을 해주는데 
GRAPHICS_CMD_LIST->SetGraphicsRootDescriptorTable(1, handle); 이렇게 해줍니다. 그래픽스용의 함수입니다. 
컴퓨트 버전에서는 이부분도 달라져야할것입니다. 
	COMPUTE_CMD_LIST->SetComputeRootDescriptorTable(0, handle);

클래스를 하나더 만들었으니 Engine에 다시 추가해줘야합니다. 


9) Engine
하나의 파일에 추가했지만 별도의 클래스다 보니 추가를 해줘야 합니다. 커맨드 큐도 그랬었습니다.

기존에 사용하던 멤버 변수 이름이 _tableDescHeap 이었는데 이름을 _graphicsDescHeap 으로 수정 했습니다. 
추가로 _computeDescHeap 도 만들었습니다. 

그리고 Get 함수도 GetGraphicsDescHeap으로 변경해주었습니다. 컴퓨트 겟 함수도 만들었구요 

구현부인 Engine.cpp 에도 _computeDescHeap 을 초기화도 해주었습니다. 
	_graphicsDescHeap->Init(256);
	_computeDescHeap->Init();
그래픽스 데스크립터 힙과 컴퓨트 데스크립터 힙의 인자가 있고 없고의 차이는 아까 위에서도 말했지만 그래픽스 버전의 경우 미리 널널하게 256 개의 데스크립터 힙이 들어올 수 있도록
미리 공간을 확보해 놓은 상태이고
컴퓨트 버전은 일단은 한개의 데스크립터 힙이 작동하는지를 확인하고 더 늘리고 싶으면 이후에 늘릴것입니다. 


10) Shader 클래스
셰이더 클래스에서도 일반 셰이더와 컴퓨트 셰이더가 갈리다 보니까 새로 만들어 줘야하겠습니다. 

기존의 셰이더 클래스가 어떻게 동작하는지를 다시 살펴보면 Shader::Init 을 할때 인자로 셰이더 파일의 경로, 셰이더 옵션들을 담은 ShaderInfo, 
각각 어떤 VS,PS 함수를 사용할지를 정할수 있는 문자열을 인자로 받습니다. 
Init에서 처음하는 일은 인자의 ShaderInfo 를 가지고 있도록 멤버 변수 _info 에 받아 둡니다. 
그리고 나서 어던 VS,PS 를 사용할지 CreateVertexShader, CreatePixelShader 실행합니다. 
즉, 지금 Init 이라는 함수 자체가 Graphics 용 셰이더를 초기화 하는 함수입니다.

그러면 이번시간에 추가하고 있는 컴퓨트 셰이더는 아예 Init 함수를 사용하면 안될것입니다. 
그렇다면 그냥 Init 이라는 함수 이름은 나중에 혼동을 일으킬수 있습니다. Init도 프로젝트에서 이름을 CreateGraphicsShader 라고 변경하겠습니다.

이제 컴퓨트 셰이더 부분을 만들어 줄것인데 따로 클래스를 파고 기존 Shader 를 상속받아 만들 수도 있지만 지금 단계에서는 일단 테스트를 통과하는게 목적이기 때문에 
기존 Shader 클래스 안에 추가로 덧붙혀서 만들어 보겠습니다. 	

Shader 클래스가 들고 있던 멤버 변수는 이렇습니다. 
	ShaderInfo							_info;
	ComPtr<ID3D12PipelineState>			_pipelineState;
	// 위의 두 멤버 변수는 그래픽스나 컴퓨트나 공통으로 사용될 공용 멤버 변수이고 

	// GraphicsShader
	ComPtr<ID3DBlob>					_vsBlob;
	ComPtr<ID3DBlob>					_psBlob;
	ComPtr<ID3DBlob>					_errBlob;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC  _pipelineDesc = {};
	// 위의 네개의 멤버 변수는 그래픽스 셰이더에서 사용되는 멤버 변수 들입니다. 

여기에 추가해줄 컴퓨트용 멤버 변수입니다. 
	// ComputeShader
	ComPtr<ID3DBlob>					_csBlob;
	D3D12_COMPUTE_PIPELINE_STATE_DESC   _computePipelineDesc = {};

컴퓨트용 파이프라인이라서 타입이 D3D12_COMPUTE_PIPELINE_STATE_DESC 입니다. 

이렇게 멤버 변수를 추가하고 보니 또 다시 혼동될 여지가 있는 이름이 있습니다. _pipelineDesc 은 그래픽스 용인데 공용 파이프라인 같은 이름입니다. 
_graphicsPipelineDesc 라고 프로젝트에 걸쳐 수정해주었습니다.

이제 좀전까지 Init 이었던 함수의 컴퓨트용 버전을 만들겠습니다 선언부는 이렇습니다.
	void CreateComputeShader(const wstring& path, const string& name, const string& version);

인자가 옵션이나 셰이더 함수들을 정해 줄 필요가 없기 때문에 이렇게 받아주고 있습니다. 지어줄 이름과 버전을 const string& 으로 받아주고 있는데 이중에 
버전이란것은 CreateGraphicsShader 안에서 CreateVertexShader, CreatePixelShader 를 할때 하드 코딩이로 vs_5_0 , ps_5_0 이라고 적어뒀던 부분입니다. 
컴퓨트 셰이더의 경우에는 버전을 하드코딩하지 않고 인자로 받아주고 있습니다. 
CreateComputeShader 의 구현부는 이렇습니다. 
void Shader::CreateComputeShader(const wstring& path, const string& name, const string& version)
{
	_info.shaderType = SHADER_TYPE::COMPUTE;		// 아직 추가해주지 않은 SHADER_TYPE 입니다. 

	CreateShader(path, name, version, _csBlob, _computePipelineDesc.CS);	
	// CreateShader 라는 함수를 만들어줄때 이미 어느정도 공용으로 사용할 수 있게 만들어 줬기때문에 컴퓨트 셰이더를 만들때도 사용하고 있습니다. 
	_computePipelineDesc.pRootSignature = COMPUTE_ROOT_SIGNATURE.Get();
	// 대신 그래픽스의 셰이더 들과 달리 파이프라인 데스크립터 의 루트시그니쳐를 컴퓨트 루트시그니쳐 라고 설정을 해줘야합니다.

	HRESULT hr = DEVICE->CreateComputePipelineState(&_computePipelineDesc, IID_PPV_ARGS(&_pipelineState));
	assert(SUCCEEDED(hr));
}

여기서 등장했던 SHADER_TYPE::COMPUTE 를 추가해주는걸 잊지 않아야 합니다.

셰이더 타입을 설정해주면 Update 할때 타입에 따라 타입에 맞는 커맨드 리스트에 파이프라인스테이트를 세팅해줄 수 있습니다. 이 내용을 바로 밑의 Update 구현부에 적용했습니다.
void Shader::Update()
{
	if (GetShaderType() == SHADER_TYPE::COMPUTE)
		COMPUTE_CMD_LIST->SetPipelineState(_pipelineState.Get());
	else
		GRAPHICS_CMD_LIST->SetPipelineState(_pipelineState.Get());
}


11) Resources 
새로 사용할 셰이더인 compute.fx 를 미리 로드해놓고 사용하기 위해서 Resources::CreateDefaultShader 에 추가해주고 그것과 연관되있는 CreateDefaultMaterial 에도 추가 해줍니다.

Resources::CreateDefaultShader 
{
	// 생략

	// Compute Shader
	{
		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->CreateComputeShader(L"..\\Resources\\Shader\\compute.fx", "CS_Main", "cs_5_0");
		Add<Shader>(L"ComputeShader", shader);
	}
}

방금전에 만들어 줬던 Shader::CreateComputeShader 를 통해서 Resources 로 미리 로드해서 가지고 있을수 있게 되었습니다. 
compute.fx 가 있는 경로와 시작함수는 CS_main, 버전은 cs_5_0 으로 만들었습니다.

이제 Material 도 추가해주겠습니다. 
Material 은 셰이더에게 인자를 넘겨줄때 사용하는게 Material 이었습니다. 

	// Compute Shader
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"ComputeShader");
		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);
		Add<Material>(L"ComputeShader", material);
	}
리소스에 이미 Add 되어있던 ComputeShaer 를 불러와서 Material 에 추가한 후 Add 해줬습니다. 

이제 컴퓨트 셰이더용 라인을 만들었고 리소스로 불러올 준비가 끝났습니다. 


12) SceneManager
컴퓨트 셰이더를 호출해서 출력하기 위해서 오브젝트 들을 관리하는 SceneManager::LoadTestScene 에서 호출을 해줘야 합니다. 

LoadTestScene 에서 처음 코드인 레이어를 설정하는 LayerMask 코드 밑에 바로 ComputeShader 코드를 추가해주겠습니다 왜냐면 이 컴퓨트 셰이더를 나중에 UI 오브젝트에 
적용해야 해서 먼저 실행해줍니다. 
#pragma region ComputeShader
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"ComputeShader");
		// 미리 로드 해놓은 ComputeShader 리소스를 가져오고 있습니다. 

		// UAV 용 Texture 생성
		shared_ptr<Texture> texture = GET_SINGLE(Resources)->CreateTexture(L"UAVTexture",
			DXGI_FORMAT_R8G8B8A8_UNORM, 1024, 1024,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE,
			D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);
		// 텍스쳐를 생성하고 있는데 사용하는 인자중에 중요한것은 마지막 인자인 D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS 입니다. 
		// 지금까지 다른 텍스쳐들은 모두 렌더 타겟용으로 사용하겠다고 해줬습니다. UAV 용도로 활용하겠다는 의미입니다. 

		shared_ptr<Material> material = GET_SINGLE(Resources)->Get<Material>(L"ComputeShader");
		material->SetShader(shader);
		material->SetInt(0, 1);
		GEngine->GetComputeDescHeap()->SetUAV(texture->GetUAVHandle(), UAV_REGISTER::u0);
		// 이부분에서 당연히 에러가 날것입니다. Texture 클래스에 GetUAVHandle 이라는 기능을 만들어 준적이 없기 때문입니다. 

		// 쓰레드 그룹 (1 * 1024 * 1)
		material->Dispatch(1, 1024, 1);
		// 이 Dispatch 라는 기능도 아직 구현하지 않았습니다. 
	}
#pragma endregion

컴퓨트 셰이더를 GEngine->GetComputeDescHeap->SetUAV 를 하는 과정에 아직 Texture 클래스에 구현하지 않은 기능이 있어서 
잠시 Texture 클래스에서 기능을 추가하고 오겠습니다. 

12-1) Texture 

텍스쳐에서 바뀔 부분은 무엇인가?

현재 텍스쳐 클래스에서 들고있는 Descriptorheap (DirectX12 이전에는 View 라고 부르던)은 총 세가지 입니다.
	ComPtr<ID3D12DescriptorHeap>	_srvHeap;
	ComPtr<ID3D12DescriptorHeap>	_rtvHeap;
	ComPtr<ID3D12DescriptorHeap>	_dsvHeap;
이 세가지 Descheap 은 모두 Graphics 용도로 사용되는 것들임 에도 불구하고 필요에 따라 각각 사용하는 DescHeap 이 다릅니다. 
이제 여기에 이번 강의의 주제 컴퓨트 셰이더 에서 사용하는 DescHeap인 uavHeap 이 추가 될것입니다. 

	ComPtr<ID3D12DescriptorHeap>	_uavHeap;
	ComPtr<ID3D12DescriptorHeap> GetUAV() { return _uavHeap; }

_uavHeap 을 추가함과 동시에 외부에서 꺼내 쓸수 있도록 Get 함수도 같이 추가합니다.
그리고 나중에 연산에 필요한 정보인 _uavHeap 의 시작 주소인 _uavHeapBegin = {}; 이라는 D3D12_CPU_DESCRIPTOR_HANDLE 도 하나 들고 있겠습니다. 
(이 미리 정보를 들고 있는걸 캐싱이라고 합니다.)
그리고 이 핸들을 외부에서 꺼낼수 있는 GetHandle 함수도 추가 합니다.
	
	D3D12_CPU_DESCRIPTOR_HANDLE		_uavHeapBegin = {};
	D3D12_CPU_DESCRIPTOR_HANDLE GetUAVHandle() { return _uavHeapBegin; }

이제 새로 추가된 변수들의 내용을 채워줘야 하는데 Texture::Create 를 보면 인자로 주는 각종 파라미터와 플래그들을 가지고 _tex2D 를 만들어서 
CreateFromResourece 에 넘겨주고 있습니다. 
그러면 이 CreateFromResourece 에서 받은 tex2D 를 .GetDesc() 를 통해 Desc 를 조건문으로 DepthStencil 인지, 아니면 RenderTarget 인지, SRV(셰이더 리소스 뷰) 인지를 
판별해서 각 _~~~Heap 의 내용물을 채워 주고 있습니다.

그러면 여기에서 UAV Heap 은 어디에서 챙겨야 할까요 RenderTarget 과 SRV 사이에 새로운 if 문을 만들어 삽입합니다. 이게 어떤 의미이냐면 
DescHeap 을 만들 때 종류에 따라 몇가지 조합이 있는데 DSV 를 단독으로 사용하거나, SRV를 단독으로 사용하거나 , RTV 와 SRV 를 같이 사용하는 조합이 있었습니다. 
여기에 UAV 까지 더하면 UAV 와 SRV 를 같이 사용할 수 있는 조합까지 더해집니다. 
_uavHeap 을 만들어 주는 부분의 코드를 보겠습니다.

		if (desc.Flags & D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS)
		{
			// UAV
			D3D12_DESCRIPTOR_HEAP_DESC uavHeapDesc = {};
			uavHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;	// uav 에 맞는 내용들을 채워주고 있습니다. 
			uavHeapDesc.NumDescriptors = 1;
			uavHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
			uavHeapDesc.NodeMask = 0;
			DEVICE->CreateDescriptorHeap(&uavHeapDesc, IID_PPV_ARGS(&_uavHeap));  // _uavHeap내용물을 채워줍니다. 

			_uavHeapBegin = _uavHeap->GetCPUDescriptorHandleForHeapStart();     	// 만든 _uavHeap 의 시작 핸들을 가져옵니다. 

			D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
			uavDesc.Format = _image.GetMetadata().format;
			uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;

			DEVICE->CreateUnorderedAccessView(_tex2D.Get(), nullptr, &uavDesc, _uavHeapBegin);
		}

이렇게 텍스쳐에 UAV 에 관한 내용을 추가 하였습니다. 
다시 SceneManager::LoadTestScene 으로 돌아가보면 

12-2) SceneManager::LoadTestScene

컴퓨트 셰이더를 만드는 코드에서 
		GEngine->GetComputeDescHeap()->SetUAV(texture->GetUAVHandle(), UAV_REGISTER::u0);
이부분이 하는 역할은 이제 compute.fx 의 u0 라는 레지스터에서 사용할 텍스쳐를 설정해주는 역할이었습니다. 

이제 텍스쳐에 관한 부분은 밑줄이 사라졌지만 아직 material->Dispatch 라는 기능이 밑줄이 쳐있습니다.
Dispatch 는 스레드 그룹들을 그리드 형태로 설정하는 함수라고 했습니다.

		material->Dispatch(1, 1024, 1);

이렇게 y 축 갯수를 1024 개로 잡고 만들고 있는데 compute.fx 에서 numthreads 로 스래드 그룹을 (1024,1,1) 로 만들었습니다. x 축 1024개 y 축 1024개의 
스레드를 구성하기위한 것입니다.

이 Dispatch 를 구현하는것은 조금 뒤로 미루겠습니다.

Dispatch 를 뒤로 미루고 먼저 해야할 일이 무엇이냐면

UI Test 오브젝트들을 만드는 코드입니다. UI 메쉬를 하나 더 만들어서 거기에 컴퓨트 셰이더로 만든 텍스쳐를 붙히려고 합니다. 

UI_Test 라고 이름 지어진 pragma region 에서 오브젝트 이름이 sphere 로 되어있는데 object 라는 이름으로 정리해주었고,
현재 for문으로 5개의 오브젝트를 만들고 있는데 하나 더 늘려서 6개를 만들도록 수정하였습니다. 여기서 각각 오브젝트가 자리를 자동으로 잡도록 
UI 오브젝트들의 SetLocalPosition 을 -350.0 부터 i * 160 씩 더해가면서 x 좌표를 움직여서 배치 했었는데 160 픽셀에서 120 픽셀로 조금 조정해주었습니다. 

object->GetTransform()->SetLocalPosition(Vec3(-350.f + (i * 120), 250.f, 500.f));

이렇게 하면 일단 6개의 오브젝트가 만들어 지는데 이중에 처음의 3개의 오브젝트에는 G_BUFFER 에서 사용하는 포지션, 노멀, 컬러 의 텍스쳐를 각각 붙혀주었었고 
그 다음 2개의 오브젝트에는 Diffuse Lighting, Specular Lighting 텍스쳐를 붙혀 주었습니다. 이제 하나더 추가된 오브젝트에는 UAVTexture 를 붙혀주겠습니다. 

	shared_ptr<Texture> texture;
	if (i < 3)
		texture = GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->GetRTTexture(i);
	else if (i < 5)
		texture = GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::LIGHTING)->GetRTTexture(i - 3);
	else
		texture = GET_SINGLE(Resources)->Get<Texture>(L"UAVTexture");

그리고 이번 테스트에서는 광원의 갯수가 많은것 같아서 Directional Light 만 남기고 나머지 광원은 날렸습니다. 

이제 다시 컴퓨트 셰이더 부분의 코드를 보겠습니다. 

#pragma region ComputeShader
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"ComputeShader");

		// UAV 용 Texture 생성
		shared_ptr<Texture> texture = GET_SINGLE(Resources)->CreateTexture(L"UAVTexture",
			DXGI_FORMAT_R8G8B8A8_UNORM, 1024, 1024,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE,
			D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);

		shared_ptr<Material> material = GET_SINGLE(Resources)->Get<Material>(L"ComputeShader");
		material->SetShader(shader);
		material->SetInt(0, 1);
		GEngine->GetComputeDescHeap()->SetUAV(texture->GetUAVHandle(), UAV_REGISTER::u0);

		// 쓰레드 그룹 (1 * 1024 * 1)
		material->Dispatch(1, 1024, 1);
	}
#pragma endregion

읽어보면 우선 셰이더 타입 shared_ptr 을 만들어서 Resources 에서 미리 로드해둔 디폴트 셰이더인 ComputeSHader 를 연결했습니다. 

그 다음으로 컴퓨트 셰이더에서 사용하는 UAV 텍스쳐를 LoadTestScene 에서 생성해줍니다. Resources 에서 만들어서 캐싱(맞는 표현인지는 모르겠습니다.) 을 해주는데 
인자로 주는것은 name, format, width, height, heap property, heap flag, resource flag, clearcolor(이건 생략했습니다.)

그리고 Mateiral 을 만들어서 셰이더랑 Int 를 세팅해주고 있습니다. 셰이더 파일에 어떤 파라미터를 넘겨주기 위해서는 Material 이 필요했었습니다. 
여기서 SetInt 의 인자로 (0,1) 을 줬었는데 첫번째 인자인 0 은 셰이더로 넘겨주는 material param.intparams 라는 int 를 담는 배열 중에 0번째 인덱스를 고르는 인자이고,
두번째 인자 1 은 그 인덱스의 값을 주는것입니다. 즉 MaterialParams.IntParams[0] = 1 을 설정해주는 함수입니다. 이 함수의 의미는 아직 잘 모르겠습니다. 

하여튼 다음은 글로벌 엔진 객체를 가져다가 ComputeDescHeap 을 가져오고 거기에 아까 생성한 UAV texture 의 핸들과 GPU에서 사용할 레지스터 슬록의 번호를 설정해주고 있습니다. 

이렇게 Shader 객체와 int 정보를 Material에 담고 Texture는 ComputeDescHeap 의 SetUAV 로 설정해서 넘겨준다음 
Dispatch 를 딱 실행 해주면서 compute.fx 가 딱 실행되면서 GPU가 넘겨받은 UAV Texture 에 열심히 색을 입혀주게 될것입니다. 

이제 마지막으로 Material로 가서 수정할 코드가 있는지 체크와 Dispatch 도 추가해주겠습니다. 


13) Material

Material의 코드를 한번 훑어 보았습니다. 셰이더에 넘겨줄 파라미터들을 담은 MaterialParams 구조체를 선언하고 있고 각 파리미터들 int, float, texture, vector2 파라미터들이
몇개씩을 담을 것인지를 enum에 기록해 두었습니다. 
클래스 안을 보면 멤버 변수로는 셰이더 객체, 파라미터들, 텍스쳐들을 들고 있습니다. 

	shared_ptr<Shader>	_shader;
	MaterialParams		_params;
	array<shared_ptr<Texture>, MATERIAL_TEXTURE_COUNT> _textures;

멤버 변수로는 이 멤버 변수들의 내용을 세팅하는 각종 Set 함수들과 외부에서 셰이더를 꺼내는 GetShader 그리고 PushData 가 있습니다. 

이 중에서 PushData 의 구현부를 보면 이렇습니다. 
void Material::PushData()
{
	// CBV 업로드
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushData(&_params, sizeof(_params));

	// SRV 업로드
	for (size_t i = 0; i < _textures.size(); i++)
	{
		if (_textures[i] == nullptr)
			continue;

		SRV_REGISTER reg = SRV_REGISTER(static_cast<int8>(SRV_REGISTER::t0) + i);
		GEngine->GetGraphicsDescHeap()->SetSRV(_textures[i]->GetSRVHandle(), reg);
	}

	// 파이프라인 세팅
	_shader->Update();
}

CBV 업로드를 하면서 MaterialParams 를 넘기고, 텍스쳐들이 담겨있는 _textures 배열의 크기만큼 for문을 돌면서 SRV 레지스터 슬롯에 하나씩 담아서 SetSRV 를 해주고 있습니다. 
이때 사용하는 함수중에 GetGraphicsDescHeap() 이라는 함수가 있는데 지금까지 컴퓨트 셰이더를 사용하기 위해 코드를 고쳐온 만큼 눈치를 챌수 있습니다. 
Graphics 라는 단어를 보면 Compute 용도 만들어야 겠구나 라는 것을
지금 이 PushData는 그래픽스 용이니까 이름을 나중에 알기 쉽게 다시 PushGraphicsData 라고 프로젝트에서 수정해줍니다.
이 부분에서 GetGraphicsDescHeap 의 이름을 가지고 그래픽스용 DescHeap이구나를 알게 된것은 이번 강의 동안 그래픽쪽 함수들의 이름을 하나하나 바꿔왔기 때문에 눈치 채기 쉬웠습니다.

이제 Material 에 컴퓨트 에 관한 함수를 만들어 줄것인데 

	void PushComputeData();
	void Dispatch(uint32 x, uint32 y, uint32 z);

이렇게 Push 함수와 나중에 컴퓨트 셰이더를 실행해줄 Dispatch 도 선언부는 미리 헤더 파일에 만들어 두었습니다.

PushComputeData 의 구현부 부터 보겠습니다. 
void Material::PushComputeData()
{
	// CBV 업로드
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushComputeData(&_params, sizeof(_params));
		// PushComputeData 라는 내용이 ConstBuffer 에 없습니다. 추가할 것
	// SRV 업로드
	for (size_t i = 0; i < _textures.size(); i++)
	{
		if (_textures[i] == nullptr)
			continue;

		SRV_REGISTER reg = SRV_REGISTER(static_cast<int8>(SRV_REGISTER::t0) + i);
		GEngine->GetComputeDescHeap()->SetSRV(_textures[i]->GetSRVHandle(), reg);
		// 이부분에서 GetComputeDescHeap 을 가져오는 부분이 달라 졌습니다. 
	}

	// 파이프라인 세팅
	_shader->Update();
}

여기서 수정해야할 부분은 ConstantBuffer 에 PushComputeData 를 만들어 주는 것
그리고 달라진 점은 GetComputeDescHeap 를 가져와서 SRV를 세팅해주고 있는 것입니다. 

Material::Dispatch 를 보겠습니다. 
void Material::Dispatch(uint32 x, uint32 y, uint32 z)
{
	// CBV + SRV + SetPipelineState
	PushComputeData();

	// SetDescriptorHeaps + SetComputeRootDescriptorTable
	GEngine->GetComputeDescHeap()->CommitTable();

	COMPUTE_CMD_LIST->Dispatch(x, y, z);

	GEngine->GetComputeCmdQueue()->FlushComputeCommandQueue();
}
방금 만든 Material::PushComputeData 를 이 Dispatch 에서 먼저 실행하면서 파이프라인을 세팅해주고 있습니다. 
그리고 나서 CommintTable 을 때리는데 여기서는 컴퓨트 커맨드 리스트에 DescriptorHeap 와 ComputeRootDescriptorTable 을 세팅해주고 있습니다. 
다음은 컴퓨트 커맨드 리스트에서 Dispatch 를 인자로 받은 x,y,z 로 실행해주고 있는데 이 Dispatch 는 DirectX 에 탑재된 그 함수 입니다. 
마지막으로 컴퓨트 커맨드큐->FlushComputeCommandQueue 를 해줍니다. 사실 여기서 일감들을 전부 실행해줍니다. 
FlushComputeCommandQueue 가 하는 일은 일단 커맨드 리스트를 닫고 ComPtr<ID3D12GraphicsCommandList>	_cmdList; 인 커맨드 리스트를 
ID3D12CommandList* cmdListArr[] = { _cmdList.Get() }; 이렇게 담고 나서 
_cmdQueue->ExecuteCommandLists(_countof(cmdListArr), cmdListArr); 로 커맨드 큐를 실행합니다.
WaitSync를 한 다음 다음 프레임을 위해 _cmdAlloc, _cmdList 를 reset 후 다시 _cmdList 를 컴퓨트 루트 시그니쳐로 세팅합니다. 

Dispatch 에서 사실 컴퓨트 셰이더의 렌더링 같은 역할을 하는것 같습니다. 


이제 하나 빼먹었던 부분인 ConstantBuffer 쪽을 살펴보겠습니다. 


14) ConstantBuffer

상수 버퍼에서 수정해줄 부분이 어디 있는지를 찾아보니 
ConstantBuffer::PushData 에서 
GEngine->GetGraphicsDescHeap()->SetCBV(cpuHandle, _reg); 이런 부분이 있습니다. 그래픽스 용 인데 그러면 컴퓨트용과 혼동할 수 있으니 이것도 이름을 바꿔 줍니다. 
PushGraphicsData 로 

그리고 밑에 SetGlobalData 라는 함수가 있는데 이것도 혹시나 착각할 여지를 주지 않기 위해 SetGraphicsGlobalData 로 이름을 변경하였습니다.

이제 PushComputeData 를 만들어 줄것인데 그래픽스 버전과 거의 비슷하지만 GraphicsDescHeap 대신 ComputeDescHeap을 불러오는 부분만 다릅니다. 



15) Test 

이제 프로그램을 빌드 하고 디버그를 해보니 Texture::Create 에서 텍스쳐 2D 를 생성하는 부분 에서 에러가 났습니다. 
	HRESULT hr = DEVICE->CreateCommittedResource(
		&heapProperty,
		heapFlags,
		&desc,
		resourceStates,
		&optimizedClearValue,
		IID_PPV_ARGS(&_tex2D));

 UAV일 경우 optimizedClearValue 가 Nullptr 이어야 한답니다. 지금은 위에서 중괄호 초기화를 해주고 Resource State 의 flag가  DepthStencil 이거나 
 Render Target 일경우 각각에 맞는 optimizedClearValue 를 설정해주고 있습니다.  

중간에 새로 pOptimizedClearValue 라는 nullptr 을 가진 변수를 하나 만들었습니다. 
	D3D12_CLEAR_VALUE* pOptimizedClearValue = nullptr;

이걸 각 조건문에 해당할때의 값을 이 포인터에 담아주고  아닐경우 nullptr 이었던 pOptimizedClearValue 를 가지고 hr 을 만들었습니다. 

	D3D12_CLEAR_VALUE optimizedClearValue = {};
	D3D12_CLEAR_VALUE* pOptimizedClearValue = nullptr;
	D3D12_RESOURCE_STATES resourceStates = D3D12_RESOURCE_STATES::D3D12_RESOURCE_STATE_COMMON;

	if (resFlags & D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)
	{
		resourceStates = D3D12_RESOURCE_STATES::D3D12_RESOURCE_STATE_DEPTH_WRITE;
		optimizedClearValue = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_D32_FLOAT, 1.0f, 0);
		pOptimizedClearValue = &optimizedClearValue;
	}
	else if (resFlags & D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET)
	{
		resourceStates = D3D12_RESOURCE_STATES::D3D12_RESOURCE_STATE_COMMON;
		float arrFloat[4] = { clearColor.x, clearColor.y, clearColor.z, clearColor.w };
		optimizedClearValue = CD3DX12_CLEAR_VALUE(format, arrFloat);
		pOptimizedClearValue = &optimizedClearValue;
	}

	// Create Texture2D
	HRESULT hr = DEVICE->CreateCommittedResource(
		&heapProperty,
		heapFlags,
		&desc,
		resourceStates,
		pOptimizedClearValue,
		IID_PPV_ARGS(&_tex2D));

이제 실행하면 의도했던 대로 실행이 됩니다. 

UI 오브젝트들 중에 6번째 UI 에 녹색, 빨간색 이 교차로 색칠된 텍스쳐가 표시되고 있습니다. 이 텍스쳐는 CPU에서 만든 버퍼로 출력한게 아니고 
GPU 에서 자체적으로 만든 버퍼이라는 점이 특이합니다. 