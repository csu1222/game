

        34. Instancing


인스턴싱, 이전 시간인 파티클 시스템에서도 봤던 개념입니다. 물체를 그릴때 몇개나 그릴지 값을 주면 한번의 IA 단계로 입력받은 만큼의 물체를 그려줍니다. 

이 인스턴싱을 사용하는 방법이 여러가지가 있기 때문에 정식 주제로 가져왔습니다. 

인스턴싱을 활용하는 이유는 명확한데 Draw Call 때문입니다.

그래픽스 렌더링 파이프라인이라는 과정을 통해 CPU가 GPU에게 렌더링을 시키는데 이 과정 자체가 사실 굉장히 무거운 작업일 수 있습니다. 
물건을 그려질때마다 Mesh:Render 안에 있는 

GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, instanceCount, 0, 0, 0);

를 통해 CPU 가 GPU 에게 요청을 해줬습니다. 

게임에서 물체를 그릴 때 딱 한개씩만 그릴 때도 있지만 똑같은 유닛이 여러개 나올때나 관중을 표현하거나 나무나 돌 같은 배경 오브젝트들도 같은 모양의 물체를 
배치만 다르게 해서 표현하기도 합니다. 

이때마다 인스턴싱 없이 한번씩 렌더링 파이프라인을 돌면 부담이 많이됩니다. 
아까 부터 부담이 많이간다고 말이 나왔는데 그러면 어째서 부담이 많이 가는지 이유가 무엇일까요

CPU 에서 계산한 리소스들을 GPU로 전송하는 부분이 부담이 됩니다. 인스턴싱은 리소스를 정송하는 부분 외에 물체를 그리는 과정 자체는 거의 똑같다고 볼 수 있습니다. 

그러면 어떤 경우에 인스턴싱을 사용할 수 있는지 알아보면 
먼저 물체를 그리는데 IA 때 넣어주는 데이터들 Vertex Buffer, Index Buffer, Topology Data 등이 같아야 합니다. 그리고 중간에 필요한 파리미터인 Constant Buffer 도 
같아야하고 마지막으로 그릴때 사용하는 셰이더 코드도 같아야 합니다. 
즉, 인스턴싱은 똑같은 물체를 그릴 때 사용할수 있습니다.

이렇게 똑같은 데이터를 사용하는부분을 최초 한번만 넘겨주고 원하는 갯수의 물체를 그릴때 까지 그걸로 계속 그리는 겁니다.  
마치 금속활자처럼 처음에 세팅한 그 텍스트를 계속 찍어내는것 같습니다.

이전 시간에 배운 파티클 시스템에서도 인스턴싱을 사용했었는데 어떤 식으로 사용했었냐면 총 1000 개의 파티클을 사방으로 랜덤하게 흩뿌리는 형태로 사용했었습니다. 
인스턴싱은 같은 IA 데이터, 같은 파라미터, 같은 셰이더를 가지고 물체를 찍어내는건데 어떻게 각각의 파티클을 구별해서 랜덤하게 뿌려 줄 수 있었을 까요?

그 이유는 IA때 받는 정보중에 SV_IntanceID 라는 것을 받아서 각각의 파티클에 고유한 아이디를 할당하고 그걸로 각 파티클을 특정해서 해당하는 정보를 

struct Particle
{
    float3  worldPos;
    float   curTime;
    float3  worldDir;
    float   lifeTime;
    int     alive;
    float3  padding;
};

구조체에 기입해서 물체를 그릴 수 있었습니다. 

오늘 인스턴싱 강의의 핵심은 이 정보를 기입하는 부분입니다. 
이전 시간에는 CPU 에서 Particle 구조체의 정보들을 다 계산해서 GPU로 넘겨주는게 아닌 기본 형태만 잡아서 넘겨주고 그 안의 데이터는 GPU u 레지스터에서 계산해 채운다음
그걸 다시 t 레지스터로 넘겨서 데이터를 활용해 물체들을 그렸습니다. 


이 방법 말고 그냥 CPU에서 계산을 해서 넘겨주는 방법을 사용하고 싶을때 사용하는 또 하나의 방법이 더 있습니다.

Mesh::Render 코드입니다. 
void Mesh::Render(uint32 instanceCount)
{
	GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, instanceCount, 0, 0, 0);
}

여기서 사실 IASetVertexBuffers 라는 함수는 슬롯을 0 에서 15 개 까지 사용할수 있다고 주석에서 알려줍니다. 
이 함수의 3개의 인자는 각각 시작 슬롯, 사용할 뷰의 갯수, 사용할 뷰의 포인터 이렇게 입니다. 즉, 두번째 인자인 1 이 사용할 버퍼의 갯수를 뜻합니다. 

그래서 이번 테스트에서는 총 두개의 Vertex Buffer 를 사용해서 첫 버퍼는 원래 사용하던 정점데이터를 넘겨주고 
두번째 버퍼에는 각 물체의 포지션 정보를 넘겨줄것입니다.

이러면 파티클 시스템 처럼 간단한 물체 말고도 범용적인 물체에 적용하는 방법입니다. 


- 코드 

우선 새로운 타입의 버퍼를 만들겁니다. 지금까지 사용하던 버퍼의 종류는 Constant Buffer, Structured Buffer 였는데 여기에 더해서 
인스턴싱에 사용되는 버퍼이니 만큼 Instancing Buffer 라고 만들것입니다. 


1) InstancingBuffer

우선 인스턴싱으로 그리는 여러 물체들을 각각이 들고 있을 정보를 struct 로 가지고 있을겁니다. 

struct InstancingParams
{
	Matrix matWorld;
	Matrix matWV;
	Matrix matWVP;
};

이번 테스트에서는 각 물체들을 조금씩 다른 위치에 만들기 위해서 트랜스폼 행렬들을 가지고 있을겁니다. 

다음으로 헤더 코드들을 보겠습니다. 
class InstancingBuffer
{
public:
	InstancingBuffer();
	~InstancingBuffer();

	void Init(uint32 maxCount = 10);

	void Clear();
	void AddData(InstancingParams& params);
	void PushData();

public:
        uint32					GetCount() { return static_cast<uint32>(_data.size()); }
	ComPtr<ID3D12Resource>		        GetBuffer() { return _buffer; }
	D3D12_VERTEX_BUFFER_VIEW	        GetBufferView() { return _bufferView; }

        void	                                SetID(uint64 instanceId) { _instanceId = instanceId; }
        uint64	                                GetID() { return _instanceId; }

private:
	uint64					_instanceId = 0;
	ComPtr<ID3D12Resource>		        _buffer;
	D3D12_VERTEX_BUFFER_VIEW	        _bufferView;

        uint32			                _maxCount = 0;
	vector<InstancingParams>	        _data;
};

멤버 변수는 각 인스턴스들을 구별할 ID, 리소스인 버퍼 그리고 그 버퍼를 묘사하는 뷰가 있습니다. 
그리고 인스턴싱을 몇개를 할지 정하는 카운트도 있고 각 인스턴스의 파라미터를 저장한 인스턴싱파라미터 타입의 벡터도 있습니다. 

멤버 함수는 초기화 함수, 파라미터가 있는 벡터를 클리어하는 함수, 파라미터를 추가하는 함수, 인스턴싱 버퍼의 데이터들을 DescriptorHeap 에 세팅할 푸시 함수,
그리고 멤버 변수들을 꺼낼수 있는 각종 Get 함수들이 있습니다. 

이제 정의부 코드를 보면서 자세한 내용을 보겠습니다. 
우선 생성자 소멸자 함수는 그냥 비어있습니다. 

처음으로 살펴볼 함수는 Init 입니다. 이 함수는 인자로 maxCount (기본값 10) 이라는 unsigned int 32 바이트 짜리 를 받고 있습니다.

void InstancingBuffer::Init(uint32 maxCount)
{
	_maxCount = maxCount;   // 인스턴싱 하고 싶은 만큼 인자로 넣어주면 됩니다. 

	const int32 bufferSize = sizeof(InstancingParams) * maxCount;   // 버퍼 사이즈도 인자만큼의 크기로 만들고 있습니다. 
	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

	DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&_buffer));
}

이렇게 원하는 크기의 버퍼를 일단 만들었습니다. 

다음으로 각 인스턴스에서 필요한 파라미터들을 AddData 로 _data 에 push_back 해주고 있습니다. 
void InstancingBuffer::AddData(InstancingParams& params)
{
	_data.push_back(params);
}

이 데이터들을 싹 밀어주는 함수
void InstancingBuffer::Clear()
{
	_data.clear();
}

이 두 함수를 가지고 한 프레임마다 시작할때 이전 데이터를 싹 clear 해주고 난 다음 사용할 데이터를 AddData 해주는 사이클입니다.
해당 프레임에서 필요한 데이터를 모두 추가해주고 난다음에는 렌더를 하기전에 추가된 데이터를 DescriptorHeap에 푸시 해줄것입니다. 

void InstancingBuffer::PushData()
{
	const uint32 dataCount = GetCount();
	if (dataCount > _maxCount)
		Init(dataCount);

	const uint32 bufferSize = dataCount * sizeof(InstancingParams);

	void* dataBuffer = nullptr;
	D3D12_RANGE readRange{ 0, 0 };
	_buffer->Map(0, &readRange, &dataBuffer);
	memcpy(dataBuffer, &_data[0], bufferSize);
	_buffer->Unmap(0, nullptr);

	_bufferView.BufferLocation = _buffer->GetGPUVirtualAddress();
	_bufferView.StrideInBytes = sizeof(InstancingParams);
	_bufferView.SizeInBytes = bufferSize;
}

dataCount 에 GetCount() 의 값을 담아서 현재 _maxCount 와 비교를 해주고 있습니다. GetCount() 는 _data의 사이즈를 리턴하는 함수로 
처음 초기화 했을때 보다 더 많은 인스턴싱파리미터를 추가했다면 그 크기로 다시 초기화를 해서 버퍼의 크기를 늘려주는 코드입니다. 

그리고 버퍼의 사이즈를 다시 한번 재주고
dataBuffer 포인터에 {0, 0} 의 엑세스 할 메모리 범위와 0번 인덱스의 하위 리소스의 메모리 주소를 받습니다.
(잘 이해가 가지않고 일단은 그냥 dataBuffer 라는 포인터에 메모리의 주소를 담는다고 이해했습니다.)

memcpy 로 데이터를 메모리에 복사해준다음 Unmap으로 연결했던 메모리를 닫습니다.

그리고 그 밑 코드는 나중에 렌더링을 할때 필요한 버퍼의 뷰의 정보들을 미리 기입을 해놓는 부분입니다. 

InstancingBuffer 는 이정도로 마무리 할것입니다. 사실 강의를 들을 때마다 각 부품들을 모두 유기적으로 연결되어있어서 각각 부품만 때고 보면 잘 느낌이 안옵니다. 

다음으로 만들것은 이 인스턴싱을 어디서 그려줄 것인가 인데 지금까지 모든 물체들은 카메라에서 그려주고 있었습니다. 
sort 함수로 각각 Deferred, Forward, Particle 끼리 모아주고 각각 렌더링을 해주었습니다. 

그런데 인스턴싱으로 만든 똑같은 물체끼리 묶어서 관리하는 것은 어디서 해야 할까를 생각해봤습니다.

그래서 Manager 필터아래에 InstancingManager 라는 클래스를 만들겠습니다.


2) InstancingManager

이 인스턴싱 매니저가 하는 역할이 무엇이냐면 
먼저 방금 만든 인스턴싱버퍼는 한번에 여러 물체를 그려내는 버퍼이고 이런 인스턴싱 버퍼가 항상 하나만 존재해야하는것은 아닙니다. 
인스턴싱으로 10개의 물체를 그려주는데 그런 인스턴싱 버퍼가 또 10개가 있을 수 있습니다.
이런 인스턴싱 버퍼를 관리하는 매니저라고 할 수 있습니다. 

헤더 코드는 이렇습니다. 
#pragma once
#include "InstancingBuffer.h"   // AddParam 에서 데이터를 추가해줄때 필요해서 include

class GameObject;

class InstancingManager
{
	DECLARE_SINGLE(InstancingManager);      // 어디서든 싱글톤으로 호출하기위함

public:
	void Render(vector<shared_ptr<GameObject>>& gameObjects);

	void ClearBuffer();
	void Clear() { _buffers.clear(); }

private:
	void AddParam(uint64 instanceId, InstancingParams& data);

private:
	map<uint64/*instanceId*/, shared_ptr<InstancingBuffer>> _buffers;       // 인스턴싱버퍼들을 관리하는 Map
        /*인스턴스아이디가 등장하는데 이게 필요한 이유는 인스턴싱버퍼로 그려주는 물체끼리 구별하기 쉽지 않을 때가 있습니다. 똑같은 IA 데이터, ConstantBuffer,
        셰이더 코드를 사용하는 물체들을 서로 다른 인스턴싱버퍼로 관리할때 그것들을 구분하게 해주는 아이디 입니다. 
        */
};

자세한 내용은 정의부를 보면서 하겠습니다. 
인스턴싱 매니저의 렌더 함수는 카메라::렌더 같이 게임오브젝트들을 정렬하고 같은 종류끼리 렌더링 하게끔 하는것이 아니라 그냥 관리하는 모든 게임오브젝트를 
전부 렌더링하라고 떠넘기는 형태입니다. 그러면 인스턴싱매니저::렌더 내부에서 그려줄 오브젝트들을 분류해줘야 하는데 그것을 cache 라는 임시 map을 만들어서 
담고 그 map의 value의 사이즈로 분류를 하고 있습니다.
void InstancingManager::Render(vector<shared_ptr<GameObject>>& gameObjects)
{
	map<uint64, vector<shared_ptr<GameObject>>> cache;
	// 임시 map 

	for (shared_ptr<GameObject>& gameObject : gameObjects)	
	{
		const uint64 instanceId = gameObject->GetMeshRenderer()->GetInstanceID();	// 나중에 MeshRenderer에 추가해줄 GetInstanceID
		cache[instanceId].push_back(gameObject);		// cache에 오브젝트의 벡터 담기 
	}

	for (auto& pair : cache)		// key: instanceId, vlaue: vector<shared_ptr<GameObject>> 인 cache 라는 map을 순회하면서 pair 라는 변수에 담아줍니다.
	{
		const vector<shared_ptr<GameObject>>& vec = pair.second;	
		// 이때 pair는 map의 원소 하나입니다. 그 중 value 부분을 vec 에 받아줍니다. 

		if (vec.size() == 1)	// 벡터의 사이즈가 1 이다 즉 이 인스턴싱버퍼로 물체 하나만 그려준다
		{
			vec[0]->GetMeshRenderer()->Render();	// 인스턴싱 할것없이 그냥 MeshRenderer 로 렌더링 이 함수는 카메라에서 물체를 그려줄때 호출하는 함수
		}
		else	// 다수의 오브젝트를 담은 vec 입니다. 이부분이 인스턴싱 렌더링
		{
			const uint64 instanceId = pair.first;	// 인스턴스 아이디를 받아주고 있습니다. 

			for (const shared_ptr<GameObject>& gameObject : vec)
			{
				InstancingParams params;	
				params.matWorld = gameObject->GetTransform()->GetLocalToWorldMatrix();
				params.matWV = params.matWorld * Camera::S_MatView;
				params.matWVP = params.matWorld * Camera::S_MatView * Camera::S_MatProjection;
				// InstancingBuffer 에서 만들었던 구조체 InstancingParams 의 내용을 각 게임오브젝트가 들고 있을 변환행렬들을 담아주고 있습니다.

				AddParam(instanceId, params);	// _params 에 추가하고 변환행렬들을 저장

			}

			shared_ptr<InstancingBuffer>& buffer = _buffers[instanceId];
			vec[0]->GetMeshRenderer()->Render(buffer);		// 아직 MeshRenderer::Render 에 인자를 받고 있지 않은데 수정할 것
		}
	}
}

// 282 줄의 AddParam 함수 
void InstancingManager::AddParam(uint64 instanceId, InstancingParams& data)
{
	if (_buffers.find(instanceId) == _buffers.end())	// 혹시 이미 해당 아이디가 있는지를 찾습니다. 
		_buffers[instanceId] = make_shared<InstancingBuffer>();	// 없다면 생성 

	_buffers[instanceId]->AddData(data);	// 해당 아이디의 InstancingBuffer->AddData 호출
}

위의 코드들이 매 프레임마다 호출될것이기 때문에 매프레임 밀어줄 필요가 있습니다. 
void InstancingManager::ClearBuffer()
{
	for (auto& pair : _buffers)
	{
		shared_ptr<InstancingBuffer>& buffer = pair.second;
		buffer->Clear();
	}
}


이제 다음으로 할 작업은 InstancingManager 의 정의부에서 에러가 몇개 떠있었는데 그걸 하나씩 고쳐나갈겁니다. 
먼저 MeshRenderer 에서 GetInstanceID 라는 함수로 인스턴스 아이디를 꺼내오고 있던걸 만들어 줄겁니다. 


3) MeshRenderer
  이런 함수를 새로 파줄겁니다. 

	uint64 GetInstanceID();

인스턴싱에서 사용되는 고유한 아이디는  어떻게 구현해줘야할지 여러 방법이 있을겁니다. 해당 오브젝트의 어떤 주소값을 가져다가 그걸 활용해서 부여한다던지
그럴 수 도 있지만 이번에 사용할 방법은 mesh 와 material 의 아이디를 관리할 InstanceID 라는 구조체를 만드는데 앞으로 각 mesh, material 의 아이디를 부여해서 
관리하는 방법으로 할것입니다.  

uint64 MeshRenderer::GetInstanceID()
{
	if (_mesh == nullptr || _material == nullptr)
		return 0;

	//uint64 id = (_mesh->GetID() << 32) | _material->GetID();
	InstanceID instanceID{ _mesh->GetID(), _material->GetID() };
	return instanceID.id;
}

이 코드는 빠진것들이 있습니다. 일단 InstanceID 라는 구조체부터 만들어 주겠습니다. 

// [32][32]
union InstanceID
{
	struct
	{
		uint32 meshID;
		uint32 materialID;
	};
	uint64 id;
};

union 이란것을 활용하고 32 비트 크기들로 아이디들을 받아주고 있는데 그 이유는 Mesh, Material 각각 32 비트씩 해서 64 비트 크기로 받아주려고 그렇습니다. 
이런 방식 말고는 비트 플레그를 이용한 방법
	//uint64 id = (_mesh->GetID() << 32) | _material->GetID();
이런게 있습니다. 

비트 플레그로 사용하는게 어려울 수 있어서 union 이라는 문법으로 만든것인데 이렇게 만들면 결국은 이 구조체는 64비트의 uint 인건 맞는데 
한번에 64 짜리 id 를 입력하나 아니면 32 비트 씩 쪼개서 하위 id들로 만드나 같은 의미가 된다는 점이 편리합니다. 

이제 Mesh 와 Metarial 의 GetID를 어떻게 만들어 줄것이냐를 생각 해보겠습니다. 각각의 클래스마다 새로 함수를 파주는 방법도 있겠지만 이 두 클래스는 공통의 부모 클래스가 있습니다.
Object 클래스인데 여기서 GetId 를 파주면 이걸 상속받는 클래스들은 모두 자신만의 ID를 가지게 될것입니다. 

3-1) Object

Object 클래스내에 추가해줄 코드들입니다. 

// Object.h
{
public:
	uint32 GetID() { return _id; }

protected:
	uint32 _id = 0;
}

// Object.cpp
{
	Object::Object(OBJECT_TYPE type) : _objectType(type)
	{
		static uint32 idGenerator = 1;
		_id = idGenerator;
		idGenerator++;
	}
}

자식 클래스들이 각자 uint32 크기의 아이디를 들고 있게 해주고 외부에서 꺼내 사용할 수도 있게 해주었습니다. 그냥 0 으로 초기화 해준 상태에서는 모든 오브젝트들의 
아이디가 0 일것이기 때문에 각자 다른 값을 지니게 하기 위해 idGenerator 를 Object 의 생성자에 만들어 줬습니다. 1 오브젝트가 생성되는 순서대로 1부터 하나씩 커지면서 
할당됩니다.
이렇게 아이디를 구현했을 경우 문제점도 있을겁니다. 1씩 더해가면서 아이디를 부여하다 보니 uint32 의 크기를 넘어가면 어떻게 되냐는지 한번 생성됐던 아이디가 
소멸하면 그 아이디는 영구 결번인 상태로 있어야 하는지 등등 입니다. 일단은 아이디를 간단하게 구현한다는 것에 의미를 두겠습니다. 

이제 Mesh 와 Material 은 각자의 아이디가 있는데 이 두개를 이어붙인 InstanceID 는 어떤 물체가 Mesh 와 Material 이 똑같다면 같은 인스턴싱 물체라고 보겠다는 의미입니다.


4) InstancingManager
다시 인스턴싱매니저로 돌아와서 보면 

InstancingManager::Render 에서 처음에 cache 라는 map 에 같은 인스턴싱 버퍼끼리 담아놓을때 사용할 InstanceID 를 지금 구현한것입니다. 

이제 다음으로 수정할 코드는 렌더링을 하는 부분입니다. 그 중에서 cache[instanceID].second.size() 를 체크해서 1이상인경우 인스턴싱을 사용하는 경우의 
렌더링을 하는 부분을 수정해야 합니다.

이제는 렌더링을 하는 방법이 두가지가 된다고 볼 수 있습니다. 


5) MeshRenderer

카메라에서의 하나의 물체만 그리는 기존의 렌더링 방식이 있고 
// MeshRenderer.h
	void Render();

// MeshRenderer.cpp
void MeshRenderer::Render()
{
	GetTransform()->PushData();

	_material->PushGraphicsData();
	_mesh->Render();
}

여기에 추가적으로 인자로 InstancingBuffer 의 shared_ptr 을 받는 Render 함수를 오버로딩 해서 만들겠습니다. 
// MeshRenderer.h
	void Render(shared_ptr<class InstancingBuffer>& buffer);

// MeshRenderer.cpp
void MeshRenderer::Render(shared_ptr<InstancingBuffer>& buffer)
{
	buffer->PushData();
	_material->PushGraphicsData();
	_mesh->Render(buffer);
}

기존의 렌더 함수에서 오브젝트 자신의 트랜스폼을 푸시해주는 방법을 다시 살펴보면 월드 뷰 프로젝션 등의 변환 행렬을 담아서 GPU b1 레지스터에 넘겨 주었습니다.

그런데 한번에 그려져야하는 인스턴싱하는 물체들은 이 b1 레지스터에 데이터를 받는게 아니라 VS_IN 에서 정보들을 받아줘야합니다. 
(IA 단계에서 한번에 넘겨주는것 같습니다. 나중에 셰이더 파일도 수정할것입니다.)
그래서 인스턴싱 렌더 함수는 트랜스폼 데이터를 따로 푸시하지 않고 바로 버퍼를 푸시 해줍니다. 
다음으로 Material 은 당연히 푸시 되어야 합니다. 여기서는 물체를 그릴때 필요한 정보들이 있었습니다. 텍스쳐라던지 사용할 셰이더의 종류같은 것들 입니다.
그러고 나서 _mesh->Render() 를 해주는데 여기에 인자로 buffer 를 줍니다. 이 인자를 받는 버전의 Mesh::Render 는 아직 없고 이어서 좀 있다 만들어 줄겁니다. 

/*
InstancingBuffer::PushData 가 어땠는지 긴가 민가 해서 복습을 합니다. 프레임이 갱신되면서 먼저 clear로 밀어준다음 넘겨줄 데이터(파라미터) 들을 AddData 
로 전부 밀어넣고 난 다음 이 데이터를 푸시 해주는데 이때 초기화할때보다 데이터가 많을경우 다시 버퍼 사이즈를 갱신하고 다시 Init 해줍니다. 
그리고 _data 들을 _buffer 에 memcpy 해줍니다. 마지막으로 _bufferView 의 BufferLocation, StrideInBytes, SizeInBytes 값들을 넣어줍니다.
*/

이렇게 렌더링에 필요한 데이터를 모두 푸시 해줬다고 하면 _mesh->Render를 해줄것입니다.

5) Mesh
기존에는 Mesh::Render 가 하나밖에 없었습니다. 인자로 instanceCount = 1 을 받아주고 있는 버전이었습니다. 
이 버전도 파티클 시스템에서 인스턴스 카운트를 설정할 수 있게 만들어서 간접적으로 인스턴싱을 활용하고 있기는 했습니다. 
하지만 이 버전은 VertexBuffer 를 하나만 넣어주는 버전이었고 
이번 시간의 인스턴싱을 사용하는 버전은 이부분도 달라지게 됩니다. 

//Mesh.h

	void Render(shared_ptr<class InstancingBuffer>& buffer);

인스턴싱 버퍼를 인자로 받는 버전을 선언 했습니다. 이어서 정의부입니다. 

// Mesh.cpp

void Mesh::Render(shared_ptr<InstancingBuffer>& buffer)
{
	D3D12_VERTEX_BUFFER_VIEW bufferViews[] = { _vertexBufferView, buffer->GetBufferView() };
	// VertexBufferView 를 두개 짜리 배열로 받아줍니다. 
	GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 2, bufferViews);
	// 그리고 IA 에 정점 버퍼를 세팅할때 두개를 설정합니다. 2번째 인자가 버퍼의 갯수, 3번째로 정점버퍼 두개가 담겨있는 배열
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, buffer->GetCount(), 0, 0, 0);
	// 이 물체를 몇개 그려줄것인지 Count를 가져와서 설정해줍니다.
}

그런데 이때 IA에서 받을 정점 버퍼를 그냥 늘려주기만 하면 되는것이 아니고 셰이더에서 받을 데이터를 묘사해주는 부분이 있었습니다. 
Shader::CreateGraphicsShader 입니다. 여기서 IA떄 넘겨줄 데이터를 묘사하는 D3D12_INPUT_ELEMENT_DESC 가 있엇습니다. 

6) Shader

	D3D12_INPUT_ELEMENT_DESC desc[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 20, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 32, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },

		{ "W", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0,  D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "W", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 16, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "W", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 32, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "W", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 48, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 64, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 80, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 96, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 112, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 128, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 144, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 160, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 176, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
	};

추가되는 데이터가 월드 , 월드*뷰, 월드*뷰*프로젝션 변환행렬을 넘겨주고 있습니다. InstancinBuffer의 _data 였습니다.	
그런데 왜 행렬들을 float4를 4개로 넘겨주고 있냐면 float 4개를 한번에 넘겨줄 방법이 없어서 나눠서 넘겨주고 있는겁니다. 
그리고 7번째 인자가 PER_VERTEX_DATA 가 아니라 PER_INSTANCE_DATA 로 되어 있습니다. 이건 인스턴싱을 진행할때마다 하나씩 데이터를 배정이 된다고 합니다. 

또 한가지 눈여겨 볼 점은 넘겨주는 각 원소들의 4번째, 8번째 인자가 1로 바뀌어 있습니다. 
D3D12_INPUT_ELEMENT_DESC 의 코드를 살펴보면

typedef struct D3D12_INPUT_ELEMENT_DESC
    {
    LPCSTR SemanticName;
    UINT SemanticIndex;
    DXGI_FORMAT Format;
    UINT InputSlot;
    UINT AlignedByteOffset;
    D3D12_INPUT_CLASSIFICATION InputSlotClass;
    UINT InstanceDataStepRate;
    } 	D3D12_INPUT_ELEMENT_DESC;

4번째 인자가 InputSlot 인걸 알 수 있는데 셰이더 파일에 인풋으로 넣을수 있는 슬롯이 0번에서 15번까지 있던것중에 1번 슬롯을 사용하겠다는 의미가 됩니다. 
이전 내용과 같이 보면 Position, TEXCOORD, Normal, Tangent 를 담은 버퍼가 0번슬롯 World, World*View, World*View*Projection 변환 행렬을 담은 버퍼가 1번 슬롯에
넘겨지는데 이렇게 각각 다른 버퍼에 담겨있는걸 묘사하는 Description 인겁니다. 

이렇게 해주면 이제 아까 Mesh::Render 중에 인스턴싱버퍼를 인자로 받는 버전에서 정상적으로 셰이더로 데이터를 넘겨 줄 수 있게되었습니다. 
여기까지가 CPP 코드 입장이고 셰이더 파일에서는 또 버퍼를 건내주는대로 잘 받아야 합니다. 


7) deferred.fx

인풋을 받아주는 VS_IN 입니다.
struct VS_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;

    row_major matrix matWorld : W;
    row_major matrix matWV : WV;
    row_major matrix matWVP : WVP;
    uint instanceID : SV_InstanceID;
};

기존의 정보들 외에 3가지 변환 행렬들을 받아주고 난 뒤에 각 인스턴싱으로 그려질 물체들에 발행할 SV_InstanceID 도 들고 있을겁니다.

받는 정보가 달라졌으니 함수도 달라집니다. 
기존에 물체를 한개씩 그려주는 경우는 변환행렬들을 Transform Params (b1) 에 담아서 글로벌에서 접근해 사용했습니다. 
이부분을 이제 둘로 쪼개 줄겁니다. 글로벌 변환행렬을 사용하는 방법과 인풋의 변환행렬을 사용하는 방법으로 쪼갤겁니다. 

그런데 어떻게 둘을 구별할지를 생각 해봐야 합니다. 지금 그리는 물체가 한개만 그리는 물체인지 인스턴싱이 적용된 물체인지를 
Material Params 의 g_int_0 에 값에 따라 구별하는 방법으로 해보겠습니다.

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    if (g_int_0 == 1)		// 인스턴싱이 적용된 버전
    {
        output.pos = mul(float4(input.pos, 1.f), input.matWVP);
        output.uv = input.uv;

        output.viewPos = mul(float4(input.pos, 1.f), input.matWV).xyz;
        output.viewNormal = normalize(mul(float4(input.normal, 0.f), input.matWV).xyz);
        output.viewTangent = normalize(mul(float4(input.tangent, 0.f), input.matWV).xyz);
        output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));
    }
    else					// 인스턴싱이 적용 안된 버전
    {
        output.pos = mul(float4(input.pos, 1.f), g_matWVP);
        output.uv = input.uv;

        output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;
        output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);
        output.viewTangent = normalize(mul(float4(input.tangent, 0.f), g_matWV).xyz);
        output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));
    }

    return output;
}

이렇게 해서 인스턴싱이 되는 물체들의 변환 행렬들을 버퍼에 담아서 IA 세팅때 넘겨줄 수 있도록 하였습니다. 

실제로 동작하는지 조립을 해봐야하는데 
우선 Camera 클래스로 가보겠습니다. 


8) Camera
인스턴싱되는 물체들은 InstancingManager 에서 관리를 해준다고 했지만 결국 게임오브젝트는 Scene에 담겨서 카메라에 찍히는 물체들을 그려주는 것이기 때문에 
카메라 클래스에서 조립을 해줘야 합니다. 

다시 카메라 클래스에서 렌더링을 해주는 과정을 떠올려보면 가장 먼저 sorting 으로 이 물체가 사용하는 셰이더가 Deferred 인지 Forward 인지 Particle 인지를 
정렬해줍니다. 그 중에서 Deferred 오브젝트를 그려주는 부분이 수정될겁니다. 

void Camera::Render_Deferred()
{
	S_MatView = _matView;
	S_MatProjection = _matProjection;

	GET_SINGLE(InstancingManager)->Render(_vecDeferred);
}

이전에는 _vecDeferred 의 게임오브젝트들을 for 문 돌면서 그려줬었는데 InstancingManager::Render 의 인자로 _vecDeferred 를 줘서 렌더링을 해줍니다. 
이러면 뭐가 달라진거냐면 물체가 예전처럼 하나만 그려줄때가 있을것이고 이번시간에 배운 인스턴싱이 적용된 물체도 있을것인데 그걸 InstancingManager 에서
걸러서 해당하는 방법으로 그려주게 됩니다.

그리고 파티클 같은 경우에는 기존의 방식을 사용하지만 Forward 같은경우도 InstancingManager 를 통해서 그려지도록 변경해주겠습니다.

void Camera::Render_Forward()
{
	S_MatView = _matView;
	S_MatProjection = _matProjection;

	GET_SINGLE(InstancingManager)->Render(_vecForward);

	for (auto& gameObject : _vecParticle)
	{
		gameObject->GetParticleSystem()->Render();
	}
}

이제는 원래대로 Client 에서 게임 엔진을 업데이트 할 때 마다 SceneManager 를 업데이트하고 Engine::Render 를 호출합니다. 
Engine::Render 에서는 RenderBegin() RenderEnd() 로 커맨드큐 에서 랜더링 할 준비를 열고 닫는데 이 사이에 그려줄 물체들을 커맨드 리스트에 밀어넣어주면 됩니다.
그 부분이 SceneManager::Render 인데 이 함수의 역할은 현재 활성화된 Scene 의 Render를 불러주는 역할만 있습니다. 
Scene::Render 에서 하는 일은 먼저 PushLightData() 현재 Scene의 게임 오브젝트들 중 _lights 들을 셰이더로 넘겨주기 위한 LightParams 에 차례대로 담는 함수입니다. 
이때 _lights 는 scene 에서 게임오브젝트들을 추가할 때 그 오브젝트가 Light 라는 Component 를 가지고 있다면 _lights 로 담습니다. 
다음으로 스왑체인, 디퍼드, 포워드 를 초기화 하고 디퍼드 그룹을 OMSetRenderTargets 해준 다음 메인카메를 렌더링 해줍니다. 

이때 Camera::Render() 가 이제는 SortGameObject() 와 Render_~~~ 으로 나뉘었엇습니다. 이때 직접 카메라에서 Render를 SceneManager 를 싱글톤으로 가져와서 
그 안의 오브젝트들을 직접 Render 해줬었는데 그걸 이제는 중간에 InstancingManager 를 거쳐서 각각 게임오브젝트가 인스턴싱이 적용된 오브젝트인가 아닌가를 구별한다음 
그려주고 있습니다. 

즉, Camera 와 MeshRenderer 사이에 InstancingManager 가 추가되었습니다.

그런데 지금 코드에서는 InstancingBuffer 를 매 프레임 마다 clear 해주는 부분이 없습니다. 이걸 해줘야 프레임마다 물체들이 계속 그려지는걸 막을 것입니다. 


9) Engine.cpp
그 인스턴싱버퍼들을 clear 하는걸 어디서 해줄까 생각하다가 일단은 그냥 Engine::Update 에 넣어줘서 프레임 시작해서 업데이트 할때 초기화를 시켜주겠습니다.

// Engine.cpp

#include "InstancingManager.h"

void Engine::Update()
{
	GET_SINGLE(Input)->Update();
	GET_SINGLE(Timer)->Update();
	GET_SINGLE(SceneManager)->Update();
	GET_SINGLE(InstancingManager)->ClearBuffer();

	Render();

	ShowFps();	
}

여기서 호출하는 ClearBuffer 함수는 인스턴싱된 물체들 자체를 밀어주겠다는게 아니고 그 물체들의 _data 세가지 변환행렬이 담긴 버퍼를 밀어주겠다는 의미입니다. 

매프레임 마다 인스턴싱 버퍼들을 새로 만든다는게 아니고 그냥 인스턴싱된 물체들의 변환행렬들을 날려주고 밀어준다는 말입니다. 

이제는 인스턴싱 기능을 만들었고 또 그걸 카메라에 연결했습니다. 

다음으로 할 일은 테스트를 위한 물체를 만들어줄것입니다. 물체는 항상 SceneManager::LoadTestScene 에서 만들어 줬었습니다. 


10) SceneManager 
이전 코드를 조금 수정할건데 이전 시간에 사용했던 파티클시스템은 이제 잠시 없애주고 
사용하던 조명도 디렉셔널 라이트 한가지를 사용했었습니다 그리고 그 Diffuse 값을 빨간색(1.f, 0.f, 0.f)으로 정해뒀었는데 이번엔 그냥 하얀색(1.f,1.f,1.f)으로
바꿔주었습니다. 

그리고 기존의 Object 고 Leather 텍스쳐를 입은 구체를 그려주고 있었는데 이걸 인스턴싱을 적용시켜서 50개를 그려줘 보겠습니다. 
#pragma region Object
	for(int i = 0; i < 50 ; i++)
	{
		shared_ptr<GameObject> obj = make_shared<GameObject>();
		obj->AddComponent(make_shared<Transform>());
		obj->GetTransform()->SetLocalScale(Vec3(25.f, 25.f, 25.f));			// scale 을 100 에서 25 로 낮췄습니다. 
		obj->GetTransform()->SetLocalPosition(Vec3(-300.f + i * 10.f, 0.f, 500.f));	//	포지션도 조금씩 움직이면서 나열되도록 해줬습니다.
		shared_ptr<MeshRenderer> meshRenderer = make_shared<MeshRenderer>();
		{
			shared_ptr<Mesh> sphereMesh = GET_SINGLE(Resources)->LoadSphereMesh();
			meshRenderer->SetMesh(sphereMesh);
		}
		{	// 물체들이 같은 인스턴스 라고 인식하기 위해서는 같은 메쉬와 같은 마테리얼을 사용해야 한다고 했습니다. 메쉬는 리소시즈 에서 만들어둔 리소스를 가져다 
			// 사용하기 때문에 같은 메쉬라고 인식이 되고 마테리얼은 이전에는 직접 만들어서 사용했었는데 그러면 50개의 각자 다른 마테리얼이 만들어 집니다. 
			// 이걸 해결하기위해 마테리얼도 리소시즈에서 만들고 그걸 가져와서 적용 시켰습니다.
			shared_ptr<Material> material = GET_SINGLE(Resources)->Get<Material>(L"GameObject");
			material->SetInt(0, 1);		// int 0 번슬롯에 1 이라는 값을 준 이유는 셰이더 파일에서 이 물체가 인스턴싱이 적용된걸 인식하기위해 조건문을 달았는데 
										// 그것 때문입니다.
			meshRenderer->SetMaterial(material);
			// 이전 버전과 비교하기 위한 주석 버전
			//material->SetInt(0, 0);
			//meshRenderer->SetMaterial(material->Clone());
		}
		obj->AddComponent(meshRenderer);
		scene->AddGameObject(obj);
	}
#pragma endregion

material 을 세팅할때 SetInt(0, 1) 인 버전은 인스턴싱을 적용한 버전었고 
주석처리된 SetInt(0, 0) 인 버전일 경우는 어떻게 되는지 보겠습니다. 
			
		material->SetInt(0, 0);
		meshRenderer->SetMaterial(material->Clone());

Mateiral 클래스에서 못보던 메소드 Clone 이 있습니다. 이건 리소스로 만든 default material 을 각 게임 오브젝트마다 개별 material 을 할당해줘야 하기때문에 
만든 메소드입니다. 왜 개별로 할당해줘야 하냐면 같은 마테리얼을 공유할때는 개별 하나만 수정해도 모든 게임오브젝트에 영향이 가기 때문입니다. 포인터 같이
이런 문제를 고려해서 각 마테리얼이 개별 할당되도록 해야합니다. 


10-1) material

shared_ptr<Material> Material::Clone()
{
	shared_ptr<Material> material = make_shared<Material>();

	material->SetShader(_shader);
	material->_params = _params;
	material->_textures = _textures;

	return material;
}
사용하는 셰이더 파라미터 텍스쳐는 똑같이 사용할건데 make_shared 로 만들어줘서 각각의 메모리를 할당받고 다시 반환하는 함수입니다. 


11) Resources
게임 오브젝트를 같은 인스턴스로 적용시키기 위해 리소스로 저장된 마테리얼을 모두 할당해줘야 했습니다. 

// Resources::CreateDefaultMaterial

	// GameObject
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Deferred");
		shared_ptr<Texture> texture = GET_SINGLE(Resources)->Load<Texture>(L"Leather", L"..\\Resources\\Texture\\Leather.jpg");
		shared_ptr<Texture> texture2 = GET_SINGLE(Resources)->Load<Texture>(L"Leather_Normal", L"..\\Resources\\Texture\\Leather_Normal.jpg");
		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);
		material->SetTexture(0, texture);
		material->SetTexture(1, texture2);
		Add<Material>(L"GameObject", material);
	}

인스턴싱에서 같은 마테리얼 객체를 들고 있기 위해 만들었습니다. 


12) 테스트 

인스턴싱이 아니라 그냥 개별 물체 50개를 그려주는 버전인 Material->SetInt(0,0) 을 실행해보니 제 컴퓨터로 420 정도의 프레임이 나왔습니다. 

다음은 인스턴싱을 적용하는 SetInt(0,1) 버전을 실행해봤습니다. 프레임이 550 정도 까지 나왔습니다. 
이때 Mesh랑 Material이 GET_SINGLE(Resources) 로 불러오기 때문에 50개의 물체가 같은 mesh, material 을 가지고 있습니다. 그러면 물체의 MeshRenderer::GetInstanceID() 에서 생성된 
Mesh와 Material 의 ID를 가지고 InstanceID 를 부여합니다. 이렇게 같은 InstanceID 를 가지게 되면 InstancingManager::Render 안에서 같은 인스턴스로 분류를 해주게 됩니다. 
하나의 인스턴스로 묶인 다음은 MeshRenderer::Render(shared_ptr<InstancingBuffer>) 인자로 인스턴싱버퍼를 인자로 받는 버전으로 실행이 됩니다. 그러면서 그려주는 50개의 
게임 오브젝트 각각의 변환행렬들을 푸시하고 다시 Mesh::Render(buffer) 를 실행합니다. 이 때 물체의 인스턴싱 버퍼가 가지고 있던 Count, 인스턴싱할 물체의 갯수를 
DrawIndexedInstanced 의 인자로 넘겨줘서 한번에 그려줍니다. 

이 옵션을 on/off 하는것만으로 이렇게 성능의 차이가 생겼습니다. 

두 버전은 DrawIndexedInstanced 를 호출하는 횟수의 차이가 있습니다. 

결국은 예를들어 하나의 물체를 그릴때마다 붓을 바꿔가면서 그려주는게 큰 시간이 들어가는 방식이었습니다. 각 물체를 그려줄때마다 CPU 와 GPU의 동기화를 해야하는 순간 이 둘 사이의 
데이터 전송속도가 한계가 되어서 GPU의 성능에 상관없이 시간을 잡아먹게 됩니다. 
반면 인스턴싱을 활용하는 방법에서는 맨처음 IA 에서는 큰 데이터를 넘겨줘야하지만 한번 넘겨준다음에는 GPU안에서 성능을 제대로 사용해서 처리해줄수 있게 됩니다.

이렇게 해서 이번 강의 내용은 마쳤습니다. 

그런데 여기에서 추가적으로 FPS 로 성능을 확인하는 방법 말고 다른 방식으로 확인 해보고 싶습니다. 	


13) 추가 내용
CPU 코드를 디버깅할때는 중단점을 걸어서 코드를 조금씩 진행시키면서 뜯어 볼 수 있었는데 셰이더 파일은 이게 안됩니다. 

DX11 까지는 비쥬얼스튜디오의 그래픽 디버깅 이라는 디버깅방법으로 하면 비슷하게 볼 수 있었다고 하는데 DX12 부터 이게 실행이 안된다고 합니다. 

그래서 비슷한 효과를 볼 수 있는 외부 프로그램의 도움을 받을 겁니다. 

PIX on Windows 라는 프로그램이고 설치후 실행합니다. 그러면 제 환경이 AAA 급인지 인디 급인지 other 급인지 물어봅니다. 게임을 배우고 있는 중이기 때문에 other 를 선택했습니다
그다음 프로그램에서 Client.exe 의 경로를 줘야하는데 프로젝트 폴더의 output 폴더안에 있도록 설정이 되어있습니다. 경로를 설정하고 Launch 를 해주면 
비쥬얼 스튜디오 에서 실행하듯이 프로그램이 실행되고 다시 PIX 에서 Capture GPU 라는 버튼을 누르면 그 시점의 프로그램 화면과 프로그램의 모든 상태가 저장이 됩니다. 
우리 프로젝트 프로그램을 종료 시키고 이제 PIX 를 보겠습니다. 

PIX 에서 몇가지 창이 있는데 Overview 와 Pipeline 등등이 있습니다. 여기서 Pipeline 을 보면 실행된 과정들이 나오고 그중에서 오늘 중점적으로 다루었던 DrawIndexedInstanced 함수를
찾아보니 2천 몇, 50, 0, 0 이런 숫자가 괄호안에 들어있습니다. 여기서 맨앞의 숫자는 이 물체를 그릴때 정점의 수 이고 뒤의 50은 알다시피 반복해서 그린 횟수인것 같습니다. 
이 프로그램을 잘 찾아보면 셰이더 파일을 하나하나 뜯어 볼 수 있습니다. 

나중에 셰이더 디버깅이 정 안되겠다 싶으면 이 프로그램을 켜서 좀 더 자세히 들여다 보면 되겠습니다. 