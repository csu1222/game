

		9 . Material



# 이전시간의 보안점 

우선 Input 클래스에서 
enum
{
	KEY_TYPE_COUNT = static_cast<int32>(UINT8_MAX + 1),
	KEY_STATE_COUNT = static_cast<int32>(KEY_STATE::END),
};
KEY_TYPE_COUNT의 크기를 UINT8_MAX가 아니라 + 1 을 해줘야 한다고 합니다. UINT8_MAX는 255라는숫자이고 우리는 0번 인덱스 부터 사용할것이기 때문입니다.
사실상 256개를 사용한다고 볼수 있습니다.

다음 보안점으로 Input::Update에서 매 프레임마다 256번 GetAsyncKeyState함수를 호출하는것이 성능에 안좋은것 같습니다.
그래서 한번에 256개의 state를 긁어오는 API가 있어서 바꿔주려고 합니다.
	BYTE asciiKeys[KEY_TYPE_COUNT] = {};
	if (::GetKeyboardState(asciiKeys) == false)
		return;
GetKeyboardState라는 API입니다. false인지 체크하는것은 뭔가 문제가 있다는것이기 때문에 return을 해주었습니다. 
if를 통과했다면 별 문제 없이 GetKeyboardState가 실행된것이고 이건 for문을 돌면서 256번GetAsyncKeyState를 해준것과 같은 기능이라고 합니다.
그래도 asciiKeys 배열에 저장된 값들은 다를것이기 때문에 알아봐야겠습니다.

MS공식문서에서 찾아보면 매개변수로는 PBYTE타입의 배열인데 256개의 가상 키의 스테이트가 각각 들어간다고 합니다.
함수의 반환 타입은 bool로 성공하면 true, 실패하면 false를 반환한다고 합니다. 위의 if문에서 이미 알아 봤었습니다.
내용은 어플리케이션에서 이 함수를 호출하면 현재 가상키들의 state를 검색 할 수 있다.
배열의 각 멤버들은 그 키의 state를 나타내는데 만약 high-order bit is 1, 그 키는 down이다. 그렇지 않으며 up이다.
( 여기서 high-order가 무엇일까요? 1바이트를 비트로 나타내면 0000 0000 인데 이중 high-order인 비트 맨앞의 비트를 켜주게되면 
1000 0000 이러면 그 키가 다운이라는 것입니다. 이 바이트를 16진수로 나타내면 0x80 입니다.)
그래서 이전 코드에서는 
if (::GetAsyncKeyState(key) & 0x8000)
이렇게 down인지 up인지를 체크했는데 
if (asciiKeys[key] & 0x80) 
이라고 체크를 하면 되겠습니다.

이렇게 이전 시간의 코드를 조금 손봤습니다.
###


우선 오늘의 주제인 Material로 들어가기전에 이게 우리에게 왜 필요한지 부터 생각해 보겠습니다.

지난시간동안 Mesh, Shader, Texture 삼총사를 이용해가지고 간단한 사각형에 텍스쳐를 입히고 그 메쉬에서 사용할 쉐이더를 Init으로 경로를 지정해서 사용하기도 하고,
텍스쳐도 Init에 이미지 파일의 경로를 줘서 사용하기도 했습니다.

그런데 여기서 아쉬운점은 제가 물체하나만 만드는게 아니라 게임인 만큼 많은수의 물체들을 만들것이라고 가정을 해보겠습니다. 
그러면 적어도 물체가 수백 수천개가 넘어갈 텐데 그 물체 하나마다 Mesh, Shader, Texture를 만들고 서로를 연결하고 경로를 지정해주고 한다면 너무나도 비효율적일것입니다.
지금보다 좀 더 나은 방법을 찾으려고 합니다. 
그런데 우리 코드를 보면 Game::Update에서 GEngine->RenderBegin과 RenderEnd사이에서 쉐이더.업데이트, 쉐이더에 인자로 줄 Transform을 만들고 인풋을 받고, 
Transform과 Texture를 세팅하고 Mesh를 Render로 CMD_LIST에 담는것까지가 하나의 물체를 표현하기 위해서 연결된 것들입니다.
거기에 더해서 shader와 texture를 다른 shader로 계산하거나 다른 texture를 씌울것이라면 Init의 경로들도 표현할 물체에 따라 달라질 것입니다.

지금은 배우면서 물체하나만 일단 표현하기위해서 이런 방식으로 관리 했지만 조금더 큰 규모로 관리하려면 이런 코드들을 묶어서 관리할 필요가 있습니다.

그러면 어떤 물체를 표현하는데 필요한 클래스들을 하나의 클래스에 묶어서 사용하면 어떨까요? Engine도 사실 그래픽을 표현하는데 필요한 기능들을 묶어서 사용하고 있기도 합니다.
그래서 한 물체를 표현하려고 Mesh, Shader, Texture같은걸 묶어서 사용하는데 이런 방법도 이상합니다. 
Mesh, Shader, Texture같은 리소스들은 동일한 오브젝트끼리 공유할수 있는걸 리소스라고 합니다. 
쉽게 말해서 오크라는 물체 100개를 만들어야 한다면 각각의 오크에서 Mesh, Shader, Texture를 만들 필요가 없을것입니다.
리소스들은 오크들에게 동일하게 공유되고 각 오크들이 다른점은 offset으로 다른 위치에 있다거나 다른 곳을 보고 있다거나 크기가 다르다거나 하는 것만 따로 관리하면 될 것입니다.

이런 묶을수 있는 코드들을 한번에 관리하기위해 Material이라는 개념을 사용하기 시작합니다.
Material을 짧게 설명하자면, 사용할 쉐이더와 그 쉐이더에 들어갈 인자같은것들을 한 클래스에 모아서 관리하는 것 입니다.

구글에 Material Unity정도로 이미지 검색을 해보면 유니티 엔진에서 사용하는 마테리얼의 예시를 볼 수 있습니다. 사용할 쉐이더도 골라주고 어떤 텍스쳐를 사용할지도 골라줍니다. 
(텍스쳐가 꼭 하나일 필요는없습니다.) 빛이 어떤식으로 반사가 되야하는지도 넣어주고 있습니다. 
이런식으로 사용할 쉐이더와 그 쉐이더에 들어갈 인자들을 묶어주는 것 이라고 할 수 있습니다.

오늘할 내용이 이런 Material에 대해 이해를하고 간단하게 만들어 보는것입니다.


# Material

마테리얼은 쉐이더와 그 인자들을 관리하는 것이라고 했었습니다. 그래서 일단 우리가 사용하던 쉐이더인 default.hlsli를 보면 b0슬롯을 쓰는 offset0으로 position을 조작하고 있고 
b1 슬롯을 사용하는 offset1은 예전에 만들었지만 지금은 사용하고 있지 않습니다.그리고 텍스쳐를 받아주는 t0슬롯도 Material에서 관리할 용도로 사용하겠습니다.

그리고 레지스터로 데이터를 넘겨주는 클래스인 ConstantBuffer가 있었습니다. 이 프로그램에서는 ConstantBuffer가 256개의 Transform사이즈를 받는 것 하나 밖에 없었습니다. 
이 CB는 Transform의 사이즈의 인자 밖에 못받는 것입니다.
그래서 결국 다른 용도로 사용하고 싶다면 그 용도에 맞는 구조체를 만들어서 CB를 또하나 사용해야 할것입니다.

# Material - ConstantBuffer
ConstantBuffer 클래스로 가보면 지금까지는 Transform 용도로만 사용하였지만 이번 시간부터 Material용도로도 사용할것이기 때문에 조금 손을 보겠습니다.
enum class 로 관리할것입니다.

enum class CONSTANT_BUFFER_TYPE : uint8
{
	TRANSFORM,
	MATERIAL,
	END,
};
enum
{
	CONSTANT_BUFFER_COUNT = static_cast<uint8>(CONSTANT_BUFFER_TYPE::END),
};
이렇게 타입과 카운트를 enum으로 만들어주었습니다.

이제 ConstantBuffer의 Init에서 지금까지는 그냥 어떤 용도인지는 모르고 사이즈와 갯수만으로 초기화를 하고 있었습니다. 
우리 계획은 레지스터의 b0 슬롯은 Transform으로 b1슬롯은 Material로 사용할것이기 때문에 Init의 인자로 각 레지스터별로 구별해서 초기화 할수 있도록 바꿔주겠습니다.
그리고 받은 레지스터를 들고 있어야 하기 때문에 private 멤버 변수로 가지고 있겠습니다.
public:
	void Init(CBV_REGISTER reg, uint32 size, uint32 count);
private:
	CBV_REGISTER			_reg = {};

이걸하고 있는이유와 어떻게 할것인지, 
-> ConstantBuffer의 PushData함수는 리소스를 GPU쪽으로 매핑한 버퍼의 각 인덱스로 리소스를 복사하고난 뒤 그 핸들을 반환하는 함수였습니다. 반환된 핸들은 Mesh::Render에서 
TableDescriptorHeap의 SetCBV로 레지스터 슬롯으로 올라갑니다. 이때 슬롯에 들어갈 정보는 지금까지 Tranform 정보 밖에 없었기 때문에 햇갈릴일이 없었지만 지금은
Transform, Material두가지를 다룰 때 혹시라도 잘못 건내주게 되면 우리 프로그램이 무너지기 때문에
이 ConstantBUffer::PushData와 TableDescHeap::SetCBV를 하나로 묶어주려고합니다.

void ConstantBuffer::PushData(void* buffer, uint32 size)
{
	assert(_currentIndex < _elementCount);

	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);

	GEngine->GetTableDescHeap()->SetCBV(cpuHandle, _reg);

	_currentIndex++;
}
이렇게 전역 객체인 GEngine으로 TableDesc::SetCBV를 가져왔습니다. 외부에 핸들을 반환할 필요가 없으니 반환타입도 void로 바꿔주었습니다.

분명 이렇게 한군대를 고쳤으니 에러가 우르르 뜰건데 일일히 찾기보다는 빌드를 해서 컴파일러에게 시키겠습니다.

두군데에서 에러가 나고있습니다. Mesh::Render와 Engine::Init에서 입니다. 


# Material - ConstantBuffer - Engine

우선 Engine::Init을 먼저 보겠습니다.
에러메세지를 보니 인자의 수가 틀렸다고 합니다. Material을 활용하기로 하면서 ConstantBuffer::Init의 첫번째 인자로 용도에따라 쓸 레지스터 슬롯을 정하도록 했었기 때문입니다.
Engine에서 이제 여러개의 CB를 사용할것 같으니 아예 함수로 만들어 주겠습니다.
	void CreateConstantBuffer(CBV_REGISTER reg, uint32 bufferSize, uint32 count);
이제 ConstantBuffer를 여러개 가지고 있을것이기 때문에 이전 처럼 _CB로 관리하기 보다는 vector로 묶어서 관리할것입니다.
	vector<shared_ptr<ConstantBuffer>> _constantBuffers;
GetCB함수도 삭제하였습니다. 대신 CONSTANT_BUFFER_TYPE을 받아서 어떤 타입을 사용할지를 골라주는 Get함수를 만들어 주었습니다.
	shared_ptr<ConstantBuffer> GetConstantBuffer(CONSTANT_BUFFER_TYPE type) { return _constantBuffers[static_cast<uint8>(type)]; }

( GetConstantBuffer도 자주 사용할것 같은데 EnginePch에 define으로 정의 해주겠습니다.
-> #define CONST_BUFFER(type)	GEngine->GetConstantBuffer(type) )


CreateConstantBuffer의 구현부는 이렇습니다.
void Engine::CreateConstantBuffer(CBV_REGISTER reg, uint32 bufferSize, uint32 count)
{
	uint8 typeInt = static_cast<uint8>(reg);
	assert(_constantBuffers.size() == typeInt);

	shared_ptr<ConstantBuffer> buffer = make_shared<ConstantBuffer>();
	buffer->Init(reg, bufferSize, count);
	_constantBuffers.push_back(buffer);
}
레지스터 슬롯을 enum class에서 int형으로 캐스팅해주고 난다음 _constantBuffers의 사이즈가 받은 reg와 같은지를 체크하고 있습니다. 이 의미는 슬롯을 줘서 만들때 0번부터 차례대로 
만들기위해 중간에 빼먹지 않도록 안전장치를 해놓은 것입니다.
함수를 호출하면 인자로 받은대로 ConstantBuffer::Init을 해주고 vector<shared_ptr<ConstantBuffer>>에 push_back을 해줄것입니다. 

이제 Engine::Init에서 _CB->Init코드를 지워야 겠습니다. 그리고 CreateConstantBuffer를 호출해주는데 

	CreateConstantBuffer(CBV_REGISTER::b0, sizeof(Transform), 256);
	CreateConstantBuffer(CBV_REGISTER::b1, sizeof(MaterialParams), 256);
이렇게 호출해 주겠습니다. 그런데 여기서 Transform이라는 구조체는 처음 ConstantBuffer를 만들때 EnginePch에 정의해줬지만 MaterialParams라는 구조체는 아직 정의 하지 않았습니다.

# Material 클래스

Transform은 EnginePch에 만들어 줬지만 MaterialParams는 Material클래스 내부에 만들어 주겠습니다.

일단 이 Material이 어떤 요소들을 담고 있어야 하는지 곰곰히 생각해보면, 
맨 먼저 어떤 쉐이더를 사용할지를 골라야 할것입니다. 
그리고 ConstantBuffer를 생성할때 필요했던 MaterialParams가 필요합니다. 하지만 아직 이 Material로 어떤 기능을 줄지 정하지 않았으므로 
임의로 int32와 float 타입의 배열을 각각 5개씩 가지고 있다고 해보겠습니다.

MaterialParams 구조체 입니다. 
enum
{
	MATERIAL_INT_COUNT = 5,
	MATERIAL_FLOAT_COUNT = 5,
	MATERIAL_TEXTURE_COUNT = 5,
};
struct MaterialParams
{
	void SetInt(uint8 index, int32 value) { intParams[index] = value; }
	void SetFloat(uint8 index, float value) { floatParams[index] = value; }

	array<int32, MATERIAL_INT_COUNT> intParams;
	array<float, MATERIAL_FLOAT_COUNT> floatParams;
};
( 여기서 array라는 문법이 처음 등장했는데 배열을 만드는 문법입니다. 원래 배웠던 배열을 만드는 문법대신 이걸 사용하는것은 처음 만들때 크기를 딱 지정할수 있어서 실수로 범위를 넘어가지 
않도록 미리 제한 할수 있습니다. 사용방법은 vector와 유사하지만 vector와 달리 처음 정한 크기에서 더 늘어나지 않습니다.)
(추가로 이제는 C스타일의 배열보다는 std::array 스타일로 배열을 다루는걸 더 권장한다고 합니다.)

MaterialParams 라는 struct는 쉐이더에 넘겨져서 offset으로 활용될것이기 때문에 쉐이더 파일 default.hlsli에서 b1슬롯을 가리키는 코드를 변경해줘야합니다.
cbuffer MATERIAL_PARAMS : register(b1)		// TEST_B1이라는 이름이었는데 바꿔줬습니다.
{
    int int_0;
    int int_1;
    int int_2;
    int int_3;
    int int_4;
    float float_0;
    float float_1;
    float float_2;
    float float_3;
    float float_4;
};
인자를 5개씩 만들어준것은 우리가 어떻게 사용할지는 정하지 않았지만 일단 넉넉하게 만들어 둔것입니다.

다음으로 Material이 텍스쳐도 관리해줄수 있습니다. 위의 enum에서도 TEXTURE_COUNT가 있었죠
쉐이더에서 텍스쳐는 cbuffer로 관리하는게 아닌 밖으로 빼서 관리하고 또 SRV로 사용했었습니다.

Texture2D tex_0 : register(t0);
Texture2D tex_1 : register(t1);
Texture2D tex_2 : register(t2);
Texture2D tex_3 : register(t3);
Texture2D tex_4 : register(t4);

이렇게가 Material의 용도일것입니다. 이외의 필요한 것이 또 생기면 그때가서 늘려주면 될것입니다.

Shader, MaterialParams, Textures 세개를 멤버 변수로 들고 있겠습니다.

private:
	shared_ptr<Shader>	_shader;
	MaterialParams		_params;
	array<shared_ptr<Texture>, MATERIAL_TEXTURE_COUNT> _textures;

사용할 멤버 함수로는 이렇게 옵니다.

public:
	shared_ptr<Shader> GetShader() { return _shader; }

	void SetShader(shared_ptr<Shader> shader) { _shader = shader; }
	void SetInt(uint8 index, int32 value) { _params.SetInt(index, value); }
	void SetFloat(uint8 index, float value) { _params.SetFloat(index, value); }
	void SetTexture(uint8 index, shared_ptr<Texture> texture) { _textures[index] = texture; }

	void Update();
Update함수의 구현부는 
void Material::Update()
{
	// CBV 업로드
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushData(&_params, sizeof(_params));

	// SRV 업로드
	for (size_t i = 0; i < _textures.size(); i++)
	{
		if (_textures[i] == nullptr)
			continue;

		SRV_REGISTER reg = SRV_REGISTER(static_cast<int8>(SRV_REGISTER::t0) + i);
		GEngine->GetTableDescHeap()->SetSRV(_textures[i]->GetCpuHandle(), reg);
	}

	// 파이프라인 세팅
	_shader->Update();
}
이렇게 Material에서 CBV, SRV를 세팅해주고 쉐이더 업데이트 까지 한번에 묶어서 해줬습니다.

여기까지 만들었으면 다시 Engine::Init으로 돌아가서 CreateConstantBuffer를 마무리 해주겠습니다. Engine.cpp에 #include "Material.h" 를 해주면 
b1을 사용하는 CreateConstantBuffer(CBV_REGISTER::b1, sizeof(MaterialParams), 256); 에서 MaterialParams 부분이 에러가 나지 않게 됩니다.

여기까지 하고 다시 빌드를 해서 다른 에러는 없나 살펴보니 역시나 있습니다. CommandQueue::RenderBegin에서 GetCB를 호출했었고 , Mesh::Render에서도 GetCB를 호출했었습니다.

# CommandQueue::RenderBegin
커맨드 큐 부터 해결해보자면 문제는 렌더링을 시작할때 이전 프레임때사용하던 ConstantBuffer를 밀어버리고 처음부터 입력을 받기위해 Clear해줄때 문제가 생겼습니다.
지금은 CB를 사용하지않고 _constantBuffers로 여러개의 상수버퍼를 사용하기때문인데
	GEngine->GetConstantBuffer(CONSTANT_BUFFER_TYPE::TRANSFORM)->Clear();
	GEngine->GetConstantBuffer(CONSTANT_BUFFER_TYPE::MATERIAL)->Clear();
이렇게 각 타입의 상수버퍼를 Clear해주는걸로 해결했습니다.

#Mesh::Render
두번째 에러는 Mesh::Render에서 나고 있습니다. 위치는 GetCB의 PushData를 호출하는 곳입니다. 역시 _CB가 없어져서 나는 에러입니다.
GEngine->GetCB()->PushData(&_transform, sizeof(_transform));
이부분인데 이 코드는 Transform을 PushData해주고 있는 부분이고 이것은이미 EnginePch에서 define해준적이 있습니다. 
CONST_BUFFER(CONSTANT_BUFFER_TYPE::TRANSFORM)->PushData(&_transform, sizeof(_transform));
로 사용해주면 되고 그 밑의 코드가 TableDescHeap으로 SetSRV(_tex)를 해주고 있습니다. 이제는 텍스쳐도 Material에서 관리해주니까 이부분도 필요가 없을것입니다.

Mesh에서 _tex로 텍스쳐를 들고 있었는데 텍스쳐 포함 각각 5개의 int와 float를 들고 있을수 있는 Material을 _tex대신 들고 있도록 해줍니다.
public:
	void SetMaterial(shared_ptr<Material> mat) { _mat = mat; }
private:
	shared_ptr<Material> _mat = {};
만드는김에 Game에서 사용할 SetMaterial도 만들었습니다.
(Mesh클래스에 마테리얼도 이렇게 관리하는게 맞는지는 다음에 다시 생각해 볼 문제 입니다. 유니티의 경우에는 MeshRenderer라는 클래스를 따로 파서 메쉬와 마테리얼을 같이 관리하고 있다고 합니다.)

Material을 들고 있게되면 SetSRV같이 텍스쳐에만 해당하는 세팅말고 아까 만들어놓은 
_mat->Update();
를 해주게 되면 Shader, MaterialParams, Texture까지 한번에 세팅해줄수 있을것입니다.

이제 다시 한번 빌드 해주면 , 이번에는 에러없이 잘 빌드 되었습니다.


# 실습

이제 실습을 한번 해보겠습니다. 이전시간에 쉐이더 파일에서 물체의 position 좌표를 Input과 Timer를 통해 변경했었습니다.
이 부분을 잠시 주석 처리하고 오늘 만든 MaterialParams 중 float_0에서 2번까지 3개를 사용해서 물체를 움직여 보겠습니다. (실용적이진않고 Material이 작동하는지를 체크하기 위한 것)

이렇게 실행하면 이제 Material이 관리하는 인자중 float_0, float_1, float_2, 그리고 tex_0 까지 내용을 잘 채워주면 정상적으로 실행되어야 합니다.

#실습 - Game 클래스

Game.cpp 로 가보겠습니다. 위쪽에서 눈에 띄는것이 이제 Shader객체와 Texture객체는 Game에서 전역으로 들고 있을 필요가 없을것 같습니다. 모두 Material에서 들고 있으면 되는 정보들이기 때문입니다.
그래서 전역이 아닌 Game::Init내로 밑의 코드를 옮겨주었습니다.
	shared_ptr<Shader> shader = make_shared<Shader>();
	shared_ptr<Texture> texture = make_shared<Texture>();
각각 Init으로 경로를 주고나서
	shader->Init(L"..\\Resource\\Shader\\default.hlsli");
	texture->Init(L"..\\Resource\\Texture\\veigar.jpg");
Material객체도 생성해주었습니다.
	shared_ptr<Material> material = make_shared<Material>();
	material->SetShader(shader);
	material->SetFloat(0, 0.1f);
	material->SetFloat(1, 0.2f);
	material->SetFloat(2, 0.3f);
	material->SetTexture(0, texture);
	mesh->SetMaterial(material);
shader와 texture도 마테리얼에 알맞게 셋팅했고 아까 사용하기로한 float_0,1,2 도 임의의 값으로 세팅해주었습니다.
이후 mesh->SetMaterial로 전역객체인 mesh의 멤버변수 _mat으로 저장해주었습니다.

다음으로 Game::Update도 손을 봐야합니다. Update함수 안에 shader->Update() 라던가 mesh->SetTexture(texture) 같은 함수들이 있는데 
shader를 업데이트해서 파이프라인을 갱신하는것과 Mesh->SetTexture로 텍스쳐를 세팅하는 부분이 이제 Material::Update에 모두 모여있습니다. 
그리고 그 Material을 mesh::Render안에서 _mat->Update()를 해주고 있습니다.  

이제 빌드하고 실행해보면 설정했던 postion값으로 약간 오른쪽 위에 베이가 사진이 떠 있는걸 확인할수 있습니다.

# 버그 - 베이가가 중앙에서 안움직임
베이가의 포지션이 material의 float로 준 대로 움직여야하는데 안움직입니다. 왜그럴까요?
문제는 material의 _param이 들고있는 데이터가 레지스터로 안 이어지기 때문일것입니다. 그래서 Material 클래스, default.hlsli 파일, Mesh클래스를 들여다보고 
마지막에 ConstantBuffer 클래스를 보았는데 PushData에서 보니 SetCBV가 TableDescHeap의 view를 레지스터에 올리는 역할을 하고 있었습니다. 그래서 자세히 보았고 그래도 이상한점이 안보였는데
혹시 각 register를 지정해주는 멤버 변수가 눈에 띄어서 이건 어디서 초기화 해주는지 확인해보니까 CosntantBuffer::Init에서 초기화 해줘야 하는데 빠져있었습니다. 그래서 
Transform 은 b0 슬롯, Material은 b1 슬롯에 연결되야 하는데 이 고리가 끊겨있어서 그랬던것이었습니다.
#

이제 오늘 해본 Material 만들기를 되돌아보면 이전에 했던 강의때와 비교해서 Shader, b1슬롯에 들어갈 MaterialParams, Texture를 하나로 묶은것 말고는 별로 다르지 않은거 같습니다.

그래도 Material의 장점은 한번 세팅한 Material을 다른 물체에게도 적용하면 똑같은 물체가 하나더 생긴다는것입니다. 
예를들어 어떤 Material이 나무의 재질을 표현하기위해 나무의 텍스쳐 MaterialParams로 나무의 빛반사정도, 나무용도의 shader를 저장했다고 하면 이 Material을 사용하는 물체들은 전부 나무의 질감을 가질 수 있습니다.

