

    몬스터 AI


이번시간에는 몬스터 AI를 고쳐볼겁니다. 분명 이전 직접 배치했던 몬스터는 AIController로 잘 동작했었는데 SpawnCreature로 스폰시킨 몬스터는 움직이지 않았습니다. 
이것을 고쳐서 정상적으로 몬스터가 플레이어를 쫒아오도록 만들어 주겠습니다. 

생각보다 간단한 작업은 아닌게 그동안 수정, 추가한 코드가 꽤 많고 이럴때 이전에 만들었던 코드를 수정하려하면 이곳 저곳에서 문제가 발생하기 좋습니다. 

몬스터가 안움직이는 이유로 이전에 잠깐 알아보다 말았느넫 BP_Monster 클래스의 디테일을보면 Pawn 항목중 Auto Possess AI 라는 옵션에서 이전에는 Placed 일때 빙의되도록 
되어있었는데 이전에 Placed or Spawn 으로 바꿔서 직접 배치 혹은 스폰으로도 자동 빙의가 되도록 했었습니다. 이 상태에서 게임을 실행했다가 중단하면 
에러메세지가 뜹니다. 
그 내용은 MyMonster 프로퍼티를 읽으려던 중 None에 접근했습니다. 라는 내용입니다. 이것은 C++로 치면 Null Crash 입니다. MyMonster는 AIController에서 BeginPlay 이벤트 부터 
가져오는 자신이 빙의된 몬스터의 레퍼런스입니다.

왜 이 MyMonster가 비어있는지를 알기 위해서 BP_AIController의 이벤트 그래프를 보면 BeginPlay때 Get Controlled Pawn을 호출해 자신이 컨트롤중인 폰을 가져오고 그것을
BP_Monster 타입으로 캐스팅해서 MyMonster로 가지고 있었습니다. 이게 처음에 툴에서 드래그 드롭으로 배치한 몬스터의 경우 아무 문제 없이 동작했지만 
코드상으로 스폰한 몬스터는 Get Controlled Pawn이 실행되는 시점에 아직 스폰이 되지 않은건지 제대로 동작하지 않습니다. 

이런경우 어떻게 해야하냐면 사용하는 이벤트가 BeginPlay가 아니라 분명 이 BP_AIController가 몬스터에 빙의 되는순간을 뜻하는 이벤트가 있을겁니다.
대략적으로 Possess 라는 키워드로 이벤트를 찾아보면 On Possess 라는 이벤트가 나옵니다. 이 이벤트를 보면 반환 값에 그냥 Possessed Pawn을 뱉어주니까 따로 Get Controlled Pawn을 사용하지 않아도 될것 같습니다.

여기까지 하고 게임을 실행해보면 일단 에러메세지가 없어졌고 해골들이 다시 움직이기 시작한걸 알 수 있습니다. 
하지만 움직임이 살짝 어색한 부분이 있습니다. 예를 들어서 몬스터가 다가오다가 바로 앞도 아닌데 공격하기 시작하기도 합니다. 
왜 인것 같냐면 이전에 몬스터와 타겟 에너미 간의 거리를 하드코딩으로 그냥 300보다 가까운지를 체크해서 BeginAttack을 호출해줬습니다. 
이 부분을 오늘 어떻게 수정할 것이냐면 몬스터도 바로 앞 타일로 다가와 공격을 하도록 수정을 해볼겁니다.

우선 인공지능과 관련된 코드가 BP_AIController의 UpdateAI 함수 안에 넣어 놨었습니다. 
기존의 UpdateAI는 미세하게 조금씩 움직이는 사양의 AI였습니다. 이부분을 수정해야하는게 이제는 타일 단위 이동을 할것이기 때문에 타겟의 벡터와 자신의 벡터로 방향벡터를 구하는 부분은 사실 필요없어졌습니다. 
맵 좌표로 관리하면 되기 때문입니다. 

1차적으로 위에서 말했던 BP_Monster의 ChaseDirection을 구해주는 부분을 삭제해줍니다. 이 ChaseDirection은 내가 어디로가야할지를 정해주기 위해 사용했었는데 딱히 필요없어졌습니다.
그리고 연관된 코드인 ChaseDirection의 x값과 z값을 비교해 더 큰쪽 방향으로 이동하게 해주는 코드도 삭제했습니다. 

다시 정리해보자면 BP_AIController의 UpdateAI코드중 MyMonster의 State가 Idle 혹은 Move 일때 동작할겁니다. 먼저 Idle 상태일때는 월드에 존재하는 BP_Knight 객체를 MyMonster의 TargetEnermy로 세팅하고 
그 타겟 에너미가 유효하다라고 한다면 State를 Move로 바꿔주는 코드였습니다. 이 부분은 현재 타일맵 단위로 움직이도록 수정한 코드에서도 사용할 수 있는 코드입니다. 
만약 State가 Move일때의 코드를 새로 만들어주면 됩니다.

몬스터는 이제 타일단위 이동을 할것이지만 이동하는 과정자체는 스르륵 이동하게 될겁니다. 
우리가 플레이어를 만들었을때를 다시 떠올려보면서 만들어 보겠습니다. 부모 클래스인 BP_Creature에서 이미 GridPos와 DestLocation으로 목적지를 관리하면서 HasArrivedToDest 함수로 내가 목적지에 도착했는지 여부를 
체크해서 아직 이동하고 있는 중이라면 그 동안은 따로 AIController를 멈춘상태에서 이동을 하고 도착했다면 그때 이어서 컨트롤러에 따른 다음 동작을 정하는겁니다. 
이 경우의 수를 처리하기 위해 브랜치를 사용하겠습니다. 

브랜치에서 Ture에 이어줄 코드는 몬스터가 목적지에 충분히 접근해 도착이라고 인정해 줄때의 코드입니다. 플레이어의 경우 직접 입력으로 목적지를 정해줬었는데 
몬스터 같은 AI의 경우 우리는 맵 어디서든지 플레이어를 향해 이동하도록 만들었습니다. 그것을 이번 타일 단위 이동으로 구현하려면 몬스터의 목적지를 플레이어의 좌표에서 한칸 떨어진 곳으로
갈때 까지 이어 목적지를 잡아야합니다. 

이제 몬스터와 타겟 에너미 사이의 거리를 구해야 하는데 그 거리를 구하는것이 기존에 구했던 방향벡터의 길이를 말하는게 아니라 타일 맵 기준으로 몇칸 떨어져 있는지를 계산하는 함수를 하나 파줄겁니다. 
이렇게 자신과 타겟 사이의 거리를 구하는 기능은 꼭 AI컨트롤러에서만 사용할 것이 아니라 언젠가 플레이어나 몬스터에서 스킬같은 걸로 사용할 수도 있기 때문에 BP_Creature에서 작업을 해주겠습니다. 

BP_Creature에 함수를 추가하는데 이름은 GetTileCountToTarget 이라고 하겠습니다. 
목적하는 타겟을 BP_Creature에서 변수로 직접 들고 있어도 되지만 지금은 아직 TargetEnermy는 BP_Monster에서만 가지고 있습니다. 대신에 타겟을 입력을 받아주겠습니다. 
입력의 이름은 TargetCrature라고 하고 타입은 BP_Creature라고 하겠습니다. 
출력은 그래서 계산된 칸이 몇칸인지를 int 로 출력해줄것입니다. 

이제 함수 내용을 채워줄차례인데 일단 입력받은 타겟의 GridPos를 가져오겠습니다. (이때 먼저 타겟이 유효한지를 체크할 수도 있습니다. 여기서는 유효체크를 생략할 것인데 유효체크를 하는게 꼭 항상 좋은것은 아니라고 합니다. 
오히려 아예 문제가 있다면 여기서 크래시를 내버려서 빨리 버그를 잡는것이 좋을 경우도 있다고 합니다.)
그리도 한번더 Get GridPos를 해줄건데 입력에서 핀을 이어 꺼낸 GridPos는 타겟의 좌표이고 지금 꺼낸 GridPos는 자신의 좌표입니다. 각각 x성분 y성분끼리 빼서 둘의 차이를 구하는 것 부터 시작하겠습니다. 
그런데 이게 음수가 될수 있습니다. 이럴때 절대값을 가져오는 Absolute 노드를 사용하면 되었었습니다. 해서 계산한 목표와 자신의 사이 좌표 성분들의 절대값을 더해주면 이것이 목표까지 이동해야 하는 타일의 수라고 할 수 있습니다.
여기까지 하면 GetTileCountToTarget의 출력값으로 넘겨주면 되겟습니다. 


다시 원래 작업하던 BP_AIController의 UpdateAI로 돌아가보겠습니다. 
현재 Tick이벤트 마다 호출되는 UpdateAI에서 몬스터의 상태가 Move일때를 작업하고 있었습니다. 유효체크와 HasArrivedToDest로 몬스터가 목적지에 도착했는지를 체크했는데 만약 True라면 
이어서 GetTileCountToTarget을 호출해 남은 칸이 딱 1칸이라면 내가 공격할수 있는 상황인것이고 그게 아니라면 이어서 목표까지 이어지는 목적지를 설정해야 합니다. 
GetTileCountToTarget의 반환 Count값이 1과 같다 혹은 같거나 작다인지를 체크합니다. True라면 공격을 시작하면되니깐 BeginAttack을 호출해줍니다. 
false라면 이어서 쫒아 가게끔 UpdateAI에서 처리를 해주거나 아니면 쫒아가는 코드는 그냥 BP_Creature의 UpdateLogic쪽에서 처리하도록 해줘도 됩니다. 

여기까지 1차적으로 큰 틀을 맞춰봤지만 아직 좀 더 남아있는 작업이 있습니다. 
우선 먼저 있었던 UpdateAI에서 목표가 어느방향에 있는지를 체크해서 그 방향으로 Direction을 조절해주는 코드가 있었습니다. 
이 몬스터의 방향을 조절하는 기능을 꼭 AIController에서 만 사용할것이 아니라 다른 곳에서도 사용할 수 있으면 편리 할 것 같습니다. 
그러므로 좀 더 공통으로 사용할 수 있게 하고 또 기능으로 때어 함수화를 해주겠습니다. 

BP_Creature에서 LookAtTarget이라는 이름의 함수를 추가하겠습니다. 이 함수가 입력으로 필요한것은 어느 타겟을 볼지를 받아주면 될것이고 이후 결과로는 그쪽을 바라보도록 Direction만 바꿔주면 될것이기 때문에 
출력핀은 필요없어 보입니다. 

내용은 먼저 입력받은 목표 크리쳐가 유효한지를 체크해도 되고 안해도 됩니다. 다음은 사실 GetTileCountToTarget과 비슷한데 타겟의 좌표와 자신의 좌표 차를 구하는것까지 작성합니다. 
여기서 이 좌표의 차이를 함수내에서 반복해 사용할 것 같다라고 한다면 그냥 함수의 로컬변수로 빼서 관리하는것도 좋습니다. 이름은 각각 DeltaX, DeltaY 같이 두 좌표의 차이라고 알 수 있게끔 지어줍니다. 
다음으로 할것은 이 DeltaX, DeltaY 에 따라 어느 방향으로 우선 이동할지를 골라주는것입니다. 이것은 이전 타일 단위 이동을 구현하기 전에도 채택했던 이동 로직입니다. 
DeltaX, DeltaY 의 절대값을 비교해서 만약 X가 더 컷다고하면 다시 DeltaX가 양수인지 음수인지에 따라 좌우 방향을 골라주고 Y가 컷을때도 음양 부호에 따라 위, 아래를 골라줍니다. 
여기 까지해서 LookAtTarget을 다 만들었으니 이것을 적용시켜봐서 잘 동작하는지 확인해보겠습니다. 

BP_AIController의 UpdateAI로 돌아가서 코드를보면 공격이나 다음 이동을 하기 전에 몬스터가 타겟을 향해 몸을 틀어야 하니까 그 부분에 LookAtTarget을 끼워 넣어보겠습니다. 
이때바라만 보는게 끝이 아니라 실제로 Direction에 따라 이동방향도 달라지도록 맞물려잇습니다. 

여기 까지 하고 게임을 실행해보면 스켈레톤의 움직임이 이상합니다. 무언가 나를 쫒아오는것 같기도 하고 아닌것 같기도한 움직임입니다. 
이게 왜 이런지 곰곰히 생각해보면 플레이어의 때에도 비슷한 문제가 있었습니다. 

플레이어의 이동 코드를 보면 UpdateLogic을 호출 할때 HasArrivedToDest 라는 함수로 지금 목적지에 도착했는지를 체크해서 만약 도착했다면 다음 목적지를 다시 세팅해주는 UpdateDestination 함수를 호출해 줬었습니다. 

UpdateDestination 함수를 살펴보면 bStopMove라는 불리언 값을 체크하는데 이 StopMove는 BP_PlayerController쪽에서 이동이 끝날때 더이상 키 입력이 있는지 없는지를 세팅해주는 값이었습니다. 
해서 만약 StopMove가 false라면 가던 방향으로 계속 가도록 다음 목적 좌표를 업데이트 해줍니다. 
이런식으로 입력여부를 기준으로 만들어 놓은 UpdateDestination은 플레이어 입장에서 만든 함수라서 그렇습니다. 
이 UpdateDestination이 BP_Creature 클래스에 있는 함수이다 보니 몬스터도 영향을 받아 갈수 없는 벽에 부딛힐 때 까지 계속해서 직진하게 되는겁니다. 

그렇다는것은 이 StopMove 를 잘 다루면 몬스터도 정상적으로 움직이지 않을까 싶은데 사실 StopMove는 플레이어 용도로 만든것이기 때문에 몬스터 쪽에서 사용하기 애매합니다. 
차라리 디렉션에 따라 다음 목적지를 바꾸는 코드를 이용하는게 방법일 수도 있을텐데 그러려면 이 UpdateDestination을 호출할때 바라보는 방향도 달라지게 해주면 되는데 
타겟을 바라보는 기능인 LookAtTarget은 이미 BP_AIController에 추가된 상태입니다. 이것도 틀린 말은 아니지만 
지금 당면한 문제를 해결하기 위해서는 UpdateDestination에서 LookAtTarget을 호출하는게 더 나은 방법이 아닌가 할 수 있는데 결국 이 UpdateDestination을 플레이어에서 호출할때와 몬스터에서 호출할때를 
나눠 사용하면 좋을것 같습니다. 

이럴때 오버라이드를 사용하면됩니다. 

BP_Monster에서 오버라이드로 UpdateDestination을 선택해주면 여기서 덮어 쓸 수 있게 됩니다. 
재정의 화면에서는 BP_Monster의 UpdateDestination 시작 노드와 이어서 Parent: UpdateDestination이 이어져 있는데 이 사이에 원하는 코드를 끼워 넣거나 아니면 그냥 뒤의 Parent : UpdateDestination를 없애고
독자적인 코드를 작성해도 됩니다. 
하여튼 두 노드사이에서 LookAtTarget을 호출해주면 입력값에 따라 Direction을 바꾸지 않아도 알아서 TargetEnermy 쪽으로 Direction을 바꾸게 됩니다. 

만약 오버라이드말고 다른 방법이 없나 하면 다른 방법도 있습니다. BP_Creature에 있는 UpdateDestination에서 자기 자신을 가져오는 Self와 Cast To BP_Monster를 해서 이 캐스팅이 성공했는지 여부에 따라 
성공했다면 이어서 LookAtTarget을 해주는 방법도 있습니다. 


여기 까지 해서 아까 보다 더 똑똑하게 움직이는 해골들을 확인할 수 있습니다. 물론 아직은 이동 경로에 벽이나 다른 몬스터가 있어도 돌아 가거나 하지는 않지만 이것은 
좀 더 어려운 길찾기 알고리즘을 적용시켜야합니다. 


강의를 끝내기 전에 한가지 더 살펴보려고 하는데 해골이 공격하는 코드가 어떻게 되어 있는지 살펴보겠습니다. 
UpdateAI에서 타일 거리가 1일때 BeginAttack을 호출하도록 되어있고
BeginAttack은 현재 상태가 Skill이 아니라면 Skill로 세팅해주고 Skill의 애니메이션을 틀어줍니다. 이어서 Process Attack 을 호출해 자깅방향 앞쪽 타일에 있는 크리쳐에 OnDamage로 피격 판정을 진행합니다.
이런 ProcessAttack 이 호출이 끝나면 공격모션의 시간동안 딜레이를 시켜 다른 입력을 받지 못하게 하고 공격이 끝났으면 Move나 Idle 같은 다른 상태로 세팅해줍니다.