

    데이터 테이블 


이전시간에 몬스터를 추가하기 위해 사전작업으로 플레이어와 몬스터의 상위 클래스인 크리쳐 클래스를 만들고 상속구조를 사용해 플레이어 나이트와 몬스터를 동작하는것까지 만들었습니다. 
하지만 아직 완성된게 아니고 몬스터나 나이트나 각기 그냥 강제로 플립북을 설정해주는 방식으로 사용하고 있었지만 
이렇게 해서는 나중에 확장했을때 불리하기 때문에 따로 데이터로 빼서 관리하도록 작업을 해볼겁니다. 

이 데이터는 어디에서 만들까 하다가 그냥 프로젝트 콘텐츠/Blueprint 아래에 새로 Data 라는 폴더를 만들고 여기서 데이터들을 관리할겁니다. 
데이터테이블을 만들기 이전에 블루프린트 구조체 파일을 하나 만들고 여기에 관리할 데이터양식을 정하게 될겁니다. 이름을 CreatureData 라고 해주겠습니다. 
열어주고 여기서 관리할 데이들을 만들어 놓을겁니다. 나중에는 레벨,경험치,돈 등 온갖 게임과 관련된 데이터도 있겠지만 지금은 오브젝트들을 움직일때 필요한데이터만 딱 넣어볼겁니다.
일단 플립북을 넣어줄건데 up, down, side 방향으로 attack, idle, move 세가지씩 있을것이니 총 9개의 플립북을 가지고 있을겁니다. 
구조체가 가지고 있을 변수타입을 페이퍼 플립북으로 바꾼 다음 추가추가 해서 9개를 만들어줍니다. 이름을 플립북 이름처럼 지어줍니다. 나중에 필요할때 더 추가해주면 되니까
일단은 저장하고 나갑니다. 

이제 CreatureData 구조체가 있는 Data 폴더의 빈곳을 다시 우클릭하고 영어로는 Miscellaneous, 한글로는 기타란에서 데이터 테이블이라는 것이 있습니다.
클릭하면 어떤 스트럭쳐로 만들것인지 선택할 수 있는데 우리는 방금만든 CreatureData 구조체로 만들어 줄것입니다. 이름을 직관적으로 CreatureDataTable이라고 짓겠습니다. 

더블 클릭해 열어보면 어떤 빈 창들이 떠있는데 사용하는것은 직관적입니다. 상단쯤에 추가 라는 버튼을 눌러보면 Row Name과 CreatureData에서 관리하던 데이터들을 가진 행이 만들어집니다. 
Row Name 행 이름은 일종의 Key값 같은 걸 넣어주면되는데 일단 Knight 의 대한 데이터를 추가하고 Skeleton도 추가해줍니다. 
그다음 직관적으로 각 플립북을 설정해주면 됩니다. 

knight 행을 클릭하고 아래쪽 창에서 Knight의 플립북들을 하나씩 넣어줍니다.
약간 노가다 이지만 나이트와 스켈레톤의 각 플립북들을 채워줬습니다.

이렇게 데이터 테이블을 가지고 관리하면 편리한 점이 데이터와 코드를 구분하는것뿐만아니라 코드에서 바로 데이터 테이블을 이용해 바로 꺼내 사용할 수 있습니다.
이게 무슨말인지 실습을 해보겠습니다.

다시 BP_Creature를 열어봅니다. 
우리가 고쳐야할 부분이 UpdataAnimation에서 플립북을 골라주는 부분이었는데 이전에는 강제로 하나씩 골라줬는데 이제 데이터로 빼서 관리해줄것이니까 해당하는 데이터가 무엇인지 지정해주면 
알아서 연동해주면 되겠습니다. 
그러면 데이터 테이블을 가져오는 기능을 살펴보겠습니다. BP_Creature의 이벤트 그래프로 가서 일단 데이터 테이블과 관련된 기능이니까 데이터 테이블로 검색해 나오는 기능들을 보겠습니다.
그 중에 Get Data Table Row 라는 기능이 눈에 띕니다. 
어떤 데이터 테이블에 대한 코드인지 골라주는 입력 핀이 있고 열어보면 우리가 만들었던 CreatureDataTable에셋을 골라줄 수 있습니다. 이 데이터 테이블을 찾았다면 Row Found 실행핀으로 진행되고
못 찾았다면 Row Not Found 실행핀으로 진행되게 되어있습니다. 만약 Row Not Found로 진행되었으면 어딘가 잘못된 것이니 예외처리를 해줘야 겠습니다.
협업상황에서는 이 코드를 만든 프로그래머와 기획자가 그 데이터를 기록한 시점이 다르거나 하면 이런 문제가 생길 수 있습니다. 
그건 그렇고 다시 Get Data Table Row를 보면 사용할 데이터 테이블 에셋을 고르면 그 데이터 테이블에 있는 Row를 골라 줄 수 있습니다. Knight 행을 꺼낼건지 Skeleton 행을 꺼낼건지 고를 수 있다는 말입니다. 
반환핀이 Out Row라고 되어있는데 찾은 이름을가진 행을 반환하는겁니다. CreatureDataTable은 CreatureData 라는 구조체를 행으로 사용했으니 이 구조체를 반환하기도 하고 우클릭해 구조체 핀 분할을 하면 
구조체의 구성 원소들을 따로 꺼낼 수도 있습니다. 그래서 여기서 원하는 데이터를 변수로 들고 있는다거나 아니면 원하는 행의 이름을 Key값으로 사용하게 들고있는다거나 하던지 여러 방법으로 관리하면 됩니다.

그럼 게임이 처음 시작할때 실행되는 BeginPlay 이벤트에서 Get Data Table Row를 호출해주면서 시작과 동시에 데이터를 찾아주도록 해 줄 수 있을겁니다. 만약 Row Not Found로 간다면 데이터가 없다는 메세지를 출력하는 정도로만 
해주고 이 코드들이 어디서 실행되야할지 생각해보면 자신의 데이터를 찾는것이니 BP_Knight 나 BP_Monster에서 호출되어야 할것입니다. 각 클래스에 복사해줍니다. 

먼저 BP_Knight를 보면 CreatureData 타입 변수 Data에 자신의 데이터를 들고 있게 해줄겁니다. Data 변수는 부모클래스인 BP_Creature에 아직 있습니다. Data는 BP_Creature 안에서 직접 사용하지 않더라도 자식클래스 
에서는 사용할것이기 때문에 부모클래스에 하나만 만들어 두는것도 좋습니다. 

BP_Monster 같은 경우에도 마찬가지로 사용해되고 아니면 Monster아래로 Skeleton클래스를 하나 더 만들어서 관리를해줄 수 도 있습니다. BP_Skeleton을 만들때 그냥 새로 블루프린트 클래스를 만들고 부모 클래스를찾아 상속받아도 
되지만 좀 더 간편하게 이미 만들어져 있는 BP_Monster를 우클릭하면 자식 클래스를 만들 수 있는 기능이 하나 더 있습니다. 이것으로 스켈레톤 클래스를 만들어 자신의 데이터를 찾는 코드를 붙여넣고 찾는 행을 Skeleton으로 
바꿔줍니다. 

BeginPlay 이벤트로 부터 이어지는 자신 데이터를 가져오는 이 코드를 반복적으로 사용할 것 같으니 함수로 묶어서 사용하는것도 괜찮습니다.

참고삼아 BP_Skeleton의 이벤트 그래프를 보면 Tick이벤트에서 이어지는 노드로 Parent:Tick 이란게 있습니다. 이게 무엇이냐면 만약에 우리가 BP_Monster클래스에서 BeginPlay를 사용한다고 해보겠습니다.
만약 중요한 코드를 BeginPlay 이벤트에서 실행했었다 하면 BP_Skeleton의 입장에서는 바로 꺼내서 사용하는게 아니라 BeginPlay 이벤트를 우클릭하면 Add call to parent function 이라는 기능을 클릭해 
Parent: BeginPlay 노드를 호출한 뒤 이후 자기 할 일을 연결해주면됩니다. 이러면 부모가 들고 있던 BeginPlay를 간접적으로 호출해줍니다.

결국 우리가 한것은 나이트와 스켈레톤의 플립북들을 구조체로 들고 있게 해 데이터테이블에서 관리하도록 했습니다.

여기서 끝이 아니죠 우리가 이 데이터 테이블을 추가한 이유는 UpdateAnimation 함수에서 사용할 플립북들을 각 클래스마다 손쉽게 관리해주기 위해서였습니다.
이부분은 그렇게 어렵지 않은데 UpdataAnimation가 있는 클래스가 BP_Creature였는데 여기서 이어 작업할 수 있습니다. BP_Creature의 Data라는이름의 CreatureData 구조체 변수를 Get 해와서 
구조체 핀 분할을 합니다. 그러면 구조체를 이루는 각 핀들로 나뉘는데 이것을 적절한 위치에 연결해주기만하면 됩니다. 연결은 각 State 마다 Direction에 따른 Select 문을사용하던 부분에 연결해주면 되는데 
이 Select문에서는 입력핀 타입을 페이퍼 플립북으로 변경해놔서 가능합니다.

이제 게임을 다시 실행해보면 나이트는 정상적으로 이동하고 또 스켈레톤도 배치해보면 시작하기전엔 나이트 이미지인데 실행후에는 스켈레톤 이미지로 바뀝니다.
근데 실행하기 전에 스켈레톤이 나이트모양으로 나오는게 좀 그러니까 BP_Skeleton 클래스로 가서 Sprite의 소스플립북을 스켈레톤의 side_idle 같은걸로 바꿔주겠습니다.

이렇게 해서 굉장히 많은 작업을 했는데 거의 동일한 코드를 그대로 유지한 채로 애니메이션을 데이터 테이블로 바꿔사용할 수 있도록 만들었습니다. 
나중에가면 전투나 밸런스 아이템과 관련된 데이터를 관리할때는 지금처럼 데이터 테이블로 데이터 하나하나 클릭으로 바꿔 가면서 관리하기는 어렵고 
이후 기획자 분들이 엑셀같은걸로 데이터를 만들어주면 그걸 가져와 게임에적용하거나 합니다. 그래도 데이터 테이블이 편리한것은 언리얼의 에셋으로 포함되어 일종의 아트리소스와 코드를 분리해 관리하는것처럼 
관리할 수 있었습니다. 

