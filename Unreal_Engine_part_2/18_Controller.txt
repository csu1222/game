

    Controller

이어서 컨트롤러에 대한 내용을 알아보겠습니다.
그런데 이미 알게 모르게 컨트롤러를 건드리고 있었습니다. 
어디서 건드리고 있었냐면 게임을 실행한 후 아웃 라이너를 살펴보면 자동적으로 Playre Controller 가 생성되어있습니다.
실질적으로 주인공을 조작하는게 이것입니다. 근데 딱히 기능을 넣어놓거나 하진 않고 그냥 기본상태의 컨트롤러입니다. 

사실 지금 플레이어 역할인 BP_Knight안에서 UpdateInput 이라는 함수 안에서 모든 입력을 받는 코드를 넣어놨습니다. BP_Monster 같은경우고 UpdateAI에서 입력을 대체하는 인공지능 
코드를 넣어 놨습니다. 세삼 말을 꺼내는게 딱히 이게 틀렸다는것은 아니고 당연히 처음 알아서 만들게 시키면 플레이어나 몬스터 클래스 내부에 컨트롤 하는 부분을 같이 넣어 두었는데 
이게 딱히 문제가 있지는 않았습니다. 

그런데 조금씩 경험이 쌓이고 좀 더 복잡한 게임을 만들게 되면 캐릭터 클래스에는 정말 이 캐릭터에 대한 정보들만 담고 싶지 컨트롤이나 AI같은 잡다한 데이터는 따로 관리하고 싶게 됩니다. 
코드양이 방대해질수록 그렇습니다. 또 하나의 문제는 지금 플레이어가 키보드 입력을 받아서 이리저리 움직이고 있는데 만약 이동하다 탈것을 타서 날아가기 시작한다거나 아니면 오토바이를 타게 된다 같은 
여러가지 상태의 이동방식이 존재 할 수 있을겁니다. 그런데 지금같이 딱 함수로 만들어관리하게 되면 다양한 이동방식에 대해 전부 분기문으로 갈라서 구현해줘야합니다. 

그리고 RPG 게임을 떠나서 FPS 게임의 경우에는 더 심각해집니다. 언리얼엔진 자체가 FPS게임을 위해 만들어진 엔진이었다보니 생각해보면 여러 모드가 있을수 있는데 이 모드에 따라 다른 이동방식이 있을겁니다. 
이럴때에도 여러 모드에 대응하는 코드를 모두 플레이어나 몬스터 클래스에서 관리하는것은 아쉽습니다. 

언리얼 엔진에서는 DevMap 화면에서 오른쪽에 디테일즈 옆에 월드 세팅이라는 것이 있을겁니다. 없다면 창 옵션에서 월드 세팅을 켜면됩니다. 
이 월드 세팅에서 게임 모드를 골라서 다른 모드로 동작하게끔 해줄 수 있습니다. 게임 모드를 오버라이드 한다고 하는데 이 오버라이드 할 때 추하는 것들이 여러가지 있습니다. 
디폴트 폰 클래스 는 플레이어가 사용할 디폴트 폰 클래스이고 플레이어 컨트롤러 클래스라고 해서 플레이어 로그인시 스폰해야하는 플레이어 컨트롤러 클래스랑 기본 UI를 뜻하는 HUD 클래스도
정해줄 수 있습니다. 이외에도 더 있습니다. 이런것을 나중에 바꿔 치기 할 수 있는데 지금은 게임모드가 None이라서 지금은 안되고 나중에 게임모드를 오버라이드 할때 살펴보겠습니다. 

또 한가지 알아볼것은 맵에 배치된 BP_Knight 오브젝트를 선택하고 디테일즈에 possess 를 검색해 봅니다. 그러면 Auto Possess Player 가 Player0 번으로 연결되어있는데 
그렇기 때문에 게임이 시작되면 Player Controller 0번이란 애가 BP_Knight 오브젝트를 조종합니다. 그제서야 입력을 받고 또 카메라도 이 오브젝트를 주시하는겁니다. 
진짜 그런지 예를 들자면 BP_Knight 오브젝트를 하나 둘 더 맵에 배치한 다음 게임을 실행해 이동해보면 모든 나이트들이 움직이는게 아니라 첫 나이트, Auto Possess Player를 Player0 로 설정해준
오브젝트만 움직이는걸 볼 수 있습니다. 이부분이 유니티와 다른 점인데 유니티의 경우에는 업데이트 코드에 동작하는걸 넣어 놨으면 모든 나이트가 움직여야 하는데 언리얼은 플레이어 컨트롤을 연결해준 
나이트만 움직이는겁니다. 마찬가지로 모든 나이트를 삭제하고 다시 나이트 하나만 배치하면 이것도 입력을 받지않습니다. 초반에 possess 를 player0이 빙의되도록 임시적으로 세팅했었기때문에 
입력을 받았던 겁니다. 그러니까 모든 영역들이 잘 맞아야 동작을 하게 됩니다. 

참고로 다른 플레이어로 빙의해 왔다 갔다 하는것 그러니까 스타크래프트 같이 유닛을 선택하듯이 하고 싶을 경우를 잠깐 실습해보겠습니다. 
BP_Knight 오브젝트를 두개 만들어 두고 레벨 블루프린트를 열어보겠습니다. 여기서 BP_Knight 들의 레퍼런스 노드를 배치합니다. 각각 맵에서 선택하고 레벨 블루프린트에서 우클릭으로 만들 수 있습니다. 
그리고 키보드 1 이벤트와 키보드 2 이벤트도 꺼내줍니다. 그리고 나서 Get Player Controller 라는 함수를 꺼내주면 기본으로 0번 인덱스의 플레이어 컨트롤러가 선택되어있습니다. 이게 로컬 컨트롤러 입니다. 
다시 출력핀에서 Possess 함수를 꺼내면 이게 컨트롤러를 빙의 시켜주는 함수이고 1번을 누르면 BP_Knight1 이 In Pawn 에 연결되어 빙의 되고 2번을 누르면 BP_Knight2가 빙의 되도록 해줍니다. 

테스트를 해보면 1번과 2번을 누르면 바꿀때 마다 카메라가 주시하는 대상이 달라지고 키보드 입력을 받는 캐릭터도 달라집니다. 

이것이 간접적으로 플레이어 컨트롤러를 실험하고 있다고 볼 수 있습니다. 플레이어 컨트롤러는 결국 폰이라는 것을 조종하는 애라고 알 수 있었습니다. 
공식문서를 찾아보면 플레이어컨트롤러는 폰과 사람사이의 조작을 이어주는 인터페이스이라고 합니다. 그리고 어느 상황에서 사용하는지를 보면 사실 모든 입력들을 폰 내부에서 처리해도 괜찮다고 합니다. 
특히나 게임이 간단한 경우에는 이것은 지금처럼 BP_Knight 에서 입력 코드들을 관리하는게 안되는 방법은 아니라는 겁니다. 
하지만 좀 더 게임이 복잡해 지면 플레이어컨트롤러에서 입력을 받아 처리하는게 낫다라고 합니다. 

그래서 오늘 본격적으로 실습할것은 무었인가 하면 BP_Knight 에 넣어놨던 UpdateInput 의 코드를 플레이어 컨트롤러 쪽으로 이전하겠습니다. 왜 꼭 해야하냐면 코드를 정리하는것도 있지만 
게임모드를 사용해보는 것도 목적에 있습니다. 컨텐츠 브라우저에 Data, UI 폴더가 있는 위치에 Creatures 라는 폴더를 만들어 지금까지 만들었던 클래스들을 다 넣어주겠습니다. 
또 Sturct 라는 폴더를 만들고 EDirection, EState 이넘 파일들을 넣어주겠습니다. 

다음으로 새로 블루프린트 클래스를 만들것인데 부모클래스를 게임모드 베이스 라는 클래스로 해줍니다. 이름은 간단하게 BP_GameMove 라고 해주겠습니다. 나중에는 게임모드가 많아지면서 이름도 복잡해지겠지만 
처음 만들고 일단은 하나만 사용할것이라 단순하게 이름지었습니다.
이제 아까 살펴본 월드 세팅에서 방금 만든 BP_GameMove로 변경할 수 있는데 이러면 이제 그 아래에 있던 디폴트 폰 클래스, HUD 클래스, 플레이어 컨트롤러 클래스, 게임 스테이트 클래스, 플레이어 스테이트 클래스, 관전자 클래스
를 수정할수 있게 열립니다. 
참고로 월드 세팅에서 수정하지 않고 BP_GameMove를 열어서 디테일즈에서 바꿀 수도 있습니다. 

게임모드중에 PlayerController 가 기본으로 되어있는데 이것도 상속받아서 우리만의 컨트롤러를 사용할 수 있습니다. 이만큼 상속이 중요한 것입니다.
PlayerController를 상속받은 BP_PlayerController 클래스를 새로 만들어주고 게임모드에서 대체 해주겠습니다. 
이러면 이제 새로 BP_Knight 가 만들어질때 컨트롤러가 기본 컨트롤러가 아닌 우리가 만든 BP_PlayerController로 만들어 질것이라고 알 수 있고 그렇다는것은 기존에 UpdateInput의 코드를 BP_PlayerController로
이전시켜서 관리하는게 하나의 방법이라고 할 수 있겠습니다. 

그리고 플레이어 컨트롤러 뿐만아니라 BP_Monster 에서는 UpdateAI에서 움직임을 제어하고 있었는데 이것도 컨트롤러가 있습니다. 새 블루프린트 클래스를 만들때 AIController 를 검색해 상속받아 만듭니다. 
이름은 역시 BP_AIController 라고 지어주고 BP_PlayerController와 같이 Creatures 폴더로 이동시켜주겠습니다. 모두 크리쳐에 대한 것들이기 때문입니다. 

먼저 BP_PlayerController 부터 코드 이전을 해보겠습니다. 이전 BP_Knight에 있던 UpdateInput의 코드들을 모두 복사해서 BP_PlayerController에서 같은이름의 UpdateInput 함수를 만들고 그 안에 코드를 
복사해주겠습니다. 그런데 여기서 완전히 똑같이 사용할 수는 없는게 이젠 우리가 한단계 더 들어가는겁니다. BP_PlayerController가 관리하는게 BP_Knight라는 폰은 아닙니다. 
폰을 조종하는 다른 무언가를 관리할 것 이기 때문에 복사한 그대로 컴파일 하면 에러가 우르르 뜨는걸 볼 수 있습니다. 
그래서 빈곳을 우클릭해서 Get Controlled Pawn 라는 함수 노드를 배치합니다. 이 함수에서는 자신이 지금 빙의되어서 조종하고 있는 폰을 가져올 수 있습니다. 다만 아직 Pawn 타입이기 때문에 한번 
캐스팅을 거쳐야합니다. 이렇게 해서 빙의되고 있는 BP_Knight를 가져올 수 있는데 이것을 매번 반복해 사용하지는 않고 BP_PlayerController의 BeginPlay 이벤트때 한번 저장해 그걸 사용하겠습니다. 
Get Controlled Pawn과 Cast to BP_Knight 한 코드를 이벤트 그래프에서 BeginPlay 이벤트에 연결해 주고 반환된 BP_Knight 객체는 Promote to Variable 로 변수화 해 MyPlayer라는 이름으로 저장해줍니다. 

아직은 MyPlayer를 저장만 한것이고 제대로 사용하지 않아 아직 에러메세지가 그대로입니다. BP_PlayerController의 UpdateInput 함수로 돌아가 가장먼저 BP_Knight의 State를 Switch 문으로 분기하고 있는 부분을 
Get MyPlayer -> Get State 로 연결해줍니다. 이런식으로 에러메세지가 발생하고있는 부분을 하나씩 고쳐줘야합니다. 다른 에러 메세지 부분은 Axis Input 값들인 MoveUp, MoveRight 값을 가지고 지금 BP_Knight가 
Move 상태인지, Idle 상태인지 그리고 Direction은 어느 방향인지를 Set State 해주고 있습니다. 
여기서 Set State는 결국 BP_Knight의 State를 세팅해주는 것이다 보니 MyPlayer의 Set State 노드로 교체 해줘야합니다. 

이제는 컴파일을 해도 에러가 뜨지 않습니다. 다시 이벤트 그래프로 돌아가서 Tick 이벤트에 UpdateInput을 연결해주겠습니다. 이제 거의 준비가 끝났다고 할 수 있습니다. 
지금 우리가 한게 무엇이냐면 BP_PlayerController에 모든 입력과 관련된 코드를 넣어놨다라는 것입니다. 

BP_Knight로 돌아가서 이제 UpdateInput을 여기서 할게 아니니 함수도 날리고 노드도 날려주겠습니다. 이대로 실행하면 잘 실행 될지 궁금합니다. 

그런데 이때 BP_PlayerController 에서는 BeginPlay 이벤트때 조종하는 BP_Knight를 끝까지 저장하는식으로 해 놨기 때문에 이전과는 상황이 달라졌습니다. 이전에는 Possess함수로 조종하는 캐릭터를 바꿀수 있었습니다.
레벨 블루프린트로 가서 이전에 빙의 실습을 위해 사용하던 코드를 날려주겠습니다. 
또 까먹은 설정이 월드 세팅 게임모드중 디폴트 폰 클래스를 디폴트 폰 이었던걸 BP_Knight로 바꿔주겠습니다. 

테스트에 한가지 상황을 더 해볼건데 이전까지는 DevMap에 직접 배치했던 BP_Knight 오브젝트들을 이번에는 모두 지우고 시작하면 어떻게 될지가 궁금합니다. 

지금 너무 이리저리 상황이 진행되서 어지러울수 있는데 정리를 한번 하자면 
게임모드란 것은 게임세상에서 어떤식으로 작업할지를 정해주는 기준이 되고 BP_GameMove라는 게임모드를 사용할때는 BP_Knight 가 주인공이 될것이고 BP_PlayerController가 BP_Knight를 조종할것이라는 
나름의 규칙을 만들고 있는 상황입니다. 

게임을 실행해보면 분명 아무 BP_Knight가 없는 상테에서 시작했는데 새로 BP_Knight가 생성되어서 조종까지 됩니다. 다만 위치와 시점이 생소한 곳에서 시작하고 있습니다. 
왜 이런가 하면 우리가 플레이어가 처음 스폰될 좌표를 정해주지 않아서 그렇습니다. 이걸 정해주기 위해서는 Map 화면 왼쪽의 액터 배치 창에서 플레이어 스타트라는 물체를 스폰할 위치에 배치하면 됩니다. 
다시시작하면 이제 정상적인 위치에 스폰도 되고 이동과 공격도 잘 되는걸 확인 할 수 있습니다.

빙 돌아서 원점으로 온것 같지만 이제는 입력하는 코드를 각 폰 클래스에서 관리하는게 아닌 입력을 받는 컨트롤러 클래스에서 모두 관리하도록 정리를 해주고 게임모드를 처음으로 조금 사용도 해봤습니다. 
이제는 나중에 캐릭터의 이동방식이 달라지게 된다면 입력 함수에서 분기문으로 관리하는게 아니라 컨트롤러 클래스를 따로 만들어서 바꿔 사용하면 되겠습니다. 

오늘 한 내용인 게임모드를 새로 만들고 디폴트 폰과 플레이어 컨트롤러를 교체하는것은 앞으로도 수 없이 하게될 작업 중 하나입니다. 
이제는 조종할 캐릭터인 BP_Knight를 배치할때 마다 Possess Player0을 굳이 하지 않아도 기본 세팅에 의해 자동적으로 플레이어가 만들어 지고 이것이 컨트롤러가 선택된다는겁니다. 
그러면 만약 BP_Knight 오브젝트를 강제로 배치한상태라면 어떻게 진행될까요? 정답은 플레이어 스타트 지점에서 스폰된 BK_Knight가 주인공이 됩니다. 
만약 이미 배치된 캐릭터를 조종하고 싶다면 이건 조종하고 싶은 BK_Knight의 디테일에서 Possess를 Player0 으로 강제로 세팅해주면 됩니다. 


그리고 이어서 해골도 마찬가지로 BP_AIController 라는걸 만들어 놨었습니다. 이건 게임모드에서 선택하는게 아니었는데 어디서 선택하는것이냐 하면 BP_Monster 클래스를 열어서 디테일즈 검색창에 
AIController를 검색해보면 AIControllerClass 라는 옵션이 있는데 이걸 BP_AIController로 바꿔줍니다. 그럼 몬스터도 이 BP_AIController안에 UpdateAI 라는 함수를 만들어 주고 호출해주면 
되겠습니다. 

작업은 대칭적으로 할 수 있습니다. BP_Monster의 UpdateAI 코드를 전부 복사해 BP_AIController에도 UpdateAI 함수를 만들어 붙여넣고 또 
BP_AIController의 이벤트 페이지에서 BeginPlay 이벤트때 Get Controlled Pawn을 하고 반환된 Pawn을 Cast to BP_Monster를한 다음 변수 MyMonster 라고 이름지어 저장합니다. 
Tick 이벤트에서는 UpdateAI를 매 프레임 호출해주도록합니다. 
다시 UpdateAI 함수로 돌아가 에러메세지가 나는 부분은 MyMonster의 데이터를 가지고 대체해줍니다. 

잊지말고 BP_Monster 클래스에 있던 UpdateAI 함수를 지워줍니다. 

테스트를 해보면 역시 잘 동작하게 됩니다. 

오늘 배운 컨트롤러에 대한 내용은 언리얼의 특성으로 딱 이렇게 해야한다는게 정해져 있기 때문에 의도한 결과를 얻기 위해서는 어느정도 숙달 되어야 할것입니다. 