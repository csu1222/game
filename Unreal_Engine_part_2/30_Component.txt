


    컴포넌트 


지난시간의 정리를 하고 이번 시간 주제인 컴포넌트를 알아보겠습니다. 

이번에 해보고 싶은것은 해골과 전투를하고 승리하면 킬 카운트가 늘어나는것은 좋은데 죽은 해골들이 일정시간이 지나면 다시 리스폰 된다던지 하면 좋을것같습니다. 
그런 기능을 만들면서 겸사 겸사 컴포넌트에 대해 알아볼겁니다. 

지금까지 여러가지 구조 방식에 대해 배웠고 여러 후보군에 대해서도 배웠습니다. 전역으로 접근할 만한 데이터는 GameMode 클래스에서 들고 있어도 되고 아니면 레벨 블루프린트에서 들고 있을 수도 있고 
이것도 아니면 게임 인스턴스라고 해서 레벨이 바뀌어도 데이터를 유지할 수 있는 클래스에서 관리해도 된다고 했습니다. 

다음으로 알아보는것은 일반적으로 BP_Creature 같은 비교적 상위 클래스를 열어보면 여러 기능들이 추가되면서 가지고 있는 멤버 함수의 수가 점점 늘고 있었습니다. 
처음에 언리얼과 유니티의 비교를 하면서 유니티는 모든 것들이 빈 깡통 클래스에 필요한 기능 컴포넌트들을 추가하면서 만들어 간다고 했습니다. 
언리얼은 상속구조가 굉장히 중요한 엔진이고 이미 단단하게 짜여있는 기능들을 잘 활용하는 엔진이라고 했습니다. 

언리얼에서 클래스를 하나 만들때마다 항상 상속받을 클래스를 정해주고 있고 있었는데 이런 것이 특징이라고 해서 언리얼엔진에 컴포넌트가 없는것은 아니고 유니티에서 상속구조를 아예 사용하지 않는것도 아닙니다. 
BP_Creature의 부모 클래스인 Paper Character 클래스만해도 자신 밑으로 Capsule Component 라고 CollisionCylinder 를 가지고 또 Arrow Component 라고 바라보는 방향을 표시하는 컴포넌트도 있습니다. 
그리고 우리가 추가한 멤버 함수, 멤버 변수들이 점점 많아져서 이것 또한 관리가 어려워질 수 있으면 이런것들도 정리를 해줘야 하는데 

예를 들면 지금 Character Movement라는 컴포넌트가 있는데 언리얼 엔진에서 Character를 만들어 줄때 이 캐릭터의 움직임과 관련된 컴포넌트를 추가해주고 
이런것과 마찬가지로 스탯과 관련된 기능들을 모아 스탯 컴포넌트로 관리해준다면 좀 더 쉽게 관리 할 수 있을겁니다. 

이후 게임을 더욱 발전 시켜서 인벤토리와 관련된 기능을 추가한다면 인벤토리와 관련된 것들을 또 인벤토리 컴포넌트로 관리해 줄 수 도 있습니다. 
물론 인벤토리를 어디서 관리할지는 게임 사양에따라 달라질 수 있습니다. 만약 캐릭터마다 인벤토리를 가지고 있는 사양이라고 하면 BP_Knight 마다 인벤토리를 들고 있게 해 줄 수 있고 
그게 아니라 온라인 게임같은경우는 자신이외의 타인의 인벤토리는 볼 수가 없을 겁니다. 그러면 따로 빼서 현재 접속자만을 가리키는 클래스를 만들어 거기서 자신의 인벤토리를 관리하게 할 수도 있을겁니다. 

그러면 이제 이 컴포넌트를 어떻게 만들고 사용하는지를 알아볼겁니다. 

몬스터가 일정 수 이하로 내려가면 다시 리스폰을 해줘서 일정 개체 수를 유지해주는 컴포넌트를 만들어 볼겁니다. 
이름으니 Spawning Pool 스포닝 풀이라고 하겠습니다. 

생각보다 컴포넌트를 만드는 방법은 단순합니다. 기존 처럼 블루프린트 클래스를 만들때 상속할 부모클래스를 Actor Component 혹은 Scene Component 중 에서 골라주면 됩니다. 
액터 컴포넌트 부터 설명을 읽어보면 액터에 추가할 수 있고 재사용이 가능한 컴포넌트라고 합니다. 
그리고 씬 컴포넌트같은 경우는 위의 액터 컴포넌트를 상속받은 클래스입니다. 그러므로 액터 컴포넌트의 기능에 더해서 씬 트랜스 폼을 가지며 다른 씬 컴포넌트에 붙을 수 있습니다. 
또 씬 컴포넌트는 배치 할 수 있다는 차이점도 있습니다. 

어떤 내용인지 하나씩 실습하면서 알아보겠습니다. 
액터 컴포넌트, 씬 컴포넌트를 각각 상속받은 블루프린트 클래스 두개를 추가하겠습니다. 이름은 BP_ActorComp, BP_SceneComp 라고 하겠습니다.

이렇게 만든 빈 컴포넌트는 이제 다른 액터들에게 추가 할 수 있습니다. 
어느 클래스에서 실습할지 생각하다가 BP_Creature에서 실습해보겠습니다. 컴포넌트 추가창에서 검색으로 BP 까지만 쳐도 우리 만든 컴포넌트 두개가 뜰겁니다. 
둘 다 추가해주고 다시 컴포넌트 창을보면 BP_SceneComp을 선택해보면 디테일즈에 Location, Rotate, Scale 성분들이 있어서 실제로 드래그 드롭으로 
다른 컴포넌트의 계층구조로 넣을 수 있고 BP_ActorComp는 딱히 좌표의 개념이 없기 때문에 그냥 존재만 하는 부품입니다. 비슷한 컴포넌트로 캐릭터 무브먼트가 있었습니다. 

씬 컴포넌트와 액터 컴포넌트의 차이는 딱 이런 차이인데 이번에 만들 스포닝 풀은 액터 컴포넌트로 만들것입니다. 
하지만 스포닝 풀을 BP_Creature 에서 관리하진 않을것이기 때문에 방금 만들었던 컴포넌트들을 없애고 BP_Creature를 나가겠습니다. 

BP_SceneComp는 이번 실습에서 사용하지 않을 것이기 때문에 파일을 삭제하고 BP_ActorComp는 BP_SpawningPool 이라고 이름을 바꿔 주겠습니다. 

스포닝풀은 어디서 관리해줄것이냐면 BP_TileMap에서 관리해주겠습니다. 맵을 처음 만들때 같이 스포닝풀을 만들는것도 괜찮기 때문입니다. 
컴포넌트를 추가할때 아까 처럼 컴포넌트 창에서 추가해주는 방식도 있지만 역시나 코드로도 컴포넌트를 추가할 수 있습니다. 
Add Component by Class 라는 노드인데 이름대로 추가해줄 컴포넌트 클래스를골라 추가해주는 것입니다. 
지금은 툴을 이용해 추가하는 방법으로 해보겠습니다. 
이제 BP_TileMap과 BP_SpawningPool 사이에 일종의 주종 관계가 생긴것입니다. 
이제 BP_TileMap에서 Get Component 류 함수를 사용해 사용중인 컴포넌트를 쉽게 가져올수 있게 되었고 반대로 컴포넌트 쪽에서도 타일 맵을 가져와야할때는 Get Owner라는 함수로 
가져올 수 있습니다. 

스포닝 플을 추가는 해줬는데 그 내용을 채워줘야합니다. 
어떤 식으로 만들것이냐면 몬스터 수를 관리하다가 일정수 이하로 내려가면 리스폰 해준다고 했었습니다. 
몬스터 수를 관리하는것은 타일맵 클래스에서 관리중이기 때문에 타일맵 객체를 가져와야하는데 위에서 말한 Get Owner를 사용해보겠습니다. 이때 가져온 owner 는 그냥 
액터 레퍼런스 타입이기 때문에 한번 BP_TileMap으로 캐스팅해줘야 합니다. 그리고 이때 가져온 타일맵은 이 클래스 내부에서 계속 사용할것 같으니 변수로 승격해 
TileMap이라고 부르겠습니다. 
이후 int 타입 변수 두개를 추가 해 줄건데 각각 CreatureCount라고 해서 현재 크리쳐 카운트와 MaxCreatureCount라고 최대 크리쳐 카운트를 들고 있겠습니다. 
우리가 유지하고 싶은 숫자를 MaxCreatureCount에 넣어줄것인데 처음 말했던 대로 2마리를 유지하도록 하겠습니다. 
몬스터가 스폰 될때마다 CreatureCount가 1씩 증가하고 없어질때는 1씩 감소하는데 현재 갯수가 MaxCreatureCount보다 안될땐는 숫자가 맞도록 스폰을 해주면 되겠습니다.

그러면 이제 CreatureCount를 어디서 증감 시켜줄지가 문제입니다. 이전에 TileMap SpawnCreature 함수를 사용해 몬스터와 플레이어를 배치하고 있었는데 
플레이어는 여기서 스폰하도록 놔두고 몬스터 스폰부분을  BP_SpawningPool 에서 스폰하도록 해주겠습니다. 

BP_SpawningPool에서 몬스터를 스폰해야할지를 체크하는 것을 Tick 이벤트에서하지 말고 새로 커스텀 이벤트를 추가해 주겠습니다. 
UpdateRandomSpawn 이라고 이름을 짓겠습니다. 이 커스텀 이벤트에 어떻게 들어올것이냐면 아까 BeginPlay 이벤트에서 Owner 를 변수로 승격해 세팅한 다음 바로 
이 커스텀 이벤트로 들어오도록 해줄겁니다. 

UpdateRandomSpawn 에서는 시작하면 브랜치를 해줄건데 CreatureCount와 MaxCreatureCount 두 수를 비교해서 CreatureCount가 더 작다면 몬스터 스폰을 해줘야 합니다. 
만약 True 즉 CreatureCount가 MaxCreatureCount보다 작다면 바로 CreatureCount를 1 증가시키고 몬스터를 스폰해주면 되는데 
스폰할때 그냥 바로 스폰하는건 재미 없으니 약간 딜레이를 걸어서 랜덤한 시간 뒤에 스폰되도록 해주겠습니다. 
딜레이할 시간을 Random Float in Range로 적당한 범위를 설정해 넘겨주고 그 후 SpawnCreature를 해주는데 이것은 아까 변수로 세팅해 뒀던 TileMap에서 가져오면됩니다. 

여기까지 왔으면 UpdateRandomSpawn가 한바퀴를 돈것이고  이것을 반복해호출해줄건데 SpawnCreature 뒤에 다시 UpdateRandomSpawn 이벤트를 연결해줍니다. 
처음 브랜치에서 false인 경우는 그냥 다음 틱에 다시 한번 이 이벤트를 호출하도록 Delay Until Next Tick 이후 UpdateRandomSpawn이벤트를 호출해줍니다. 

왜 처음부터 while 루프를 도는게 아니라 이렇게 재귀적으로 호출했냐고 하면 이 이벤트를 시작할때 브랜치에서 false 가 떳을때 이후 코드는 연산하지 않고 그냥 넘어갈 수 있는
코드가 되기 때문입니다. 

여기까지 해서 CreatureCount를 체크해서 몬스터를 스폰해주는 것 까지는 했습니다. 
하지만 아직 몬스터가 사망했을때 CreatureCount를 1 줄여주는 부분이 없는데 죽을때는 BP_Creature의 OnDead 로 들어오게 되고 여기서도 마침 BP_TileMap의 
Despawn Creature 함수를 활용하고 있습니다. 이 Despawn Creature에서 약간의 코드 추가를 하면 될것같습니다. 

Despawn Creature에서는 가지고 있는 크리쳐 목록인 Creatures 에서 지우고자하는 크리처를 Remove하고 그 크리처를 다시 Destroy 합니다. 
그러고 함수가 끝나는데 이 맨 뒤에 크리쳐 카운트를 줄이는 코드를 붙이면 될것 같습니다. 
그냥 곧바로 크리쳐 카운트를 줄여줘도 가능하겠지만 BP_SpawningPool 내부에서 동작하는 변수를 너무 밖에서 수정하게끔 해주는것은 
코드 정리나 유지 보수에 좋지 않을 수 있으니 이 부분을 함수로 만들어서 사용해도 되겠습니다. 

이렇게 해서 스포닝 풀 컴포넌트를 만들어 봤는데 사실 엄밀하게 하자면 BP_Knight도 크리쳐에 포함되기 때문에 몬스터들에게만 스포닝 풀이 동작하도록 해줘야 하는데 
이런것은 나중에 꼭 필요할때 처리해주기로 하겠습니다. 


게임을 실행해서 테스트를 해보면 이제 시작하자 마자 해골이 스폰되어 있는것이 아니라 아까 세팅해둔 딜레이 범위 만큼의 시간이 지나면 차례로 스폰이 됩니다. 