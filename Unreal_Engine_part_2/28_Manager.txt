

    매니저


이어서 기존에 하던 게임 구현과는 조금 다른 내용입니다. 전체적인 구조와 설계에 대해 고민 해볼겁니다. 

그 중에서도 특히 매니저라는것이 이번 시간의 주제입니다. 

지금까지는 그냥 게임을 만들때 생각나는대로 필요에 의해 코드를 이리저리 붙히고 있었습니다. 
게임 구조상 맵이 중요한 역할을 하고 있고 충돌을 관리하고 또 충돌을 관리하기 위해서는 배치된 모든 크리쳐의 정보를 알아야 해서 어쩌다 보니 이 TileMap 에 
온갖 정보와 로직을 다 넣어 놨습니다. 

작은 게임을 만들때는 그냥 이렇게 만들어도 상관없습니다. 포폴같은 경우도 이런식으로 만들어도 충분하지만 
좀 더 진지한 규모의 게임을 만들게 되면 이런 코드를 정리해야합니다. 

또 타일맵에 있는 기능을 다른 크리쳐에서 사용하기 위해서 Get Actor Of Class라는 함수로 계속 가져다 사용했었는데 이 함수의 설명에도 씌여있듯이 이렇게 자주 호출하면 성능 상 
좋지않습니다. 
그리고 TileMap을 가져다 사용하다보면 게임에서 다른 맵으로 넘어갔을경우는 어떻게 그 기능을 사용할지도 애매 합니다.
UI의 경우도 어떤 맵하나에서 관리하는것도 좋지 않고 그 킬카운트 UI도 그 킬카운트라는 데이터를 UI에서 관리하는것도 좋지 않습니다. 


이런 것들을 중앙에서 통괄해 관리하도록 매니저 클래스를 만들어 보겠습니다. 

규모가 큰게임이라고 할 때 한국에서 가장 많이 다루는 MMORPG 장르를 예시로 들어보겠습니다. 
MMORPG를 플레이할때 한 계정혹은 캐릭터는 가지고 있는 아이템들, 인게임 머니, 그리고 스킬등 많은 정보를 가지고 있을것이고 또 이어서 퀘스트, 업적, 길드, 창고 등 많은 컨텐츠와 UI가 맞물려서 동작하게 될겁니다. 
이런 수 많은 데이터를 딱히 관련성없는 하나의 맵에서 관리하게 하는것은 이상할겁니다. 또 각 컨텐츠를 사용할때 요구하는 정보들도 많아질텐데 그 정보들을 편리하게 어디선가 쏙쏙 꺼내
사용해야 합니다. 또 이런 매니저같은것은 싱글톤 패턴으로 만든 클래스 혹은 전역 변수로 언제 어디서든 접근하게끔 만드는경우가 많은데
사실은 언리얼에서도 그런식으로 싱글톤, 전역변수식으로 사용합니다. 

그런데 이것은 C++ 기준이고 블루프린트에서는 그런 느낌을 어떻게 비슷하게내는가 할까요 
사실 블루프린트는 C++ 같은 언어에 비해 자유도가 낮기 때문에 자유자제로 그런 기능을 사용할수는 없지만 언리얼 구조상에서 비슷하게 제공하는 꽤 있기는합니다. 

DevMap으로 돌아가 살펴보도록 하겠습니다. 
그 전에 먼저 언리얼 공식문서를 살펴보면 어떤 이미지가 있습니다. 언리얼에서 게임 만들때 어떤 구조로 만드는지를 형상화 한건데 PlayerController와 AIController가 폰에 빙의하게 되고 
컨텐츠에 속하는 HUD, Input, PlayerCamaraManager 는 PlayerController에 종속되고 또 이 PlayerController는 Game, GameMode, GameState 라고 하는 상위 개념에 종속됩니다. 

이 GameMode, GameState 같은것이 이번 주제에 해당합니다. 사실 게임모드는 한번 본적이 있습니다. 컨트롤러 개념을 도입하면서 게임모드를 잠깐 다뤄봤고 언리얼 엔진 자체가 FPS게임을 만들기 위한 게임엔진이었다고도 
말을 했었습니다. 

그래서 이 GameMode 에서 게임 맵에 종속되는 코드들을 넣어 줄 수 있습니다. 게임 맵이 바뀌게 되면 다른 게임모드를 연결 시켜줄 수 있습니다. 
게임모드가 유용한 이유가 무엇이냐면 언제 어디서든 이 게임모드에 접근 가능한 함수들이 준비되어있기 때문입니다. 
이전에 우리가 만들었던 BP_GameMode를 열어보겠습니다. 

게임모득도 블루 프린트 클래스로 관리되고 있기 때문에 기존의 사용법과 크게 다르지는 않습니다. 
그래도 게임모드 클래스가 다른 클래스들 예를 들어 BP_Creature와 다른점을 알아보기 위해 게임모드에서 변수를 Test란 이름과 Int 타입으로 만들어 보겠습니다. 
이렇게 만든 Test란 변수를 게임모드 밖의 클래스 예를 들어 BP_Creature의 이벤트 그래프에서 쉽게 가져올수 있습니다. 

실습을 해보자면 BP_Creature의 이벤트 그래프, BeginPlay 이벤트 끝에서 해보겠습니다. 신기하게도 바로 Get GameMode 라는 함수를 호출하면 바로 게임모드를 가져올 수 있는데 
다만 이때 반환되는건 언리얼에서 제공하는 일반 GameMode고 우리가 만들었던 BP_GameMode는 한번 캐스팅을 해줘야합니다. 캐스팅을 한 후 반환된 BP_GameMode에서 
Get Test를 해서 아까 만들었던 변수를 가져올 수 있습니다. 
이렇게 게임모드는 전역변수 혹은 싱글톤 객체처럼 사용하기 적합한 개념이라고 할 수 있습니다. 
언리얼 블루프린트에서 중앙에서 관리자 역할을 시키고 싶을때 게임모드를 사용하면 된다는 것입니다. 

지금까지 그 중앙적 매니저를 BP_TileMap에서 담당하고 있었는데 이 기능들을 게임모드에서 관리해 좀 더 언리얼 구조에 맡게끔 만드는 것도 가능합니다. 
물론 지금 소개한 방법이 조삼모사 같이 보일 수 있습니다. 이전처럼 Get Actor Of Class 로 가져와 사용하면되는데 굳이 Get GameMode로 바꿔야 하냐 느낄 수 있는데 
사실 Get Actor Of Class는 정석적인 방법이라고 보기어렵습니다. 

그러면 게임모드는 항상 옳은 방법인가 하면 그렇지 않고 단점도 분명 존재 합니다. 
아까 게임모드는 레벨에 종속적이라고 했습니다. 그래서 게임을 진행하면서 다음 맵, 레벨로 넘어간다거나 하면 그럴 경우 이전 레벨에서 세팅했던 내용이 날라갈 수 있습니다. 
만약에 진짜 게임을 실행하고나서 끌때까지 계속 유지해야하는 정보가 있다고 하면 어떻게 할까요? 

그 답은 게임모드를 이용하지 않고 그 상위의 클래스가 있는데 게임 인스턴스라는 것이 있습니다. 

Blueprints폴더에 새로 블루프린트 클래스를 만들건데 Game Instance 를 상속받아 만듭니다. 이름도 BP_GameInstance라고 지어줍니다. 
이것을 열어서 보면 이 게임 인스턴스는 액터가 아니기 때문에 다른 클래스들과 내용물 생긴게 조금 다르다는걸 알 수 있습니다. 
따로 컴포넌트들도 없고 그래서 무언거 기본으로 떠있는 디테일즈도 없습니다. 

그러면 게임 인스턴스는 어떻게 사용하느냐 하면 언리얼의 상단 설정 칸중 편짐-> 프로젝트 세팅 -> 맵&모드 로 가서 하단에 게임 인스턴스를 우리가 만든 BP_GameInstance로 바꿔줘야합니다. 
이러면 게임이 실행되면 이 BP_GameInstance가 실행이 될겁니다. 이렇게 해서 다시 BP_GameInstance로 돌아가 보겠습니다. 

만약 게임에서 계속 유지되어야 하는 데이터가 있다고 치겠습니다. 예를 들어 온라인 게임과 같은 경우에 첨에 로그인을 해서 캐릭터 ID와 캐릭터 번호가 지정이 됩니다. 
그런것이 UserId 라고 관리 될 수도 있을 겁니다. 
당연히 여러 방법으로 만들수 있기 때문에 정말 딱 정해진 방법인것은 아닙니다. 
다만 여러 시행착오를 거쳐 가장 효율적인 구조를 찾는것이 중요하겠습니다. 

다른 클래스에서 가져오는것은 게임모드와 마찬가지로 Get Game Instance->Cast To BP_GameInstance->Get Test 이런 식으로 가져와 사용할 수 있습니다. 
그런데 매번 이렇게 캐스팅해서 사용하는것도 귀찮다 하면 이전에 블루프린트 시간에 알아봤었던 블루프린트 함수 라이브러리를 만들어보겠습니다. 
이 함수 라이브러리는 어디엔가에 종속적인것이 아니라서 C++ 기준으로 스택틱함수 처럼 어디서든지 사용할 수 있는 것들이기 때문에 
아까 사용햇던 Get Game Instance->Cast To BP_GameInstance->Get Test 라는 일련의 코드 덩어리를 가져다가 스태틱함수로 묶어 버리면 편리하게 사용하게 됩니다. 

이렇게 함수를 묶어서 만드는것을 그냥 귀찮아서 만든다고 생각하는게 아니라 이런식으로 코드를 묶어두는게 현업에서 중요한 부분일 수 있습니다. 
반복적으로 나오는 이야기인데 어떤 코드들이 자주 사용되어서 이곳저곳에 복사 붙여넣기하다가 언젠가 이 코드가 수정되어야 할때 붙여넣기한 부분 모두를 직접 수정해야합니다. 
그렇데 설상가상으로 이후 나중에 추가된 인원이 이렇게 붙여넣기로 작업되어 있을걸 생각하지 못하고 자기가 작업하던 부분만 수정하게 되면 버그가 발생하는겁니다. 

지금도 우리 프로젝트도 마찬가지로 Get Actor Of Class 로 시작하는 코드를 이곳 저곳에서 사용하고 있는데 혹시 나중에 이 부분을 수정해야하면 
일일히 찾아서 수정해야 될겁니다. 최근 언리얼에서 그나마 편하게 할수 있는 방법은 찾고자 하는 노드를 우클릭해서 Find Reference를 하면 어디서 사용하고 있는지를 찾아 볼 수 있습니다. 

이번 시간에 알아보는 내용은 기능상으로는 별 달라질게 없지만 설계, 코드 관리를 어떻게 하면 좋을지를 말하고 있습니다. 

말하다 보니 BP_TileMap이나 BP_GameInstance 같은 전역으로 사용하는 것들에 대해서만 말하고 있는데 이것들 뿐만아니라 그 외에 자주 사용될법한 코드를 따로 함수로 빼서 관리하는게 더 나을 수 있습니다. 
예를들어서 Process Attack 함수에서 자신의 바로 앞의 타일을 찾는 코드 같은경우가 있는데 자신의 앞 타일은 공격뿐 만아니라 이런저런 상황에서 사용될법합니다. 
예를 들어 바로 앞의 NPC에게 상호작용을 한다던지, 앞에 있는 채집물을 캔다던지 할 경우가 있을건데 이런 상황입니다. 
이럴 때 절대 코드들을 복사해 사용하지 말고 함수로 빼서 사용해야합니다. 

함수로 만들고 싶은 코드들을 복수 선택하고 우클릭 후 Collapse to Function 함수로 접기를 하면 새로운 함수로 빠집니다. 


여기서 끝이 아닌게 UI쪽도 한번 다뤄봐야합니다. 