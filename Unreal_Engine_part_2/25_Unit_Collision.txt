


    유닛 충돌


이번시간에는 플레이어와 몬스터 사이의 충돌이 없어서 뚫고 지나 다니는것을 수정해보겠습니다. 
겸사 겸사 공격할때 피격판정을 충돌범위를 가지고 하는게 아니라 타일 단위로 다음 칸에 있는 적을 공격하는 식으로 바꾸겠습니다. 즉, Attack Range 라고 이름 붙힌 콜리전박스를 없애겠습니다.

일단 충돌은 플레이어나 몬스터나 한쪽에서 관리하는것보다는 공통적으로 사용하는 한 오브젝트에서 관리하는게 나을 것 같으니 BP_TileMap에서 만들어 보겠습니다.
충돌을 유닛 별로 진행하기 위해서는 현재 스폰되어있는 캐릭터들을 모두 관리해줄 필요가 있는데 캐릭터의 모든 데이터가 필요하다기 보다는 맵 어디에 위치해 있는가를 알면 됩니다. 
그렇기 때문에 이전에 어느 타일이 이동 가능한 타일인지 배열로 관리하던 MapGrid 같이 관리해 줄 수도 있습니다. 

그런데 만약 맵은 넓은데 캐릭터를 많이 배치 하지 않을것이라고 하면 굳이 맵 전체를 관할하는 배열을 만들기 보다 그냥 존재하는 캐릭터를 배열로 들고 있는것도 괜찮을겁니다. 
여러가지 방식이 있을 수 있는데 우리는 캐릭터들을 들고 있는 방법을 사용해 보겠습니다. 

BP_Creature 타입 배열 변수를 만들고 이름을 Creatures 라고 지어 줍니다. 이 배열은 맵의 크기에 따라 즉 지금은 100개의 공간을 미리 만들어 관리하는게 아닌 
그때 그때 배치되어있는 크리쳐 들을 담아주는 배열입니다. 

어디서 이 Creatures의 내용물을 채워 줘야 할지 고민해보면 BP_TileMap에서는 크리쳐들을 스폰하는 함수 SpawnCreature 가 있었습니다. 여기서 맵의 랜덤 위치에 입력한 클래스의 타입으로 
크리쳐를 배치하는데 이때 Creatures도 겸사 겸사 내용을 채워줄 수 있을것 같습니다. 기존 SpawnCreature의 코드에서 SetDestination 뒤에 이어서 Creatures에 Add 해줍니다. 
그러면 SpawnCreature 를 할때 마다 알아서 Creatures에 들어가게 됩니다. 

그리고 이어서 이벤트 그래프에서 스켈레톤을 스폰하던 부분을 보겠습니다. BeginPlay에서 시퀀스를 해주는데 2번 시퀀스에서 스켈레톤을 스폰하고 있었습니다. 이 스켈레톤 스폰 이전에는 
PlayerStart 에서 배치된 플레이어의 SetDestination을 호출해주는 부분이 있습니다. 플레이어는 SpawnCreature로 스폰시켜주는게 아니었어서 따로 Creatures에 Add 해줘야합니다. 

이러면 플레이어와 몬스터 모두 Creatures에서 관리해주게 됩니다. 

이제 CanGo 에서 좌표의 타일이 이동 가능한지를 MapGrid로 체크해주고 있었는데 여기에 추가로 해당 좌표에 플레이어나 몬스터가 있는지도 추가적으로 체크해주겠습니다. 
여기서 쓰일 특정위치에 크리쳐가 있는지 여부를 판별하는 기능은 공통으로 자주 쓰일것 같으니 따로 함수로 만들어 주겠습니다. 

GetCreatureAtGridPos 라는 이름으로 만들어줍니다. 입력은 역시 Int 타입 두개를 받아주던지 아니면 EGridPos 구조체로 받아줄 수 있습니다. 출력은 역시 해당 칸에 있을 BP_Creature를 반환해줄 것이고 
만약 해당 칸에 크리쳐가 없다면 그 여부를 불리언으로 도 반환해줄겁니다. 그냥 BP_Creature만 반환해 이게 유효한지 체크를 해줄 수 도 있지만 그냥 불리언으로 바로 받아서 사용하는 방법을 채택하겠습니다. 

이제 GetCreatureAtGridPos의 코드를 채워주겠습니다. 
먼저 Creatures의 내용물들을 순회하면서 입력받은 GridPos와 내용물의 GridPos가 같은지를 체크하고 같다면 그것을 반환하고 Creatures를 모두 순회해도 같은 크리쳐가 없다면 해당하는 크리처가 없는채로 반환이 될겁니다. 
Creatures를 For each Loop를 돌면 각 내용물들을 순회할 수 있을겁니다. 각 내용물들의 GridPos를 알아야 하는데 이미 BP_Creature는 자기 GridPos를 변수로 들고 있어서 Get 해오면 됩니다. 
입력값과 크리쳐의 좌표를 같은지를 비교해 결과물을 리턴 노드에 연결해줍니다. 

다시 CanGo로 돌아가보겠습니다. 이전 MapGrid에서 해당 좌표가 벽인지 여부를 체크 한 다음 한번더 GetCreatureAtGridPos로 해당위치에 크리쳐가 있는지를 체크하게끔 하면되겠습니다. 

이렇게 유닛 끼리의 충돌을 구현해봤습니다. 


여기서 끝이 아니라 추가로 공격 판정을 콜리전 박스 충돌로 판정하는 것을 이제는 타일 단위로 다음 칸에 있는 적을 공격하는 식으로 수정해본다고 했었습니다. 

BP_Creature쪽으로 돌아가서 ProcessAttack 함수를 들여다 봐보겠습니다. 어떤식으로 작업했었는지 다시 떠올려 보면 
AttackRange 라는 Box Collision을 Sprite 밑에 만들어서 Sprite가 좌우 반전하는것에 영향을 받도록 만들어 주고 그때 그때 Direction의 값에 따라 위,아래,사이드의 AttackRange를 Select 해준다음 골라준 
콜리전과 다른 BP_Creature 오브젝트와 Overlapping 되었는지를 체크해 그것들에 피격판정을 담당하는 OnDamaged 함수를 호출해 주는 식이었습니다. 

여기서 우리가 원하는 공격범위를 AttackRange들을 모두 제거하고 또 콜리전끼리 충돌했는지를 판별하던 Get Overlapping Actors 함수까지 날려주었습니다. 

이제 내 앞에 있는 칸을 얻어오도록 해보겠습니다. 
시작은 역시 Direction 에 따른 Select를 하는 부분입니다. 상하좌우를 이제는 맵 좌표값으로 다룰것이기 때문에 Select 노드의 입력핀 타입을 EGridPos로 변경하고 각각 구조체 핀 분할을 해 Int 두개씩으로 나눠줍니다. 
각 값을 넣어줄겁니다. UP이면 Y좌표가 1 줄어들 것이고, DOWN 이면 Y값이 1 증가, Right라면 X값이 1증가, Left면 X값이 1감소합니다. 이것을 이제 현재 크리쳐의 위치에다가 더해주면 Direction의 앞칸을 의미하게 됩니다. 
이렇게 만든 다음 위치라는 좌표를 가지고 이 위치에 다른 플레이어나 몬스터가 있는지를 알아야 하는데 이 기능은 아까 BP_TileMap에서 GetCreatureAtGridPos 라고 만들었었습니다. 
BP_Creature에서 BP_TileMap의 기능을 사용하기 위해서 몇번 작업 해봤습니다. Get Actor Of Class 함수로 가져올 수 있는데 사용할때 마다 말하지만 이 함수는 성능상 좋지 않은 함수이기 때문에 지금처럼 
ProcessAttack 같은 Tick 이벤트를 하는 곳에서 사용하는것은 지양해야하고 나중에 처음 한번만 실행하고 그걸 저장해 두는 식으로 사용해야 합니다. 일단은 간단하게 구현하기 위해 사용할겁니다. 
하여튼 BP_TileMap을 가져와서 GetCreatureAtGridPos를 호출합니다. 이 함수에 입력으로 방금 구했던 좌표를 넣어주면 다음 좌표에 크리쳐가 있는지를 체크 할 수 있습니다. 
그래서 그 곳이 무엇인가가 있었다면 그 크리쳐의 피격판정 OnDamaged를 진행하면 될것이고 
이렇게 해서 ProcessAttack도 성공적으로 구현한것입니다. 

실제로 테스트 해보면 이전과 같이 정상적으로 공격과 피격판정이 작동하는걸 확인 할 수 있습니다. 

여기까지 2D 게임중에서도 두가지 방식에 대해 알아본것입니다. 지금처럼 타일 단위로 관리해서 좌표로 관리하는 방법과 또 이전에는 언리얼엔진의 기능들, 콜리전과 중력같은 걸 이용해서 만들었습니다.
둘 다 실무에서 사용할 법한 기법들입니다. 꼭 2D뿐만아니라 3D에서도 칸 단위로 사용하는 게임도 많습니다. 예를 들어서 리니지M 같은게임은 플레이어나 몬스터 끼리 충돌을 일으켜 길을 막는 게임입니다. 
이 충돌을 게임적 로직에 잘 녹여낸 경우이기도 합니다. 타일 단위도 사실 타일의 사이즈를 월드 좌표 기준으로 150이상의 큰 단위로 만들었는데 이걸 잘게 쪼개면 결국 충돌에 대한 이야기입니다. 

