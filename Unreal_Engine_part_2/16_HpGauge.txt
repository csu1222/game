

    체력 게이지


이어서 캐릭터들 머리위에 체력 게이지를 띄워서 피격시 점점 줄어드는걸 해보려고 합니다. 

당연한 이야기지만 UI도 게임에서 굉장히 중요한 부분을 차지합니다. 특히 언리얼 엔진같은경우는 UI와 관련된 부분이 많습니다. 
전부 할 수는 없고 일단 HP게이지에 대한 내용만 실습해보겠습니다. 

실습을 시작하면서 DevMap의 컨텐츠 브라우저 창에서 Bluprints 폴더아래 UI라는 폴더를 새로 만들어 주겠습니다. 
이 UI폴더안에서 우클릭을해보면 유저인터페이서란의 위젯 블루프린트라는것이 있습니다. 열어보면 위젯 블루프린트도 부모 클래스를 골라주는 창이 나오는데 
User Widget 을 선택해줍니다. 이 위젯 블루프린트 파일의 이름은 WBP_HpBar 라고 해주겠습니다.여기서 WBP_는 문법같은건 아니고 그냥 나중에 알아보기 쉽게 
네임 컨밴션을 맞춰준겁니다. 

WBP_HpBar를 열어보겠습니다. 생소한 화면이 뜨게 될겁니다. 이 위젯 블루프린트라는것은 언리얼에서 제공하는 UI를 블루프린트와 역어서 관리한다 라고 생각할 수 도 있고 
이 시스템 자체를 UMG, Unreal Motion Graphics 의 약자로 생각할 수 있습니다. 
언리얼에서도 버전이 굉장히 오래됐습니다. 지금 배우는것은 언리얼 5를 공부하고 있지만 초창기부터 발전해나가는 역사를 보고있다고 할 수 있는데 
초창기에는 힘들게 코드상으로 UI를 구현하고는 했는데 이제는 툴을이용해 그래픽적으로 보면서 UI를 배치하고 오른쪽위에는 디자이너버튼과 그래프 버튼이 있는데 
그래프 버튼을 누르면 여기서 코드를 연동할수도 있는 기능이 있습니다. 

사실 이 위젯 블루프린트의 기능만해도 어마어마하게 많습니다. 그냥 UI배치만해도 골치가 아픈데 보통은 게임회사에서는 UX/UI를 전담하는 팀이 있습니다. 
그래서 게임을 배우는 입장에서는 이 위젯 블루프린트를 완벽하게 마스터 하겠다라는 개념보다는 입문자입장에서 간단간단한 것들만 구현할수있는정도로 공부하고 
나중에 팀에서 필요하다고하면 그때 부터 집중적으로 파도 되겠습니다. 

먼저 화면의 모눈종이에서 오른쪽 위를 보면 Fill Screen 이라고 되어있는데 이건 화면전체를 대상으로하는 UI를 만들때 사용하는건데 우리는 그렇게 까지 필요없고 
Custom 으로바꾼다음 한 200에 25 정도 크기의 UI를 만들어 보겠습니다. 
이 상태에서 왼쪽을 보면 팔레트라는 창이 있습니다 기능이 정말 많은데 지금은 HpBar 하나를 만들고 싶으니까
일반->프로그래스 바 를 이용해서 만들어보겠습니다. 프로그래스 바를 드래그 드롭해 배치했습니다. 

프로그래스바의 디테일을보면 퍼센트라는 이 옵션을 드래그해보면 바가 차오르고 주는걸 볼 수 있습니다. 이런 기능이 있는게 프로그래스바 라는겁니다. 
이외에도 이미지나 버튼 같은것도 정말 많이 사용할것이고 게임화면 크기에 맞춰 크기가 증감하도록 앵커라는것도 사용할일이 많겠지만 
지금 단계에서는 HpBar를 만드는걸 목표로하기 때문에 그냥 프로그래스바의 색만 바꿔주겠습니다.
디테일에서 외형->컬러 및 오퍼시티 채우기 에서 RGB 값을 (1,0,0) 로 수정해주면 빨간색이 됩니다. 

결국 언리얼엔진이나 유니티 엔진이나 겁먹지 말고 이리저리 테스트 해보는게 중요하다고 했었습니다. 
지금까지 건드려본 것들에의하면 우리는 피격판정으로 인한 체력의 증감을 체력바로 표현하고싶고 그것은 프로그래스바의 퍼센트라는 옵션을 건드리면 되겠다 싶습니다. 
이 퍼센트는 0부터 1사이의 값들로 되어있다는것도 알 수 있었습니다. 
그리고 왼쪽아래창은 hierarchy 계층구조라고 해서 WBP_HpBar 밑으로 프로그래스바가 배치되어있습니다. 나중에는 이 계층구조가 많이 복잡해지면서 사용되겠지만 일단은 
프로그래스바 하나뿐입니다. 프로그래스바의 이름을 HpProgressBar라고 수정해줍니다. 

여기까지 하면 HpBar가 준비가 된겁니다. 
이제 우리 클래스에 추가해주면 됩니다. 캐릭터들 머리위에 배치해주면 되는데 어느 클래스에서 관리해야 할지 생각해보면 
사실 BP_Creature가 몬스터 캐릭터 모두를 아우르는 부모클래스다보니 여기서 붙여주는게 합리적일겁니다. BP_Creature의 컴포넌트추가로 검색해보면 Widget 이라는게 있습니다. 
이것을 추가해주고 이름을 HpBarWidget 이라고 지어줍니다. 이 위젯 컴포넌트는 말그대로 위젯을 연결할 수 있는 부품이기 때문에 여기에 또 HpBar를 연결해줘야합니다. 
HpBarWidget의 디테일을 보면 유저인터페이스 란 안에 위젯 클래스를 선택해줄수 있습니다. 지금은 WBP_HpBar 하나밖에 없어서 이걸 연결해줍니다. 

그런데 바로 배치되면 화면에 이상하게 나타납니다. 크기를 조절해줘야합니다. 크기도 줄이고 회전도 시켜줍니다. 참고로 디테일즈에 Draw size라는 것으로도 크기를 조절할 수 있습니다. 
200에 25정도로 해보겠습니다. 배치는 완료되었고 이제 코드에서 Hp에 따라 게이지가 증감하도록 해주겠습니다. 
거듭 말하지만 사실은 기능이 굉장히 많습니다. 예를 들어서 다시 유저 인터페이스 중 스페이스라는 옵션은 월드와 스크린을 선택할 수 있는데 월드는 캐릭터가 멀어지면 그 거리만큼 이 
UI도 작아지는 걸 말하고 스크린은 캐릭터가 아무리 멀어지더라도 UI는 화면에 붙어서 같은 크기를 유지하는 옵션입니다. 

아직은 체력 게이지가 증감하고 있지는 않습니다. 이걸 어디에서 코드를 추가해야할지 생각해보면 우리가 피격판정으로 체력이 주는것은 ProcessAttack 에서 
OnDamaged 를 호출하면서 체력을 깍고 있는데 여기서 printText로 체력을 출력하는 부분을 제거하고 이부분을 체력게이지로 표현되도록 하겠습니다. 
언리얼엔진에 익숙하지 않으면 당황할 수 있지만 우리가 해야할 일을 생각해보면 일단 HpBar를 가져다가 퍼센트 값을 주면 그 만큼 프로그래스 게이지가 채워질것이고 
이걸 툴로 할 수 있는 일은 코드로도 다 가능할것이라는 믿음을 가지고 일단 시도해봅니다. 

컴포넌트로 추가한 HpBarWidget을 Get 해오는데 이걸 그대로 사용하진않고 아까 여기서 다시 위젯클래스를 설정했었습니다. 
Get User Widget Object 라는 노드를 꺼내 HpBarWidget 을 연결해줍니다. 이것을 이용해서 WBP_HpBar를 가져올수 있습니다. 그 전에 Get User Widget Object는 
User Widget Object의 레퍼런스를 반환하는데 우리가 사용하기 위해서는 한번더 캐스팅을 해줘야합니다. Cast to WBP_HpBar 를 사용합니다. 

이부분은 몇번하다보면 익숙해지는데 Widget 컴포넌트는 결국 따로 만들어둔 Widget Blueprint를 가져와 그려줄 수 있는 도구입니다. 
실제로 사용할 WBP_HpBar 객체는 위와같이 꺼내올 수 있습니다. 꺼내온 WBP_HpBar 객체에서도 다시 HpProgressBar를 꺼내와 그 퍼센트를 건드려야 HpBar를 구현할 수 있다보니 
WBP_HpBar에서 다시 Get HpProgressBar를 꺼냅니다. 여기서 또 Set Percent를 검색해 배치할 수 있습니다. 

이제는 현재 체력이 몇 퍼센트인지를 Set Percent에 넘겨주면 되겟습니다. 여기서 잘 생각해보면 지금 UI관련코드가 있는 ProcessAttack 함수는 공격자 입장에서 호출되고 있습니다.
그래서 Set Percent에 넘겨주는 Hp는 공격자측이 아닌 피격자 측의 값을 넘겨줘야합니다. 그래서 Get Overlapping Actors에서 반환된 피격자 오브젝트의 체력을 가져와 사용하던지 
아니면 아예 이 UI를 피격자 측에서 실행되는 OnDamaged 함수에서 후출해주던지 해야합니다. 

그래서 이런 설계가 항상 고민입니다. 말이 나온긴에 UI코드를 OnDamaged쪽으로 이동해줍니다. 
여기서 피격연산을 할때 사용하던 Hp와 MaxHp를 그냥 나눗셈해 사용하면 되는데 정수끼리의 나눗셈에서 주의해야할것은 소수점 아래의 값이 날라가기때문에 Hp,MaxHp 둘 중하나를 
Float로 캐스팅해 연산해줘야힙니다.

이제 잘 되었는지 게임을 실행해봅니다. 그려면 때리기 시작하면 HpBar가 줄기는 주는데 아무 공격안했을때 HpBar가 꽉차있지 않고 애매하게 차 있습니다.

왜 이런 문제가 발생했는지 생각해보면 Set HpBar가 게임을 처음실행할때 같이 실행되지 않기 때문에 그렇습니다.
한번 다시 WBP_HpBar 의 HpProgressBar로 가서 퍼센트 값을 테스트하느라 엉뚱한값이었던걸 1로 수정해보겠습니다. 그러면 처음부터 HpBar가 만땅인걸 볼 수 있습니다.
땜빵같아보이지만 일단은 우리가 의도한대로의 기능을 만들었습니다. 

다시 한번 훑어보겠습니다. 
위젯 블루프린트라는 파일을 만들어서 UMG 시스템을 활용합니다. 이걸 이런저런 수단으로 UI를 꾸미는데 우리는 그냥 프로그래스바 하나만으로 체력바를 표현했고 
이 위젯블루프린트를 우리 BP_Creature에 적용하기 위해서는 위젯 컴포넌트를 클래스에 추가하고 이 위젯 컴포넌트가 연결할 위젯 클래스를 방금 만든 위젯 블루프린트 파일로 설정합니다.
코드상에서는 피해를 받는쪽에서 코드를 작성하는게 나을거 같아서 OnDamaged쪽에 코드를 추가했습니다. 

이부분이 고민이 되는데 OnDamaged는 이전까지는 피격자 입장에서 공격을 받은뒤 자신의 체력을 깍는 연산을하고 있었습니다. 그런데 지금 추가된 UI관련 코드는 
엄밀히 말하면 피격판정 연산과는 관련이 적습니다. 그런게 아쉬운데 그렇다고해서 이 방법이 무조건 잘못되었다는것은 아니고 이렇게 진행하려면 앞으로는 
항상 피격판정 연산뒤에는 HpBar를 표시하는 코드가 딸려있다고 기억하고 이것을 또 함수이름에 티가 나도록 표현해주면 좋습니다. 
왜 이렇게 하냐면 나중에 협업을 하게되면 나중에 만약에 이번엔 힐을 받는 함수를 만들어 OnHealed 라고 하고 HP가 힐링되는 코드를 작성합니다. 그런데 이어서 UI를 갱신하는 코드를 까먹고
추가하지 않는다면 힐을 할때는 HpBar가 움직이지 않는다는 버그가 발생합니다. 

그래서 UI를 관리하는 코드를 그냥 복사 붙여넣기로 계속 추가하다보면 관리하기가 힘들어 지기 때문에 Hp를건드리는 함수에서는 무조건 이어서 관리를 하거나 UI부분을 함수로 만들어 관리
하도록 해야합니다. 

또 참고로 지금처럼 UI를 직접 건드리는 방법 WBP_HpBar를 가져오고 Set Percent를 사용하는 방법이 절대 하면 안되는것은 아니긴합니다.
사실 언리얼에서 제공하는 우아하고 재밌는 방법들이 많습니다. 

다시 WBP_HpBar 로 돌아가보겠습니다. 여기서 체력이 바뀌었을때 HpProgressBar의 퍼센트가 바뀌어야 된다는건데 여기서 바인드라는 기능이 있습니다. 
바인드는 무언가를 엮다라는 의미가 있습니다. 그래서 우리가 원하는 값과 HpProgressBar의 퍼센트와 엮어 놓을 수 있습니다. 
Create Bind를 할때 어떤 함수와도 엮을 수 있고 아니면 어떤 변수와도 엮을 수 있습니다. 

Create Bind를 하면 WBP_HpBar의 그래프쪽에 자동으로 Get_HpProgressBar_Percent 라는 함수가 만들어지고 이게 매 프레임마다 호출이 될겁니다. 
이함수의 내부에 알맞는 값을 추출해서 Return노드에 연결해놓으면 매프레임 퍼센트가 갱신이 된다는고
꼭 함수가 아니라 변수를 이용해 바인딩 할 수도 있습니다.
디자이너 쪽으로가서 바인딩을 눌러보면 바인딩제거를 할 수 있습니다. 제거해서 다시 원상복귀 시키고나서
 Get_HpProgressBar_Percent 함수를 날리고 변수를추가해 Float 타입으로 설정합니다. HpRatio라고 이름을 지어줍니다.

다시한번 디자이너 쪽에서 바인딩을 눌러보면 함수바인딩 뿐만아니라 방금만든 HpRatio도 선택할 수 있다는걸 볼 수 있습니다. 
HpRatio와 바인딩을하면 이제 HpRatio값을 수정하면 그 값에 따라 퍼센트가 달라지게 됩니다. 이걸 테스트 하기 위해서 HpRatio값을 1로 설정해 시작할때는 만피라고 하겠습니다.
WBP_HpBar 라는 위젯 블루프린트의 그래프를 이제 마치 블루프린트 클래스처럼 사용할 수 있는데 HpRatio를 Get, Set 하면 그 값에 따라 UI가 변화합니다.

이것을 우리가 실습했던 코드에 적용하면 WBP_HpBar에서 다시 HpProgressBar를 꺼내고 그 중 Percent 값을 set 해주던걸
WBP_HpBar에서 바로 Set HpRatio를 꺼내 세팅해주겠습니다. 우리가한것은 그냥 변수값만 바꿔본것인데 게임을 실행해 공격해보면 UI가 변화된다는걸 확인 할 수 있습니다. 
이것이 바인딩의 효과입니다.

이렇게만 보면 Percent를 건드리나 변수를 만들어 건드리나 거기서 거기아닌가 싶습니다. 하지만 나중에 가면 WBP_HpBar가 HpRatio라는 변수를 관리하는게 아니라 
WBP_HpBar가 관리하고 있는 플레이어나 몬스터의 Hp값을 참조해 저장하다가 그걸 이용해 그 크리쳐의 체력게이지를 실시간으로 계산해 HpBar에 바인딩해줄 수 있습니다. 

다시 정리하면 원하는 UI의 특정함수를 실행해 UI를 건드릴 수도 있고 언리얼엔진에서는 바인딩기능도 제공해서 어떤 함수나 변수의 값과 연동을 시켜 그에 따라 UI가 자동으로 갱신이 되는 
기능입니다. 