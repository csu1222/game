

    타일맵 정보 추출 


이번시간에는 타일맵에서 각 타일의 정보를 추출해 이리저리 활용하는 방안에 대해서입니다. 
시작하기에 앞서 이전 시간에 표시에서 콜리전을 체크했던걸 풀면 화면이 조금 지저분한게 정리될겁니다. 

처음에 만약 아무것도 없이 타일맵 정보를 추출하려고 하면 막막할겁니다. 지금까지는 항상 어떤 기술을 공부할때 책이나 강의를 본 다음 그걸 응용해 구현하는 식으로 진행했을겁니다. 
하지만 언젠가 이런 상용엔진을 공부할때는 직접 헤딩을해가면서 돌파를 해야할수 있습니다. 

타일맵에 대한 정보를 추출하려면 어떻게 해야할지 생각해보겠습니다. 사실은 지금까지 배운 내용을 잘 조합하면 해결할수 있는 문제입니다. 
우리가 타일맵을 배치할때 TileMap 파일을 드래그 드롭해 만들었고 그리고 이 타일맵의 타입이 뭔지 아웃라이너에서 보면 PaperTileMapActor라고 되어있습니다. 여기서 Actor라는게 중요합니다.
언리얼에서 Actor란 게임 세상에 배치할 수 있는 것들을 Actor라고 표현하는데 지금까지 BP_Knight나 BP_Skeleton은 상속구조를 통해서 기능을 추가하거나 부모클래스 타입을 추출해 사용하거나 했습니다. 

그렇다면 지금 TileMap도 예외가 아니라는것입니다. 
컨텐츠 브라우저에서 BluePrints 폴더로 돌아가서 블루프린트 클래스 생성할 때 TileMapActor를 찾아보면 PaperTileMapActor를 찾을 수 있습니다. 이것을 상속받아서 BP_TileMap이라는 클래스를 만들어 주겠습니다. 
BP_TileMap을 열어보면 컴포넌트에 Render Component라는게 하나 있습니다. 이것의 디테일즈에서 타일맵을 골라 줄 수있는 부분이 있는데 열어보면 고를수 있는 타일맵이 이전시간까지 만들었던 
타일맵 한가지입니다 선택해 주겠습니다. 그리고 지금 프로젝트에서는 이런저런 이유로 캐릭터든 뭐든 5배로 크기를 키워서 사용하고 있었습니다. 이것도 마찬가지로 크기를 키워줍니다. 
컴파일 저장을 해줍니다. 

BP_TileMap도 역시 블루프린트 클래스이다 보니 이벤트 그래프로 가보면 BeginPlay 이벤트, Tick이벤트 도 있고 ActorBeginOverlap 이라는 이벤트도 있습니다. 
여기서 코드를 사용하면 이런저런 정보를 추출할 수 있겠다 싶습니다. 

DevMap으로 가서 이전시간에 추가했던 맵을 삭젱하고 BP_TileMap으로 배치해주겠습니다. 위치도 Location 리셋버튼을 누르면 원래 자리로 가서 그대로 게임 실행해도 잘동작합니다. 
바뀐건 BP_TileMap라는 클래스로 만든 맵이라는것 뿐입니다. 

오늘 하고 싶었던 맵에 대한 정보를 추출하기 위해서는 블루프린트 코드를 통해 추출하면 되는것입니다. 여태껏 만들었던 타일 맵은 언리얼의 툴을 가지고 레이어도 나누고 벽과 바닥을 만들고 
또 콜리전을 추가하던 것이었는데 언리얼이건 유니티건 결국 코드로 기능을 만든 다음 그 기능과 툴을 연결시켜서 작업을 하도록 되어있을겁니다. 

그렇다보니 우리는 언리얼에 익숙하지 않아도 PaperTileMapActor이라는 상위 클래스도 있고 타일 맵 툴도 있으니 이 둘사이를 연결하고 맵의 데이터를 추출하는 어떤 함수나 매크로 기능이 있을것이라고 
믿고 블루프린트 창에서 그 기능을 찾아야합니다. 이런 비슷한 일을 맵 뿐만아니라 처음 다루는 분야에도 적용해 스스로 헤딩해야합니다. 

이어서 BP_TileMap 클래스를 열어서 컴포넌트줄 Render Component를 살펴보면 우리가 이전시간에 만들었던 TileMap이 어디에 위치해 있는지를 보면 Render Component의  Tile Map 이라는 옵션에 있었으니까 
왠지 모르지만 렌더 컴포넌트를 Get 해서 tile과 관련된 노드를 검색해보겠습니다. 이렇게 찾고자하는 기능의 키워드를 검색해 나오는 기능들의 이름을 보면서 찾는걸 권장합니다. 
그 중에서 타일에 대한 정보를 얻고 싶을때는 Get Tile 이라는 함수를 사용하면 되지 않을까 합리적으로 생각할 수 있을겁니다. 

Get Tile 함수는 입력으로 X, Y 좌표와 레이어 번호를 받습니다. 이전에 Wall 레이어와 Ground 레이어의 번호가 레이어 번호일것이고 알고 싶은 타일의 좌표를 넘겨주면 될것 같습니다. 
리턴 벨류는 페이퍼 타일 구조체를 리턴하는데 이것을 구조체 핀 분할을 하면 원하는 데이터를 얻을 수 있을것 같습니다. 또 이 핀 분할한 리턴값들을보면 타일의 인덱스, 타일셋 레퍼런스, 그리고 잘 모르겠는 
Flip H, Flip V, Flip D 라는 불리언이 있습니다. 앞의 두개는 아마도 타일이 속해있던 타일셋 객체의 레퍼런스와 그 타일셋중 몇번째 타일이었는지 인덱스를 말하는것 같습니다. 
타일셋 객체의 레퍼런스를 Is Valid 체크를 하면 이 타일이 유효한지 알 수 있을것 같습니다. 이런식으로 접근해 나가면 처음 알아보는 기능도 더듬더듬 진행해 나갈 수 있을겁니다. 

이제 코드를 만들어 볼건데 우리가 하고싶은게 무엇이냐면 맵에 있는 정보를 추출해서 각 좌표의 타일이 갈수 있는 타일인지 아닌지를 불리언 배열로 관리해주겠습니다. 
불리언 변수를 하나 추가해서 MapGrid 라는 이름을 붙여주고 불리언 배열로 변경해 주겠습니다. 2차원인 맵 좌표를 배열로 어떻게 관리할 것이냐면 
맵을 기준으로 10*10 으로 되어있으니 0 에서 9번은 맵의 첫줄을 각각 매핑할것이고 다믕 10번 인덱스는 맵에서 한줄 내려와 (1,0) 위치를 매핑해줄겁니다.
이런식으로 2D맵을 1차원 배열로 관리할때는 이런식으로 하는게 일반적입니다. 
그러면 내가 어떤 특정 좌표를 안다고 했을때 그 좌표에서 아래방향으로 가고 싶다면 그 좌표 인덱스에 10만큼을 더해주면 아래로 가는 좌표가 될것이고 왼쪽으로 거려면 1을 빼주고 오른쪽은 1을 더해주고 
위로는 10을 빼주는 식으로 알 수 있을겁니다. 

다시 MapGrid를 어떻게 채워줄것이냐면 BP_TileMap의 BeginPlay 이벤트에서 Sequece 노드를 연결합니다. 이 시퀀스에서 첫번째로 MapGrid를 채워줄겁니다. 그 전에 먼저 MapGird의 크기를 조정하는 
Resize부터 해줄겁니다 지금은 맵이 10*10 크기이니까 100개 짜리로 만들면 되긴 하지만 지금 이걸 하드코딩식으로 100 으로 Resize 하게되면 나중에 만약 사양이 달라졌을때 또 직접 맵의 크기를 매번 수정해줘야합니다. 
그러니까 이것 맵의 크기라는것도 추출을 해줘야합니다. 

렌더 컴포넌트를 다시 Get 해와서 노드를 검색해보면 Get Tile Map 이라는 노드가 있습니다. 여기서 다시 Get Map Width와 Get Map Height 를 꺼낼 수 있는데 이것이 있을것이라는 힌트는 
TileMap 파일의 디테일즈에 있었습니다. 이 기능을 코들에서 꺼내 사용하는겁니다. 이 두가지 Width와 Height를 곱하면 맵의 크기를 알 수 있을겁니다. 
이렇게 만든 TileGrid의 Resize를 Seqence 0번을 연결해주면 일단 사이즈는 맞춰 둔것입니다. 

여기까지 잘 실행이 되는지 Seqence 1번에 아무노드를 연결하고 테스트 해보겠습니다. 그냥 PrintText 를 하나 연결해주겠습니다. 이 PrintText 노드에 중단점을 걸고 게임을 실행합니다. 
그러면 각 노드에 커서를 가져다 대면 그 실행하는 시점의 데이터들을 볼 수 있는데 의도한대로 MapGrid의 크기는 100으로 리사이즈 되고 있습니다. 그리고 렌더 컴포넌트와 거기서 가져온 타일맵도 확인 할 수 있습니다. 
중단점으로 멈춰놓았을때 이 타일맵의 정보를 살펴보면 많은 힌트를 얻을 수 있습니다. 방금 꺼내온 width, height도 들어있고 또 타일 레이어스 라고해서 이전에 만들어준 Wall레이어와 Gound레이어 정보도 들어있는걸 알 수 있습니다.
이런것을 뒤져보면서 나중에 활용할 힌트들을 얻을 수 있습니다. 

이제 시퀀스 0번에서 MapGrid의 크기를 맵의 크기만 큼 확장해주었으면 이제 시퀀스 1번에서 각 타일중 갈수 없는 영역을 하나씩 골라서 그 부분만 true로 세팅해줘야 하는 부분입니다. 
일단 MapGrid를 순회하면서 값을 수정해줘야 하니 For Each 노드를 사용할것입니다. 이 For Each 노드의 반환 값중 인덱스라고 하는 값을 맵의 좌표로 환산해야합니다. 
당연히 규칙이 있는데 아까 얘기 한 대로 10개씩 끊어서 열이 달라지는데 이걸 구현하는 방법을 알아보겠습니다. 

For each 노드에서 Array Index 핀을 뽑아서 % 연산자 노드를 꺼내주고 또 / 나눗셈 연산자 노드를 꺼내 줍니다. /은 말그대로 나눗셈이고 % 연산자는 프로그래밍에서 나머지 연산자라고 해서 어떤 값으로 나누고 나서 
남은 나머지를 반환 해주는 연산자입니다. 이 두가지 연산자를 가지고 몫과 나머지로 x 좌표값, y 좌표값을 추출할겁니다. /로 몫을 어떻게 가져올것이냐면 어떤 좌표를받아서 그 좌표에 맵의 너비값인 10을 나눠줄건데 
그러면 정수타입과 정수 타입을 나누게 됩니다. 만약 76 / 10 이라고 하면 프로그래밍에서 정수끼리의 나눗셈에서는 소수점 이하가 버려집니다. 즉 7이라는 값이 나오고 이 7이라는 값은 몫이 됩니다. 
나머지 연산은 76과 10을 나누게 되면 6이 나머지가 되므로 두 값을 각각 x, y 좌표로 치면 (7,6) 이라는 좌표가 되는겁니다. 물론 우리코드에서는 인덱스가 0부터 시작하는 만큼 보정을 조금 해야합니다. 

이제 이 몫과 나머지 값들을 위에서 미리 알아 봤었던 렌더 컴포넌트->Get Tile 코드를 사용할 때입니다. 좌표를 넣어주면 그 위치의 타일정보를 가져오는데 레이어 번호를 입력하는 부분에서 아까 알아봤던 
Wall 레이어번호인 1을 넣어주겠습니다. (지금까지 하드코딩한것은 나중에 한번에 수정해 줄 수 있습니다.) 해서 이 좌표가 유효한지 Is Valid를 해주는데 만약 유효하다고 하면 타일이 이 위치에 있다는 말이고 
Wall레이어에서 타일이 있다는 것은 벽이 있는 좌표라는 것이니까 이동 할 수 없는 좌표라는것이고 Set MapGrid를 해서 true로 세팅해주겠습니다. 

지금까지 한 작업을 한번 정리해보겠습니다. BP_TileMap을 만들고 그 이벤트 페이지의 BeginPlay 이벤트에 코드를 작성하였는데 하려는것은 맵의 각 타일이 이동할 수 있는 타일인지 이동 할 수 없는 타일인지를 
MapGrid라는 불리언 배열로 정보를 추출하고 싶습니다. 먼저 두가지 부분으로 나눠 실행하기 위해 Sequence 노드를 사용하였고 Then 0번에서는 MapGrid를 타일맵의 타일 수 만큼으로 리사이즈 했습니다. 
이때 타일 맵의 너비, 높이를 가져오기 위해 렌더 컴포넌트에서 Get Tile Map으로 타일 맵 레퍼런스를 가져오고 여기서 다시 Map Width와 Map Height를 가져와 곱했습니다. 
다음으로 Then 1번 에서는 MapGird의 각 원소들을 타일의 이동 가능 여부로 삼는 코드였습니다. 1차원 배열을 2차원 타일맵의 좌표로 표현하기 위해 배열의 인덱스 값을 맵의 너비값으로 나눠 나머지를 x좌표,
몫을 y좌표로 사용했습니다. 그것으로 MapGrid를 For Each 순회를 도는데 각 좌표의 타일이 Wall 레이어에서 유효한지를 체크해 유효하다면 벽 타일이고 즉 이동불가능한 타일이라는것을 MapGrid에 작성해 나갔습니다. 

마지막으로 시퀀스 노드에 Then을 하나 추가해서 모든 연산이 끝났으면 printText를 하도록 여기에 중단점을 걸고 한번 잘 동작했는지를 확인해보겠습니다. 
의도대로 잘 벽있는 인덱스는 True, 아닌 곳은 false 입니다. 

이제 이것들을 토대로 몬스터나 플레이어가 이동가능한 곳으로만 이동하는 코드를 만들어야하는데 이것은 다음 강의에서 하고 
지금을 다른 함수 하나를 더 만들어볼겁니다. CanGo 라는 이름의 함수를 만들어서 다음 시간에 사용할 자신의 좌표에서 가고자 하는방향으로 이동할수 있는지 여부를 알아보는 함수입니다. 여기서 좌표는 타일맵 기준의 좌표를 말합니다. 
CanGo 함수는 입력을 두개 받아줄건데 둘 다 int 타입으로 맵 좌표를 받아줍니다. 반환은 불리언타입을 반환하면서 이동할 수 있는지 없는지 여부를 반환할겁니다. 
이제 MapGrid를 가지고 갈수 있는지 여부를 판별해줄겁니다. 그걸 알기 위해서는 좌표에서 MapGrid인덱스로 변환을 해줘야합니다. 위에서 했던것의 반대행동인데 좌표, 인덱스간 규칙이 x좌표는 그대로이고 y좌표는 10을 곱한 다음 x와 더해줍니다.
