

    피격 판정 #1


이전시간까지 기사 캐릭터와 스켈레톤을 배치하기 위해 상속구조설계를 통해 크리쳐 라는 부모 클래스를 만들어 상속하였고 
또 자식 클래스들의 플립북을 일일히 지정하기 보다는 따로 데이터 테이블로 빼서 관리하도록 하였습니다.

이제 해볼 것인 본격적으로 기사와 스켈레톤간의 공격, 피격을 구현해보는 시간입니다.
전투 시스템의 기초라고 할 수 있습니다. 

전투 시스템을 처음 만들때 고민이 많아 질 수 있습니다. 당연히 전투에서는 공격력과 최대 체력, 현재 체력이 있을것인데 그런데 그 다음에 기사가 공격모션을 때렸을때 
누가 어디서 스켈레톤의 체력을 깍는 코드를 실행해야할것인지 고민이 됩니다. 이런 사소한부분에서 설계적인 노하우가 조금씩 쌓이는건데 
일단은 공격을 해서 스켈레톤이 맞았다는 판별이 되어야 체력을 깍을 수 있을겁니다. 그리고 또 한가지 지금은 캐릭터나 몬스터를 DevMap에 직접 오브젝트를 드래그 드롭으로 배치했지만
나중에 되면 몬스터가 몇 백 몇 천이 될 수 있는데 그러면 하나하나 드래그 드롭하는것보다 코드상에서 몬스터를 스폰시키는게 더 나을겁니다.
이렇게 이곳저곳에서 스폰된 몬스터중에 피격판정을 받은 오브젝트를 구별할 줄 알아야합니다. 지금 그냥 글로봐서는 당연한게 아닌가 할 수 있는데 
코드로 만들어볼려고 하면 그렇게 쉽게 되지는 않을 수 있습니다. 

또 한가지 기사가 공격을 했을때 그 피격범위 안에 있다는 것을 어떻게 판별할 수 있을까요? 이것도 굉장히 다양한 방법이 있을겁니다.
예를들어서 몬스터들을 별도의 따로 컨테이너로 (배열이나 맵)관리하다가 플레이어가 공격한다고 하면 그 플레이어 공격 범위 안에있는 몬스터를 찾아 피격된다고 해도 되고 

그게 아니면 3D 게임에서 자주 사용되는 방법으로는 충돌을 이용한 방법입니다. 이 충돌이라는 용어가 3D게임에서 굉장히 많이 등장을 하는데 이전에 Character 클래스를 상속받고나서 
중력의 영향을 받아 바닥으로 떨어지던걸 받쳐주는 블로킹 볼륨과도 충돌을이용해 받쳐주던 것이고 DevMap에서 플레이어 캐릭터를 자세히 보면 실선으로 캡슐모양 범위가 설정되어있습니다.
이것도 충돌 범위입니다. 그래서 이전에 스켈레톤을 지나치치 못하고 멈췄었습니다. 이것도 충돌의 한 예시라고 볼 수 있습니다. 
이런식으로 플레이어가 공격했을때 공격범위에 어떤 충돌이 가능한 범위를 설정해서 충돌한 몬스터를 판별해 피격 판정을 내릴 수 있지 않을까 싶습니다. 

옛날 게임들 바람의 나라 같은 경우는 캐릭터의 이동이 타일 형식으로 이동을 하고 공격도 타일로 내가바라보는 앞칸을 공격하는 방식이었으니깐 그렇게 공격판정을 판별 할 수도 있습니다.

우리는 충돌을 이용한 피격 판정을 구현해 볼겁니다. 그러면 이제 또 충돌박스는 어디서 관리해야할지 고민이 됩니다. 나중에는 몬스터도 공격을 할것이기 때문에 그렇다 보니 공격 범위라는 기능은 
공통적인 곳에서 들고 있는게 낫지 않을까 싶습니다. 

그런 의미에서 BP_Creature클래스를 열어보겠습니다. 뷰 포트를 보면서 시작할건데 컴포넌트 창을보면 캡슐 컴포넌트(CollisionCylinder) 라고 캐릭터 자체의 부피를 나타내는 범위가 있는데 이거 말고
이제 캐릭터 앞쪽으로 피격범위를 판별해줄 무언가를 추가해주겠습니다. 컴포넌트 추가로 찾아보면 Collision 류 중에 Box Collision이라고 있습니다. 추가하고 이 Box Collision을 일단 Sprite 산하로 위치 했습니다.
이렇게 해야지만 나중에 좌우로 캐릭터가 뒤집힐때 Box도 같이 뒤집히기 때문입니다. 다음으로 Box의 범위를 정당히 조절해주면 되는데 뷰포트에서 qwer 버튼과 마우스로 조절할 수 있습니다. 

만약 이 Box Collision 을 Sprite 산하가 아닌 다른곳에서 추가했으면 비교적 작은 크기인데 Sprite산하에서 만들면 좀 크게 만들어 집니다. 왜냐하면 Sprite에서 스케일을 기본 값이 아닌 
(5,5,5) 로 만들었었기 때문입니다. 범위를 적절히 조절했으면 이제 코드로 이 box를 피격범위로 인정하겠다 하면 됩니다. 경우에 따라 피격범위에 자신도 걸릴 수 있어서 앞으로 땡길 수도 있는데 
일단은 진행해보겠습니다. 이제 이 박스를 AttackRange라는 이름으로 바꿔서 어떤 용도로 사용할건지 명시해줍니다. 

DevMap로 가보면 게임 실행전에는 AttackRange가 표시되는데 실행했을때는 사라집니다. 이것은 다시 BP_Creature클래스에서 AttackRange의 디테일즈에서 렌더링 쪽에 Hidden in game 게임중에 숨김 옵션이 켜져있는데
이걸 체크 해제한 후 실행하면 게임실행중에도 공격범위가 표시됩니다. 이건 디버깅할때 확인용도로 사용할 수 있습니다. 

나중에가면 캐릭터의 공격범위 값을 따로 들고 있으면서 그 값에 따라 이 AttackRange라는 Box Collision의 크기를 조절해주게 할 수 있습니다. 지금은 간단하게만 해줄겁니다. 

이 다음으로 해야할것은 내가 공격할때 박스 안에 들어오는 대상을 체크하는겁니다. 게임에 따라 한번에 한 대상만 공격하는 사양도 있고 범위안의 모든 대상을 공격하는 사양도 있습니다. 
우리가 만듵 코드를 살펴보면 UpdateAnimation 함수가 애니메이션과 관련된 부분이었고 UpdateLogic이 이동과 관련된 부분이었습니다. 
그 다음에 공격할때 키입력을 받는 부분은 Attack Event 라는 커스텀 이벤트 부분에서 관리하고 있었습니다. 이 Attack Event를 봐보겠습니다.

Attack Event는 공격키를 입력받으면 State를 Skill로 수정하고 공격 애니메이션을 실행해주도록 한 다음 공격애니메이션의 길이만큼 다른 State로 바뀌지 않도록 딜레이를 거는 작업을 하고 있습니다.
딱히 피격판정에 대한 코드는 없습니다. 그리고 Attack Event라는 이름이 햇갈릴 수 있으니 BeginAttack 이라고 이름을 바꿔주겠습니다. 
공격판정하는 코드를 이벤트 코드 중간에 끼워 넣어야하는데 공격 애니메이션을 실행하고 딜레이하는 사이에서 코드를 추가해줘보겠습니다. 

새로 함수를 만들어 ProcessAttack 이라고 이름지어줍니다. 
여기서 주변의 몬스터를 끌어 모아야 하는데 이 함수가 게임에 따라서 엄청난 코드량을 가지게 된다고 합니다. 거의 몇천줄 짜리 함수가 되기도 하는데 주변에 있는 타겟들을 다 가져와서 피격판정을 진행하게 될텐데 
이것은 3D 게임의 경우에는 로직이 굉장히 복잡해집니다. 일단 3D 세상인데다가 범위안에 있는 타겟들중에 아군도 있을 수 있고 또 타겟이 무적스킬을 쓰고 있는 중이라던가 할 수 있습니다. 
하여튼 우리의 ProcessAttack에서는 뭐부터 해야할지 생각해보면 일단 무작정 AttackRange 라는 걸 꺼내보겠습니다. 

그리고 이제는 이렇게 생각 하는 법을 익혀야합니다. 잘 모르겠지만 이 AttackRange에는 무언가 범위에 있는걸 체크하는 기능이 있을것 같다고 생각해 찾아봅니다.
Actor를 검색해보면 Get Overlapping Actors라는 함수가 있습니다. 배치하고 커서를 가져다 대보면 오버랩된 엑터들을 액터 배열로 가져온다고 합니다. 
그리고 그냥 모든 액터를 긁어와야하는게 아니라 입력 핀에서 어떤 클래스를 상속받은 엑터들을 긁어 올건지 설정해줄 수 있습니다. 우리는 BP_Creature클래스를 상속받은 타겟들을 긁어와야하니 
BP_Creature로 설정해줍니다. 나중에는 플레이어말고 몬스터만 피격하도록 해줄테지만 그때 가서 다시 필터링을 한번더 해줘도 됩니다. 

일단 잘 실행되는지 테스트를해보겠습니다. 긁어온 액터의 Length를 출력해보겠습니다. 게임을 실행해 허공을 때리면 재미있게도 1이 출력되고 몬스터에 다가가 공격하면 2가 출력됩니다. 
왜 1부터 출력이 되는지는 아마 공격범위에 자기자신도 들어가서 그런것 같습니다. 이부분은 나중에 예외처리를 해주면 되고 일단 공격범위 판별된걸 확인했습니다. 
이 충돌과 관련된 내용을 좀 더 깊게 들어가면 기능이 훨씬 많고 어려운 내용이 있지만 일단은 이번 파트에서는 간단간단하게 소개만하고 넘어가는 정도로 다루겠습니다. 

(충돌이라는것을 몬스터 판별용도로 사용하고 있지만 이외에 카메라가 이동하면서 벽면에 닿으면 알아서 땡겨지게 하거나 아니면 화면을 클릭했을때 어떤 유닛을 선택하는 것 같이 정말 활용 범위가 넓습니다. 
이렇게 활용범위가 넓은 만큼 각 용도로 충돌 여부를 세부적으로 다 필터링해서 사용해야합니다. 지금이야 간단하게 넘어가지만 나중에 다른 파트에서는 충돌때문에 꽤 골치가 아파질 수 있습니다.)

공격범위의 타겟들을 가져오는데 성공했습니다. 이제 여기에 이 타겟들의 체력을 깍는 동작을 해야할겁니다. 긁어온 엑터 배열을 for each 문으로 순회해보겠습니다.
그런데 말 드대로 엑터 배열은 엑터들을 담고있는데 우리는 지금 BP_Creature를 상속받은 클래스들을 대상으로 작업하고 싶습니다. 그래서 캐스팅을 해줍니다. Cast To BP_Creature 라는 노드를 검색해 배치합니다. 
왜 굳이 캐스팅을 하냐면 앞으로 넣어줄 피격과 관련된 코드들을 BP_Creature에다가 넣어줄 것이기 때문입니다. 
캐스팅은 경우에 따라 성공할수도 있고 실패할수도 있지만 애당초 지금 코드에서는 Get Overlapping Actors의 필터링 대상을 BP_Creature로 했기때문에 굳이 캐스팅이 실패할 경우를 생각하지 않아도 됩니다. 

이제 피격을 할때의 코드를 어디서 들고 있을지를 고민해봐야합니다. 체력을 깍는 여러방법들이 있는데 때리는 입장의 캐릭터가 공격 로직을 실행하면서 피격되는 몬스터의 데이터를 가져와 체력을 깍을지,
아니면 피격되는 쪽의 몬스터에서 피해를 받고있다는 함수를 만든다음 그 함수를 호출할지가 고민입니다. 
정답부터 말하자면 후자인 피격되는 쪽에서 피격 함수를 만들고 그걸 호출하는 방식이 더욱 좋습니다. 그래도 아직은 왜 좋은지 와닿지 않을텐데 만약 밖에서 맞는쪽의 데이터를 꺼내와 건드린다면
안좋은점이 피격되는 몬스터의 상태가 만약 무적상태라거나 디버프나 버프가 있다면 그것들이 적용된 데미지는 증감되는 일이 자주 일어나고 아니면 MMORPG 같은 경우는 데미지를 받는 양에 따라 어그로 수치가 쌓인다거나 
공헌도가 쌓인다거나하는 피격되면 쌓이는 것들이 많은데 이런걸 밖에서 관리하기 시작하면 굉장히 어려워집니다. 그것 말고도 많은 문제가 생깁니다. 

결과적으로 피해를 받는쪽에서 체력을 깍는 코드가 일반적입니다. 
그러면 ProcessAttack 함수 까지는 공격하는 쪽입장이었고 공격받는쪽의 함수를 다시 하나 추가하겠습니다. 여기서는 이름을 OnDamaged라는 이름으로 하겠습니다. 
지금은 이렇게 함수를 하나하나 만들어주고 있지만 나중에 가면 언리얼에서 제공하는 dedicated server 라고 해서 온라인 게임을 쉽게 만드는 프레임워크가 있는데 이걸 사용할경우 
대부분의 기능들이 이미 다 잡혀있습니다. 바로 Apply Damage 라는 노드를 검색해보면 아직 만든적이 없는데 이미 존재하는 기능입니다. 이 함수도 지금 만들려고하는 OnDamaged라는 함수와 흡사한 기능입니다. 
입력으로 피해를 받는 액터, 받는 데미지, 공격자의 정보와 컨트롤러를 넣어주고 데미지의 타입도 넣어줍니다. 데미지의 타입이란것은 만약 공격받고 난 후 불타오른다거나 독 상태이상에 빠진다거하 하는 타입입니다.
또 반환핀에서는 재미있게도 Actual Damage를 뱉어주는데 의도한 데미지 100을 주려고 했는데 피격자의 방어력이나 버프 혹은 디버프를 통해 실제로 들어간 데미지가 달라 질 수도 있는데 그런계산을 마친 데미지값을 반환합니다. 

결국은 피해자 측 함수를 언리얼에서도 만들어 놨다는걸 알 수 있고 이건 나중에 데이케이트 서버를 만들때 실습을 해볼겁니다. 
이것 말고 AnyDamage 이벤트라는 것도 있는데 아까 방금 내가 맞았다 라는 Apply Damage함수를 실행하면 이 이벤트에서 이어서 코드를 만들면됩니다. 이 내용은 참고삼아 말한 것이지만 
그럼에도 불구하고 이 것들을 엿보면 우리가 구현할 코드에 도움이됩니다. 가령 Apply Damage 에서 받고있는 인자들 피격자가 누구인지, 공격자가 누구인지, 데미지는 얼마인지 같은 정보들이 필요하구나 같은 걸 알 수 있습니다. 
 
OnDamaged함수의 입력값으로 Int 타입 Damage를 받고, 공격자가 누구인지 BP_Creature 타입으로 Attacker를 받도록 했습니다. 
Damage는 그냥 하드코딩으로 10이라는 값을 일단 줬습니다. 그리고 공격자는 누굴까요 지금 이 함수를 호출하고 있는 자신입니다. Self를 검색해보면 Get a reference to self 라는 노드로 자기자신 을 가져올수 있습니다. 
이걸 Attacker에 연결해줍니다. 이상태에서 이 OnDamaged 함수로 들어오면 이제는 피격자 입장이 됩니다. 여기서는 자신의 체력에서 데미지 만큼을 깍아주면될겁니다. 경우에 따라서는 공격자에 따라 무언가 추가효과를 줄 수도 있습니다.
이 OnDamaged가 BP_Creature 에있는 함수니까 이걸 평생 그대로 사용해야하는건아니고 자식 클래스중에 피격되었을때 특수한 기능을 한다면 이 함수를 오버라이드 해서 사용해도 됩니다.
일반적인경우에는 어떻게 동작할지를 BP_Creature에 작성해보겠습니다.

이제 MaxHp, Hp 가 필요해 졌으니 변수로 추가해주겠습니다. 지금은 그냥 변수로 관리하지만 나중에는 이것도 데이터 테이블로 빼서 관리할겁니다. 
이제 OnDamaged 함수에서 Get Hp를 하고 -연산자 노드를 꺼냅니다. Hp에서 Damage를 빼주는데 이때 Hp값이 만약 0이하로 내려갈수 있기때문에 Clamp 함수로 Min, Max 값 구간을 정해줍니다. 
Attacker는 지금 사용하지 않았는데 만약 사용한다고 하면 내가 나 자신을 공격한경우 여기서 막아주면 될겁니다. Attacker와 self가 == 인지를 브랜치를 해서 true라면 스킵, false라면 데미지 연산을 진행하는식으로 할 수 
있습니다. 

이제 제대로 동작하는지 확인해보겠습니다. ProcessAttack 함수에서 자신을 공격하는걸방지하는 코드를 다시 추가한 다음 그 후 피격자의 Hp를 출력해도되고 
아니면 OnDamaged 에서 출력 값으로 피격받은후의 Hp를 반환하도록 해서 이걸 바로 출력해도 됩니다.

이렇게 해서 피격판정 범위에 따라 공격하는 기능을 구현하였고 그런데 이제 횡으로만 공격할수 있고 상하좌우로 공격하는경우도 커버하려면 좀 더 보완해야겠습니다.


-------------------------------
        피격 판정 #2

이어서 작업해 볼것은 Attack Range 가 위 아래 방향으로는 회전하지 않는 것을 수정해 볼것이고 또 실질적으로 HP나 MaxHp를 하드코딩해 놨었습니다. 이걸 수정해보겠습니다.'

먼저 Hp 들을 수정해보자면 CreatureData 구조체를 열고 여기에서 관리할 새 변수 두개를 추가합니다. 크리쳐가 가져야할 Hp, Damage를 추가할건데 
Int 타입으로 추가한 다음 두 변수를 구조체의 맨윗줄로 이동시킵니다. 중요도에 따라 이렇게 순서를 정리하기도 한다고 합니다. 
이제는 사실 기획의 영역입니다. 대미지 같은건 지금처럼 고정으로 관리할지 아니면 나중에 이 크리쳐의 장비나 레벨, 스킬에 따라 달라지도록 관리할지를 정해주면됩니다. 
또 한가지 약간 궁금할 수 있는것은 MapHp와 Hp 둘다 데이터에 추가하지 않는게 의아해 질 수 있습니다. 지금 추가한 Hp 같은경우는 사실 MaxHp로 사용할겁니다. 
왜냐하면 MaxHp는 잘 변하지 않을것이고 HP는 전투가 진행되면서 늘고 줄것이기 때문에 이렇게 자주 변하는 값은 데이터에서 관리할 만한 정보가 아니라는것입니다.
잘 구분해야합니다. 객체마다 가지고 있을 값과 , 객체 전체 동일하게 가지고 있을 데이터가 무엇인지를 구분할 수 있어야합니다. 

데이터 구조체에 추가로 변수를 추가했으니 이제 데이터 테이블을 열어봅니다. 그러면 Knight, Skeleton 둘 다 이제 Hp 와 Damage가 추가 되어있습니다. 
각각 대충 기사는 체력 100, 데미지 10으로 해골은 체력 50, 데미지 5 정도로 세팅해보겠습니다. 

이제 다시 BP_Creature 클래스로 돌아가서 OnDamaged 함수에서 데미지 계산을 하는걸 보면 이제는 Knight의 체력 데미지와 Skeleton의 체력 데미지가 다를테니 
BP_Knight나 BP_Skeleton 의 BiginPlay에서 체력,데미지를 설정하는 코드를 넣어놓으면 될까 생각이됩니다. 이 방법도 안되는 방법은 아니지만 코드가 너무 반복적이게 될겁니다. 
클래스들이 늘어 날때 마다 각가 해주기는 뭐 하니까 공통적인 부분을 위로 올려주겠습니다. 

BP_Knight 의 이벤트 그래프에서 BeginPlay 이벤트를 호출할때 데이터 테이블중 Knight의 데이터를 가져와 BP_Creature의 변수인 Data에 Set 해주고 있습니다.
여기에 이어서 다시 부모 함수에 대한 호출 추가를 해 Parent: BeginPlay 노드를 꺼냅니다. 이것을 Set Data 뒤쪽에서 호출해주겠습니다. 
마찬가지로 BP_Skeleton 도 똑같이 수정해줍니다. 

왜 Parent: BeginPlay를 코드 뒤쪽에 위치놓냐면 일단 각 데이터를 가져온 다음에서야 Hp와 Damage를 가지고 뭔가를 할 수 있기 때문에 서순상 뒤쪽에 배치합니다. 

이제는 부모클래스이 BP_Creature에서 처리해주면 되겠습니다. 
이벤트 그래프에 BeginPlay 이벤트를 배치하고 Hp와 MaxHp를 Set 해주면 되겠는데 이 값은 자식 클래스에서 채워놓은 Data를 참고해서 Set 해줍니다. 

이렇게 작업을 하면 기사나 해골이나 BeginPlay 이벤트를 호출하면 데이터 테이블에서 가져온 각자의 데이터에 따라 Hp와 MaxHp가 세팅이 됩니다. 
게임을 실행해 해골을 공격해보면 50부터 체력이 다는걸로 잘 동작한다는걸 알 수 있습니다. 이런식으로 반복되는거 같은 코드는 위로 위로 올리면 코드가 더 깔끔해집니다. 

비슷하게 BP_Knight, BP_Monster 에서 Tick이벤트로 기사는 UpdateInput, UpdateLogic, UpdateAnimation 을 호출하고 있고 몬스터는 UpdateLogic, UpdateAnimation를 호출하고 있습니다. 
반복되는 UpdateLogic, UpdateAnimation를 날린 다음 Parent: Tick이벤트를 호출해줍니다. 그래서 BP_Creature에서 Tick 이벤트, UpdateLogic, UpdateAnimation를 호출해주면 됩니다. 

상속구조를 최대한 활용해서 자식 클래스에서는 최대한 단순하게 코드를 사용하도록 해주었습니다. 

다음으로는 이제 캐릭터가 위 아래로 갈때 공격범위가 자연스럽지 않은 부분을 수정해주겠습니다. 
당연히 많은 방법이 있을겁니다. 좌우방향 같은경우에는 스프라이트의 회전을 가지고 구현이 되는것 같은데 위아래로는 조금 애매합니다.
손으로 AttackRange를 위아래로 돌려보고 그 수치를 저장해 사용하는것도 방법이고 아니면 그냥 애당초 Attack Range를 두개 더 복사해 위쪽 범위와 아래쪽 범위를 담당하게끔 해도 됩니다. 

여기서는 AttackRange를 복사하는 방법으로 해보겠습니다. 두개더 복사한 AttackRange를 손으로 대강 위아래 방향에 위치시켜주고 이름을 알아보기 쉽게 
AttackRangeUp, AttackRangeSide, AttackRangeDown 으로 수정했습니다. 

이어서 지금까지 피격과 관련된 부분을 ProcessAttack에서 넣어 놨고 여기서 Get Overlapping Actors 를 AttackRangeSide에 대해서 해주고 있는데 
이제는 무조건 Side 만 하는게 아니라 Direction에 따라 Up, Down 범위를 사용할지를 판별하면됩니다. 
각 경우를 Select를 이용할겁니다. Direction을 꽂아주고 AttackRange 들을 각각 가져와 각 방에 따라 연결해 줍니다.

이 방법으로 실습했다고 해서 이게 꼭 정석적인 방법이라는게 아닙니다. 각자 원하는 결과를 가져온다면 다 가능한 방법이될것입니다. 

실제로 테스트를 해보면 이제 상하좌우로 공격해도 피격판정이 잘 일어나게 됩니다. 

참고로 캐릭터끼리 충돌했을때 둥글게 비벼지는것은 캐릭터의 충돌 범위가 캡슐 형태로 되어있기 때문인데 이걸 수정하고 싶으면 그냥 충돌 박스를 큐브로 바꿔주면됩니다. 

이다음으로 하고 싶은것은 이제 공격한후 로그로 표시되는것은 좋겠는데 이제 체력을 비주얼적으로 머리위에 띄워놓는걸 하고 싶습니다. 다음 강의에서 이어 해보겠습니다. 