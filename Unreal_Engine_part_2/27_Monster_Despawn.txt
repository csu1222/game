

        몬스터 디스폰


이번시간에는 몬스터 디스폰을 알아볼건데 게임답게 만들기 위한 내용입니다. 플레이어도 조작 가능해지고 몬스터도 알아서 플레이어에게 다가와 공격하는 상태에서 
공격하면 Hp바 UI가 동작하면서 현재 Hp가 보입니다. 만약 이 Hp가 다 닳았다면 그 캐릭터가 맵에서 없어지고 플레이어의 경험치가 올라간다던가 아니면 킬 카운트가 올라간다던지 
하는식으로 게임이 진행될건데 

매번 고민은 새로 만드는 기능은 어디서 관리해야 할지가 고민입니다. 
우리 코드를 보면 OnDamaged 함수라고 해서 피격자 입장에서 피격 판정을 하는 함수가 있었습니다.  이 이후에 그냥 피격자의 HP를 체크해 0일때 그냥 삭제를 해주면 되는게 아니고 
지금까지 관리하던 방법에 의하면 BP_TileMap이라는 클래스에서 스폰을 담당하고 있었습니다. 그리고 이게 스폰을 담당하는이유는 이게 캐릭터간의 충돌까지 담당하고 있기때문에 
스폰한 캐릭터 들을 다 관리를해야 했습니다. 

그렇다면 디스폰 기능도 이 BP_TileMap에서 관리하는게 나아 보입니다. 
또 이런 식으로 만드는 이유는 다음 시간 매니징의 빌드업이기도 합니다. 지금까지 2D 게임을 만들면서 느꼇지만 프로그램을 만들때 코드의 구조를 어떻게 짤지가 대단히 고민이 됩니다. 
이 구조라는것을 잘못 짜게되면 이후로 계속 해서 비효율적으로 작업을 해야 하기 때문입니다. 

아무튼 일단은 이번시간의 내용을 시작해보겠습니다. 
BP_TileMap에서 함수를 하나 만들겁니다. 이름은 DespawnCreature 라고 하겠습니다. 
(왠지 SpawnCreature와 DespawnCreature는 짝을 이룰거 같으니 함수 순서를 조금 조정해줬습니다.)
DespawnCreature는 인풋을 받아줄건데 이 함수에서 디스폰할 객체를 받아줘야 하니깐 BP_Creature타입에 Creature라는 이름으로 받아주겠습니다. 
시작하면서 유효체크를 한번해주겠습니다. 
유효하다고 하면 먼저 캐릭터 충돌에 사용하던 Creatures 라는 배열에서 디스폰할 객체를 지워줍니다. Creatures의 Remove Item 노드를 배치하고 지울 객체를 연결해줍니다. 
(지금 처럼 배열에서 아이템을 지우는 작업이 사실 빠른 작업은 아닙니다. 인덱스로 접근하는게 아닌 아이템을 접근하려면 배열을 순회하면서 하나하나 지우려는 아이템과 같은지를 확인해야 합니다. 
다만 지금처럼 배열안의 원소들이 아주 많지는 않은 상황에서는 사용할 만합니다.)
Creatures라는 벡터 뿐만아니라 게임 월드에 배치된 크리쳐를 삭제도 해줘야하는데 그것은 Destroy Actor 라는 함수입니다. 이것은 이전에 분명 액터를 배치하는 Spawn Actor 라는 기능이 있었으니 
반대되는 기능이 있을것이라는 믿음을 가지고 찾을 수 있습니다. 해서 이 Destroy Actor로 액터를 삭제했다면 DespawnCreature함수는 일단 완료된것 같습니다. 

이제는 이 DespawnCreature함수를 어디서 호출해 줄지 생각해보겠습니다. 
HP가 0이 된 다음 디스폰을 할것이니까 OnDamaged 함수 뒤쪽에서 호출해주는게 맞을까요? 하지만 이 OnDamaged는 용도가 피해를 받았다 라는것을 연산하는 함수입니다. 여기에 사망처리까지 같이 하는것은 
나중에 혼동이 올 수 있습니다. 

그래서 따로 함수를 추가하겠습니다. 이렇게 하면 자식 클래스들 Knight나 Monster에서 죽음 판정이 다르게 동작할 수 도 있는데 그러면 그때 오버라이딩으로 따로 처리할 수도 있습니다. 
새 함수 이름을 OnDead라고 추가합니다. 

다시 OnDamaged로 돌아와 마지막에 HP Ratio를 계산한 다음에서 이 HP Ratio가 0 보다 작거나 같은지를 체크해줍니다. 그래서 그 값이 True인지 False인지 브랜치 해줍니다. 
True라면 OnDead를 호출해주겠습니다. 

OnDead의 내용을 채워줄겁니다. 아까 BP_TileMap에서 만들었던 DespawnCreature를 호출해줘야하는데 지금까지 외부 객체를 가져올때 사용했던 Get Actor Of Class 로 가져오겠습니다.
호출한 DespawnCreature은 입력으로 디스폰할 크리쳐를 넘겨줘야합니다. 현재 호출하고 있는 자신을 삭제할것이기 때문에 Get a Reference to Self 로 자신을 넘겨줍니다. 

여기까지 해서 한번 테스트를 해보겠습니다. OnDamaged를 계산하가 Hp Ratio가 0 이하로 떨어지면 OnDead를 호출하고 또 이어서 DespawnCreature을 호출해주게 됩니다. 
게임을 실행해 해골들을 때리다보면 Hp가 0이 되면 월드에서 사라지게 되는걸 볼 수 있습니다. 

이렇게 디스폰을 만들기는 했는데 여기 까지만 하는것은 조금 심심하니 내가 몇마리를 잡았는지를 관리해 UI로 띄우는 것을 해보겠습니다. 

UI의 경우는 간단하게 알아보고 넘어갈겁니다. 이전에 컨텐츠 폴더 아래로 Bluprint/UI 폴더를 만들었었습니다. 여기에 HpBar 라는 위젯 블루프린트를 만들어 체력게이지를 표시했었는데 
비슷한 느낌으로 상단에 킬 카운트를 표시하도록 해보겠습니다. 

UI의 경우는 다른 맵이나 캐릭터 같은 객체들과는 느낌이 좀 다릅니다. 방금 말한 것들은 월드에 배치되어있고 그것을 카메라가 찍고 있는 느낌인데 UI같은 경우는 대부분 카메라가 어떻게 움직이건간에 
화면상에는 그대로 따라옵니다. 말하자면 영상을 찍고 그 위에 특수효과를 씌운것과 같습니다. 

UI를 추가하는것은 UI 폴더의 빈곳을 우클릭하고 유저 인터페이스 란의 위젯 블루프린트를 만든 다음 상단의 사용자 위젯으로 만든 다음 이름은 WBP_GameUI라고 하겠습니다. 
WBP_GameUI를 열어보면 UI를 그리는 디자이너창과 코드를 담당하는 그래프 창이 있습니다. 

일단 디자이너 창에서 만들어보겠습니다. 
왼쪽의 팔레트 창에서 패널/캔버스 패널을 드래그 드롭으로 배치해보겠습니다. 

이 캔버스 패널을 배치하면 그 안에 원하는 UI를 배치하기가 용이해집니다. 이 캔버스 패널안에 버튼도 한쪽에 배치하고 텍스트 블록도 배치하고 등 도화지가 된다고 볼 수 있습니다.
그리고 앵커라고 해서 닻의 개념이 있는데 지금 만들고 있는 화면의 크기가 언제든지 바뀔수 있을겁니다. 예를 들어 모바일게임을 만든다고하면 모바일 기종마다 화면크기가 다르게 되는데 
화면크기를 고정적으로 만든다고하면 UI 가 어색하게 표현될겁니다. 그런것을 조절하기 위해서 앵커를 설정해서 어느정도 비율로 해야할지를 정해줄 수 있습니다. 
이 UI쪽 분야도 어려운 분야이고 대형 게임회사에서는 UI전문 팀이 있을정도로 분야가 깊습니다. 

일단 오늘 할 것은 캔버스 패널안에 텍스트 블럭하나만 사용할겁니다. 이름은 KillCountText라고 하겠습니다. 이 텍스트 블럭의 위치는 적당히 상단혹은 구석에 배치하면됩니다. 
그리고 우리가 한글이나 워드 같은 텍스트 에디터를 사용할때 처럼 입력하는 글이 중앙정렬이 됐으면 좋겠다 생각이 드는데 그런 기능이 분면 디테일즈에 있을것이라고 생각이 됩니다. 
외형 Appearance 쪽을 보면 폰트 크기같은것과 정렬 아이콘도 있습니다. 

그건 그렇고 기능적으로 우리가 하고싶은것은 이 텍스트 박스 안에 킬 카운트를 띄우고 싶습니다. 
이 킬카운트 텍스트를 밖의 클래스에서 세팅하고 그걸 받아서 텍스트 박스에 띄울 수도 있겠지만 그것 말고 이번에는 위젯 블루프린트의 그래프 창으로 가보겠습니다. 
여기서 변수르 추가해서 KillCount라는 int 변수로 관리해보겠습니다. 그러고 다시 텍스트 블록의 디테일즈에서 바인드라는 기능이 있었습니다. 
함수와 바인드도 할 수 있고 아니면 아까 만들었던 KillCount 변수를 바인드 할 수도 있습니다. 
만약 KillCount 변수를 바인딩 하게 되면 그 값이 바로 표시 되는데 그것 말고 만약 Kill Count : ~~ 이런 형식으로 텍스트를 띄우고 싶다면 그냥 함수로 바인딩을 해줍니다. 
이 함수이릉믕 GetKillCountText 라고 지어주고 자주 사용하던 포맷 텍스트함수로 문자열을 만들어 줍니다. 
이렇게 작업하면 이제 우리가 이 KillCount값을 세팅해주면 변경 될때 알아서 갱신이 되어 텍스트를 출력해주게 될겁니다. 
저장하고 창을 닫겠습니다.


위젯 블루프린트로 UI를 만들기는 했는데 그게 끝이 아니고 배치를 해야할겁니다. 
이 배치는 어디서 관리해야할지 또 고민이 됩니다. 지금 타일맵 기반의 2D게임을 만들면서 BP_TileMap을 중심으로 이런저런 코드를 실행해주고 있으니까 
여기의 시퀀스 번호를 하나 더 늘려서 여기서 킬 카운트 UI를 배치해보겠습니다. 

BP_TileMap의 이벤트 그래프 에서 Create Widget 노드를 호출해 위젯을 만들고 WBP_GameUI를 불러오도록 해줍니다. 그리고 그 반환 위젯 객체를 다음에 또 사용할 수 있도록 
변수로 승격해 들고 있겠습니다. GameUI라고 이름지어줍니다.  하지만 이렇게 위젯을 추가하기만 해서는 안되고 이어서 Add To Viewport 를 해줘야 합니다. 

이 상태에서 게임을 한번 실행해보면 화면에 킬카운트 라는 텍스트가 표시됩니다. 아직은 카운트가 증가하지는 않지만 텍스트는 뜨는겁니다. 

그러면 이제 킬 카운트를 갱신하는것을 추가 해줄건데 어떤 크리쳐가 죽엇을때 여기서 자신을 죽인 상대의 킬카운트를 올려주면 될것입니다. 
그런데 하나 애매한것은 이 OnDead 함수는 BP_Creature 클래스 안에 있는 함수입니다. 그러면 플레이어 몬스터 모두 무언가 킬을 하게 되면 킬 카운트를 늘리게 되는데 원하는것은 플레이어가 몬스터를 잡았을 때만 
늘리고 싶다고 가정하면 지금 여기 BP_Creature On Dead에서 카운트를 늘리기에는 애매하다는것입니다. 

원하는대로 On Dead 에서 플레이어가 킬 햇을때만 카운트를 늘리려면 어떻게 해야 할까요? 
한가지 방법은 On Dead를 호출하는 On Damaged 부터 Attacker를 입력 받고 있는데 이 공격자를 On Dead에서 이어 받아주고 이것이 어떤 타입인지에 따라 코드를 나눠주면 될것 입니다. 
Cast to BP_Knight 를 호출해주고 이 캐스팅이 성공했는지 실패했는지 여부에 따라 킬 카운트를 늘릴지 말지를 결정해줄 수 있었는데 

여기서 또 한가지 고밍해야 할것은 현재 킬카운트를 늘릴 객체인 GameUI는 또 BP_TileMap에서 관리하고 있어서 BP_Creature에서 또 Get Actor Of Class 를 해줘야 하는 처지입니다. 
처음 게임을 만들면 이렇게 구조가 꼬이는 경우가 생긴다고 합니다. 일단은 지금 상태에서 어떻게든 만들어 보겠습니다. 
Get Actor Of Class 로 BP_TileMap을 가져오고 또 이어서 Get GameUI를 가져오고 또 다시 Get KillCount를 합니다. 이 값을 늘려주는 + 1 을 한 다음 Set KillCount를 하던가 아니면 ++ 연산자 노드를 사용합니다. 

이제 한번 테스트를 해서 제대로 동작하는지를 확인해보면 역시 몬스터를 잡게 되면 킬 카운트가 1씩 잘 늘어 표시 된다는걸 알 수 있습니다. 


여기 까지 해서 몬스터 디스폰과 또 킬 카운트 UI까지 추가 해봤습니다. 

그렇지만 지금 까지 만든 코드에서 찜찜한 부분이 없는지 생각해봐야합니다. 우선 TileMap이라는것을 사실 처음 만들었을때는 말 그대로 맵을 관리하는 클래스였는데 하다보니까 크리쳐 스폰, 디스폰도 관리하게 되고 UI도
관리하게되고 그렇습니다. 
그리고 GameUI도 KillCount라는 변수로 킬 카운트를 표시해주기 위해 만들었는데 사용하는것을 보면 크리쳐의 On Dead에서 증가 시켜주고 있습니다. 
그런데 만약 이 KillCount가 UI에 표시되는것 뿐만아니라 그 값에 따라 어떤 보상이 달라 진다거나 난이도가 달라진다거나 하면 또 복잡해집니다. 또 다시 TileMap을 불러오고 GameUI를 불러오고 또 KillCount를 불러와 참조해야하는것입니다. 

다음시간에 본격적으로 고민해볼것은 그래서 전체적인 설계에 대해 고민을 해볼까합니다. 