


    상속구조 설계


지난 시간까지 캐릭터를 상하좌우로 움직이게 하고 그 방법으로 캐릭터 무브먼트 컴포넌트의 함수를 사용해서 구현해봤습니다. 
캐릭터 무브먼트 의 디테일즈에서 다양한 파라미터들을 조금 살펴봤습니다. 

그런데 이전 시간에 프레임당 현재 가속도 속도를 출력하도록 했었던걸 정리 해주겠습니다. 

참고로 지난시간에 캐릭터 무브먼트의 가속도를 직접 건드려서 캐릭터가 딱딱 정지하는걸 구현하긴 했지만 사실은 Set Velocity 를 사용해서 가속을 받지않고 바로 멈추게끔 해줄 수 있습니다. 
방법이 다양하다는것입니다. 

이제 무엇을 해볼것이냐 하면 지금까지 이동까지는 꽤 만족스러운 수준까지 구현을 했으니 이제 전투를 본격적으로 구현하기 위해서 
몬스터 한마리를 배치하고 싶습니다. 몬스터 이미지는 해골인데 강의 수업자료로 포함되어있었습니다. 스켈레톤도 각각 모션들이 png로 되어있고 이걸 플립북으로 만드는 작업을 Knight 때와 같이 해주겠습니다.

순서는 이렇습니다. 
수업자료에서 Skeleton 폴더를 우리 프로젝트 컨텐츠 브라우저의 All/콘텐츠/Maps/Sprite 아래로 드래그 드롭해 가져옵니다. 
가져 스켈레톤 폴더안의 down, up, side 모션 폴더들을 모두 한번에 선택하면 오른쪽 파일창에 모든 이미지 리소스들이 나오는데 모두 선택후 우클릭 -> 스프라이트 액션 -> 페이퍼 2D 텍스쳐 설정 적용 을 해줍니다. 
다시 페이퍼 2D 텍스쳐 설정 적용이 끝난 이미지 리소스들을 모두 선택한 후 우클릭 -> 스프라이트 액션 -> 스프라이트 생성을 해줍니다. 
그러면 각각의 폴더에 이미지들의 스프라이트가 생성됩니다. 
이제 각 모션 폴더마다의 스프라이트들을 복수 선택후 우클릭 -> 플립북 생성을 하면 그 모션의 플립북이 생성됩니다. 
모든 모션의 플립북을 생성해주고 한단계 상위 폴더인 Skeleton 폴더로 다 이동해줍니다. 참고로 idle 같은 리소스는 이미지가 한장뿐이지만 그래도 플립북으로 만들어 줘야합니다. 
나중에 인자로 플립북을 설정할때 타입을 맞춰줘야 하기 때문입니다. 

이렇게 해서 스켈레톤의 플립북들이 준비되었는데 기사의 플립북이나 스켈레톤의 플립북이나 같은 종류 모션은 같은 이름으로 되어있습니다. 
여기서 선택을 해야합니다. 나만의 네임 컨벤션을 만들어 주는 방법이 있습니다. 예를들어서 플립북을 나타내기위해 플립북 이름 앞에 FB_ 로 시작하게끔 해주거나 또 기사에 대한 플립북은 
FB_Knight_down_attack 이런식으로 이름지을 수 있습니다. 이것은 프로젝트마다 다른 것이니깐 취향이나 기호에 따라 수정해주면 되고 
이번 프로젝트는 간단한 페이퍼 2D 게임을 만드는 것이기 때문에 그냥 그대로 사용하는 방법을 취하겠습니다. 


이제 플립북을 추가하는 간단한 작업을 해보았고 진짜 고민은 이 블루프린트를 어떻게 설계할것인지가 고민입니다.
새로 BP_Skeleton 이라는 블루프린트 클래스를 만든 다음에 우리가 BP_Knight 클래스에 넣어놓은 모든 기능을 전부 복사해 가져온다 라는게 가장 처음 떠올릴만한 방안입니다. 
하지만 이 방법은 안좋은 방법일겁니다. 왜냐하면 게임이 기사한명과 몬스터 한마리 딱 1:1이라고 하면 합리적일 수 있겠지만 게임이 몬스터의 종류가 수십 수백이 될 수도 있고 
플레이어도 기사 뿐만아니라 궁수 마법사 등 다양한 캐릭터가 추가될 수도 있습니다. 이럴때 마다 복사 해서 클래스를 늘리는건 올바른 방법이 아닐겁니다. 

그래서 이런 부분을 만들 때 이전 객체 지향 프로그래밍의 특징 중 하나인 상속성에 대한 내용을 다시 가져와야합니다. 공용 기능은 더욱 상위 클래스로 관리해 부모클래스로 부터 상속받아 사용하는겁니다. 
RPG 게임에서 보통 어떤 방법을 사용하냐면 기사, 궁수, 마법사 등을 뭉쳐서 플레이어라는 상위 클래스를 만들고 몬스터들도 여러 몬스터들을 뭉쳐서 몬스터라는 상위 클래스로 만들고 
플레이어와 몬스터 클래스를 합쳐서 크리쳐 라는 상위 클래스로 만드는 경우가 많습니다. 

우리도 지금 BP_Knight라는것을 기사라는 용도로 사용하고 있지만 이제 스켈레톤을 추가하게 되면 어떤 코드를 같이 재사용 할 수 있을지 생각해보겠습니다. 
UpdateInput 같은경우는 플레이어가 입력받은 키에 따라 Direction이나 State를 정해주는 부분이니까 이것은 몬스터에겐 필요없을것 같고 UpdateLogic은 이동과 관련된 부분이고 
UpdateAnimation은 애니메이션과 관련된 부분입니다. 

물론 UpdateAnimation은 BP_Knight와 관련된 플립북으로 채워져 있지만 스켈레톤에서는 다른 플립북으로 교체해줄겁니다.
이렇게 클래스에 따라 교체해줘야할 것들은 데이터로 따로 관리하는게 좋습니다. 왜냐면 몬스터의 종류가 여러개가 됐을 때 각기 플립북을 지정해주는것 보다는 
예를들어 해골이란 몬스터는 체력이 얼마이고 방어력이 얼마이고 공격력은 얼마이고 어떤 특성을 가지고 있고 어떤 AI로 움직이고 어떤 애니메이션을 사용할지를 뭉쳐서 관리하는게 편합니다. 
데이터를 뭉쳐서 바뀌는 부분만 관리하게 되면 사실 BP_Knight, BP_Skeleton, BP_Orc 같이 각기 클래스를 만들어 줄 필요없이 바뀐 데이터만 갈아끼워 만들 수도 있습니다. 
이건 사실 사양에 따라 달라지기는 합니다. 

우리는 어떻게 할것이냐 하면 BP_Knight클래스 파일을 복사해 하나 더 만든 다음 이름을 BP_Creature 라는 이름으로 플레이어나 몬스터 모두의 공통조상이 되는 클래스로 만들어 볼겁니다. 
우선 BP_Knight를 복사한게 BP_Creature 이다 보니 PaperCharacter를 상속받은상태입니다. 여기서 부터 시작을 해볼건데 이 크리쳐는 플레이어라는 보장이 없으니까 불필요한 요소들을 제거해보겠습니다. 

확실한건 뷰포트에서보면 캐릭터에 스프링 암을 추가하고 여기에 카메라를 붙여 놨었습니다. 하지만 몬스터인경우에는 카메라가 붙어있을 이유가 없습니다. 그래서 카메라와 스프링암을 날려주겠습니다.
처음 시작 스프라이트 같은경우에는 임시로만 넣어주고 나중에 소스코드에서 수정해줄예정이기때문에 지금 나이트 스프라이트 이긴하지만 그냥 놔두겠습니다. 
다음으로 UpdateInput 같은 경우는 나중에 플레이어쪽으로 이동시켜줄것인데 나중에 플레이어 클래스를 만들때 옮겨주기 위해서 일단은 놔두고 나중에는 삭제해줄것이라는것만 기억해두겠습니다. 

BP_Creature의 이벤트 그래프를보면 Tick 이벤트랑 InputAction Attack 이벤트가 있습니다. 인풋 엑션 이벤트에서 공격키가 입력되면 공격 모션을 틀어주는게 목적인데 이제 이것을 
입력을 받는 이벤트대신 우리만의 커스텀 이벤트로 교체해주겠습니다.  나중에 이 커스텀 이벤트의 내용을 몬스터나 플레이어 타입에 맞춰서 넣어주면 되겠습니다. 

UpdateLogic도 보면 이 함수는 이동고 관련된 함수였습니다. 이동하는 방향을 Get MoveUp이랑 Get MoveRight 를 사용했었습니다. 
그런데 이 두 MoveUp,MoveRight 입력값에 따라 조절되는 값이었고 몬스터는 입력을 받지않고 인공지능대로 움직일 것이기 때문에 플레이어한테만 적용되는 코드입니다. 
즉, Direction을 가지고 방향을 조절해야하는것입니다. Direction을 방향조절에 사용하는 방법은 여러가지 있을겁니다. Switch문을 사용하는방법도 있고 Select문을 사용하는 방법도 있을겁니다. 
Select문을 사용하는방법으로 해보자면 Direction에서 Select문을 꺼낸다음 핀타입을 벡터로 변경하고 스케일값은 그냥 1.0으로 두고 이동 벡터에 그냥 막바로 꽂아줍니다. 
이때 이동하는 방향에 따라 벡터를 넣어주면됩니다. 이러면 이제 몬스터나 플레이어 양쪽에서 공용으로 활용할 수 있는 코드가 됩니다.

이런 식으로 코드를 조금씩 최적화 해나가는 것입니다. 만약 이미 게임을 많이 만들어 봤다면 처음부터 게임에 플레이어와 몬스터가 나올거니까 크리쳐를 만들고 하는것을 시작할때부터 클래스 설계구조를 만든 다음
시작하는게 좀 더 나을 수 있습니다. 그런데 처음 공부할때는 그것은 힘드니 일단 하나하나 만들어보고 그때 필요에따라 수정해 나가면서 만드는것도 나쁘지 않습니다. 

다음으로 할 것은 이제 BP_Knight를 보면 PaperCharacter를 상속받게 해놨는데 이것을 이제 BP_Creature를 상속받게끔 만들어 줄겁니다.
부모클래스 바꾸는건 이전에 알아봤듯이 클래스를 열고 클래스 세팅을 클릭하고 디테일즈를 보면 부모클래스를 선택하는 부분이 있습니다. 이때 부모클래스를 바꾸면 이곳 저곳에서 에러메세지가 뜰것입니다. 
왜 에러가 나는가 하면 부모클래스와 곂치는 코드가 있어서 그렇습니다. 예를들어서 BP_Creature에서 Direction이란 State라는 변수를가지고 있는데 BP_Knight에서도 마찬가지로 Direction, State를 가지고 있습니다
그렇다 보니 알아서 변수 이름 뒤에 _0이 붙도록 수정이 되었는데 변수를 곂쳐서 두개씩 들고 있을 이유가 없기 때문에 BP_Knight의 변수들은 없애줍니다. 
함수들도 마찬가지입니다. 불필요하게 곂치는 일이 많으니까 문제가 발생하는겁니다. 스프링암과 카메라는 마침 플레이어만 들고 있어야하는것이니 그냥 두면되고 UpdateLogic과 UpdateInput,UpdateAnimation은 삭제해줍니다.
일단 곂치는건 삭제하고 나서 생기는 문제를 해결하는쪽으로 해보겠습니다.

이제 깔끔해졌습니다. 일단 컴파일 저장을 한번해보면 에러때문에 컴파일이 안되진 않습니다. 하지만 BP_Knight의 이벤트 그래프를보면 InputAction Attack 이벤트 뒤로 코드가 왠지 휑해졌다는걸 볼 수 있습니다.
이미 있던 변수들을 날렸기 때문에 끊어졌다고 할 수 있습니다. 그런데 상관없는게 BP_Creature에서 이미 Attack Event 라는 커스텀 이벤트 뒤에 코드들이 다 준비 되어있기 때문에 
BP_Knight 에서는 InputAction Attack 뒤에서 Attack Event를 호출해주면 됩니다. 여기까지해서 컴파일이 통과되면 크리쳐와 나이트 클래스를 분리하는데에 성공했다고 할 수 있습니다.
여기서 한가지 더 BP_Creature에서 Tick 이벤트마다 Update 함수들을 호출해 줄 필요도 사실 없습니다. 상속받은 자식 클래스에서 각자 자기상황에 맞게 호출해주면 되기 때문입니다. 

게임을 실행해서 플레이어가 잘 움직이는지를 확인할 수 있습니다.

여기서 몇가지만 좀 더 추가해보자면 크리쳐 클래스의 UpdateInput 이 함수는 우리가 키보드 입력을 받아서 동작을 하는 함수입니다. 그런데 이 크리쳐는 플레이어뿐만아니라 몬스터까지도 포함하는개념이기 때문에
크리쳐에서 관리할 일은 아니고 BP_Knight 쪽에서 관리하도록 복사해주겠습니다. 사실 BP_Knight도 BP_Player라는 여러직업을 아우르는 부모함수를 만들어 관리하는것이 좋을겁니다. 

이제 플레이어 정리가 끝났으니 본격적으로 스켈레톤을 만들어 주겠습니다.
클래스이름은 좀 더 활용성있게 BP_Monster라는 이름으로 하고 상속은 BP_Creature를 상속받도록 만들어주겠습니다.
Tick 이벤트에는 입력을 받는 UpdateInput 빼고 UpdateLogic과 UpdateAnimation을 복사해넣어줍니다. 이동할 내용은 나중에 인공지능을 넣어줄겁니다.
여기서 UpdateAnimation에서는 사용할 플립북들을 설정해줘야하는데 현재는 플레이어의 플립북을 사용하고 있습니다. 어떻게 해결할지 생각해보다가 한가지 방법은 오버라이드를 하는것입니다.
함수추가부분에서 오버라이드를 찾아보면 UpdateAnimation을 고를 수 있습니다. 이 함수를 재정의 하는것인데 여기서 플립북을 해골 버전 플립북으로 수정해 사용하는 방법이 하나 있을텐데 
이것은 매번 똑같이 반복해줘야합니다. 거기에 나중에 이 BP_Monster는 해골뿐만아니라 다른 몬스터까지 관리할것이라면 이것은 옳은 방법이 아닐겁니다. 

그래서 본격적으로 이런 플립북 같은 것들을 데이터로 빼서 관리하는방법을 다음 시간부터 배워볼건데 우선 이번시간에는 일단넘어가겠습니다. 
이 상태에서 BP_Monster를 DevMap에 배치해보면 일단 겉보기는 기사의 모습이지만 아웃라이너에서는 이 오브젝트가 BP_Monster라고 나옵니다. 실행해서 이동키를 눌러보면 BP_Knight 오브젝트만 이동하는걸 볼 수 있습니다.
나중에 모습을 해골로 바꿔주고 이동도 인공지능에 의해 이리저리 움직이도록 해주고 기사가 공격을하도록 기능도 추가하면 될것입니다. 

다음시간에 이제 이 몬스터 오브젝트가 해골의 형태를하고 해골의 스텟, 모션을 하게하려면 데이터를 갈아끼우면 되도록 할것입니다. 


정리하면 이번시간에 배운 상속구조설계는 매우 중요한 부분입니다. 상속 설계를 잘해야 중복되는 코드를 줄일 수도 있고 안정적으로 동작하게끔도 해줄겁니다. 