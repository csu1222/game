


        FSM


이번에는 이름도 유명한 인공지능에 대한 주제입니다. 몬스터가 인공지능에의해 움직이도록 해줄겁니다. 

언리얼 엔진은 조금이라도 해봤으면 Behavior Tree를 떠올릴것입니다. 언리얼에서 제공하는 인공지능입니다. 오해 할 수 있는게
인공지능 = Behavior Tree 라고 생각하면 안됩니다. 오히려 고급기술에 해당한다고 할 수 있습니다. 

이번 첫번째 시간에는 Behavior Tree를 사용하지 않고 정말로 맨땅에 해딩하는 느낌으로 처음으로 구현하는 식으로 실습을 해보겠습니다. 

일단은 몬스터쪽에서 인공지능을 사용할것이기 때문에 BP_Monster를 열어보겠습니다. 
함수를 추가해 UpdateAI 라는 이름을 짓고 Tick 이벤트에서 Parent: Tick이벤트를 호출한 다음에 이어서 UpdateAI도 호출해주겠습니다. 
그러면 매 프레임마다 UpdateAI가 실행되면서 여기서 원하는 로직을 넣어주면 되겠습니다. 

그리고 보통 게임 학원을 다녀보면 C++을 배운 다음 처음으로 이런저런 포트폴리오를 만들게 하는데 이때 인공지능을 이런식으로 매프레임마다 업데이트 하는 
식으로 만듭니다. 
물론 게임의 사양마다 다르지만 이런 인공지능을 본적이 있을겁니다. 몬스터가 한 방향을 일정시간 보고 있다가 시간이 지나면 뒤를 돌아 어느 지점을 가서 그쪽을 또 
일정시간 지키고 서있는 식의 행동을 했었습니다. 그리고 정찰을 하다 주변의 플레이어를 발견했다 즉 일정 거리안에 플레이어가 있다고 한다면 정찰 상태에서 
쫒아가는 상태로 바꿔가지고 접근을하고 충분히 접근했다면 공격을 하는식으로 상태가 바뀔겁니다. 

이런식으로 동작할때 이걸 구현하려면 어떻게 해야하는지 생각해보겠습니다. 초보자의 경우는 이럴때 불리언으로 접근하는 경우가 많습니다. 
예를 들어서 불리언 변수들을 만들어서 내가 정찰중인지, 정지했는지, 추격중인지, 
공격중인지 이 상태들을 불리언으로 관리하는 경우가 있는데 
이 방법은 나중에 불리언끼리 로직이 꼬일 수 있기때문에 별로 좋지 않은 방법이라고 했었습니다. 

상태방식으로 관리하는게 좋다고 했엇는데 이미 캐릭터의 이동, 정지, 공격을 상태로 관리하고 있었는데 이걸 그대로 응용해도 괜찮다 라는 말입니다. 
State를 그대로 Get 해와서 Selet 문을 배치하겠습니다. 나중에 필요하다면 State에 죽어있는상태라던지 여러가지 추가할 수 있습니다. 애당초 State를 만든것이 
이렇게 사용하기 위해서입니다. 

그리고 이 상태에 따라 할 행동을 결정하는 방법을 유식한말로 표현한다면 유한상태기계라고 한답니다. Finite-State Machine FSM 이 영어 명칭입니다. 
이 FSM 방식으로 정말 대부분의 몬스터 패턴을 만들 수 있습니다. 와우 레이드 보스급의 패턴이 아닌이상 대부분의 쪼렙 몬스터는 대부분 상태 기반으로 만드는게 
깔끔합니다. 
내가 상태라는게 있고 만약 idle 상태라고하면 실행해야할 코드가 비교적명확합니다. idle을 시작한지 몇초의 시간이 지나면 다시 Move상태로 간다던지 아니면 
중간에 플레이어가 발견범위 안에 들어오면 추적상태가 되어서 플레이어를 쫒아 간다던지 또 추적 상태에 들어가면 추적동안에 실행되어야될 코드들로 넘어간다던지 할 수 있습니다. 

FSM은 게임뿐만아니라 다른 곳에서도 통용됩니다. ATM기계를 만든다거나 아니면 자판기를 만들때에도 불리언으로 만드는것보다 상태기반으로 만드는게 더 관리하기 좋습니다. 
인공지능의 기본이 되는 방법이다보니 한번쯤은 실습을 하고 넘어가는게 좋을것 같습니다. 

각 상태분기마다 코드들은 함수로 따로 빼서 관리해도 될겁니다. 만약 자식노드중에 행동이 달라져야한다면 그때 오버라이드 해서 사용할 수도 있기때문에 더욱 그렇습니다.
그래도 처음에는 일단 그냥 노드들을 나열해 코드를 짜보겠습니다. 

먼저 Idle 상태에서는 주변에 플레이어가 있는지를 검색해 있다면 따라 가도록 해주고 싶습니다. 
그러면 플레이어 서칭은 어떻게 해야할까요 만약우리가 플레이어 오브젝트들을 관리하는 오브젝트 매니저 같은게 있으면 그걸 가지고 서칭하고 거리를 계산했을테지만 
지금은 드래그앤 드롭으로 직접 배치했기 때문에 그렇게는 안되고 Get Actor Of Class 라는 함수를 이용해보겠습니다. 이 함수의 설명을 읽어보면 월드에서 지정한 클래스 타입의 첫 액터를 찾습니다. 
다만 다소 느린 작업이니 매 프레임마다 호출하지는 말라고 되어있습니다. 매 프레임마다 호출하지 말라고는 하는데 그래도 지금을 일단 사용하겠습니다. 
지금단계에서는 벌써 성능을 신경쓸 필요는 없고 돌아가기만 하면 되는걸 목표로 하겠습니다. 
Get Actor Of Class 의 반환값으로 액터를 반환해줍니다. 그런데 이때 따로 액터를 찾지 못할 경우가 있을겁니다. 이럴때를 대비해 체크를 해야하고 또 만약 찾았다면 그 액터를 쫒아갈때도 사용할것이기 때문에 
변수로 승격해줄겁니다. 이때도 로컬변수로 승격할지 일반 변수로 승격할지 골라 줄 수 있는데 우리의 경우는 만약 찾았다면 다음번 실행때에도 이 변수가 유지되어서 추격을 하고 싶으니까 일반 변수로 만들겠습니다. 
변수 이름은 알아보기 쉽게 TargetEnermy라고 하겠습니다. 

Idle 상태일때 어떻게 진행될지 다시 보자면 Get Actors Of Class 에서 BP_Knight를 찾도록하면 월드에서 가장 첫 액터를 찾게 되고 그것을 일반변수 TargetEnermy라고 저장합니다. 이 타겟이 유효한지를 체크하게되는데 
Is Valid 로 체크해 유효하다면 자신의 상태를 Move로 Set 합니다. 이런식으로 상태에 따른 코드를 넣어주면 됩니다. 

이어서 Move 상태일때 이동하는 코드를 넣어주면 되는가 하면 그렇지 않습니다. 여기서도 따로 이동하는 코드를 넣어주는것은 스파게티 코드를 만드는 격이고 이미 이전에 BP_Creature에서 Tick 이벤트 동안 
UpdateLogic을 호출하면서 이동하는 코드를 넣었습니다. 그러므로 이 BP_Monster의 UpdateAI에서는 어느방향으로 갈지를 즉 Direction을 세팅해주면 됩니다. 

Move 상태이고 그 이후로 진행할때 혹시 모르니 TargetEnermy를 Is Valid 체크를 한번더 해줍니다. 왜냐하면 꼭 Idle에서 타겟을 감지 했을때만 Move 상태로 들어오는게 아니고 정찰을하면서 타겟을 일정시간 못찾았을때에도 Move로 
들어올것이기 때문입니다. 만약 타겟이 유효하다면 이제 타겟쪽으로 이동하도록 방향벡터를 변경해주면 되겠습니다. 방향벡터를 구하는 법은 이미 배웠었습니다. 가고자하는 목표의 벡터값에서 자신의 벡터를 빼면 타겟으로 향하는 벡터가 
나옵니다. (여기서 벡터라는것은 위치벡터같이 말했습니다.) 그런데 이제 만약 타겟이 축방향으로 있는게 아니라 대각선 방향으로 있다면 어떤 Direction을 줘야할지는 이제 직접 정해줘야합니다. 
무조건 횡이동먼저 종이동을 나중에 하도록 한다던가 아니면 횡거리와 종거리중 더 먼 쪽을 먼저 이동하도록 한다거나 하는건 개발자가 정하기 나름입니다. 
다시 코드로 돌아와서 어찌 됐건 방향벡터를 구해줘야 하니깐 자신의 벡터와 타겟의 벡터를 가져오겠습니다. Get Actor Location으로 Self와 TargetEnermy의 벡터를 가져와서 뺄셈을 해줍니다. 
이렇게 타겟까지의 벡터를 나중에 또 사용할 수 있을것 같으니 다시 변수로 승격해줍니다. 이름을 ChaseDirection이라고 하겠습니다. 

다음으로 대부분의 경우는 추격을하다가 내 공격범위 안에 들어오면 더이상 추격하는게 아니라 공격을 하게 될겁니다. 그래서 여기서 브랜치로 분기를 하나 해줄건데 
ChaseDirection 에서 Vector Length를 하게되면 거리를 추출할 수 있는데 이 거리가 나중에는 공격 범위를 가져다 비교하면 되지만 지금은 그냥 테스트하기위해 300이라는 범위로 하드코딩해주겠습니다. 
이때 만약 300범위 안쪽에 있었다면 Skill 상태로 진행하면 되겠고 아니라면 계속해서 추격해주면 될것입니다. 

Skill 상태로 세팅해주고 다음 프레임에서 공격을 진행하게 해주는것도 안되는 것이 아니지만 아쉬운 점은 우리가 이전에 이런 기능을 만들어 놓은 적이 있습니다. 어떤 기능이냐면 이전에 BeginAttack 이라고해서 
기사의 경우 공격키인 스페이스바를 누를때 실행이 되도록 했었습니다. BeginAttack은 상태도 Skill로 바꿔주고 애니메이션도 갱신해주고 또 ProcessAttack 이라고 공격판정과 피격으로 인한 체력감소도 실행해준 다음 
공격 모션동안 딜레이도 줘서 그 동안 다른 동작을 하지 못하도록 도 해줍니다. 

이게 가만히 보니까 꼭 플레이어에서만 사용하는게 아니라 몬스터도 마찬가지로 사용해도 되지 않을까 생각이 들 수 있습니다. 그래서 방금 작업하던 브랜치에서는 BeginAttack을 호출해주도록하겠습니다. 

반대로 타겟이 범위내에 없을경우에는 이제 추격을 해줘야하는데 좌우로는 X좌표값을 사용하고 상하로는 Z좌표값을 사용하고 있는 상황입니다. Get ChaseDirection 을 구조체 핀 분할을 해주고 여기서 X좌표값과 Z좌표값을 
비교해 어느게 더 큰지를 판별합니다. 이때 이 좌표값들이 음수일 수도 있으니까 절대값끼리 비교해야합니다. Absolute로 절대값을 가져온다음 두 크기를 비교해줍니다. 두 경우를 브랜치로 분기하게될텐데 
만약 X 좌표값을 절대값이 더 크다면 좌 혹은 우 방향으로 가면 될것입니다. 좌혹은 우방향을 나눌때는 이전에 알아 봤었던 Compare float 노드를 사용하면 됩니다. 이 노드로 입력한 값을 원하는 수와 비교해 
큰거나 작거나 같을때 분기해 진행할 수 있었습니다. 

이제는 로직이 어느정도 완성이 되었습니다. 
다시 한번 요약을 해보겠습니다. BP_Monster에서 매 프레임마다 UpdateAI 함수가 실행되고 있고 먼저 몬스터의 State를 체크하는데 
Idle 이라면 Get Actor Of Class로 BP_Knight를 찾습니다. 찾은 나이트를 Is Valid체크를 하고 만약 유효하다면 몬스터의 상태를 Move로 세팅합니다. 
Move 상태라면 먼저 다시한번 찾은 타겟의 유효 체크를 하고 유효하다면 몬스터에서 타겟까지의 방향 벡터를 구해줍니다. 구한 방향벡터의 크기가 공격범위 안이라면 BeginAttack을 호출해 공격을 시작하고 
아니라면 이제 추격하게끔 하는데 이때 방향벡터의 X좌표값과 Z좌표값이 좌우와 상하에 관여하는데 이 두 절대값을 비교해 더 큰쪽부터 이동하도록 브랜치와 Compare float 를 활용해 Direction을 정합니다. 

여기 까지해서 한번 테스트 실행을 해봅니다. 제대로 몬스터가 플레이어쪽으로 걸어와 공격을 합니다. 만약 이때 몬스터의 이동속도가 너무 빠르다 싶으면 BP_Monster의 컴포넌트중 캐릭터 무브먼트 컴포넌트의 
디테일즈를 보면 Max Fly Speed 나 Max Walk Speed를 조절해주면 됩니다. 

앞으로 이제 몬스터와의 거리가 일정거리 이상 멀어지거나 하면 멈추고 하게끔 해주면 고전지능의 알피지 인겁니다. 