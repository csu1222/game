

    타일 단위 이동


지난시간에 했던 것은 타일맵 기준 좌표를 입력하면 GridMap의 인덱스로 변환해주는 GridPosToIndex 함수와 마찬가지로 타일맵 기준의 좌표를 입력하면 월드좌표의 벡터를 반환하는 
GetTilePos 함수를 만들고 이것을 BP_Knight의 BeginPlay이벤트 시점에 Set Actor Location으로 이동을 해주는 실습을 해봤습니다. 

이제 다음으로는 캐릭터가 불연속적으로 이동하는게 아닌 현재 위치에서 한칸씩 이동하도록 만들어 주겠습니다. 
근데 이전 시간처럼 인근 타일로 이동한다고 쳐도 이동하는 모션없이 뚝뚝 끊겨서 이동하는것도 이상할겁니다. 자연스럽게 일정시간동안 이동하는 것을 보여주는게 자연스럽습니다. 
이것을 구현해볼겁니다. 

이 타일 이동을 구현하는 방법은 여러가지가 있을 수 있겠는데 먼저 캐릭터의 현재 어느 위치에 있는지를 Actor Location으로 알 수 있었는데 이것 말고도 현재 Grid 기준으로 
몇번 좌표에 위치해 있는지를 알 수 있는 방법이 한가지 있습니다. 그래서 다음칸으로 이동해야한다면 그리드 기준 좌표는 한번에 가되 월드 기중 좌표는 뒤 따라 스르륵 이동하도록 
해줄겁니다. 

앞으로 그리드 좌표를 인트 두개로 계속 관리해야합니다. 그런데 이것을 그냥 인트두개로 사용하기 보다는 Struct로 만들어 두 인트를 묶어 사용하겠습니다. 
Blueprints/Struct 폴더로가서 Struct 하나를 새로 만들어 주겠습니다. 이름은 EGridPos라고 이름 짓겠습니다.

그러고 나서 Creature 폴더로 갈겁니다. 앞으로 캐릭터들은 그리드 좌표를 따로 관리를 할것이라고 했었는데 그래서 공통되는 부모 클래스 격인 BP_Creature 클래스를 열어보겠습니다. 
또 변수로 타입 EGridPos인 GridPos를 들고 있게 합니다. 

방금 설명한 대로 그리드 포지션은 이동한다고 키를 누르게 되면 그 순간 바로 다음 좌표로 이동해 있을겁니다. 어떻게 보면 앞으로 이 캐릭터가 움직일 목적지라고 볼 수도 있습니다. 
그리드 포지션을 미리 움직이는것은 혹시라도 캐릭터들끼리 이동하면서 부딛히는 상황을 피하기 위해 나중에 이동을 시작한 캐릭터가 이동실패해야 합니다. 이것을 위해 자리를 선점하는 개념이라고 할 수 도 있습니다. 

이어서 구해줄 것은 이전까지 BP_Creature에서 이동을 담당하는 함수였던 UpdateLogic 코드를 보면 현재 자신의 State가 Move 인경우 Direction에 따라 무브먼트 컴포넌트에서 나온 
Add Movement Input 함수로 이동을 하는 코드였습니다. 이제는 조금 입장이 달라져야 하는게 내가 당장 입력한 키보드 입력도 중요하긴 하지만 그전에 일단 이전에 이미 키보드 입력을 해서 목적지가 설정이 되었으면
그 장소로 이동하는걸 우선 처리하도록 해야하니까 UpdateLogic의 코드가 달라져야할것입니다.

그래서 새로운 함수를 추가할건데 이 함수는 GridPos와 내 현재 위치를 동시에 관리해주는걸 목표로 하고 있고 함수 이름은 SetDestination 이라고 하겠습니다. 목적지를 설정하는 역할을 할겁니다. 
먼저 인자를 어떻게 받아줄 것이냐면 int 타입으로 GridX, GridY 두가지를 받아줄겁니다. 이 것은 아까 만들었던 EGridPos구조체로 한번에 받아줘도 됩니다. 
한가지 더 받아줄건데 불리언 타입으로 bForceMove 를 받아 줄겁니다. 이것은 뭘할것이냐면 이동할때 목적지로 한번에 뿅 이동할것인지 아니면 스르륵 이동할것인지 플래그 역할을 할겁니다. 
왜 한번에 이동하는 것 까지 신경쓰냐면 게임을 시작할때 캐릭터를 위치 시킬때도 스르륵 이동시키지는 않을 것이고 뿅 이동하게끔 할것이라서 그때 사용하기위한 플래그입니다. 

그러면 그리드 좌표를가지고 월드 좌표를 구하려면 이전시간에 만들었던 BP_TileMap 클래스의 GetTilePos 함수를 사용하면 되었습니다. 
먼저 Get Actor Of Class로 BP_TileMap을 가져온 다음 여기서 GetTilePos를 호출 할 수 있었습니다. 이 GetTilePos 함수는 입력받은 그리드 좌표를 월드좌표로 반환도 해주지만 그 좌표가 유효한 좌표인지 Valid체크도 
같이 해줍니다. 그래서 한번 브랜치를 사용해 분기를 해주는데 유효하다면 GridPos 변수의 값을 세팅해주겠습니다 유효하지 않을때는 목적지를 설정하지 않고 그냥 끝낼겁니다. 

다음으로 GetTilePos함수의 반환값중 실제로 이동할 월드 좌표가 벡터타입으로 반환됩니다. 이걸 이제 아까 봤던 UpdateLogic의 Add Movement Input으로 이 좌표로 이동을 시켜야 하기 때문에 변수로 승격을 해주겠습니다. 
이름은 DestLocation 정도면 될 것 같습니다. 그러면 사실상 GridPos 와 DestLocation 은 같은 위치를 가리키고 있는 변수들입니다. 하지만 상황에 따라 다르게 사용할 것 이기 때문에 둘 다 따로 변수로 들고 있겠습니다. 

결국은 여기까지 왔으면 다시 한번 브랜치로 분기해서 ForceMove 값에 따라 바로 이동할지 말지를 나눠줍니다. ForceMove값이 True 라면 바로 Set Actor Location으로 위치를 설정해주겠습니다. 
그러면 이것을 어떻게 사용할 수 있냐 하면 BP_Knight 클래스로 가보겠습니다. 여기서 BeginPlay이벤트쪽에 이전시간에 테스트 하기위해서 Get Actor Of Class 로 BP_TileMap을 가져오고 거기서 또 
GetTilePos 함수로 임의의 맵 좌표를 줘서 그곳으로 Set Actor Location했었습니다. 이것을 SetDestination 함수로 대체 할 수 있게 됩니다. 함수를 이어준 다음 한 4 ,5 정도 좌표에 위치하도록 하고 ForceMove를 true로 
주면 됩니다. 

일단 강제 이동 까지는 만들었으니 다음은 뭘 만들어야 할지 생각해보겠습니다. 
이제 타일 단위 이동인데 스르르 이동하는 부분을 만들어야 합니다. 그러려면 내가 키보드 입력으로 한 방향을 잠깐 누르고 땟다고 하더라도 그 뱡향으로 한 타일은 이동하게끔 해줘야합니다. 
가장 먼저 Direction에 따라 1.0씩 이동하는 Select 노드를 삭제하겠습니다. 그리고 캐릭터의 State를 확인 한 뒤 Move일때 브랜치를 하나 추가하겠습니다 왜냐하면 두가지 상황이 있을 수 있습니다. 
내가 어느 인근 좌표를 찍어서 그 곳을 이동하는 과정이 있을것이고 어느정도 도달했으면 거기서 이동을 멈춰야 할 텐데 도착 여부를 판별 할 수 있어야지만 할겁니다. 
즉, 이동을 시작했을때 어떤 목적지 가지 도착했는지를 만들어둬야합니다. 

이것도 새로운 함수로 추가하겠습니다. 이름은 HasArrivedToDest 라고 하겠습니다. 
딱히 인풋을 받지 않아도 멤버 변수인 DestLocation에 근접하고 있는지를 체크하면 될것 같습니다. 
어떻게 기능할것이냐면 현재 자신의 좌표에서 DestLocation에 가까워지면 도착했다고 인정을 해주면 되는건데 
결국 이동하고자 하는 방향 벡터를구해서 그 거리를 추출한 다음 그거리가 일정 범위로 들어왔으면 도착했다고 인정하면 되겠습니다. 반환 값은 불리언 하나를 반환해주겠습니다. 도착햇는지 여부를 나타낼겁니다. 

먼저 이동하려고 하는 방향 벡터를 구하는것은 도착할 위치인 DestLocation에서 자신의 벡터를 빼주면 됩니다. 여기서 Vector Length를 구하면 이제 거리를 추출한겁니다 이 거리가 임의의 유효거리 안으로만 들어오면 
도착했다고 하면 될겁니다. 방향 벡터 거리가 10 이하라면 도착했다고 인정해주겠습니다. 이 비교한 결과를 반환해주면됩니다. 이 함수도 내부에서 어떤 값을 수정하는게 아니므로 퓨어 함수로 바꿔주겠습니다. 

이제 UpdateLogic 으로 돌아와보겠습니다. State 체크후 브랜치의 조건으로 HasArrivedToDest의 값을 넣어줍니다. 이때 True False 두가지로 분기가 될건데 여기서 true 라는것은 목적지에 다달았다는 것이고 
false 라는것은 아직 도달하지 않았다는거니까 이동을 해주면 될것입니다. 이동방향을 구해서 Set Actor Location을 하거나 아니면 기존대로 Add Movement Input으로 이동을 시켜주면 되겠습니다. 
Add Movement Input을 그대로 사용하고자 하면 아까 했던대로 방향 벡터를 구해서 연결해주면 됩니다. Add Movement Input 같은 경우는 입력된 벡터에서 방향 성분만 꺼내 이동시키기 때문에 따로 
단위 벡터로 변환하지 않고 그냥 입력 해줘도 되었습니다.  이렇게 해서 아직 목적지에 도착하지 않았을 경우의 이동 코드를 작성했고 
남은 것은 나머지 목적지에 도착했을 경우입니다. 

이때에도 두가지 상황이 있을 수 있습니다. 하나는 이동이 끝난 뒤에 키보드를 땐 상태여서 가만히 있는 경우가 있을것이고 또 한가지는 이어서 키보드 입력이 있어 다음 좌표로 계속 이동해야 하는 상황이 있을 수 있습니다. 

그래서 이 경우도 좀 코드가 길어질 것으로 예상이 되니까 새로 함수를 파주겠습니다. UpdateDestination이라고 하겠습니다. 
가장 먼저 내가 어디로 이동하고 싶은지 Direction을 꺼내 보겠습니다. 이어서 Select 노드를 연결해주는데 핀 타입을 EGridPos 구조체타입으로 바꿔 줍니다. 이어서 각 상하좌우 구조체 핀 분할을 해줍니다. 
이렇게 하면 Direction에 따라 이동하려고 하는 좌표를 입력해줍니다. 예를 들어서 Up이라면 x는 0 y는 -1 좌표를 가질겁니다 또 오른쪽의 경우는 x = 1, y = 0, 아래는 x = 0, y = 1, 왼쪽은 x = -1 y = 0 이라는 좌표를 가질겁니다. 
타일맵 기준 좌표계에서는 그렇습니다. 이렇게 가고자 하는 방향을 좌표로 표시 해봤으면 자신의 현재 좌표에 더해주면 다음으로 갈 좌표가 구해질겁니다. 여기서 자신의 현재 좌표는 GridPos 라는 변수로 관리하고 있었습니다. 
GridPos 도 역시 구조체 핀 분할을 해서 X, Y로 나눠주고 Select 의 값을 각각 더해주겠습니다. 
하나 조심해야 할것은 만약 입력한, 다음으로 갈 좌표가 맵에서 벗어 났다면 더이상 유효하지 않을것이기 때문에 유효 체크를 해줘야 하는데 이미 BP_TileMap 에 CanGo 라는 이름의 함수로 구현했었습니다. 
Get Actor Of Class 로 BP_TileMap을 가져오고 CanGo에 방금 연산한 다음 목적지 좌표를 넘겨 줍니다. 

CanGo를 통과한 좌표는 이제 유효 하기도 하고 벽도 아닌 타일일겁니다. 그러면 그곳으로 이동한다는 함수 SetDestination 를 호출해주면 될것입니다. 이때 ForceMove는 false로 줘서 스르르 이동하도록 해줄 겁니다.

여기까지 하고 한번 테스트를 해보면 우리의도로는 한칸씩 이동을 했어야 하는데 지금 제대로 동작하지 않고 있습니다. 
그 이유는 이전에 만들었던 코드와 꼬여서 제대로 작동하지 않는겁니다. 결국 문제가 되는 부분은 UpdateLogic이 가장 중요한 부분인데 여기가 동작하는 조건은 현재 내 State가 Move일때만 이 로직이 
실행됩니다. 그런데 이 Move라는 State는 어디서 관리하고 있냐면 BP_PlayerController 에서 연관이 있습니다. 여기서 키보드를 땠다 즉 MoveUp이나 MoveRight 라는 축 매핑값이 둘 모두 0이라면 State를 Idle로 바꿔주도록 
만들어 놨었습니다. 이제는 내가 키보드를 누르고 있지 않는다 하더라도 아직 목적지 까지 도착하지 않았다면 Move 상태를 유지해야 한다는것을 추가해주겠습니다. 
MoveUp과 MoveRight 값이 OR 연산을 하고 있을때 추가로 MyPlayer로 저장하고 있는 플레이어객체에서 HasArrivedToDest 함수를 꺼내서 그반환값을 보면 내가 도착했는지를 불리언으로 반환하고 있는데 이것을 Not boolean 연산으로
뒤집어 내가 만약 도착하지 못했다면 이라는 조건을 OR 연산에 추가합니다. 
그러면 이런 조건문이 되는겁니다. 내가 만약 도착하지 못했거나, MoveUp값이 0이 아니거나, MoveRight 값이 0이 아니라면 Move State를 유지한다는 것입니다. 

이제 다시한번 게임을 실행하면 한번에 쫘악 이동하는것 까지는 확인 했지만 방향을 꺽거나 벽에 부딛히기 전까지 멈추질 않습니다. 
왜 이런것이냐면 이제 캐릭터를 이동하는 조건은 설정했지만 결국은 Direction은 같은 방향을 계속 가리키고 있고 또 UpdateDestination에서는 다음 칸이 Can Go 한 타일이라면 그곳을 계속해서 목적지로 설정해주고 있습니다. 

이것을 수정하는 방법은 내가 키보드를 입력하고 있는지의 여부를 가지고 계속 움직여야하는지 멈춰야하는지를 한번더 크로스 체킹해줘야 겠습니다. 

BP_Creature에 새로운 변수를 하나 만들어 줄건데 Boolean 타입으로 bStopMove라고 이름 짓겠습니다. 
그리고 다시 BP_PlayerController의 UpdateInput 쪽으로 돌아와 시퀀스의 갯수를 하나 더 늘립니다. 여기서 상하좌우 어느쪽으로도 가지 않는다고 하면 그것은 멈추라는 말이 될겁니다. 
MoveUp, MoveRight가 0과 같다라는 비교한 다음 And 연산을 합니다. 플레이어의 Set StopMove를 가져와 그 And연산값을 세팅해줍니다. 이러면 멈추겠다라는 플래그가 됩니다. 

다음은 BP_Creature의 UpdateDestination으로 갑니다. 여기서 함수가 시작할때 브랜치 하나를 추가해주겠습니다. 여기서 StopMove 여부를 체크해줄겁니다. 만약 이 브랜치에서 False 다 라고 하면 지금까지 하던것처럼 
이동하는 코드를 연결해 주면 됩니다. 

다시 테스트 해보면 타일 한칸한칸씩 이동하는걸 볼 수 있습니다. 이렇게 해서 이동을 한칸씩 하는 게임이다고 하면 이런식으로 만들면 되겠습니다. 
오늘의 방법에서는 GridPos 는 입력 즉시 이동할 목적지에 위치하게 해서 다른 캐릭터끼리 부딛히지 않도록 해주기도했습니다. 물론 아직은 맵하고만 멈추는 상태이지만 나중에 캐릭터와도 멈추도록 수정해주겠습니다. 

이번 시간 코드가 비교적 복잡한 작업이었습니다. 혼자 만들다 보면 이런 과정이 어떻게 한번에 주르륵 생각할 수 있을지 걱정이 되는데 물론 이 코드를 초보자가 만들면 한번에 딱 만들기가 어렵습니다. 
필요한 코드를 한개씩 만들어 나가고 여기저기 조립하면서 만들어 나가면 정말 탁월한겁니다. 

오늘 작업하면서 상속 구조와 컨트롤러로 입력을 관리하는것의 편리함을 알 수 있었습니다. 
완전히 이동 로직이 달라짐에도 불구하고 기능따라 관리를 해서 작업이 편했습니다. 