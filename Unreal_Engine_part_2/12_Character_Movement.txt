

    Character Movement


지난시간까지 Set Actor Location 이라는 함수를 이용해서 캐릭터를 좌우로 이동하는것을 구현해봤습니다. 
이번시간에는 Character Movement라는 컴포넌트를 사용해서 같은 기능이 구현되도록 작업해볼겁니다. 

왜 굳이 이미 만든 기능을 똑같은걸 다시하는가 할 수 있습니다. 
이거에 대해 장단점을 실습하는게 중요합니다. 

Set Actor Location 같은 경우는 이동할 좌표를 직접 다 계산하고 입력에 넣어주는 방법이었고 또 비슷한 기능인 Add Actor World Offset 이라는 함수가 있는데 
여기서는 Get Actor Location과 이동할 거리를 더해주는걸 생략할수 있는 기능이긴한데 별로 다를것은 없습니다. 

본격적으로 캐릭터 무브먼트 컴포넌트를 공부하기 전에 먼저 언리얼엔진의 특징인 계층구조가 단단히 잡혀있는게 단점이자 장점이라고 할 수 있는데 
단점은 자유도가 낮으니 이걸 익힐때 복잡하고 어렵다는게 단점이고 장점은 우리가 언리얼 엔진에 구조를 보면서 코드 구조를 잡는데 노하우를 배울 수 있습니다. 오래동안 
쌓여온 코드 구조의 노하우를 배울수 있는데 그러면 이동과 관련된 기능들을 컴포넌트로 빼서 관리하고 있을까요?
보통 처음에 게임을 배우는 학생들이 게임 포트폴리오를 만들면 캐릭터가 이동하는코드를 업데이트 코드에서 이동하는 코드를 막바로 넣어 놓는 경우가 많습니다. 
직관적인 방법이기 때문에 꼭 나쁜 방법은 아니지만 나중에 좀 안좋아 질 수 있는 상황이 게임이 점점 복잡해지고 장르고 FPS라고 해보겠습니다. 
FPS의 경우에는 내가 뛰어다니는 상황도 있겠지만 경우에 따라 공중부양을하는 상황 예를 들어 배틀그라운드에서 낙하산을 타고 내려온다거나 오버워치에서 비행을 하는등의 
상황이라고 하면 그렇게 다양한 상황에서 처리가 좀 힘들게 됩니다. 기본 이동뿐만아니라 각각 다양한 이동 상황의 좌표계산을 업데이트 코드에서 관리해야하기 때문입니다. 

그렇기 때문에 컴포넌트로 만들어 부품화 한다면 이동과 관련된 코드를 모아 관리할 수 있고 또 다른 방식으로 이동하게 된다면 무브먼트 컴포넌트 자체를 다른 컴포넌트로 바꿔 사용하면 
됩니다. 컴포넌트 방식이 꼭 이동뿐만아니라 AI, 컨트롤러 같이 다양한 상황에서 필요에따라 부품을 뺐다 꼈다 하는 식으로 사용하면 편리하게 코드를 관리할수 있습니다. 
참고로 BP_knight의 컴포넌트 Add에서 Movement 를 검색해보면 다양한 무브먼트 컴포넌트가 있다는걸 알 수 있습니다.

다양한 무브먼트 컴포넌트가 있지만 캐릭터 무브먼트의 기능이 워낙 많다보니 왠만한 상황에서는 그냥 캐릭터 무브먼트로 다 사용할 수 있다고 합니다. FPS뿐만아니라 MMORPG에서도 그냥 
캐릭터 무브먼트를 그대로 사용하기도 한다고 합니다. 

캐릭터 무브먼트를 선택한 상태에서 오른쪽에 Details 를 살펴보면 정말 많은 기능들이 있다는걸 알 수 있습니다. 일반세팅이라고 해서 중력 계수, 캐릭터의 무게, 땅과의 마찰력, 앉았을때의 캐릭터 높이등을 설정할 수 있고 
걷기를 할때의 상황, 점프나 낙하할때의 상황, 수영할때나 비행할때, 회피할때 등등 정말 많은 상황을 커버할 수 있습니다. 
캐릭터 무브먼트를 건드리기전에 Devmap 에서 BP_Knight 오브젝트의 Details에서 바닥으로 떨어지지 않도록 중력 스케일을 0으로 설정했었습니다. 기본값은 1.0 이었기 때문에 만약 새로 BP_Knight 오브젝트를 
하나 더 배치한다로 하면 새로 배치된 나이트는 아직 중력 스케일을 수정하지 않았기 때문에 게임 실행시 바닥으로 떨어질겁니다. 이런 상황을 가정해서 테스트로 사용하던 나이트 오브젝트의 중력 스케일을 다시 1.0으로 되돌려 보겠습니다.
당연히 실행하면 땅으로 떨어집니다. 
캐릭터가 땅으로 떨어지지 않게 하는 방법으로는 방금했던 중력 스케일을 0으로 수정하는것과 블로킹 볼륨을 바닥처럼 깔아서 캐릭터가 그 위에 설 수 있게 만드는 방법이 있습니다. 

왜 굳이 바닥을 깔아 놨느냐 하면 얘를들어 캐릭터에 점프하는기능이 있어야 한다고 하면 캐릭터 무브먼트에 점프 관련기능이 있어서 구현하기 쉽다는 겁니다. 점프할때 중력영향을 받는것이 좋기 때문입니다. 

그 다음 알아보고 싶은것은 이제 캐릭터가 상하 좌우처럼 그냥 이동하고 싶다면 어떻게 해야할까요 대표적인 함수가 하나 있는데 BP_Knight 블루프린트에서 캐릭터 무브먼트를 꺼내 주고 Add Input Vector 라는 함수를 
배치해보겠습니다. 
이것과 비슷하게 캐릭터 무브먼트를 따로 꺼내지 않고 Add Movement Input 이라는게 있는데 이 두가지 함수는 쌍둥이라고 할 수 있습니다. 내부적으로 Add Movement Input을 까보면 캐릭터 무브먼트를 가져와
Add Input Vector를 하는 식으로 되어있습니다. 

그래서 이 Add Input Vector에 대해 알아보기 위해 커서를 가져다 대면 이렇게 설명하고 있습니다. 

Add Input Vector : 월드 스페이스에서 누적된 입력에 지정된 벡터를 추가합니다. 입력 벡터는 보통 0에서 1사이입니다. 입력 벡터는 한 프레임 동안 누적된 뒤 무브먼트 업데이트 중에 가속도로 누적됩니다. 
결국 하고 싶은 이야기는 Add Input Vector 노드에서 받는 Vector 입력에다 어디로 이동했으면 좋겠다는것을 표현하면 됩니다. 예를들어서 오른쪽으로 이동하고 싶다고하면 
x : 1.0, y : 0, z : 0 이라고 값을 주면됩니다. 이것을 UpdateLogic 함수에서 Move State를 확인하는 스위치문 뒤에 연결해 줘보겠습니다. 

그런데 이렇게 까지만 하면 이상하게 생각할 수 있는게 이전에 Set Actor Location을 사용했을때는 이동거리를 Delta Time과 Speed를 곱해주고 캐릭터의 현재 위치를 더해서 넘겨줘야했습니다.
근데 지금은 딱히 그렇지 않고 어디로 이동하고 싶다고 덩그러니 입력하면 되니까 이상합니다. 속도랑 델타 타임은 어떻게 됐는지 궁금해지는데 정답은 캐릭터 무브먼트 컴포넌트에 다 있습니다. 
캐릭터 컴포넌트의 디테일즈를 보면 중력 스케일 뿐만아니라 Max Acceleration 이라고 최대 가속을 들고 있고 또 내리다보면 Max Walk Speed 라고 해서 걷기 최대속도라는 정보들을 이용해서 이동이 이뤄진다고 생각하면됩니다. 
그리고 가속도가 있기 때문에 캐릭터가 등속도 이동하는게 아니라 이동시작할때 조금식 속도가 빨라지며 최대 속도에 도달한 다음 멈출때도 서서히 느려지면서 멈추게 됩니다. 
나중에 이런저런 설정으로 중력, 마찰력을 설정하면 그 영향도 받게 될겁니다. 

이해하기 쉽도록 간단하게 실습해보자면 BP_Knight 블루프린트에서 Tick 이벤트 에 연결된 노드 끝에 로그를 찍어보겠습니다. 어떤걸 찍을것이냐면 현재 가속도와 속도를 찍어보겠습니다. 
현재 가속도는 Get Current Acceleration 이라는 함수를 사용하면되고 현재 속도는 Get Velocity 함수를 사용하면됩니다. 이 두 노드 모두 벡터를 반환하는데 Vector Length를 사용해서 Float로 변환한 다음
format Text로 출력하면 되겠습니다. 

이제 중간테스트를 하면 아까 UpdateLogic 에서 오른쪽으로움직이는 코드만 넣어놨기 때문에 애니메이션과는 다르게 항상 오른쪽으로만 움직이게 될겁니다. 
그리고 현재 가속도는 2048에 현재속도는 600 이 매 프레임 출력됩니다. 여기서 결국 볼수 있는건 자세히보면 캐릭터의 이동속도가 한번에 600으로 가는게 아니라 점차 증가하면서 결국 600에 도달하는걸 
로그로 볼 수 있습니다. 여기서 본 가속도, 속도등은 역시 캐릭터 무브먼트의 디테일즈에서 세팅 할 수 있는겁니다. 
결국 이전시간에 Speed 라는 변수로 관리하던것을 캐릭터 무브먼트 디테일즈안에 포함되어있는것이라고 할 수 있습니다. 

Add Movement Input 도 비슷하게 동작하고 있는데 받아주는 입력값이 World Direction 이라는 벡터와 Scale Value라는 플로트를 받아주고 있습니다. 
나중에 CPP로 코드를 까서 어떻게 동작하고 있는지를 보면 World Direction에 Scale Value를 막 바로 곱해줍니다.
이걸로 역방향으로 갈때 조절한다거나 하는 식으로 사용할 수 있습니다. 근데 처음보면 햇갈릴 수 있는게 Float 를 받아주고 있고 항상 동일하게 컴퓨터성능에 구애받지 않게끔 동작해야하니까 
Delta Time을 넣어줘야 할 것 같이 생겼습니다. 근데 그런 개념이 아닙니다. 이미 캐릭터 무브먼트 안에서 온갖 데이터들이 관리되고있어서 딱히 컴포넌트 외부에서 델타타임을 입력받아야하지 않습니다. 

그런데 이 Add Movement Input의 Scale Value가 있으면 편한게 지금까지 Get MoveRight 같은 걸하면 오른쪽은 1.0이 반환되고 왼쪽은 -1.0이 반환 되고 있었는데 이걸 Add Movement Input 의 Scale Value에 
꽂아주면 알아서 오른쪽 왼쪽 이동이 처리가 됩니다. 이런 부분은 조금 편리할 수 있습니다. 

그런데 여기서 오해할수 있는 부분이있는데 Add Input Vector 나 Add Movement Input 을 연달아 호출하면서 이동할 좌표를 x로 1.0씩 주면 호출한 횟수만큼 배수만큼 빨리 이동할것이라고 착각할 수 있습니다.
실제로 한번 테스트 해보면 딱히 그만큼 빨리 이동하지는 않는걸 볼 수 있습니다. 
마찬가지로 Scale Value를 100.0을 갑자기 입력한다고 해보겠습니다. 그래도 역시나 최대속도는 그대로입니다. 그러니까 넣어주는 벡터는 어디로 이동하고 싶은지 의도를 넣어주는거라고 이해하면 됩니다. 
만약 여러방향을 동시에 넣어준다고 하면 어떻게 될까요 넣어준 방향끼리 부딛혀서 싸운 결과가 실행된다고 할 수 있습니다. 
어떤 말인지 다시 알아보겠습니다. 

우리가 이전 파트에서 벡터에 대해 알아봤습니다. 벡터란 원점을 기준으로 어느 방향으로 어느정도의 크기로 이동할지를 나타낸 값이라고 햇습니다. 그러면 여러 벡터가 있다면 각각 벡터의 합 공식에 의해 
새로운 벡터가 나타날겁니다. 그리고 이런 벡터의 방향만 가져오기 위해서는 Normalize 라고 해서 단위 벡터로 만들어 사용했습니다. 즉 Add Input Vector나 Add Movement Input 으로 여러 값을 같이 호출하면
그 벡터들의 합을 정규화해서 단위벡터로 만들고 그 방향만 가지고 나머지 속도나 가속도는 따로 적용한다는 것입니다. 

이제 이전시간에 만들었던 Set Actor Location 방식을 날리고 오늘 배운 방식으로 다시 만들어보겠습니다. 
UpdateLogic 의 시작노드에서 스테이트의 스위치문까지는 유지합니다. 스위치문에서 Move 스테이트일때 Add Movement Input 을 연결해주고 벡터는 x축을 1.0으로 해줍니다. 여기에 아까 언급했던
Get MoveRight 값을 Scale Value에 연결하면 자동적으로 왼쪽으로 갈때는 벡터가 반전되어서 제대로 좌우이동이 구현됩니다. 

이전시간에 구현했던 코드보다 훨씬 짧고 간결해 졌는데 이걸 처음배울때 딸랑 이 코드만 배워서는 왜 이렇게 동작하는지 요소들을 잘 모르기때문에 이후 응용이 어려워집니다.

다음은 좀 더 어려워진 부분입니다. 예를들어 이제 캐릭터가 상하좌우 모두 이동하도록하고싶다면 어떻게 해야할까요
간단하게 생각해보면 다시한번 Add Movement Input을 연결해서 이번엔 z축이동을 하게하고 MoveUp을 Scale Value로 주면 되지 않을까 할 수 있습니다. 
실행해보면 상하이동이 안되는걸 볼 수 있습니다. 

왜이럴지 생각해보면 혹시 중력값때문일 수 있으니 중력 관련 플레그를 다 끄고 중력 스케일도 0으로 밀어줘보는것도 당연히 떠올릴수 있는 방법입니다. 
역시 이렇게 해도 상하 운동이 되지않을텐데   

그냥 결론부터 보자면 캐릭터 무브먼트중에 캐릭터 무브먼트(일반 세팅)이라는 곳에 디폴트 랜드 이동모드라는 옵션이 있습니다. 기본적으로 어떤 식으로 움직이는가 라는 옵션인데 기본으로 Walking 이라고 되어있습니다.
Walk는 수평이동만 하지 하늘을 날지 못할것이기 때문에 이것을 Flying 으로 바꾸고 다시 실행해봤습니다. 이제는 신기하게도 상하좌우로 이동이 되는걸 볼 수 있습니다. 
그런데 조금 이상한게 이전처럼 캐릭터가 딱 멈추는게 아니라 미끄러운것처럼 잘 안멈춰집니다. 이런부분을 우리가 만들 게임대로 잘 이리저리 수치를 조절해야하는겁니다. 

캐릭터 무브먼트 디테일즈를 살펴보면 이런 옵션이 있습니다. 캐릭터 무브먼트 : 날기 라는 란이 있는데 최대 비행속도가 600이라고 되어있습니다. 이 수치는 아까 최대이동속도와 같은 수치이고 
그 밑으로 감속 날기 제동 Break Deacceleration 옵션이 있는데 이게 0이라고 되어있습니다. 기본 걷기를할대 이 감속 제동값이 2048로 되어있으니 한번 날기에서도 같은 값을 주고 테스트 해보겠습니다. 
그러면 훨씬 자연스러운 제동이 됩니다. 이런식으로 직접 헤딩하면서 알아보는게 좋습니다.

한가지 더 수정할점이라면 캐릭터가 이동하면서 수직으로 방향을 딱 꺽으면 바로 방향이 틀어지는게 아니라 약간 곡선을 그리면서 방향 전환이 되는게 맘에 안든다고 해보겠습니다.
이건 어떻게 설정하냐면 캐릭터 무브먼트의 디테일즈를 보면 아마 가속도와 관련된 문제지 않을까 싶습니다. 지금은 2048이라는 값으로 되어있는데 방향을 누르자마자 그 방향으로 휙꺽으려면
가속도 값이 훨씬 크면 될것같습니다. 예를등러서 지금 가속도 값에서 0을 세개 더 붙여보겠습니다. 감속 제동값도 마찬가지로 0을 세개 붙이고 테스트 해보겠습니다.

이러면 이제 아까와 다르게 딱딱 직각으로 움직이게 된것 같습니다.


이번 강의를 정리해보자면 Set Actor Location 대신 이미 캐릭터 무브먼트라는 컴포넌트에 만들어져있는 Add Input Vector나 Add Movement Input 함수를 사용해 캐릭터 이동을 구현해봤습니다.
여러 세부 조절을 할 수 있고 그 범위가 워낙 광범위해서 조금 불편하다고 느낄 수 있지만 그럼에도 불구하고 나중에 3D 게임을 만든다고 하면 또 서버까지 붙여서 멀티플레이를 구현한다고 하면
Set Actor Location으로는 진짜 머리가 아플텐데 마침 언리얼에서 이미 캐릭터 무브먼트라는 컴포넌트가 이미 준비되어있다는것은 유용한 점입니다. 
물론 그 전에 좀 더 친숙해질 필요는 있을겁니다.