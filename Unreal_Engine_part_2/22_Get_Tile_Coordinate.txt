


    타일 좌표 구하기 


이전 시간에 타일맵과 맵에서 좌표나 타일의 정보를 추출하는 방법을 알아봤습니다. 툴로 만든 리소스에서 코드로 정보를 추출했었습니다. 

지금까지 살펴봤던 기능들을 보면 언리얼에서 2D 게임을 만들때 생각보다 횡스크롤 플랫포머 게임은 궁합이 잘 맞는걸 볼 수 있습니다. 언리얼의 중력같은 기능을 활용하면 
점프같은 기능을 쉽게 구현할 수도있는 점이 그렇고 오히려 더욱 레트로한 2D 게임, 지금 만들고 있는 타일 맵에서의 게임의 경우가 언리얼과 별로 궁합이 좋지 않은것 같습니다. 
타일 맵을 지원하기는 하지만 언리얼의 캐릭터의 캡슐 컴포넌트가 맵의 크기와 잘 맞지않는 다거나 원형의 캡슐 때문에 서로 부딛힐때 미끄러지는 현상이 있다거나 합니다. 

거기에 또 이번 시간에 해볼 타일 단위 이동도 언리얼에서 기본적으로 지원한다기 보다는 우리가 직접 코드로 구현하는것에 가깝습니다. 

우선 이전 시간에 타일맵의 각 좌표가 이동가능한 타일인지를 표현하는 MapGrid를 만들었습니다. 
이것에 이어서 캐릭터를 맵의 좌표로 이동하는 기능을 만들어 보겠습니다. 

BP_TileMap 클래스로 먼저 가보겠습니다. 이전시간에 Can Go 라는 함수를 만들어 어떤 좌표를 줬을때 그 좌표가 갈수 있는 타일인지를 불리언으로 뱉어주는 함수를 만들었습니다. 
또 이벤트 그래프에서는 BeginPlay 이벤트에서 MapGrid의 값들을 채워주기 위해서 툴로 만들었던 TileMap 의 데이터를 추출해와 1차원 불리얼 배열로 가져왔습니다. 

그 과정에서 타일맵이라는 2차원 좌표 평면과 1차원 배열사이의 변환을 해 사용했었습니다. 이 기능을 앞으로도 자주 사용할것 같으니 따로 함수로 빼 관리해주겠습니다. 
추가할 함수 이름은 GridPosToIndex 입니다. 함수는 파라미터로 int 타입 변수 두개를 받아줄겁니다. 이 각 X,Y 좌표입니다. 리턴값은 좌표를 1차원 Index로 변환해 리턴해줄것이니 
마찬가지로 int 타입 변수입니다. 
앞으로 이 함수는 자주 사용할 함수이고 그러다 보니 좀 더 안정성을 위해 입력 받은 좌표가 유효한지 부터 체크해주겠습니다. 그래서 이 함수가 받은 좌표가 유효하면 제대로 동작해 Index를 잘 반환할것이지만 
좌표가 유효하지 않다면 함수 동작은 멈추고 또 제대로 동작하지 않았다고 외부로 알려야합니다. 그러기 위해서 입력받은 좌표가 유효한지 Valid한지를 리턴해주기 위해 리턴값으로 불리언 변수 bValid를 하나 뱉어 주겠습니다. 

이제 GridPosToIndex의 내용을 구현해 보겠습니다. 가장 먼저 넘겨 받은 인자들인 x좌표, y좌표가 유효한지 체크해주겠습니다. 유효한지를 알려면 일단 두 값 모두 0보다는 커야 합니다. 
또 x는 맵의 너비, y는 맵의 높이 이하의 값이어야합니다. 이 범위 안에 속해있는지를 검색해야합니다. 
이때 이 범위를 체크하는 노드가 있습니다. In Range(Integer) 라는 노드입니다. 얼핏 봐도 Min,Max 값 사이에 있는지를 체크해주고 또 Min, Max로 준 값과 같을때도 포함할건지 체크 박스가 있습니다. 
0이상 10미만의 값을 주면 될것 같습니다. 

여기서 10이라는 값은 맵의 너비를 뜻하는데 이전시간부터 기 너비값을 그냥 하드코딩으로 입력하고 있었는데 사실을 이 방식은 좋지 않다는걸 다 알겁니다. 
혹시라도 나중에 툴을 이용해 맵의 크기를 변경했을때 코드가 알아서 적용되는게 아닌 맵의 너비를 입력한 부분 모두 손수 수정해줘야하기 때문에 빼먹다가 에러가 나기쉽습니다. 
이번 기회에 하드코딩했던 부분들을 다 바꿔주겠습니다. 

맵의 너비, 맵의 높이를 변수로 저장해줄겁니다. MapWidth, MapHeight 라고 int 타입 변수두개를 추가 합니다. 그리고 이벤트 그래프로 가서 BeginPlay 이벤트때 같이 너비, 높이를 세팅해주도록 하겠습니다. 
시퀀스를 사용하고 있었는데 Then0 에서 먼저 렌너 컴포넌트로 부터 타일 맵의 데이터를 추출해 맵 너비, 맵 높이를 사용하고 있었습니다. 이 부분에서 겸사 겸사 변수 값을 저장해 주면 됩니다. 
이렇게 변수를 저장했으면 이후 값들을 사용하던 부분에 다 적용해줍니다. 

다시 GridPosToIndex 함수로 돌아와 x 좌표의 In Range 하는 범위 값으로 MapWidth를 연결해줍니다. Y값도 마찬가지로 범위 체크를 해주고 이 두 불리언 값을 And 연산으로 체크해 이 값이 true 라면 유효한 좌표인것이고
false라면 유효하지 않은 좌표인것입니다. 
그리고 나서 이제는 좌표를 인덱스 값으로 연산해줄 차례입니다. Can Go에서 했던 방법은 X값은 그대로, Y값은 MapWidth를 곱해서 둘을 더한값이 인덱스가 되었습니다. 그대로 사용하면됩니다. 

이제 이 GridPosToIndex라는 함수를 만들었으면 이것을 최대한 사용해줘야겠습니다. 이전에 만들었던 Can Go의 내부에서도 사실 좌표의 예외체크를 건너띙 GridPosToIndex를 사용하고 있습니다. 
CanGo 함수를 수정해보면 내부에서 GridPosToIndex를 호출해 유효 체크와 좌표에서 인덱스 변환을 해준 다음 유효 체크 값에 따라 브랜치를해 유효한 좌표가 아니라면 False를 반환하고 
유효한 좌표였다면 MapGrid에서 좌표에 해당하는 값을 반환하도록 해줍니다. 

다음으로 만들어 줄것은 이제 X, Y라는 좌표 값이 주어졌을때 그에 해당하는 월드 좌표값을 구하는 함수를 만들어줄겁니다. 지금 X,Y 좌표는 타일맵 기준의 좌표계에서의 좌표이고 월드 좌표는 DevMap을 기준으로 하는 좌표계인데
이 월드 좌표를 기준으로 캐릭터를 움직여야하기 때문에 이 함수를 만듭니다. 

Get Tile Pos 라는 이름으로 함수를 추가하겠습니다. 인자로는 역시 GridX, GridY라고 int 타입 두개를 받아주고 반환도 두가지를 반환할 건데 한가지는 불리언타입으로 역시 입력 좌표가 유효한지를 체크한 값
두번째는 벡터를 반환하는데 타일맵 좌표에서 월드좌표로 변환한 값을 반환하겠습니다. 

이제 중간의 기능을 만들면 됩니다. 여기서 아까 만든 GridPosToIndex 함수를 호출해주겠습니다. GridPosToIndex 에서 좌표의 유효체크를 이미 했으니 바로 반환핀으로 연결해주면 됩니다. 
타일맵 좌표를 어떻게 월드 좌표로 변환할지 살펴보기 위해 잠시 DevMap을 열어보겠습니다. Devmap에 배치한 BP_TileMap 오브젝트는 배치후 한번 Location을 리셋 했었습니다. 그래서 월드좌표의 원점인 (0,0,0)
을 Location값으로 삼았는데 화면에서 보면 이 (0, 0, 0) 좌표가 BP_TileMap의 (0,0) 타일을 가리키고 있습니다. 그러면 여기서 타일 하나 만큼씩을 상하좌우로 움직이면 그 좌표를 알 수 있을것 같습니다. 
이 타일만큼의 크기가 얼마일까요?
BP_Skeleton 오브젝트를 원점에 배치한 다음 손으로 끌어서 타일 하나정도를 움직이고 Location값을 보면 대략 150정도 이동한것이라는걸 알 수 있습니다. 그러면 이 150이라는 값은 어디서 나왔는지는 
아마 툴을 이용해 TileMap을 만들어 줄때 설정이 되었을겁니다. 

그래서 Sprite 폴더의 TileMap 파일을 다시 열어보겠습니다. 디테일즈 중에 Tile Width와 Tile Height 라는 옵션이 있는데 이게 사실 값이 Tile Set 에서 가져온 타일의 픽셀단위일겁니다. 
이 픽셀은 언리얼엔진 기준에서 또 크기가 얼마인지도 Pixcel Per Unreal Unit 언리얼 유닛 당 픽셀 이라는 옵션이있습니다. 
현재 Tile Width와 Tile Height는 32 씩 이고 언리얼 유닛 당 픽셀은 1.0입니다. 그런데 맵을 그냥 배치한게 아니라 캐릭터들과의 크기를 맞추기 위해서 Scale에 5를 곱했었기때문에 
결국 월드 좌표에서 한 타일의 크기가 32 * 5 라는걸 알 수 있습니다.
만약 처음에 애당초 통맵 크기에 맞춰 캐릭터들을 키우지 않았더라면 괜히 스케일에 5씩을 곱해주지 않아도 되었을겁니다. 지금이야 이제와서 모두 스케일을 원래대로 바꾸자면 
캐릭터들도 다 건드려야하고 캐릭터 머리위의 Hp바 UI도 수정해야하기 때문에 일단은 지금처럼 진행을 해나가겠습니다. 

다시 BP_TileMap의 GetTilePos 함수로 돌아가보면 한 타일만큼의 이동거리를 알게 되었습니다. 여기서도 방금 알아본 옵션들의 수치를 다 변수화 해서 관리하는것도 한 방법일겁니다. 
우리도 Float 변수두개를 추가해서 MapSizex, MapSizeY 라고 저장해 각각 32.0 씩 값을 가지고 있도록 해주겠습니다. 
이제 Location을 계산하기 위해서 인자 GridX 에다가 MapSizeX를 곱해주고 또 스케일을 5만큼 늘려놨기 때문에 5도 곱해주겠습니다. Y도 마찬가지로 값들을 곱해주는데 
아까 DevMap에서 보면 아래로 내려가는 건 음수 였습니다. 그러므로 Y값은 -도 곱해줍니다.

다음으로 해야할 것은 지금사용하느 타일맵이 지금은 원점(0, 0, 0) 에 위치해있지만 언젠가 위치가 달라 질 수도 있으니까 맵의 좌표를 기준으로 이동하게끔 계산해주겠습니다. 
Get Actor Location으로 맵 오브젝트의 Location값을 가져와 여기에 계산한 x,y 좌표들을 더해주겠습니다. x 좌표 이동은 Location 벡터중 x 축에 더해주면 되겠고 
y 좌표 이동은 z축에 더해주면 됩니다.  구조체 핀 분할을해 각각 더해주면 됩니다. 그리고 이 값이 GetTilePos에서 알고 싶은 좌표다 라고 알 수 있습니다. 

지금까지 작업한 코드가 잘 동작하는지를 테스트 해보겠습니다. 좌표 이곳 저곳의 값을 알아보고 싶은거다 보닝 BP_TileMap 오브젝트에서 이걸 테스트하기는 적절하지 않고 
직접 이동가능한 BP_Knight 오브젝트에서 테스트 코드를 넣어보겠습니다. BeginPlay에 이어서 코드를 작성할건데 
이때 조금 고민되는것이 BP_Knight 와 별개로 이미 월드에 BP_TileMap이 배치되어있는 상황인데 적 오브젝트를 여기서 어떻게 가져올지 고민입니다. 
어떤 노드를 사용해야하냐면 Get Actor Of Class 노드를 사용하는데 이 함수는 성능상으로는 효율이 안좋지만 지금은 테스트 코드로 사용하기 때문에 괜찮습니다. 
함수에서 찾을 클래스를 골라주면 월드에 그 클래스에 해당하는 오브젝트의 레퍼런스를 하나 반환해줍니다. 바로 이어서 Get Tile Pos 함수를 호출해 줄 수 있습니다. 

참고로 Get Tile Pos 함수는 내부에서 뭔가를 수정하는 개념이 아니라 있는 정보들을 연산해 반환하는 식입니다. 이런 방식의 함수는 디테일즐 보면 Pure 라는 옵션을 체크해줍니다. 
그러면 신기하게도 외부에서 호출할때 노드가 아까는 파란색 이었는데 지금은 초록색으로 뜬다는걸 알 수 있습니다. 

다시 BP_Knight로 돌아와 임시로 4, 5 좌표를 GetTilePos 함수에 주고 그 값으로 Set Actor Location 해주었습니다. 실행해보면 4,5 좌표위치에 캐릭터가 배치되어있다는걸 볼 수 있습니다. 

이제 각 칸에 대한 위치를 구하는것까지는 완성되었으니 이제 캐릭터 기준으로 상하좌우로 입력을 받아 이동하는데 이동 할수 있는 타일인지를 받아 가거나 멈추거하 하는것을 구현해보겠습니다. 