


    UI와 HUD 


지난시간에 이어서 구조와 관련된 이야기를 할건데 그 중에서도 UI와 관련된 이야기입니다. 
이 이야기는 언리얼에 국한된 이야기가 아니고 유니티아니면 다른 엔진이건 거의 공통적인 이야기입니다. 

굉장히 중요한 팁 중 하나가 실제 UI와 데이터를 분리하는게 중요하다는 것입니다. 
이게 무슨 말인가 하면 이전에 BP_GameUI 에서 캔버스 패널과 그 안에 텍스트 박스를 배치해 거기서 킬 카운트를 출력하고 있었습니다. 
이때 킬카운트를 이 위젯 블루프린트 내에서 관리해주면서 수정될 때 마다 킬카운트 텍스트 박스를 갱신해주도록 하고 있습니다. 

이 BP_GameUI는 킬카운트를 그리기 위해서 만든 클래스입니다. 
그런데 이 킬카운트를 사용하는곳은 BP_Creature의 OnDead였습니다 여기서 공격자가 플레이어일때 BP_GameUI를 가져와 킬카운트를 증가 시켜주고 있습니다. 
그리고 사실 처음 만들때 직관적으로 할 수 있는 방법입니다. UI를 만드는김에 여기서 사용하는 데이터도 관리해주면 되지 않을까 할 수 있는데 
하지만 이 킬카운트라는 데이터가 오직 이 UI에서만 사용하는 데이터라면 상관이 없겠지만 
대부분의 경우에는 다른곳에서도 맞물려 사용하는경우가 많습니다. 

예를 들자면 우리가 만든게 그냥 캔버스 패널과 텍스트 박스가 아니라 인벤토리 창이라고 해보겠습니다. 그러면 인벤토리 관련된 많은 UI가 같이 열릴겁니다. 
요즘 게임들을 보면 내가 인벤토리나 매뉴창을 열었다고 해서 그 UI들이 고정된 상태가 아니라 인벤토리를 연 상태에서 아이템을 줍는다거나 하면 실시간으로 갱신이 됩니다. 
그래서 이 UI라는것은 언제든지 변화가 일어 날 수 있는겁니다. 

이럴때 UI와 데이터를 섞어서 관히라게 되는 경우 UI를 사용하지 않고 그냥 그 데이터만 사용하고자 가져다 사용할때 문제가 될 확률이 높습니다.
실제로 업계에서는 UI와 거기서 사용되는 데이터를 분리해 관리하는것이 대부분이었다고 합니다. 

UI에 그려줄때 사용할 데이터를 이전 시간에 알아 봤던 매니저 클래스에서 관리하면서 필요할때 가져다 사용한다는것입니다. 
이렇게 관리해야지만 구조가 꼬이지 않게 됩니다. 우리가 작업했던 코드로 보면 OnDead라고 하는 킬카운트를 건드는것처럼 
캐릭터 정보창에서 실시간 공격력 같은것을 그때 그때 스텟들과 버프, 디버프를 연산해 표시해야하는데 이 정보를 매니저나 캐릭터 관련 정보를 한번에 관리하는 클래스에서 사용하는게 
훨씬 더 자연스럽습니다. 

이런 이야기가 나온김에 이전시간에 BP_GameMode나 BP_GameInstance도 만들었고 또 UI에서 관리하는 KillCount 변수도 이전해보겠습니다. 

우선 KillCount가 등장했던 이유는 텍스트 박스 UI에서 플레이어가 지금 몇 킬을 했다고 표시하면서 포맷 텍스트를 갱신해주는 역할이엇습니다. 
수정하면서 갱신이 되게끔 GetKillCountText 라는 위젯 블루프린트의 함수를 바인딩 해줬었습니다. 

그런데 다시 생각해보면 GetKillCountText에서 사용되는 KillCount 라는 int 변수가 꼭 이 위젯 블루프린트에서 관리될 필요가 없어 보입니다. 예를들어 이전에 만들었던 BP_GameMode에서 관리하는것도 
한 방법일겁니다. 
이전에 Test 라고 만든 테스트용 int 변수를 기왕 만든김에 KillCount라는 이름으로 바꿔 주고 이것을 말 그대로 킬카운트로 사용해보겠습니다. 

먼저 BP_GameMode를 간편하게 가져다 사용하기 위해 FunctionLib 에 래핑 함수를 하나 만들어 줍니다. GetBPGameMode 라고 해서 Get GameMode의 결과물을 BP_GameMode로 캐스팅해 반환하는 함수입니다. 

다음으로 우리가 킬카운트를 갱신해주고 있는 부분을 보면 BP_Creature의 OnDead라고 했었습니다. 여기서 BP_GameUI를 가져와 킬카운트를 수정하고 있었는데 그것이 아니라 
GetBPGameMode를 호출하고 거기에 있는 KillCount를 세팅해주면 됩니다. 

그러면 이제 UI와 관련없이 이 BP_GameMode의 KillCount를 수정하게끔 해줬습니다. 만약에 언젠가 기획자가 찾아와 내가 잡은 몬스터가 저장이 되어서 다음 게임을 켤때도 이어서 저장되었으면 좋겠다고 해도 
이제는 그것을 만들 수 있다는 것입니다. 게임모드로 따로 빼서 관리하기 때문에 그 데이터를 DB나 별도의 파일에 로드 세이브를 하게끔 만들어 주면 되는것입니다. 

잊지 말고 다시 BP_GameUI로 돌아가서 여기서 사용되는 킬카운트를 BP_GameMode에서 꺼내 사용하도록 만들어 주면 됩니다. 

우리가 지금 한 작업이 단순하기는 하지만 처음 설계부터 신경을 써야 이후 코드 관리에 더 수월해 질겁니다. 

좀 더 자세히 알아보자면 지금까지 UI로 사용하던 위젯 블루프린트라는 방식이 더 최신의 방식이고 UMG(Unreal Motion Graphics)라고 합니다. 그래서 이 이전의 방식인 HUD 클래스 방식을 사용할 이유는 없습니다. 
그럼에도 궁금하기는 하니까 HUD 클래스가 어떻게 동작하는지를 간단하게 실습해보고자 합니다. 

HUD 방식은 아직 언리얼에서 지원하고 있는데 어디서 확인 할 수 있냐면 월드 세팅에서 하던 게임모드 관련 옵션에서 세팅할 수 있는 기본 클래스중 하나가 HUD 클래스입니다. 
오래된 방식, 레거시 코드이긴하지만 언리얼 구조상에서 이어지고 있는 방식입니다. 


HUD 실습을 해보겠습니다. 컨텐츠 폴더/Blueprints/UI 위치 아래로 새로 클래스를 하나 추가해주는데 HUD로 검색하면 그대로 HUD라는 클래스가 나오는데 이것을 상속받아 만듭니다. 
이름은 간단하게 BP_HUD라고 하겠습니다. 이제 월드 세팅에서 게임모드의 HUD클래스를 지금 만든 BP_HUD로 세팅해줍니다. 

BP_HUD를 열어보겠습니다. 컴포넌트로는 DefaultSceneRoot 라는 것이 있고 창은 뷰포트 창과 이벤트 그래프가 있습니다. 다른 블루프린트 클래스와 그렇게 많이 다르지는 않습니다. 

우선 HUD가 위젯 블루프린트와 같이 UI를 그려주는 클래스라고 했는데 디자이너 창 같은 툴이 하나도 없습니다. 
위젯 블루프린트는 직관적으로 UI를 디자인 할 수 있었습니다. HUD에서도 직접 만들 수 있다고 합니다. 이제 와서는 아주 간단한 UI를 만들때 HUD를 사용하는것을 고려 하기도 한다는데 딱히 권장하지는 않는다고 합니다. 
어떤 의미인지 한번 테스트를 해보겠습니다. 

이벤트 그래프의 BeginPlay 이벤트에서 Set Show HUD 라는 노드를 연결하고 입력핀이 불리언인데 이것을 True로 켜주면 앞으로 작업할 것들이 보이게 됩니다. 
기본적으로 배치되어있는 다른 이벤트는 Tick 이벤트와 Overlapped 이벤트가 있었는데 이것들대신 Receive Draw HUD 이벤트를 사용하겠습니다. 
이 이벤트는 매 프레임마다 호출되는 일종의 HUD 용 업데이트 함수라고 볼 수 있습니다. 

Receive Draw HUD 이벤트에 Add Hit Box라는 함수를 연결하고 이어서 Draw Rect 함수, Draw Text 함수도 연결을 해주겠습니다. 
일단은 따라서 실습을 해봅니다. 

첫번째로 Add Hit Box 함수에서 Position 값을 (100.0, 100.0) 으로 Size는 (200.0, 200.0) 으로 세팅해보겠습니다. 이 히트 박스는 말 그대로 월드에 배치되어서 마우스로 클릭하거나 마우스 커서가 들어갔다 나오는걸 감지하는 영역입니다. 
다음으로 Draw Rect 함수에서는 히트박스와 마찬가지로 위치를 뜻하는 Screen X, Screen Y 값을 (100.0, 100.0) 으로 주고 Screen W, Screen H 라고 Width, Height 는 (200.0, 200.0)으로 세팅해보겠습니다. 
마지막으로 Draw Text는 여기에 연결할 String 타입 변수를 하나 추가해 입력핀에 연결해줍니다. 

이러면 일단 테스트 준비가 되었고 이어서 HitBox BeginCursorOver 와 HitBox EndCursorOver, HitBox Clicked 이벤트 세개를 꺼내 주겠습니다. 
그리고 Set Message를 연결해 주고 각각 다른 문자열을 줘 출력해주는 코드입니다. 

이제 실습을 해보려고 했는데 빠진 코드가 있습니다. 
BeginPlay 이벤트에서 Show HUD를 해주기는 했지만 여기서 좀 더 세팅해줘야합니다. 
Get PlayerController 로 0번을 가져온 다음 Set Mouse Cursor 와 Set Click Event 를 True로 켜줘야 합니다. 

게임을 실행해보면 어떤 사각형이 떠있고 이 사각형 안에 커서를 넣었다 빼거나 클릭을 하면 좌 상단에 메세지가 출력되고 있습니다. 
이런식으로 UI를 구현할 수 있는 HUD이긴 하지만 이제 와서는 권장되지 않는것은 아까 말했듯이 위젯 블루프린트를 사용하면 더욱 쉽게 구현할 수 있기 때문입니다. 

그럼에도 불구하고 굳이 HUD를 사용해야 하는 이유가 있다면 다른 클래스에서 쉽게 꺼낼수 있다는 점입니다. 
예를 들어서 BP_Creature 같은데서 Get PlayerController를 하고 다시 Get HUD를 하면 바로 HUD 객체를 가져올 수 있습니다. 이런 언리얼 엔진 구조에서 오는 이점이 있습니다. 

HUD를 사용한다면 지금처럼 따로 클래스를 만들어 관리하는 것도 가능하고 아니면 레벨 블루프린트에서 UI를 만들어 관리하는 방법도 있습니다. 

거듭 말하지만 위젯 블루프린트가 더욱 간편하게 같은 기능을 구현할 수 있는데 
잠깐 알아보자면 이전에 만들었던 BP_GameUI의 캔버스 패널 한 구석을 그냥 버튼 이라는 팔레트를 드래그 드롭으로 영역을 지정하고 클릭 이벤트를 사용한다면 디테일즈에서 내려보면 관련 옵션이 있습니다. 
클릭 이벤트를 추가하면 바로 위젯 블루프린트의 그래프로 넘어가 클릭 이벤트에서 이어지는 코드를 작성하면됩니다. 